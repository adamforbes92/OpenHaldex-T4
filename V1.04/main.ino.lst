
C:\Users\Adam\AppData\Local\Temp\arduino\sketches\7EEAED8D91ED3DE9C164BD85930F6797/main.ino.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
	}
}
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
	}
}
60001426:	4770      	bx	lr

60001428 <ResetHandler2>:
{
60001428:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
6000142c:	f000 f910 	bl	60001650 <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001430:	2408      	movs	r4, #8
60001432:	4b60      	ldr	r3, [pc, #384]	; (600015b4 <ResetHandler2+0x18c>)
	memory_copy(&_stext, &_stextload, &_etext);
60001434:	4a60      	ldr	r2, [pc, #384]	; (600015b8 <ResetHandler2+0x190>)
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001436:	f8c3 4154 	str.w	r4, [r3, #340]	; 0x154
	memory_copy(&_stext, &_stextload, &_etext);
6000143a:	4960      	ldr	r1, [pc, #384]	; (600015bc <ResetHandler2+0x194>)
6000143c:	4860      	ldr	r0, [pc, #384]	; (600015c0 <ResetHandler2+0x198>)
6000143e:	f7ff ffdf 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
60001442:	4a60      	ldr	r2, [pc, #384]	; (600015c4 <ResetHandler2+0x19c>)
60001444:	4960      	ldr	r1, [pc, #384]	; (600015c8 <ResetHandler2+0x1a0>)
60001446:	4861      	ldr	r0, [pc, #388]	; (600015cc <ResetHandler2+0x1a4>)
60001448:	f7ff ffda 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
6000144c:	4960      	ldr	r1, [pc, #384]	; (600015d0 <ResetHandler2+0x1a8>)
6000144e:	4861      	ldr	r0, [pc, #388]	; (600015d4 <ResetHandler2+0x1ac>)
60001450:	f7ff ffe2 	bl	60001418 <memory_clear>
	SCB_CPACR = 0x00F00000;
60001454:	4c60      	ldr	r4, [pc, #384]	; (600015d8 <ResetHandler2+0x1b0>)
60001456:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
6000145a:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000145e:	2300      	movs	r3, #0
60001460:	4a5e      	ldr	r2, [pc, #376]	; (600015dc <ResetHandler2+0x1b4>)
	SCB_CPACR = 0x00F00000;
60001462:	f8c1 0d88 	str.w	r0, [r1, #3464]	; 0xd88
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001466:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
6000146a:	3301      	adds	r3, #1
6000146c:	2bb0      	cmp	r3, #176	; 0xb0
6000146e:	d1fa      	bne.n	60001466 <ResetHandler2+0x3e>
60001470:	4b5b      	ldr	r3, [pc, #364]	; (600015e0 <ResetHandler2+0x1b8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
60001472:	2180      	movs	r1, #128	; 0x80
60001474:	4a5b      	ldr	r2, [pc, #364]	; (600015e4 <ResetHandler2+0x1bc>)
60001476:	f803 1b01 	strb.w	r1, [r3], #1
6000147a:	4293      	cmp	r3, r2
6000147c:	d1fb      	bne.n	60001476 <ResetHandler2+0x4e>
	SCB_VTOR = (uint32_t)_VectorsRam;
6000147e:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001482:	4e4c      	ldr	r6, [pc, #304]	; (600015b4 <ResetHandler2+0x18c>)
60001484:	f04f 3980 	mov.w	r9, #2155905152	; 0x80808080
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001488:	f8df b188 	ldr.w	fp, [pc, #392]	; 60001614 <ResetHandler2+0x1ec>
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000148c:	f8df a188 	ldr.w	sl, [pc, #392]	; 60001618 <ResetHandler2+0x1f0>
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001490:	f04f 31ff 	mov.w	r1, #4294967295
	SCB_VTOR = (uint32_t)_VectorsRam;
60001494:	f8c5 4d08 	str.w	r4, [r5, #3336]	; 0xd08
	SYST_CVR = 0;
60001498:	2700      	movs	r7, #0
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
6000149a:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000149e:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014a2:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014a6:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014aa:	f8d5 3d24 	ldr.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ae:	f8df 816c 	ldr.w	r8, [pc, #364]	; 6000161c <ResetHandler2+0x1f4>
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014b2:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014b6:	4a4c      	ldr	r2, [pc, #304]	; (600015e8 <ResetHandler2+0x1c0>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014b8:	f8c5 3d24 	str.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014bc:	f8d8 301c 	ldr.w	r3, [r8, #28]
600014c0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014c8:	f8c8 301c 	str.w	r3, [r8, #28]
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014cc:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
600014d0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d8:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014dc:	6691      	str	r1, [r2, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014de:	66d1      	str	r1, [r2, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e0:	6711      	str	r1, [r2, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014e2:	6751      	str	r1, [r2, #116]	; 0x74
	configure_cache();
600014e4:	f000 f8bc 	bl	60001660 <configure_cache>
	_VectorsRam[14] = pendablesrvreq_isr;
600014e8:	4b40      	ldr	r3, [pc, #256]	; (600015ec <ResetHandler2+0x1c4>)
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
600014ea:	4941      	ldr	r1, [pc, #260]	; (600015f0 <ResetHandler2+0x1c8>)
	_VectorsRam[14] = pendablesrvreq_isr;
600014ec:	63a3      	str	r3, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
600014ee:	4b41      	ldr	r3, [pc, #260]	; (600015f4 <ResetHandler2+0x1cc>)
600014f0:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f2:	2363      	movs	r3, #99	; 0x63
600014f4:	616b      	str	r3, [r5, #20]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f6:	2303      	movs	r3, #3
	SYST_CVR = 0;
600014f8:	61af      	str	r7, [r5, #24]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014fa:	612b      	str	r3, [r5, #16]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
600014fc:	4b3e      	ldr	r3, [pc, #248]	; (600015f8 <ResetHandler2+0x1d0>)
600014fe:	f8c5 3d20 	str.w	r3, [r5, #3360]	; 0xd20
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001502:	f8d5 3dfc 	ldr.w	r3, [r5, #3580]	; 0xdfc
60001506:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
6000150a:	f8c5 3dfc 	str.w	r3, [r5, #3580]	; 0xdfc
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000150e:	4b3b      	ldr	r3, [pc, #236]	; (600015fc <ResetHandler2+0x1d4>)
60001510:	681a      	ldr	r2, [r3, #0]
60001512:	f042 0201 	orr.w	r2, r2, #1
60001516:	601a      	str	r2, [r3, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001518:	685b      	ldr	r3, [r3, #4]
6000151a:	600b      	str	r3, [r1, #0]
	usb_pll_start();	
6000151c:	f000 f91c 	bl	60001758 <usb_pll_start>
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001520:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	set_arm_clock(F_CPU);
60001524:	4836      	ldr	r0, [pc, #216]	; (60001600 <ResetHandler2+0x1d8>)
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001526:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000152a:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000152e:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	set_arm_clock(F_CPU);
60001532:	f000 fab5 	bl	60001aa0 <__set_arm_clock_veneer>
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001536:	f8d8 106c 	ldr.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
6000153a:	4b32      	ldr	r3, [pc, #200]	; (60001604 <ResetHandler2+0x1dc>)
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000153c:	4a32      	ldr	r2, [pc, #200]	; (60001608 <ResetHandler2+0x1e0>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000153e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
60001542:	f8c8 106c 	str.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
60001546:	601f      	str	r7, [r3, #0]
	PIT_TCTRL0 = 0;
60001548:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000154c:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001550:	f8c3 7128 	str.w	r7, [r3, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001554:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001558:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000155a:	07db      	lsls	r3, r3, #31
6000155c:	d408      	bmi.n	60001570 <ResetHandler2+0x148>
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000155e:	f642 6315 	movw	r3, #11797	; 0x2e15
		SNVS_LPSRTCLR = 1546300800u << 15;
60001562:	492a      	ldr	r1, [pc, #168]	; (6000160c <ResetHandler2+0x1e4>)
60001564:	6551      	str	r1, [r2, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001566:	6513      	str	r3, [r2, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001568:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000156a:	f043 0301 	orr.w	r3, r3, #1
6000156e:	6393      	str	r3, [r2, #56]	; 0x38
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001570:	4a25      	ldr	r2, [pc, #148]	; (60001608 <ResetHandler2+0x1e0>)
60001572:	4c27      	ldr	r4, [pc, #156]	; (60001610 <ResetHandler2+0x1e8>)
60001574:	6893      	ldr	r3, [r2, #8]
60001576:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000157a:	6093      	str	r3, [r2, #8]
	analog_init();
6000157c:	f000 fa50 	bl	60001a20 <analog_init>
	pwm_init();
60001580:	f000 fa8a 	bl	60001a98 <__pwm_init_veneer>
	tempmon_init();
60001584:	f000 f916 	bl	600017b4 <tempmon_init>
	startup_middle_hook();
60001588:	f000 f864 	bl	60001654 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
6000158c:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
6000158e:	2b13      	cmp	r3, #19
60001590:	d9fc      	bls.n	6000158c <ResetHandler2+0x164>
	usb_init();
60001592:	f000 f9a7 	bl	600018e4 <usb_init>
60001596:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
60001598:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
6000159c:	d3fb      	bcc.n	60001596 <ResetHandler2+0x16e>
	startup_debug_reset();
6000159e:	f000 f85d 	bl	6000165c <startup_debug_reset>
	startup_late_hook();
600015a2:	f000 f859 	bl	60001658 <startup_default_late_hook>
	__libc_init_array();
600015a6:	f000 fa83 	bl	60001ab0 <____libc_init_array_veneer>
	main();
600015aa:	f000 fa7d 	bl	60001aa8 <__main_veneer>
	while (1) asm("WFI");
600015ae:	bf30      	wfi
600015b0:	e7fd      	b.n	600015ae <ResetHandler2+0x186>
600015b2:	bf00      	nop
600015b4:	400d8000 	.word	0x400d8000
600015b8:	00007b80 	.word	0x00007b80
600015bc:	60001be8 	.word	0x60001be8
600015c0:	00000000 	.word	0x00000000
600015c4:	200012c0 	.word	0x200012c0
600015c8:	6000976c 	.word	0x6000976c
600015cc:	20000000 	.word	0x20000000
600015d0:	20006b20 	.word	0x20006b20
600015d4:	200012c0 	.word	0x200012c0
600015d8:	20001000 	.word	0x20001000
600015dc:	000062f9 	.word	0x000062f9
600015e0:	e000e400 	.word	0xe000e400
600015e4:	e000e4a0 	.word	0xe000e4a0
600015e8:	400ac000 	.word	0x400ac000
600015ec:	00004ead 	.word	0x00004ead
600015f0:	20006978 	.word	0x20006978
600015f4:	00004eb1 	.word	0x00004eb1
600015f8:	20200000 	.word	0x20200000
600015fc:	e0001000 	.word	0xe0001000
60001600:	08f0d180 	.word	0x08f0d180
60001604:	40084000 	.word	0x40084000
60001608:	400d4000 	.word	0x400d4000
6000160c:	56c00000 	.word	0x56c00000
60001610:	2000697c 	.word	0x2000697c
60001614:	2018101b 	.word	0x2018101b
60001618:	13110d0c 	.word	0x13110d0c
6000161c:	400fc000 	.word	0x400fc000

60001620 <ResetHandler>:
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001620:	4b07      	ldr	r3, [pc, #28]	; (60001640 <ResetHandler+0x20>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001622:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001626:	4a07      	ldr	r2, [pc, #28]	; (60001644 <ResetHandler+0x24>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001628:	4807      	ldr	r0, [pc, #28]	; (60001648 <ResetHandler+0x28>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000162a:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
6000162c:	6418      	str	r0, [r3, #64]	; 0x40
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000162e:	4a07      	ldr	r2, [pc, #28]	; (6000164c <ResetHandler+0x2c>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001630:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001632:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001634:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001638:	f3bf 8f6f 	isb	sy
	ResetHandler2();
6000163c:	f7ff fef4 	bl	60001428 <ResetHandler2>
60001640:	400ac000 	.word	0x400ac000
60001644:	aaaaaaab 	.word	0xaaaaaaab
60001648:	00200007 	.word	0x00200007
6000164c:	20078000 	.word	0x20078000

60001650 <startup_default_early_hook>:
FLASHMEM void startup_default_early_hook(void) {}
60001650:	4770      	bx	lr
60001652:	bf00      	nop

60001654 <startup_default_middle_hook>:
60001654:	4770      	bx	lr
60001656:	bf00      	nop

60001658 <startup_default_late_hook>:
60001658:	4770      	bx	lr
6000165a:	bf00      	nop

6000165c <startup_debug_reset>:
FLASHMEM void startup_debug_reset(void) { __asm__ volatile("nop"); }
6000165c:	bf00      	nop
6000165e:	4770      	bx	lr

60001660 <configure_cache>:
{
60001660:	b410      	push	{r4}
	SCB_MPU_CTRL = 0; // turn off MPU
60001662:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60001666:	2100      	movs	r1, #0
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001668:	2410      	movs	r4, #16
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
6000166a:	482b      	ldr	r0, [pc, #172]	; (60001718 <configure_cache+0xb8>)
	SCB_MPU_CTRL = 0; // turn off MPU
6000166c:	f8c3 1d94 	str.w	r1, [r3, #3476]	; 0xd94
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001670:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001674:	2411      	movs	r4, #17
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001676:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
6000167a:	4828      	ldr	r0, [pc, #160]	; (6000171c <configure_cache+0xbc>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
6000167c:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001680:	2412      	movs	r4, #18
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
60001682:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
60001686:	4826      	ldr	r0, [pc, #152]	; (60001720 <configure_cache+0xc0>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001688:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
6000168c:	4a25      	ldr	r2, [pc, #148]	; (60001724 <configure_cache+0xc4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
6000168e:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
60001692:	4c25      	ldr	r4, [pc, #148]	; (60001728 <configure_cache+0xc8>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001694:	f042 0215 	orr.w	r2, r2, #21
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
60001698:	4824      	ldr	r0, [pc, #144]	; (6000172c <configure_cache+0xcc>)
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
6000169a:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
6000169e:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016a2:	4c23      	ldr	r4, [pc, #140]	; (60001730 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016a4:	4823      	ldr	r0, [pc, #140]	; (60001734 <configure_cache+0xd4>)
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016a6:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016aa:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016ae:	4c22      	ldr	r4, [pc, #136]	; (60001738 <configure_cache+0xd8>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016b0:	f8c3 2d9c 	str.w	r2, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016b4:	4821      	ldr	r0, [pc, #132]	; (6000173c <configure_cache+0xdc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016b6:	4a22      	ldr	r2, [pc, #136]	; (60001740 <configure_cache+0xe0>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016b8:	f8c3 4da0 	str.w	r4, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016bc:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016c0:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016c4:	f502 22a0 	add.w	r2, r2, #327680	; 0x50000
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016c8:	4c1e      	ldr	r4, [pc, #120]	; (60001744 <configure_cache+0xe4>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016ca:	320c      	adds	r2, #12
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016cc:	481e      	ldr	r0, [pc, #120]	; (60001748 <configure_cache+0xe8>)
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016ce:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016d2:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016d6:	4a1d      	ldr	r2, [pc, #116]	; (6000174c <configure_cache+0xec>)
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016d8:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600016dc:	4c1c      	ldr	r4, [pc, #112]	; (60001750 <configure_cache+0xf0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016de:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016e2:	2201      	movs	r2, #1
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600016e4:	481b      	ldr	r0, [pc, #108]	; (60001754 <configure_cache+0xf4>)
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600016e6:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600016ea:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016ee:	f8c3 2d94 	str.w	r2, [r3, #3476]	; 0xd94
	asm("dsb");
600016f2:	f3bf 8f4f 	dsb	sy
	asm("isb");
600016f6:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
600016fa:	f8c3 1f50 	str.w	r1, [r3, #3920]	; 0xf50
	asm("dsb");
600016fe:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001702:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
60001706:	f8d3 2d14 	ldr.w	r2, [r3, #3348]	; 0xd14
}
6000170a:	f85d 4b04 	ldr.w	r4, [sp], #4
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000170e:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
60001712:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
}
60001716:	4770      	bx	lr
60001718:	1000003f 	.word	0x1000003f
6000171c:	03080025 	.word	0x03080025
60001720:	00100009 	.word	0x00100009
60001724:	20006b20 	.word	0x20006b20
60001728:	00200013 	.word	0x00200013
6000172c:	07020021 	.word	0x07020021
60001730:	20000014 	.word	0x20000014
60001734:	13080025 	.word	0x13080025
60001738:	10000009 	.word	0x10000009
6000173c:	20200016 	.word	0x20200016
60001740:	130b0027 	.word	0x130b0027
60001744:	40000017 	.word	0x40000017
60001748:	60000018 	.word	0x60000018
6000174c:	070b002f 	.word	0x070b002f
60001750:	70000019 	.word	0x70000019
60001754:	130b002f 	.word	0x130b002f

60001758 <usb_pll_start>:
{
60001758:	b4f0      	push	{r4, r5, r6, r7}
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
6000175a:	4a15      	ldr	r2, [pc, #84]	; (600017b0 <usb_pll_start+0x58>)
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
6000175c:	2740      	movs	r7, #64	; 0x40
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
6000175e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001762:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001766:	f44f 5500 	mov.w	r5, #8192	; 0x2000
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000176a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
6000176e:	f243 0042 	movw	r0, #12354	; 0x3042
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001772:	6913      	ldr	r3, [r2, #16]
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001774:	f013 0f02 	tst.w	r3, #2
60001778:	d10e      	bne.n	60001798 <usb_pll_start+0x40>
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
6000177a:	f413 5f00 	tst.w	r3, #8192	; 0x2000
6000177e:	d00f      	beq.n	600017a0 <usb_pll_start+0x48>
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001780:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001784:	d00e      	beq.n	600017a4 <usb_pll_start+0x4c>
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001786:	2b00      	cmp	r3, #0
60001788:	daf3      	bge.n	60001772 <usb_pll_start+0x1a>
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
6000178a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
6000178e:	d10b      	bne.n	600017a8 <usb_pll_start+0x50>
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001790:	065b      	lsls	r3, r3, #25
60001792:	d50b      	bpl.n	600017ac <usb_pll_start+0x54>
}
60001794:	bcf0      	pop	{r4, r5, r6, r7}
60001796:	4770      	bx	lr
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001798:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
6000179a:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
6000179c:	6190      	str	r0, [r2, #24]
			continue;
6000179e:	e7e8      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
600017a0:	6155      	str	r5, [r2, #20]
			continue;
600017a2:	e7e6      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
600017a4:	6156      	str	r6, [r2, #20]
			continue;
600017a6:	e7e4      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600017a8:	6191      	str	r1, [r2, #24]
			continue;
600017aa:	e7e2      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600017ac:	6157      	str	r7, [r2, #20]
			continue;
600017ae:	e7e0      	b.n	60001772 <usb_pll_start+0x1a>
600017b0:	400d8000 	.word	0x400d8000

600017b4 <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017b4:	4a3f      	ldr	r2, [pc, #252]	; (600018b4 <tempmon_init+0x100>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600017b6:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600017b8:	493f      	ldr	r1, [pc, #252]	; (600018b8 <tempmon_init+0x104>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017ba:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017be:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600017c2:	f04f 0c00 	mov.w	ip, #0
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600017c6:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 600018bc <tempmon_init+0x108>
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017ca:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600017ce:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 600018c0 <tempmon_init+0x10c>
{
600017d2:	b430      	push	{r4, r5}
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017d4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600017d8:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  calibrationData = HW_OCOTP_ANA1;
600017dc:	f8d1 10e0 	ldr.w	r1, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600017e0:	4d38      	ldr	r5, [pc, #224]	; (600018c4 <tempmon_init+0x110>)
600017e2:	b2cb      	uxtb	r3, r1
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600017e4:	4c38      	ldr	r4, [pc, #224]	; (600018c8 <tempmon_init+0x114>)
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017e6:	4839      	ldr	r0, [pc, #228]	; (600018cc <tempmon_init+0x118>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600017e8:	602b      	str	r3, [r5, #0]
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017ea:	ee07 3a90 	vmov	s15, r3
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
600017ee:	0d0b      	lsrs	r3, r1, #20
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600017f0:	f3c1 210b 	ubfx	r1, r1, #8, #12
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
600017f8:	ee06 3a90 	vmov	s13, r3
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
600017fc:	ee07 1a10 	vmov	s14, r1
60001800:	4b33      	ldr	r3, [pc, #204]	; (600018d0 <tempmon_init+0x11c>)
60001802:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001806:	6021      	str	r1, [r4, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001808:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000180c:	4931      	ldr	r1, [pc, #196]	; (600018d4 <tempmon_init+0x120>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000180e:	ee37 6ac6 	vsub.f32	s12, s15, s12
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001812:	ee37 5ac5 	vsub.f32	s10, s15, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001816:	ee76 6ac7 	vsub.f32	s13, s13, s14
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000181a:	ee77 7ae5 	vsub.f32	s15, s15, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000181e:	ee26 6a26 	vmul.f32	s12, s12, s13
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001822:	edc3 6a00 	vstr	s13, [r3]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001826:	ee25 5a26 	vmul.f32	s10, s10, s13
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000182a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000182e:	ee67 4aa6 	vmul.f32	s9, s15, s13
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001832:	edc0 7a00 	vstr	s15, [r0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001836:	eec6 5a27 	vdiv.f32	s11, s12, s15
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
6000183a:	4827      	ldr	r0, [pc, #156]	; (600018d8 <tempmon_init+0x124>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000183c:	ee85 6a27 	vdiv.f32	s12, s10, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001840:	eec4 6aa7 	vdiv.f32	s13, s9, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001844:	ee75 5a87 	vadd.f32	s11, s11, s14
60001848:	eefc 5ae5 	vcvt.u32.f32	s11, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000184c:	ee36 6a07 	vadd.f32	s12, s12, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001850:	ee15 4a90 	vmov	r4, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001854:	eebc 6ac6 	vcvt.u32.f32	s12, s12
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001858:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000185c:	ee76 7a87 	vadd.f32	s15, s13, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001860:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001864:	ee16 3a10 	vmov	r3, s12
60001868:	f8d2 4190 	ldr.w	r4, [r2, #400]	; 0x190
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000186c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001870:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001874:	4321      	orrs	r1, r4
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001876:	ee17 3a90 	vmov	r3, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000187a:	f8c2 1190 	str.w	r1, [r2, #400]	; 0x190
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000187e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001882:	f8d2 1190 	ldr.w	r1, [r2, #400]	; 0x190
60001886:	430b      	orrs	r3, r1
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001888:	4914      	ldr	r1, [pc, #80]	; (600018dc <tempmon_init+0x128>)
6000188a:	f8c2 3190 	str.w	r3, [r2, #400]	; 0x190
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
6000188e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
60001892:	f043 0302 	orr.w	r3, r3, #2
60001896:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
6000189a:	4b11      	ldr	r3, [pc, #68]	; (600018e0 <tempmon_init+0x12c>)
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
6000189c:	f880 c040 	strb.w	ip, [r0, #64]	; 0x40
600018a0:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018a4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
600018a8:	2201      	movs	r2, #1
}
600018aa:	bc30      	pop	{r4, r5}
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018ac:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
}
600018b0:	4770      	bx	lr
600018b2:	bf00      	nop
600018b4:	400d8100 	.word	0x400d8100
600018b8:	401f4400 	.word	0x401f4400
600018bc:	42aa0000 	.word	0x42aa0000
600018c0:	42b40000 	.word	0x42b40000
600018c4:	20006924 	.word	0x20006924
600018c8:	20006920 	.word	0x20006920
600018cc:	20006928 	.word	0x20006928
600018d0:	2000692c 	.word	0x2000692c
600018d4:	0fff0000 	.word	0x0fff0000
600018d8:	e000e400 	.word	0xe000e400
600018dc:	20001000 	.word	0x20001000
600018e0:	00006479 	.word	0x00006479

600018e4 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600018e4:	4b31      	ldr	r3, [pc, #196]	; (600019ac <usb_init+0xc8>)
600018e6:	f640 7261 	movw	r2, #3937	; 0xf61
{
600018ea:	b510      	push	{r4, lr}
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600018ec:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600018f0:	f240 4404 	movw	r4, #1028	; 0x404
	usb_init_serialnumber();
600018f4:	f000 f8cc 	bl	60001a90 <__usb_init_serialnumber_veneer>
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600018f8:	4a2d      	ldr	r2, [pc, #180]	; (600019b0 <usb_init+0xcc>)
	USB1_BURSTSIZE = 0x0404;
600018fa:	492e      	ldr	r1, [pc, #184]	; (600019b4 <usb_init+0xd0>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600018fc:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001900:	482d      	ldr	r0, [pc, #180]	; (600019b8 <usb_init+0xd4>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001902:	f043 0303 	orr.w	r3, r3, #3
60001906:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
6000190a:	4b2c      	ldr	r3, [pc, #176]	; (600019bc <usb_init+0xd8>)
	USB1_BURSTSIZE = 0x0404;
6000190c:	f8c1 4160 	str.w	r4, [r1, #352]	; 0x160
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001910:	6802      	ldr	r2, [r0, #0]
60001912:	421a      	tst	r2, r3
60001914:	d103      	bne.n	6000191e <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001916:	f8d1 31a8 	ldr.w	r3, [r1, #424]	; 0x1a8
6000191a:	079a      	lsls	r2, r3, #30
6000191c:	d01b      	beq.n	60001956 <usb_init+0x72>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
6000191e:	4a25      	ldr	r2, [pc, #148]	; (600019b4 <usb_init+0xd0>)
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001920:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001924:	4b24      	ldr	r3, [pc, #144]	; (600019b8 <usb_init+0xd4>)
60001926:	6359      	str	r1, [r3, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001928:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
6000192c:	f043 0302 	orr.w	r3, r3, #2
60001930:	f8c2 3140 	str.w	r3, [r2, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001934:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001938:	079b      	lsls	r3, r3, #30
6000193a:	d4fb      	bmi.n	60001934 <usb_init+0x50>
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000193c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001940:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001944:	4b1c      	ldr	r3, [pc, #112]	; (600019b8 <usb_init+0xd4>)
60001946:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000194a:	f8c1 028c 	str.w	r0, [r1, #652]	; 0x28c
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
6000194e:	2019      	movs	r0, #25
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001950:	639a      	str	r2, [r3, #56]	; 0x38
		delay(25);
60001952:	f000 f899 	bl	60001a88 <__delay_veneer>
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001956:	4a18      	ldr	r2, [pc, #96]	; (600019b8 <usb_init+0xd4>)
60001958:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000195c:	4c15      	ldr	r4, [pc, #84]	; (600019b4 <usb_init+0xd0>)
	USBPHY1_PWD = 0;
6000195e:	2100      	movs	r1, #0
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001960:	6390      	str	r0, [r2, #56]	; 0x38
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001962:	200a      	movs	r0, #10
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001964:	4b16      	ldr	r3, [pc, #88]	; (600019c0 <usb_init+0xdc>)
	USBPHY1_PWD = 0;
60001966:	6011      	str	r1, [r2, #0]
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001968:	f44f 7220 	mov.w	r2, #640	; 0x280
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000196c:	f8c4 01a8 	str.w	r0, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001970:	4618      	mov	r0, r3
60001972:	f000 f885 	bl	60001a80 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001976:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000197a:	4603      	mov	r3, r0
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
6000197c:	f44f 0081 	mov.w	r0, #4227072	; 0x408000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001980:	f240 1143 	movw	r1, #323	; 0x143
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001984:	6018      	str	r0, [r3, #0]
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001986:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
	endpoint_queue_head[1].config = (64 << 16);
6000198a:	641a      	str	r2, [r3, #64]	; 0x40
6000198c:	4b0d      	ldr	r3, [pc, #52]	; (600019c4 <usb_init+0xe0>)
6000198e:	4a0e      	ldr	r2, [pc, #56]	; (600019c8 <usb_init+0xe4>)
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001990:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001994:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001998:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
6000199c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600019a0:	2301      	movs	r3, #1
	NVIC_ENABLE_IRQ(IRQ_USB1);
600019a2:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
	USB1_USBCMD = USB_USBCMD_RS;
600019a6:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	//transfer_log_head = 0;
	//transfer_log_count = 0;
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}
600019aa:	bd10      	pop	{r4, pc}
600019ac:	400d8000 	.word	0x400d8000
600019b0:	400fc000 	.word	0x400fc000
600019b4:	402e0000 	.word	0x402e0000
600019b8:	400d9000 	.word	0x400d9000
600019bc:	001e1c00 	.word	0x001e1c00
600019c0:	20000000 	.word	0x20000000
600019c4:	20001000 	.word	0x20001000
600019c8:	00006661 	.word	0x00006661

600019cc <_reboot_Teensyduino_>:


FLASHMEM void _reboot_Teensyduino_(void)
{
600019cc:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
600019ce:	4b0e      	ldr	r3, [pc, #56]	; (60001a08 <_reboot_Teensyduino_+0x3c>)
600019d0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
600019d2:	079b      	lsls	r3, r3, #30
600019d4:	d400      	bmi.n	600019d8 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
600019d6:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
600019d8:	b672      	cpsid	i
		USB1_USBCMD = 0;
600019da:	4b0c      	ldr	r3, [pc, #48]	; (60001a0c <_reboot_Teensyduino_+0x40>)
600019dc:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
600019de:	4a0c      	ldr	r2, [pc, #48]	; (60001a10 <_reboot_Teensyduino_+0x44>)
		USB1_USBCMD = 0;
600019e0:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
600019e4:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
		IOMUXC_GPR_GPR16 = 0x00200003;
600019e8:	490a      	ldr	r1, [pc, #40]	; (60001a14 <_reboot_Teensyduino_+0x48>)
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
600019ea:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
		IOMUXC_GPR_GPR16 = 0x00200003;
600019ee:	6411      	str	r1, [r2, #64]	; 0x40
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
600019f0:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
600019f2:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
600019f6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
		*p = 0xEB120000;
600019fa:	4807      	ldr	r0, [pc, #28]	; (60001a18 <_reboot_Teensyduino_+0x4c>)
600019fc:	4a07      	ldr	r2, [pc, #28]	; (60001a1c <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
600019fe:	69db      	ldr	r3, [r3, #28]
		*p = 0xEB120000;
60001a00:	6002      	str	r2, [r0, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a02:	689b      	ldr	r3, [r3, #8]
60001a04:	4798      	blx	r3
	}
	__builtin_unreachable();
60001a06:	bf00      	nop
60001a08:	401f4400 	.word	0x401f4400
60001a0c:	402e0000 	.word	0x402e0000
60001a10:	400ac000 	.word	0x400ac000
60001a14:	00200003 	.word	0x00200003
60001a18:	20208000 	.word	0x20208000
60001a1c:	eb120000 	.word	0xeb120000

60001a20 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a20:	4b10      	ldr	r3, [pc, #64]	; (60001a64 <analog_init+0x44>)
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a22:	20a0      	movs	r0, #160	; 0xa0
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a24:	4a10      	ldr	r2, [pc, #64]	; (60001a68 <analog_init+0x48>)
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a26:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a28:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
{
60001a2c:	b410      	push	{r4}
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a2e:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a30:	f240 6437 	movw	r4, #1591	; 0x637
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001a34:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a36:	f441 7140 	orr.w	r1, r1, #768	; 0x300
60001a3a:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a3c:	6454      	str	r4, [r2, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a3e:	6490      	str	r0, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001a40:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a42:	061b      	lsls	r3, r3, #24
60001a44:	d4fc      	bmi.n	60001a40 <analog_init+0x20>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a46:	4a09      	ldr	r2, [pc, #36]	; (60001a6c <analog_init+0x4c>)
60001a48:	f240 6137 	movw	r1, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a4c:	23a0      	movs	r3, #160	; 0xa0
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a4e:	6451      	str	r1, [r2, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a50:	6493      	str	r3, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001a52:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a54:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001a58:	d1fb      	bne.n	60001a52 <analog_init+0x32>
		//yield();
	}
	calibrating = 0;
60001a5a:	4a05      	ldr	r2, [pc, #20]	; (60001a70 <analog_init+0x50>)
60001a5c:	7013      	strb	r3, [r2, #0]
}
60001a5e:	f85d 4b04 	ldr.w	r4, [sp], #4
60001a62:	4770      	bx	lr
60001a64:	400fc000 	.word	0x400fc000
60001a68:	400c4000 	.word	0x400c4000
60001a6c:	400c8000 	.word	0x400c8000
60001a70:	20006ae2 	.word	0x20006ae2

60001a74 <_init>:
60001a74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60001a76:	bf00      	nop
60001a78:	bcf8      	pop	{r3, r4, r5, r6, r7}
60001a7a:	bc08      	pop	{r3}
60001a7c:	469e      	mov	lr, r3
60001a7e:	4770      	bx	lr

60001a80 <__memset_veneer>:
60001a80:	f85f f000 	ldr.w	pc, [pc]	; 60001a84 <__memset_veneer+0x4>
60001a84:	00007a81 	.word	0x00007a81

60001a88 <__delay_veneer>:
60001a88:	f85f f000 	ldr.w	pc, [pc]	; 60001a8c <__delay_veneer+0x4>
60001a8c:	000057e9 	.word	0x000057e9

60001a90 <__usb_init_serialnumber_veneer>:
60001a90:	f85f f000 	ldr.w	pc, [pc]	; 60001a94 <__usb_init_serialnumber_veneer+0x4>
60001a94:	00006dd1 	.word	0x00006dd1

60001a98 <__pwm_init_veneer>:
60001a98:	f85f f000 	ldr.w	pc, [pc]	; 60001a9c <__pwm_init_veneer+0x4>
60001a9c:	00006201 	.word	0x00006201

60001aa0 <__set_arm_clock_veneer>:
60001aa0:	f85f f000 	ldr.w	pc, [pc]	; 60001aa4 <__set_arm_clock_veneer+0x4>
60001aa4:	00007671 	.word	0x00007671

60001aa8 <__main_veneer>:
60001aa8:	f85f f000 	ldr.w	pc, [pc]	; 60001aac <__main_veneer+0x4>
60001aac:	00005e5d 	.word	0x00005e5d

60001ab0 <____libc_init_array_veneer>:
60001ab0:	f85f f000 	ldr.w	pc, [pc]	; 60001ab4 <____libc_init_array_veneer+0x4>
60001ab4:	00007b25 	.word	0x00007b25

60001ab8 <__frame_dummy_init_array_entry>:
60001ab8:	00000101 00000251 00000371 000009dd     ....Q...q.......
60001ac8:	00000c4d 00004955 00004b9d 00004d9d     M...UI...K...M..
60001ad8:	000055ad                                .U..

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <irq_gpio6789>:
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
                        return (void *)-1;
      20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
      22:	f04f 4384 	mov.w	r3, #1107296256	; 0x42000000
                }
                __brkval = prev + incr;
        }
        return prev;
}
      26:	699d      	ldr	r5, [r3, #24]
      28:	695a      	ldr	r2, [r3, #20]
      2a:	4015      	ands	r5, r2
      2c:	d00d      	beq.n	4a <_teensy_model_identifier+0x26>
      2e:	4f24      	ldr	r7, [pc, #144]	; (c0 <_teensy_model_identifier+0x9c>)
      30:	2601      	movs	r6, #1
      32:	619d      	str	r5, [r3, #24]
	// set the SRTC
	SNVS_LPSRTCLR = t << 15;
	SNVS_LPSRTCMR = t >> 17;
	// start the SRTC
	SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
	while (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)); // wait
      34:	fa95 f4a5 	rbit	r4, r5
	// start the RTC and sync it to the SRTC
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
      38:	fab4 f484 	clz	r4, r4
      3c:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
}
      40:	fa06 f404 	lsl.w	r4, r6, r4
      44:	4798      	blx	r3
      46:	43a5      	bics	r5, r4
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
	return usec;
}
      48:	d1f4      	bne.n	34 <_teensy_model_identifier+0x10>
      4a:	4b1e      	ldr	r3, [pc, #120]	; (c4 <_teensy_model_identifier+0xa0>)
      4c:	699d      	ldr	r5, [r3, #24]
      4e:	695a      	ldr	r2, [r3, #20]
      50:	4015      	ands	r5, r2
      52:	d00d      	beq.n	70 <_teensy_model_identifier+0x4c>
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      54:	4f1c      	ldr	r7, [pc, #112]	; (c8 <_teensy_model_identifier+0xa4>)
      56:	2601      	movs	r6, #1
      58:	619d      	str	r5, [r3, #24]
      5a:	fa95 f4a5 	rbit	r4, r5
}
      5e:	fab4 f484 	clz	r4, r4
      62:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      66:	fa06 f404 	lsl.w	r4, r6, r4
      6a:	4798      	blx	r3
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      6c:	43a5      	bics	r5, r4
      6e:	d1f4      	bne.n	5a <_teensy_model_identifier+0x36>
      70:	4b16      	ldr	r3, [pc, #88]	; (cc <_teensy_model_identifier+0xa8>)
		return ADC2_R0;
      72:	699d      	ldr	r5, [r3, #24]
      74:	695a      	ldr	r2, [r3, #20]
}
      76:	4015      	ands	r5, r2
	if (pin > sizeof(pin_to_channel)) return 0;
      78:	d00d      	beq.n	96 <_teensy_model_identifier+0x72>
}
      7a:	4f15      	ldr	r7, [pc, #84]	; (d0 <_teensy_model_identifier+0xac>)
      7c:	2601      	movs	r6, #1
      7e:	619d      	str	r5, [r3, #24]
      80:	fa95 f4a5 	rbit	r4, r5
      84:	fab4 f484 	clz	r4, r4
      88:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
			break;
      8c:	fa06 f404 	lsl.w	r4, r6, r4
      90:	4798      	blx	r3
      92:	43a5      	bics	r5, r4
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x52) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FF8000;
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
      94:	d1f4      	bne.n	80 <_teensy_model_identifier+0x5c>
      96:	4b0f      	ldr	r3, [pc, #60]	; (d4 <_teensy_model_identifier+0xb0>)
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
      98:	699d      	ldr	r5, [r3, #24]
      9a:	695a      	ldr	r2, [r3, #20]
      9c:	4015      	ands	r5, r2
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
      9e:	d00d      	beq.n	bc <_teensy_model_identifier+0x98>
	flash_wait();
}
      a0:	4f0d      	ldr	r7, [pc, #52]	; (d8 <_teensy_model_identifier+0xb4>)
      a2:	2601      	movs	r6, #1
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
      a4:	619d      	str	r5, [r3, #24]
	flash_wait();
      a6:	fa95 f4a5 	rbit	r4, r5
      aa:	fab4 f484 	clz	r4, r4
      ae:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      b2:	fa06 f404 	lsl.w	r4, r6, r4
      b6:	4798      	blx	r3
      b8:	43a5      	bics	r5, r4
      ba:	d1f4      	bne.n	a6 <_teensy_model_identifier+0x82>
{
	irq_anyport(&GPIO6_DR, isr_table_gpio1);
	irq_anyport(&GPIO7_DR, isr_table_gpio2);
	irq_anyport(&GPIO8_DR, isr_table_gpio3);
	irq_anyport(&GPIO9_DR, isr_table_gpio4);
}
      bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      be:	bf00      	nop
      c0:	20000af0 	.word	0x20000af0
      c4:	42004000 	.word	0x42004000
      c8:	20000b70 	.word	0x20000b70
      cc:	42008000 	.word	0x42008000
      d0:	20000bf0 	.word	0x20000bf0
      d4:	4200c000 	.word	0x4200c000
      d8:	20000c70 	.word	0x20000c70

000000dc <register_tm_clones>:
    if(c == skipChar)
      ; // ignore
    else if(c == '-')
      isNegative = true;
    else if (c == '.')
      isFraction = true;
      dc:	4805      	ldr	r0, [pc, #20]	; (f4 <register_tm_clones+0x18>)
      de:	4b06      	ldr	r3, [pc, #24]	; (f8 <register_tm_clones+0x1c>)
      e0:	1a1b      	subs	r3, r3, r0
    return 0; // zero returned if timeout
      e2:	0fd9      	lsrs	r1, r3, #31
      e4:	eb01 01a3 	add.w	r1, r1, r3, asr #2
    value = -value;
  if(isFraction)
    return value * fraction;
  else
    return value;
}
      e8:	1049      	asrs	r1, r1, #1
      ea:	d002      	beq.n	f2 <register_tm_clones+0x16>
      ec:	4b03      	ldr	r3, [pc, #12]	; (fc <register_tm_clones+0x20>)
      ee:	b103      	cbz	r3, f2 <register_tm_clones+0x16>
      f0:	4718      	bx	r3
      f2:	4770      	bx	lr
      f4:	200012c0 	.word	0x200012c0
      f8:	200012c0 	.word	0x200012c0
      fc:	00000000 	.word	0x00000000

00000100 <frame_dummy>:
     100:	b508      	push	{r3, lr}
     102:	4b05      	ldr	r3, [pc, #20]	; (118 <frame_dummy+0x18>)
  brakes3.buf[4] = 0x0;   // low byte, LEFT Rear
  brakes3.buf[5] = 0x04;  // high byte, LEFT Rear // 254+10? (5050 returns 0xA)
  brakes3.buf[6] = 0x0;   // low byte, RIGHT Rear
  brakes3.buf[7] = 0x04;  // low byte, RIGHT Rear  // 254+10?
  HaldexCAN.write(brakes3);
}
     104:	b11b      	cbz	r3, 10e <frame_dummy+0xe>
     106:	4905      	ldr	r1, [pc, #20]	; (11c <frame_dummy+0x1c>)
     108:	4805      	ldr	r0, [pc, #20]	; (120 <frame_dummy+0x20>)
     10a:	f3af 8000 	nop.w
     10e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     112:	f7ff bfe3 	b.w	dc <register_tm_clones>
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
     116:	bf00      	nop
     118:	00000000 	.word	0x00000000
     11c:	200068cc 	.word	0x200068cc
     120:	6000b800 	.word	0x6000b800

00000124 <setup>:
bool printMode(void *params) {
  Serial.printf("OpenHaldex mode=%d\n", state.mode);
  return true;
}

void setup() {
     124:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	// is always initialized early during startup.  The baud rate setting
	// is not used.  Communication occurs at USB native speed.  For
	// compatibility with Arduino code, Serial.begin waits up to 2 seconds
	// for your PC to open the virtual serial port.
        void begin(long baud_unused __attribute__((unused))) {
		uint32_t millis_begin = systick_millis_count;
     128:	4d3f      	ldr	r5, [pc, #252]	; (228 <setup+0x104>)
				// Wait up to 2 seconds for Arduino Serial Monitor
				if (elapsed > 2000) break;
			} else {
				// But wait only 3/4 second if there is no sign the
				// USB host has begun the USB enumeration process.
				if (elapsed > 750) break;
     12a:	f240 28ee 	movw	r8, #750	; 0x2ee
     12e:	4c3f      	ldr	r4, [pc, #252]	; (22c <setup+0x108>)
	// Testing Serial as a boolean indicates whether USB is active and a program
	// running on your PC has raised the DTR signal, which typically means it has
	// opened the port and is ready to communicate.
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     130:	4f3f      	ldr	r7, [pc, #252]	; (230 <setup+0x10c>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     132:	f8df 9118 	ldr.w	r9, [pc, #280]	; 24c <setup+0x128>
		uint32_t millis_begin = systick_millis_count;
     136:	682e      	ldr	r6, [r5, #0]
		yield();
     138:	f007 fa22 	bl	7580 <yield>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     13c:	7823      	ldrb	r3, [r4, #0]
     13e:	2b00      	cmp	r3, #0
     140:	d050      	beq.n	1e4 <setup+0xc0>
     142:	783b      	ldrb	r3, [r7, #0]
     144:	07db      	lsls	r3, r3, #31
     146:	d54d      	bpl.n	1e4 <setup+0xc0>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     148:	682b      	ldr	r3, [r5, #0]
     14a:	f8d9 2000 	ldr.w	r2, [r9]
     14e:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     150:	2b0e      	cmp	r3, #14
     152:	d947      	bls.n	1e4 <setup+0xc0>
#if stateDebug
  Serial.println(F("\nOpenHaldexTeensy 4.0 Initialisation"));
  Serial.printf("Running at %dMHz\r\n", F_CPU_ACTUAL / (1000 * 1000));
#endif /* stateDebug */

  Serial2.begin(baudBT);
     154:	2200      	movs	r2, #0
     156:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     15a:	4836      	ldr	r0, [pc, #216]	; (234 <setup+0x110>)
     15c:	f004 ff8e 	bl	507c <HardwareSerial::begin(unsigned long, unsigned short)>
#if stateDebug
  Serial.println(F("\nBluetooth initialised!"));
#endif /* stateDebug */

  // Turn off the power LED for power saving
  pinMode(LED_BUILTIN, OUTPUT);
     160:	2101      	movs	r1, #1
     162:	200d      	movs	r0, #13
     164:	f005 fbd0 	bl	5908 <pinMode>
  canInit();
     168:	f002 fae8 	bl	273c <canInit()>
  readEEP();
     16c:	f004 fc54 	bl	4a18 <readEEP()>

  // Setup the RGB LED pins for outputs
  pinMode(pinLED_R, OUTPUT);
     170:	2101      	movs	r1, #1
     172:	200c      	movs	r0, #12
     174:	f005 fbc8 	bl	5908 <pinMode>
  pinMode(pinLED_G, OUTPUT);
     178:	2101      	movs	r1, #1
     17a:	200a      	movs	r0, #10
     17c:	f005 fbc4 	bl	5908 <pinMode>
  pinMode(pinLED_B, OUTPUT);
     180:	2101      	movs	r1, #1
     182:	200b      	movs	r0, #11
     184:	f005 fbc0 	bl	5908 <pinMode>

  // Setup the switches (Switch Mode & Bluetooth) for interrupt / inputs (keeps response quick)
  // can't have BT_Conf as an interrupt and change the pin state...
  attachInterrupt(pinSwitchMode, checkSwitchMode, HIGH);
     188:	2201      	movs	r2, #1
     18a:	492b      	ldr	r1, [pc, #172]	; (238 <setup+0x114>)
     18c:	2011      	movs	r0, #17
     18e:	f005 fde9 	bl	5d64 <attachInterrupt>
  pinMode(pinBT_Conf, INPUT);
     192:	2100      	movs	r1, #0
     194:	2004      	movs	r0, #4
     196:	f005 fbb7 	bl	5908 <pinMode>

    inline
    struct task *
    next_task_slot()
    {
        timer_foreach_task(slot) {
     19a:	4b28      	ldr	r3, [pc, #160]	; (23c <setup+0x118>)
     19c:	6828      	ldr	r0, [r5, #0]
     19e:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     1a2:	681a      	ldr	r2, [r3, #0]
     1a4:	b3aa      	cbz	r2, 212 <setup+0xee>
        timer_foreach_task(slot) {
     1a6:	3314      	adds	r3, #20
     1a8:	428b      	cmp	r3, r1
     1aa:	d1fa      	bne.n	1a2 <setup+0x7e>
     1ac:	4b23      	ldr	r3, [pc, #140]	; (23c <setup+0x118>)
     1ae:	6828      	ldr	r0, [r5, #0]
     1b0:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     1b4:	681a      	ldr	r2, [r3, #0]
     1b6:	b312      	cbz	r2, 1fe <setup+0xda>
        timer_foreach_task(slot) {
     1b8:	3314      	adds	r3, #20
     1ba:	428b      	cmp	r3, r1
     1bc:	d1fa      	bne.n	1b4 <setup+0x90>

  //timer.every(20, sendStandaloneCAN);
  /* Standalone Haldex Control */

  // Disable unwanted Teensy optionals
  CCM_ANALOG_PLL_AUDIO |= CCM_ANALOG_PLL_AUDIO_POWERDOWN;
     1be:	4b20      	ldr	r3, [pc, #128]	; (240 <setup+0x11c>)
     1c0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
     1c2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     1c6:	671a      	str	r2, [r3, #112]	; 0x70
  CCM_ANALOG_PLL_VIDEO |= CCM_ANALOG_PLL_VIDEO_POWERDOWN;
     1c8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
     1cc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     1d0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  CCM_ANALOG_PLL_ENET |= CCM_ANALOG_PLL_ENET_POWERDOWN;
     1d4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
     1d8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     1dc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
}
     1e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			uint32_t elapsed = systick_millis_count - millis_begin;
     1e4:	682b      	ldr	r3, [r5, #0]
			if (usb_configuration) {
     1e6:	7822      	ldrb	r2, [r4, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
     1e8:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
     1ea:	b12a      	cbz	r2, 1f8 <setup+0xd4>
				if (elapsed > 2000) break;
     1ec:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
     1f0:	d8b0      	bhi.n	154 <setup+0x30>
			yield();
     1f2:	f007 f9c5 	bl	7580 <yield>
     1f6:	e79f      	b.n	138 <setup+0x14>
				if (elapsed > 750) break;
     1f8:	4543      	cmp	r3, r8
     1fa:	d9fa      	bls.n	1f2 <setup+0xce>
     1fc:	e7aa      	b.n	154 <setup+0x30>
    {
        struct task * const slot = next_task_slot();

        if (!slot) return NULL;

        slot->handler = h;
     1fe:	4c11      	ldr	r4, [pc, #68]	; (244 <setup+0x120>)
        slot->opaque = opaque;
        slot->start = start;
        slot->expires = expires;
     200:	f241 3188 	movw	r1, #5000	; 0x1388
        slot->start = start;
     204:	e9c3 2001 	strd	r2, r0, [r3, #4]
        slot->repeat = repeat;
     208:	2201      	movs	r2, #1
        slot->handler = h;
     20a:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     20c:	e9c3 1203 	strd	r1, r2, [r3, #12]

        return slot;
     210:	e7d5      	b.n	1be <setup+0x9a>
        slot->handler = h;
     212:	4c0d      	ldr	r4, [pc, #52]	; (248 <setup+0x124>)
        slot->expires = expires;
     214:	f640 31b8 	movw	r1, #3000	; 0xbb8
        slot->opaque = opaque;
     218:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     21a:	2201      	movs	r2, #1
        slot->start = start;
     21c:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     21e:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     220:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     224:	e7c2      	b.n	1ac <setup+0x88>
     226:	bf00      	nop
     228:	2000697c 	.word	0x2000697c
     22c:	20006af0 	.word	0x20006af0
     230:	20006aef 	.word	0x20006aef
     234:	200067a8 	.word	0x200067a8
     238:	00000729 	.word	0x00000729
     23c:	20006984 	.word	0x20006984
     240:	400d8000 	.word	0x400d8000
     244:	00004aed 	.word	0x00004aed
     248:	00000375 	.word	0x00000375
     24c:	20006acc 	.word	0x20006acc

00000250 <_GLOBAL__sub_I_state>:
    btInit();  // can't have BT_Conf as an interrupt and change the pin state...
  }

  // light up the LED as per the 'state.mode'
  LED();
}
     250:	b508      	push	{r3, lr}
***/

struct EEPROMClass{

#if defined(__arm__) && defined(TEENSYDUINO)
    EEPROMClass()                        { eeprom_initialize(); }
     252:	f005 fbbf 	bl	59d4 <eeprom_initialize>
    Timer() : tasks{} {}
     256:	f44f 72a0 	mov.w	r2, #320	; 0x140
     25a:	2100      	movs	r1, #0
     25c:	4801      	ldr	r0, [pc, #4]	; (264 <_GLOBAL__sub_I_state+0x14>)
     25e:	f007 fc0f 	bl	7a80 <memset>
     262:	bd08      	pop	{r3, pc}
     264:	20006984 	.word	0x20006984

00000268 <loop>:
void loop() {
     268:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     26c:	4d3b      	ldr	r5, [pc, #236]	; (35c <loop+0xf4>)
     26e:	b084      	sub	sp, #16
     270:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 36c <loop+0x104>
        task->handler = NULL;
     274:	2700      	movs	r7, #0
                    task->repeat = task->handler(task->opaque) && task->repeat;
     276:	f04f 0a01 	mov.w	sl, #1
     27a:	f505 76a0 	add.w	r6, r5, #320	; 0x140
     27e:	462c      	mov	r4, r5
     280:	e009      	b.n	296 <loop+0x2e>
     282:	f854 3c04 	ldr.w	r3, [r4, #-4]
     286:	b1bb      	cbz	r3, 2b8 <loop+0x50>
     288:	f844 ac04 	str.w	sl, [r4, #-4]
                    if (task->repeat) task->start = t;
     28c:	f844 9c0c 	str.w	r9, [r4, #-12]
        timer_foreach_task(task) {
     290:	3414      	adds	r4, #20
     292:	42b4      	cmp	r4, r6
     294:	d019      	beq.n	2ca <loop+0x62>
            if (task->handler) {
     296:	f854 2c14 	ldr.w	r2, [r4, #-20]
     29a:	2a00      	cmp	r2, #0
     29c:	d0f8      	beq.n	290 <loop+0x28>
     29e:	f8d8 9000 	ldr.w	r9, [r8]
                if (duration >= task->expires) {
     2a2:	e954 3103 	ldrd	r3, r1, [r4, #-12]
                const unsigned long duration = t - task->start;
     2a6:	eba9 0303 	sub.w	r3, r9, r3
                if (duration >= task->expires) {
     2aa:	428b      	cmp	r3, r1
     2ac:	d3f0      	bcc.n	290 <loop+0x28>
                    task->repeat = task->handler(task->opaque) && task->repeat;
     2ae:	f854 0c10 	ldr.w	r0, [r4, #-16]
     2b2:	4790      	blx	r2
     2b4:	2800      	cmp	r0, #0
     2b6:	d1e4      	bne.n	282 <loop+0x1a>
        task->repeat = 0;
     2b8:	f844 7c04 	str.w	r7, [r4, #-4]
        task->opaque = T();
     2bc:	e944 7705 	strd	r7, r7, [r4, #-20]
        task->expires = 0;
     2c0:	e944 7703 	strd	r7, r7, [r4, #-12]
        timer_foreach_task(task) {
     2c4:	3414      	adds	r4, #20
     2c6:	42b4      	cmp	r4, r6
     2c8:	d1e5      	bne.n	296 <loop+0x2e>
     2ca:	f8d8 3000 	ldr.w	r3, [r8]
            if (task->handler) {
     2ce:	f855 3c14 	ldr.w	r3, [r5, #-20]
     2d2:	b133      	cbz	r3, 2e2 <loop+0x7a>
     2d4:	f8d8 3000 	ldr.w	r3, [r8]
                if (duration >= task->expires) {
     2d8:	e955 1203 	ldrd	r1, r2, [r5, #-12]
                const unsigned long duration = t - task->start;
     2dc:	1a5b      	subs	r3, r3, r1
                if (duration >= task->expires) {
     2de:	4293      	cmp	r3, r2
     2e0:	d202      	bcs.n	2e8 <loop+0x80>
        timer_foreach_const_task(task) {
     2e2:	3514      	adds	r5, #20
     2e4:	42b5      	cmp	r5, r6
     2e6:	d1f2      	bne.n	2ce <loop+0x66>
  if (millis() - lastTransmission >= btTimeout) {
     2e8:	491d      	ldr	r1, [pc, #116]	; (360 <loop+0xf8>)
    bt_packet rx_packet = { 0 };
     2ea:	2400      	movs	r4, #0
     2ec:	f8d8 3000 	ldr.w	r3, [r8]
  if (millis() - lastTransmission >= btTimeout) {
     2f0:	6809      	ldr	r1, [r1, #0]
     2f2:	f8d8 3000 	ldr.w	r3, [r8]
     2f6:	4a1b      	ldr	r2, [pc, #108]	; (364 <loop+0xfc>)
     2f8:	1a5b      	subs	r3, r3, r1
  while (Serial2.available()) {
     2fa:	4d1b      	ldr	r5, [pc, #108]	; (368 <loop+0x100>)
  if (millis() - lastTransmission >= btTimeout) {
     2fc:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
     300:	bf2c      	ite	cs
     302:	2300      	movcs	r3, #0
     304:	2301      	movcc	r3, #1
     306:	7013      	strb	r3, [r2, #0]
     308:	e00c      	b.n	324 <loop+0xbc>
    bt_packet rx_packet = { 0 };
     30a:	e9cd 4400 	strd	r4, r4, [sp]
     30e:	9402      	str	r4, [sp, #8]
     310:	f88d 400c 	strb.w	r4, [sp, #12]
	float parseFloat();
	float parseFloat(char skipChar);
	size_t readBytes(char *buffer, size_t length);
	size_t readBytes(uint8_t *buffer, size_t length) { return readBytes((char *)buffer, length); }
	size_t readBytesUntil(char terminator, char *buffer, size_t length);
	size_t readBytesUntil(char terminator, uint8_t *buffer, size_t length) { return readBytesUntil(terminator, (char *)buffer, length); }
     314:	f005 fa24 	bl	5760 <Stream::readBytesUntil(char, char*, unsigned int)>
     318:	4603      	mov	r3, r0
    btProcess(&rx_packet);
     31a:	4668      	mov	r0, sp
    rx_packet.len = Serial2.readBytesUntil(SERIAL_PACKET_END, rx_packet.data, ARRAY_SIZE(rx_packet.data));
     31c:	f88d 3000 	strb.w	r3, [sp]
    btProcess(&rx_packet);
     320:	f000 f8b4 	bl	48c <btProcess(bt_packet*)>
  while (Serial2.available()) {
     324:	4628      	mov	r0, r5
     326:	f004 fde3 	bl	4ef0 <HardwareSerial::available()>
     32a:	4606      	mov	r6, r0
     32c:	230c      	movs	r3, #12
     32e:	f10d 0201 	add.w	r2, sp, #1
     332:	21ff      	movs	r1, #255	; 0xff
     334:	4628      	mov	r0, r5
     336:	2e00      	cmp	r6, #0
     338:	d1e7      	bne.n	30a <loop+0xa2>
  if (digitalRead(pinBT_Conf)) {
     33a:	2004      	movs	r0, #4
     33c:	f005 fad2 	bl	58e4 <digitalRead>
     340:	b920      	cbnz	r0, 34c <loop+0xe4>
}
     342:	b004      	add	sp, #16
     344:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     348:	f000 bade 	b.w	908 <LED()>
    btInit();  // can't have BT_Conf as an interrupt and change the pin state...
     34c:	f000 f956 	bl	5fc <btInit()>
}
     350:	b004      	add	sp, #16
     352:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     356:	f000 bad7 	b.w	908 <LED()>
     35a:	bf00      	nop
     35c:	20006998 	.word	0x20006998
     360:	200068c4 	.word	0x200068c4
     364:	20006ae1 	.word	0x20006ae1
     368:	200067a8 	.word	0x200067a8
     36c:	2000697c 	.word	0x2000697c

00000370 <_GLOBAL__sub_I__Z12btSendStatusPv>:
     370:	f005 bb30 	b.w	59d4 <eeprom_initialize>

00000374 <btSendStatus(void*)>:
#include "openhaldex.h"

bool btSendStatus(void *params) {
     374:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bt_packet packet;
  if (!isScreen) {
     378:	4c3c      	ldr	r4, [pc, #240]	; (46c <btSendStatus(void*)+0xf8>)
bool btSendStatus(void *params) {
     37a:	b084      	sub	sp, #16
  if (!isScreen) {
     37c:	7823      	ldrb	r3, [r4, #0]
     37e:	2b00      	cmp	r3, #0
     380:	d03c      	beq.n	3fc <btSendStatus(void*)+0x88>
     382:	f8df 8104 	ldr.w	r8, [pc, #260]	; 488 <btSendStatus(void*)+0x114>
     386:	f10d 0501 	add.w	r5, sp, #1
     38a:	4f39      	ldr	r7, [pc, #228]	; (470 <btSendStatus(void*)+0xfc>)
     38c:	4e39      	ldr	r6, [pc, #228]	; (474 <btSendStatus(void*)+0x100>)

  if (isScreen) {
    packet.data[0] = APP_MSG_STATUS;
    packet.data[1] = 0;  // was haldexStatus
    packet.data[2] = haldexEngagement;
    packet.data[3] = int(lockTarget);
     38e:	edd7 7a00 	vldr	s15, [r7]
    packet.data[7] = int(pedValue);
    packet.data[8] = softwareVersion;
    packet.data[9] = SERIAL_PACKET_END;
    packet.len = 10;

    Serial2.write(packet.data, packet.len);
     392:	4629      	mov	r1, r5
    packet.data[7] = int(pedValue);
     394:	4b38      	ldr	r3, [pc, #224]	; (478 <btSendStatus(void*)+0x104>)
    packet.data[3] = int(lockTarget);
     396:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    packet.data[2] = haldexEngagement;
     39a:	f898 4000 	ldrb.w	r4, [r8]
    packet.data[7] = int(pedValue);
     39e:	ed93 7a00 	vldr	s14, [r3]
    packet.data[5] = state.mode_override;
     3a2:	4836      	ldr	r0, [pc, #216]	; (47c <btSendStatus(void*)+0x108>)
    packet.data[3] = int(lockTarget);
     3a4:	ee17 3a90 	vmov	r3, s15
    packet.data[7] = int(pedValue);
     3a8:	eefd 7ac7 	vcvt.s32.f32	s15, s14
    packet.data[2] = haldexEngagement;
     3ac:	f88d 4003 	strb.w	r4, [sp, #3]
    packet.data[3] = int(lockTarget);
     3b0:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[8] = softwareVersion;
     3b4:	4b32      	ldr	r3, [pc, #200]	; (480 <btSendStatus(void*)+0x10c>)
    packet.data[7] = int(pedValue);
     3b6:	ee17 2a90 	vmov	r2, s15
    packet.data[5] = state.mode_override;
     3ba:	f890 4023 	ldrb.w	r4, [r0, #35]	; 0x23
    packet.data[8] = softwareVersion;
     3be:	681b      	ldr	r3, [r3, #0]
    packet.data[7] = int(pedValue);
     3c0:	f88d 2008 	strb.w	r2, [sp, #8]
    packet.data[6] = state.mode;
     3c4:	7802      	ldrb	r2, [r0, #0]
    packet.len = 10;
     3c6:	f44f 7085 	mov.w	r0, #266	; 0x10a
    packet.data[4] = vehicleSpeed;
     3ca:	7836      	ldrb	r6, [r6, #0]
    packet.data[5] = state.mode_override;
     3cc:	f88d 4006 	strb.w	r4, [sp, #6]
    packet.data[9] = SERIAL_PACKET_END;
     3d0:	24ff      	movs	r4, #255	; 0xff
    packet.data[8] = softwareVersion;
     3d2:	f88d 3009 	strb.w	r3, [sp, #9]
    packet.data[1] = 0;  // was haldexStatus
     3d6:	2300      	movs	r3, #0
    packet.data[6] = state.mode;
     3d8:	f88d 2007 	strb.w	r2, [sp, #7]
    Serial2.write(packet.data, packet.len);
     3dc:	220a      	movs	r2, #10
    packet.len = 10;
     3de:	f8ad 0000 	strh.w	r0, [sp]
    Serial2.write(packet.data, packet.len);
     3e2:	4828      	ldr	r0, [pc, #160]	; (484 <btSendStatus(void*)+0x110>)
    packet.data[4] = vehicleSpeed;
     3e4:	f88d 6005 	strb.w	r6, [sp, #5]
    packet.data[9] = SERIAL_PACKET_END;
     3e8:	f88d 400a 	strb.w	r4, [sp, #10]
    packet.data[1] = 0;  // was haldexStatus
     3ec:	f88d 3002 	strb.w	r3, [sp, #2]
    Serial2.write(packet.data, packet.len);
     3f0:	f005 f95c 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  }
  return true;
}
     3f4:	2001      	movs	r0, #1
     3f6:	b004      	add	sp, #16
     3f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    packet.data[3] = lockTarget;  //lockTarget;
     3fc:	4f1c      	ldr	r7, [pc, #112]	; (470 <btSendStatus(void*)+0xfc>)
     3fe:	f10d 0501 	add.w	r5, sp, #1
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     402:	f8df 8084 	ldr.w	r8, [pc, #132]	; 488 <btSendStatus(void*)+0x114>
     406:	f10d 0005 	add.w	r0, sp, #5
    packet.data[3] = lockTarget;  //lockTarget;
     40a:	edd7 7a00 	vldr	s15, [r7]
        packet.data[i] = SERIAL_PACKET_END - 1;
     40e:	21fe      	movs	r1, #254	; 0xfe
    packet.data[1] = 0;  // was haldexStatus
     410:	f88d 3002 	strb.w	r3, [sp, #2]
    packet.data[3] = lockTarget;  //lockTarget;
     414:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     418:	f898 3000 	ldrb.w	r3, [r8]
    packet.data[4] = vehicleSpeed;  //vehicleSpeed;
     41c:	4e15      	ldr	r6, [pc, #84]	; (474 <btSendStatus(void*)+0x100>)
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     41e:	f88d 3003 	strb.w	r3, [sp, #3]
    packet.data[3] = lockTarget;  //lockTarget;
     422:	ee17 3a90 	vmov	r3, s15
     426:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[4] = vehicleSpeed;  //vehicleSpeed;
     42a:	7833      	ldrb	r3, [r6, #0]
     42c:	f88d 3005 	strb.w	r3, [sp, #5]
    packet.data[5] = SERIAL_PACKET_END;
     430:	23ff      	movs	r3, #255	; 0xff
     432:	f88d 3006 	strb.w	r3, [sp, #6]
    packet.len = 6;
     436:	f44f 7383 	mov.w	r3, #262	; 0x106
     43a:	f8ad 3000 	strh.w	r3, [sp]
     43e:	462b      	mov	r3, r5
    for (int i = 0; i < packet.len - 1; i++) {
     440:	4298      	cmp	r0, r3
     442:	d006      	beq.n	452 <btSendStatus(void*)+0xde>
      if (packet.data[i] == SERIAL_PACKET_END) {
     444:	f813 2f01 	ldrb.w	r2, [r3, #1]!
     448:	2aff      	cmp	r2, #255	; 0xff
        packet.data[i] = SERIAL_PACKET_END - 1;
     44a:	bf08      	it	eq
     44c:	7019      	strbeq	r1, [r3, #0]
    for (int i = 0; i < packet.len - 1; i++) {
     44e:	4298      	cmp	r0, r3
     450:	d1f8      	bne.n	444 <btSendStatus(void*)+0xd0>
    Serial2.write(packet.data, packet.len);
     452:	2206      	movs	r2, #6
     454:	4629      	mov	r1, r5
     456:	480b      	ldr	r0, [pc, #44]	; (484 <btSendStatus(void*)+0x110>)
     458:	f005 f928 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  if (isScreen) {
     45c:	7823      	ldrb	r3, [r4, #0]
     45e:	2b00      	cmp	r3, #0
     460:	d195      	bne.n	38e <btSendStatus(void*)+0x1a>
}
     462:	2001      	movs	r0, #1
     464:	b004      	add	sp, #16
     466:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     46a:	bf00      	nop
     46c:	20006ae7 	.word	0x20006ae7
     470:	200068c8 	.word	0x200068c8
     474:	20006af3 	.word	0x20006af3
     478:	200068e4 	.word	0x200068e4
     47c:	20006954 	.word	0x20006954
     480:	20000d2c 	.word	0x20000d2c
     484:	200067a8 	.word	0x200067a8
     488:	20006ae3 	.word	0x20006ae3

0000048c <btProcess(bt_packet*)>:
     48c:	4a52      	ldr	r2, [pc, #328]	; (5d8 <btProcess(bt_packet*)+0x14c>)

void btProcess(bt_packet *rx_packet) {
  byte lockpoint_index;
  bt_packet tx_packet;

  lastTransmission = millis();
     48e:	4b53      	ldr	r3, [pc, #332]	; (5dc <btProcess(bt_packet*)+0x150>)
     490:	6812      	ldr	r2, [r2, #0]
     492:	601a      	str	r2, [r3, #0]

  switch (rx_packet->data[0]) {
     494:	7843      	ldrb	r3, [r0, #1]
     496:	2b04      	cmp	r3, #4
     498:	d807      	bhi.n	4aa <btProcess(bt_packet*)+0x1e>
     49a:	e8df f003 	tbb	[pc, r3]
     49e:	0618      	.short	0x0618
     4a0:	0f03      	.short	0x0f03
     4a2:	07          	.byte	0x07
     4a3:	00          	.byte	0x00
#endif

      break;

    case APP_MSG_CUSTOM_DATA:
      lockpoint_index = rx_packet->data[1];
     4a4:	7883      	ldrb	r3, [r0, #2]

      if (lockpoint_index < NUM_LOCK_POINTS) {
     4a6:	2b09      	cmp	r3, #9
     4a8:	d949      	bls.n	53e <btProcess(bt_packet*)+0xb2>
     4aa:	4770      	bx	lr
          Serial.println("App assumed control of override");
          break;
      }
      break;
    case APP_MSG_IS_SCREEN:
      isScreen = true;
     4ac:	494c      	ldr	r1, [pc, #304]	; (5e0 <btProcess(bt_packet*)+0x154>)
     4ae:	2001      	movs	r0, #1
      state.mode_override = false;
     4b0:	4b4c      	ldr	r3, [pc, #304]	; (5e4 <btProcess(bt_packet*)+0x158>)
     4b2:	2200      	movs	r2, #0
      isScreen = true;
     4b4:	7008      	strb	r0, [r1, #0]
      state.mode_override = false;
     4b6:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
      break;
  }
}
     4ba:	4770      	bx	lr
void btProcess(bt_packet *rx_packet) {
     4bc:	b500      	push	{lr}
     4be:	7883      	ldrb	r3, [r0, #2]
     4c0:	b085      	sub	sp, #20
     4c2:	2b03      	cmp	r3, #3
     4c4:	d82a      	bhi.n	51c <btProcess(bt_packet*)+0x90>
     4c6:	e8df f003 	tbb	[pc, r3]
     4ca:	786e      	.short	0x786e
     4cc:	6010      	.short	0x6010
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     4ce:	7883      	ldrb	r3, [r0, #2]
     4d0:	2b03      	cmp	r3, #3
     4d2:	d826      	bhi.n	522 <btProcess(bt_packet*)+0x96>
     4d4:	4a43      	ldr	r2, [pc, #268]	; (5e4 <btProcess(bt_packet*)+0x158>)
      if (state.mode == MODE_FWD) {
     4d6:	2b01      	cmp	r3, #1
      state.ped_threshold = rx_packet->data[2];
     4d8:	78c1      	ldrb	r1, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     4da:	7013      	strb	r3, [r2, #0]
      state.ped_threshold = rx_packet->data[2];
     4dc:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
      if (state.mode == MODE_FWD) {
     4e0:	d125      	bne.n	52e <btProcess(bt_packet*)+0xa2>
        lockTarget = 0;
     4e2:	4b41      	ldr	r3, [pc, #260]	; (5e8 <btProcess(bt_packet*)+0x15c>)
     4e4:	2200      	movs	r2, #0
     4e6:	601a      	str	r2, [r3, #0]
     4e8:	e021      	b.n	52e <btProcess(bt_packet*)+0xa2>
          tx_packet.data[2] = state.mode;
     4ea:	4b3e      	ldr	r3, [pc, #248]	; (5e4 <btProcess(bt_packet*)+0x158>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     4ec:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     4ee:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     4f2:	f04f 0c02 	mov.w	ip, #2
          tx_packet.data[2] = state.mode;
     4f6:	7818      	ldrb	r0, [r3, #0]
          tx_packet.data[3] = state.ped_threshold;
     4f8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
          tx_packet.data[4] = SERIAL_PACKET_END;
     4fc:	f88d 2005 	strb.w	r2, [sp, #5]
          Serial2.write(tx_packet.data, tx_packet.len);
     500:	2205      	movs	r2, #5
          tx_packet.data[2] = state.mode;
     502:	f88d 0003 	strb.w	r0, [sp, #3]
          tx_packet.len = 5;
     506:	f8ad 1000 	strh.w	r1, [sp]
          Serial2.write(tx_packet.data, tx_packet.len);
     50a:	f10d 0101 	add.w	r1, sp, #1
     50e:	4837      	ldr	r0, [pc, #220]	; (5ec <btProcess(bt_packet*)+0x160>)
          tx_packet.data[3] = state.ped_threshold;
     510:	f88d 3004 	strb.w	r3, [sp, #4]
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     514:	f88d c002 	strb.w	ip, [sp, #2]
          Serial2.write(tx_packet.data, tx_packet.len);
     518:	f005 f8c8 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
}
     51c:	b005      	add	sp, #20
     51e:	f85d fb04 	ldr.w	pc, [sp], #4
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     522:	4b30      	ldr	r3, [pc, #192]	; (5e4 <btProcess(bt_packet*)+0x158>)
     524:	2100      	movs	r1, #0
      state.ped_threshold = rx_packet->data[2];
     526:	78c2      	ldrb	r2, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     528:	7019      	strb	r1, [r3, #0]
      state.ped_threshold = rx_packet->data[2];
     52a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      if (rx_packet->data[1] == MODE_CUSTOM) {
     52e:	7883      	ldrb	r3, [r0, #2]
     530:	2b03      	cmp	r3, #3
        isCustom = true;
     532:	4b2f      	ldr	r3, [pc, #188]	; (5f0 <btProcess(bt_packet*)+0x164>)
     534:	bf0c      	ite	eq
     536:	2201      	moveq	r2, #1
        isCustom = false;
     538:	2200      	movne	r2, #0
     53a:	701a      	strb	r2, [r3, #0]
     53c:	4770      	bx	lr
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     53e:	4a29      	ldr	r2, [pc, #164]	; (5e4 <btProcess(bt_packet*)+0x158>)
     540:	eb03 0143 	add.w	r1, r3, r3, lsl #1
     544:	f890 c003 	ldrb.w	ip, [r0, #3]
        if (lockpoint_index > 6) {
     548:	2b06      	cmp	r3, #6
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     54a:	4411      	add	r1, r2
     54c:	f881 c001 	strb.w	ip, [r1, #1]
        state.custom_mode.lockpoints[lockpoint_index].lock = rx_packet->data[3];
     550:	f890 c004 	ldrb.w	ip, [r0, #4]
     554:	f881 c002 	strb.w	ip, [r1, #2]
        state.custom_mode.lockpoints[lockpoint_index].intensity = rx_packet->data[4];
     558:	7940      	ldrb	r0, [r0, #5]
     55a:	70c8      	strb	r0, [r1, #3]
        if (lockpoint_index > 6) {
     55c:	d90c      	bls.n	578 <btProcess(bt_packet*)+0xec>
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     55e:	3b07      	subs	r3, #7
     560:	2101      	movs	r1, #1
     562:	7fd0      	ldrb	r0, [r2, #31]
     564:	fa01 f303 	lsl.w	r3, r1, r3
     568:	4303      	orrs	r3, r0
     56a:	77d3      	strb	r3, [r2, #31]
        state.custom_mode.lockpoint_count++;
     56c:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
     570:	3301      	adds	r3, #1
     572:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
     576:	4770      	bx	lr
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     578:	2001      	movs	r0, #1
     57a:	f892 1020 	ldrb.w	r1, [r2, #32]
     57e:	fa00 f303 	lsl.w	r3, r0, r3
     582:	430b      	orrs	r3, r1
     584:	f882 3020 	strb.w	r3, [r2, #32]
     588:	e7f0      	b.n	56c <btProcess(bt_packet*)+0xe0>
          state.mode_override = false;
     58a:	4b16      	ldr	r3, [pc, #88]	; (5e4 <btProcess(bt_packet*)+0x158>)
     58c:	2200      	movs	r2, #0
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     58e:	211f      	movs	r1, #31
     590:	4818      	ldr	r0, [pc, #96]	; (5f4 <btProcess(bt_packet*)+0x168>)
     592:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
     596:	f006 ff75 	bl	7484 <usb_serial_write>
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     59a:	4817      	ldr	r0, [pc, #92]	; (5f8 <btProcess(bt_packet*)+0x16c>)
}
     59c:	b005      	add	sp, #20
     59e:	f85d eb04 	ldr.w	lr, [sp], #4
     5a2:	f005 b8b7 	b.w	5714 <Print::println()>
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     5a6:	4b0f      	ldr	r3, [pc, #60]	; (5e4 <btProcess(bt_packet*)+0x158>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     5a8:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     5aa:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_LOCKPOINTS;
     5ae:	f04f 0c00 	mov.w	ip, #0
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     5b2:	f893 0020 	ldrb.w	r0, [r3, #32]
          tx_packet.data[3] = state.custom_mode.lockpoint_rx_h;
     5b6:	7fdb      	ldrb	r3, [r3, #31]
     5b8:	e7a0      	b.n	4fc <btProcess(bt_packet*)+0x70>
          state.custom_mode.lockpoint_rx_l = 0;
     5ba:	4b0a      	ldr	r3, [pc, #40]	; (5e4 <btProcess(bt_packet*)+0x158>)
     5bc:	2100      	movs	r1, #0
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     5be:	221e      	movs	r2, #30
     5c0:	1c58      	adds	r0, r3, #1
          state.custom_mode.lockpoint_rx_l = 0;
     5c2:	f883 1020 	strb.w	r1, [r3, #32]
          state.custom_mode.lockpoint_rx_h = 0;
     5c6:	77d9      	strb	r1, [r3, #31]
          state.custom_mode.lockpoint_count = 0;
     5c8:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
}
     5cc:	b005      	add	sp, #20
     5ce:	f85d eb04 	ldr.w	lr, [sp], #4
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     5d2:	f007 ba55 	b.w	7a80 <memset>
     5d6:	bf00      	nop
     5d8:	2000697c 	.word	0x2000697c
     5dc:	200068c4 	.word	0x200068c4
     5e0:	20006ae7 	.word	0x20006ae7
     5e4:	20006954 	.word	0x20006954
     5e8:	200068c8 	.word	0x200068c8
     5ec:	200067a8 	.word	0x200067a8
     5f0:	20006ae6 	.word	0x20006ae6
     5f4:	20000360 	.word	0x20000360
     5f8:	20000a68 	.word	0x20000a68

000005fc <btInit()>:

void btInit() {
     5fc:	b530      	push	{r4, r5, lr}
#if stateDebug
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
#endif                          /* stateDebug */

  // drive all LEDs low to save power!
  digitalWrite(pinLED_R, LOW);
     5fe:	2100      	movs	r1, #0
void btInit() {
     600:	b083      	sub	sp, #12
  digitalWrite(pinLED_R, LOW);
     602:	200c      	movs	r0, #12
  blinkLED(625, 4, 10, 0, 0);  // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
  //digitalWrite(pinBT_Reset, LOW);
  pinMode(pinBT_Reset, INPUT);
  delay(2500);

  Serial2.end();         // end current (if any) Serial2/Bluetooth connections
     604:	4d42      	ldr	r5, [pc, #264]	; (710 <btInit()+0x114>)
  digitalWrite(pinLED_R, LOW);
     606:	f005 f943 	bl	5890 <digitalWrite>
  digitalWrite(pinLED_G, LOW);
     60a:	2100      	movs	r1, #0
     60c:	200a      	movs	r0, #10
  blinkLED(625, 4, 10, 0, 0);  // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
     60e:	460c      	mov	r4, r1
  digitalWrite(pinLED_G, LOW);
     610:	f005 f93e 	bl	5890 <digitalWrite>
  digitalWrite(pinLED_B, LOW);
     614:	200b      	movs	r0, #11
     616:	4621      	mov	r1, r4
     618:	f005 f93a 	bl	5890 <digitalWrite>
  pinMode(pinBT_Conf, OUTPUT);
     61c:	2101      	movs	r1, #1
     61e:	2004      	movs	r0, #4
     620:	f005 f972 	bl	5908 <pinMode>
  pinMode(pinBT_Reset, OUTPUT);
     624:	2101      	movs	r1, #1
     626:	2005      	movs	r0, #5
     628:	f005 f96e 	bl	5908 <pinMode>
  digitalWrite(pinBT_Reset, LOW);
     62c:	4621      	mov	r1, r4
     62e:	2005      	movs	r0, #5
     630:	f005 f92e 	bl	5890 <digitalWrite>
  digitalWrite(pinBT_Conf, HIGH);
     634:	2101      	movs	r1, #1
     636:	2004      	movs	r0, #4
     638:	f005 f92a 	bl	5890 <digitalWrite>
  blinkLED(625, 4, 10, 0, 0);  // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
     63c:	4623      	mov	r3, r4
     63e:	220a      	movs	r2, #10
     640:	f240 2071 	movw	r0, #625	; 0x271
     644:	2104      	movs	r1, #4
     646:	9400      	str	r4, [sp, #0]
     648:	f000 f99a 	bl	980 <blinkLED(int, int, int, int, int)>
  pinMode(pinBT_Reset, INPUT);
     64c:	4621      	mov	r1, r4
     64e:	2005      	movs	r0, #5
     650:	f005 f95a 	bl	5908 <pinMode>
  delay(2500);
     654:	f640 10c4 	movw	r0, #2500	; 0x9c4
     658:	f005 f8c6 	bl	57e8 <delay>
  Serial2.end();         // end current (if any) Serial2/Bluetooth connections
     65c:	4628      	mov	r0, r5
     65e:	f004 fe49 	bl	52f4 <HardwareSerial::end()>
  Serial2.begin(38400);  // AT mode requires Baud 38400
     662:	4622      	mov	r2, r4
     664:	4628      	mov	r0, r5
     666:	f44f 4116 	mov.w	r1, #38400	; 0x9600
     66a:	f004 fd07 	bl	507c <HardwareSerial::begin(unsigned long, unsigned short)>
							  return write((const uint8_t *)str, strlen(str)); }
     66e:	2204      	movs	r2, #4
     670:	4928      	ldr	r1, [pc, #160]	; (714 <btInit()+0x118>)
     672:	4628      	mov	r0, r5
     674:	f005 f81a 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\r', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     678:	4623      	mov	r3, r4
     67a:	220a      	movs	r2, #10
     67c:	2101      	movs	r1, #1
     67e:	f44f 709c 	mov.w	r0, #312	; 0x138
     682:	9400      	str	r4, [sp, #0]
     684:	f000 f97c 	bl	980 <blinkLED(int, int, int, int, int)>
     688:	2212      	movs	r2, #18
     68a:	4923      	ldr	r1, [pc, #140]	; (718 <btInit()+0x11c>)
     68c:	4628      	mov	r0, r5
     68e:	f005 f80d 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+UART=9600,0,0"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     692:	4623      	mov	r3, r4
     694:	220a      	movs	r2, #10
     696:	2101      	movs	r1, #1
     698:	f44f 709c 	mov.w	r0, #312	; 0x138
     69c:	9400      	str	r4, [sp, #0]
     69e:	f000 f96f 	bl	980 <blinkLED(int, int, int, int, int)>
     6a2:	2216      	movs	r2, #22
     6a4:	491d      	ldr	r1, [pc, #116]	; (71c <btInit()+0x120>)
     6a6:	4628      	mov	r0, r5
     6a8:	f005 f800 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+NAME=OpenHaldexT4"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     6ac:	4623      	mov	r3, r4
     6ae:	220a      	movs	r2, #10
     6b0:	2101      	movs	r1, #1
     6b2:	f44f 709c 	mov.w	r0, #312	; 0x138
     6b6:	9400      	str	r4, [sp, #0]
     6b8:	f000 f962 	bl	980 <blinkLED(int, int, int, int, int)>
     6bc:	220b      	movs	r2, #11
     6be:	4918      	ldr	r1, [pc, #96]	; (720 <btInit()+0x124>)
     6c0:	4628      	mov	r0, r5
     6c2:	f004 fff3 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+ROLE=0"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     6c6:	4623      	mov	r3, r4
     6c8:	220a      	movs	r2, #10
     6ca:	2101      	movs	r1, #1
     6cc:	f44f 709c 	mov.w	r0, #312	; 0x138
     6d0:	9400      	str	r4, [sp, #0]
     6d2:	f000 f955 	bl	980 <blinkLED(int, int, int, int, int)>
     6d6:	220a      	movs	r2, #10
     6d8:	4912      	ldr	r1, [pc, #72]	; (724 <btInit()+0x128>)
     6da:	4628      	mov	r0, r5
     6dc:	f004 ffe6 	bl	56ac <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+RESET"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     6e0:	4623      	mov	r3, r4
     6e2:	2101      	movs	r1, #1
     6e4:	220a      	movs	r2, #10
     6e6:	f44f 709c 	mov.w	r0, #312	; 0x138
     6ea:	9400      	str	r4, [sp, #0]
     6ec:	f000 f948 	bl	980 <blinkLED(int, int, int, int, int)>

  Serial2.end();          // end AT mode
     6f0:	4628      	mov	r0, r5
     6f2:	f004 fdff 	bl	52f4 <HardwareSerial::end()>
  Serial2.begin(baudBT);  // begin normal mode with the above baud
     6f6:	4628      	mov	r0, r5
     6f8:	4622      	mov	r2, r4
     6fa:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     6fe:	f004 fcbd 	bl	507c <HardwareSerial::begin(unsigned long, unsigned short)>

  pinMode(pinBT_Conf, INPUT);
     702:	4621      	mov	r1, r4
     704:	2004      	movs	r0, #4

#if stateDebug
  Serial.println(F("Bluetooth initialised!"));
#endif /* stateDebug */
}
     706:	b003      	add	sp, #12
     708:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  pinMode(pinBT_Conf, INPUT);
     70c:	f005 b8fc 	b.w	5908 <pinMode>
     710:	200067a8 	.word	0x200067a8
     714:	20000300 	.word	0x20000300
     718:	20000308 	.word	0x20000308
     71c:	2000031c 	.word	0x2000031c
     720:	20000334 	.word	0x20000334
     724:	20000340 	.word	0x20000340

00000728 <checkSwitchMode()>:
#include "openhaldex.h"

void checkSwitchMode() {
     728:	b538      	push	{r3, r4, r5, lr}
  int i = 0;
     72a:	2400      	movs	r4, #0
#if stateDebug
  Serial.println(F("Switch mode button pressed!"));
#endif /* stateDebug */

  while (digitalRead(pinBT_Conf) && (i < 11)) {
     72c:	e01c      	b.n	768 <checkSwitchMode()+0x40>
  }
}

void blinkLED(int duration, int flashes, int R, int G, int B) {
  for (int i = 0; i < flashes; i++) {
    delay(duration);
     72e:	f005 f85b 	bl	57e8 <delay>
    analogWrite(pinLED_R, R);
     732:	2105      	movs	r1, #5
     734:	200c      	movs	r0, #12
     736:	f005 fcbf 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, G);
     73a:	2100      	movs	r1, #0
     73c:	200a      	movs	r0, #10
     73e:	f005 fcbb 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, B);
     742:	2105      	movs	r1, #5
     744:	200b      	movs	r0, #11
     746:	f005 fcb7 	bl	60b8 <analogWrite>
    delay(duration);
     74a:	2064      	movs	r0, #100	; 0x64
     74c:	f005 f84c 	bl	57e8 <delay>
    analogWrite(pinLED_R, 0);
     750:	2100      	movs	r1, #0
     752:	200c      	movs	r0, #12
     754:	f005 fcb0 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, 0);
     758:	2100      	movs	r1, #0
     75a:	200a      	movs	r0, #10
     75c:	f005 fcac 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, 0);
     760:	2100      	movs	r1, #0
     762:	200b      	movs	r0, #11
     764:	f005 fca8 	bl	60b8 <analogWrite>
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     768:	2004      	movs	r0, #4
     76a:	f005 f8bb 	bl	58e4 <digitalRead>
     76e:	4603      	mov	r3, r0
    delay(duration);
     770:	2064      	movs	r0, #100	; 0x64
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     772:	2b00      	cmp	r3, #0
     774:	d048      	beq.n	808 <checkSwitchMode()+0xe0>
     776:	2c0b      	cmp	r4, #11
    i++;
     778:	f104 0401 	add.w	r4, r4, #1
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     77c:	d1d7      	bne.n	72e <checkSwitchMode()+0x6>
    isStandalone = !isStandalone;
     77e:	4a5c      	ldr	r2, [pc, #368]	; (8f0 <checkSwitchMode()+0x1c8>)
     780:	240b      	movs	r4, #11
     782:	7813      	ldrb	r3, [r2, #0]
     784:	f083 0301 	eor.w	r3, r3, #1
     788:	7013      	strb	r3, [r2, #0]
    delay(duration);
     78a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     78e:	f005 f82b 	bl	57e8 <delay>
    analogWrite(pinLED_R, R);
     792:	2105      	movs	r1, #5
     794:	200c      	movs	r0, #12
     796:	f005 fc8f 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, G);
     79a:	2100      	movs	r1, #0
     79c:	200a      	movs	r0, #10
     79e:	f005 fc8b 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, B);
     7a2:	2105      	movs	r1, #5
     7a4:	200b      	movs	r0, #11
     7a6:	f005 fc87 	bl	60b8 <analogWrite>
    delay(duration);
     7aa:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     7ae:	f005 f81b 	bl	57e8 <delay>
    analogWrite(pinLED_R, 0);
     7b2:	2100      	movs	r1, #0
     7b4:	200c      	movs	r0, #12
     7b6:	f005 fc7f 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, 0);
     7ba:	2100      	movs	r1, #0
     7bc:	200a      	movs	r0, #10
     7be:	f005 fc7b 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, 0);
     7c2:	2100      	movs	r1, #0
     7c4:	200b      	movs	r0, #11
     7c6:	f005 fc77 	bl	60b8 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     7ca:	3c01      	subs	r4, #1
     7cc:	d1dd      	bne.n	78a <checkSwitchMode()+0x62>
  if (btConnected) {
     7ce:	4b49      	ldr	r3, [pc, #292]	; (8f4 <checkSwitchMode()+0x1cc>)
     7d0:	781d      	ldrb	r5, [r3, #0]
     7d2:	b9fd      	cbnz	r5, 814 <checkSwitchMode()+0xec>
    buttonToggle++;
     7d4:	4c48      	ldr	r4, [pc, #288]	; (8f8 <checkSwitchMode()+0x1d0>)
	size_t print(int n)				{ return print((long)n); }
     7d6:	4849      	ldr	r0, [pc, #292]	; (8fc <checkSwitchMode()+0x1d4>)
     7d8:	6821      	ldr	r1, [r4, #0]
     7da:	3101      	adds	r1, #1
     7dc:	6021      	str	r1, [r4, #0]
     7de:	f004 ff8d 	bl	56fc <Print::print(long)>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	// Print an unsigned number and newline
	size_t println(uint8_t b)			{ return print(b) + println(); }
	// Print a signed number and newline
	size_t println(int n)				{ return print(n) + println(); }
     7e2:	4846      	ldr	r0, [pc, #280]	; (8fc <checkSwitchMode()+0x1d4>)
     7e4:	f004 ff96 	bl	5714 <Print::println()>
    if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     7e8:	6823      	ldr	r3, [r4, #0]
     7ea:	2b03      	cmp	r3, #3
     7ec:	dd39      	ble.n	862 <checkSwitchMode()+0x13a>
      buttonToggle = 0;
     7ee:	6025      	str	r5, [r4, #0]
        if (isStandalone) {  // jump over 'stock' since it's Standalone and can't see Body CAN
     7f0:	4b3f      	ldr	r3, [pc, #252]	; (8f0 <checkSwitchMode()+0x1c8>)
     7f2:	781b      	ldrb	r3, [r3, #0]
     7f4:	2b00      	cmp	r3, #0
     7f6:	d064      	beq.n	8c2 <checkSwitchMode()+0x19a>
          buttonToggle++;
     7f8:	2301      	movs	r3, #1
     7fa:	6023      	str	r3, [r4, #0]
  delay(300);  // reduce button bashing
     7fc:	f44f 7096 	mov.w	r0, #300	; 0x12c
}
     800:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  delay(300);  // reduce button bashing
     804:	f004 bff0 	b.w	57e8 <delay>
  if (i >= 11) {
     808:	2c0b      	cmp	r4, #11
     80a:	d0b8      	beq.n	77e <checkSwitchMode()+0x56>
  if (btConnected) {
     80c:	4b39      	ldr	r3, [pc, #228]	; (8f4 <checkSwitchMode()+0x1cc>)
     80e:	781d      	ldrb	r5, [r3, #0]
     810:	2d00      	cmp	r5, #0
     812:	d0df      	beq.n	7d4 <checkSwitchMode()+0xac>
     814:	240b      	movs	r4, #11
    delay(duration);
     816:	2064      	movs	r0, #100	; 0x64
     818:	f004 ffe6 	bl	57e8 <delay>
    analogWrite(pinLED_R, R);
     81c:	2105      	movs	r1, #5
     81e:	200c      	movs	r0, #12
     820:	f005 fc4a 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, G);
     824:	2105      	movs	r1, #5
     826:	200a      	movs	r0, #10
     828:	f005 fc46 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, B);
     82c:	2105      	movs	r1, #5
     82e:	200b      	movs	r0, #11
     830:	f005 fc42 	bl	60b8 <analogWrite>
    delay(duration);
     834:	2064      	movs	r0, #100	; 0x64
     836:	f004 ffd7 	bl	57e8 <delay>
    analogWrite(pinLED_R, 0);
     83a:	2100      	movs	r1, #0
     83c:	200c      	movs	r0, #12
     83e:	f005 fc3b 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, 0);
     842:	2100      	movs	r1, #0
     844:	200a      	movs	r0, #10
     846:	f005 fc37 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, 0);
     84a:	2100      	movs	r1, #0
     84c:	200b      	movs	r0, #11
     84e:	f005 fc33 	bl	60b8 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     852:	3c01      	subs	r4, #1
     854:	d1df      	bne.n	816 <checkSwitchMode()+0xee>
  delay(300);  // reduce button bashing
     856:	f44f 7096 	mov.w	r0, #300	; 0x12c
}
     85a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  delay(300);  // reduce button bashing
     85e:	f004 bfc3 	b.w	57e8 <delay>
    switch (buttonToggle) {
     862:	2b03      	cmp	r3, #3
     864:	d8ca      	bhi.n	7fc <checkSwitchMode()+0xd4>
     866:	a201      	add	r2, pc, #4	; (adr r2, 86c <checkSwitchMode()+0x144>)
     868:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     86c:	000007f1 	.word	0x000007f1
     870:	000008ab 	.word	0x000008ab
     874:	00000893 	.word	0x00000893
     878:	0000087d 	.word	0x0000087d
        if (isStandalone) {
     87c:	4b1c      	ldr	r3, [pc, #112]	; (8f0 <checkSwitchMode()+0x1c8>)
     87e:	781a      	ldrb	r2, [r3, #0]
     880:	b322      	cbz	r2, 8cc <checkSwitchMode()+0x1a4>
          state.mode_override = false;
     882:	4b1f      	ldr	r3, [pc, #124]	; (900 <checkSwitchMode()+0x1d8>)
          state.mode = MODE_FWD;
     884:	2201      	movs	r2, #1
          state.mode_override = false;
     886:	2100      	movs	r1, #0
          state.mode = MODE_FWD;
     888:	701a      	strb	r2, [r3, #0]
          buttonToggle = 1;
     88a:	6022      	str	r2, [r4, #0]
          state.mode_override = false;
     88c:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
          break;
     890:	e7b4      	b.n	7fc <checkSwitchMode()+0xd4>
        state.mode_override = false;
     892:	4b1b      	ldr	r3, [pc, #108]	; (900 <checkSwitchMode()+0x1d8>)
     894:	2100      	movs	r1, #0
        state.mode = MODE_5050;
     896:	2202      	movs	r2, #2
  delay(300);  // reduce button bashing
     898:	f44f 7096 	mov.w	r0, #300	; 0x12c
        state.mode_override = false;
     89c:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
        state.mode = MODE_5050;
     8a0:	701a      	strb	r2, [r3, #0]
}
     8a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  delay(300);  // reduce button bashing
     8a6:	f004 bf9f 	b.w	57e8 <delay>
        state.mode_override = false;
     8aa:	4b15      	ldr	r3, [pc, #84]	; (900 <checkSwitchMode()+0x1d8>)
     8ac:	2100      	movs	r1, #0
        state.mode = MODE_FWD;
     8ae:	2201      	movs	r2, #1
  delay(300);  // reduce button bashing
     8b0:	f44f 7096 	mov.w	r0, #300	; 0x12c
        state.mode_override = false;
     8b4:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
        state.mode = MODE_FWD;
     8b8:	701a      	strb	r2, [r3, #0]
}
     8ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  delay(300);  // reduce button bashing
     8be:	f004 bf93 	b.w	57e8 <delay>
        state.mode_override = false;  // was disabled & false?
     8c2:	4a0f      	ldr	r2, [pc, #60]	; (900 <checkSwitchMode()+0x1d8>)
     8c4:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
        state.mode = MODE_STOCK;
     8c8:	7013      	strb	r3, [r2, #0]
        break;
     8ca:	e797      	b.n	7fc <checkSwitchMode()+0xd4>
        if (isCustom) {
     8cc:	4b0d      	ldr	r3, [pc, #52]	; (904 <checkSwitchMode()+0x1dc>)
     8ce:	781b      	ldrb	r3, [r3, #0]
     8d0:	b143      	cbz	r3, 8e4 <checkSwitchMode()+0x1bc>
          state.mode_override = false;
     8d2:	4b0b      	ldr	r3, [pc, #44]	; (900 <checkSwitchMode()+0x1d8>)
          state.mode = MODE_CUSTOM;
     8d4:	2003      	movs	r0, #3
          buttonToggle = -1;
     8d6:	f04f 31ff 	mov.w	r1, #4294967295
          state.mode_override = false;
     8da:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
          state.mode = MODE_CUSTOM;
     8de:	7018      	strb	r0, [r3, #0]
          buttonToggle = -1;
     8e0:	6021      	str	r1, [r4, #0]
          break;
     8e2:	e78b      	b.n	7fc <checkSwitchMode()+0xd4>
          state.mode_override = false;
     8e4:	4a06      	ldr	r2, [pc, #24]	; (900 <checkSwitchMode()+0x1d8>)
          buttonToggle = 0;
     8e6:	6023      	str	r3, [r4, #0]
          state.mode_override = false;
     8e8:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
          state.mode = MODE_STOCK;
     8ec:	7013      	strb	r3, [r2, #0]
          break;
     8ee:	e785      	b.n	7fc <checkSwitchMode()+0xd4>
     8f0:	20006ae8 	.word	0x20006ae8
     8f4:	20006ae1 	.word	0x20006ae1
     8f8:	200068ac 	.word	0x200068ac
     8fc:	20000a68 	.word	0x20000a68
     900:	20006954 	.word	0x20006954
     904:	20006ae6 	.word	0x20006ae6

00000908 <LED()>:
void LED() {
     908:	b508      	push	{r3, lr}
  switch (state.mode) {
     90a:	4b1c      	ldr	r3, [pc, #112]	; (97c <LED()+0x74>)
     90c:	781b      	ldrb	r3, [r3, #0]
     90e:	2b03      	cmp	r3, #3
     910:	d833      	bhi.n	97a <LED()+0x72>
     912:	e8df f003 	tbb	[pc, r3]
     916:	1e2c      	.short	0x1e2c
     918:	0210      	.short	0x0210
      analogWrite(pinLED_R, 5);
     91a:	2105      	movs	r1, #5
     91c:	200c      	movs	r0, #12
     91e:	f005 fbcb 	bl	60b8 <analogWrite>
      analogWrite(pinLED_G, 0);
     922:	2100      	movs	r1, #0
     924:	200a      	movs	r0, #10
     926:	f005 fbc7 	bl	60b8 <analogWrite>
      analogWrite(pinLED_B, 5);
     92a:	2105      	movs	r1, #5
     92c:	200b      	movs	r0, #11
}
     92e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 5);
     932:	f005 bbc1 	b.w	60b8 <analogWrite>
      analogWrite(pinLED_R, 0);
     936:	2100      	movs	r1, #0
     938:	200c      	movs	r0, #12
     93a:	f005 fbbd 	bl	60b8 <analogWrite>
      analogWrite(pinLED_G, 0);
     93e:	2100      	movs	r1, #0
     940:	200a      	movs	r0, #10
     942:	f005 fbb9 	bl	60b8 <analogWrite>
      analogWrite(pinLED_B, 10);
     946:	210a      	movs	r1, #10
     948:	200b      	movs	r0, #11
}
     94a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 10);
     94e:	f005 bbb3 	b.w	60b8 <analogWrite>
      analogWrite(pinLED_R, 0);
     952:	2100      	movs	r1, #0
     954:	200c      	movs	r0, #12
     956:	f005 fbaf 	bl	60b8 <analogWrite>
      analogWrite(pinLED_G, 10);
     95a:	210a      	movs	r1, #10
      analogWrite(pinLED_G, 0);
     95c:	200a      	movs	r0, #10
     95e:	f005 fbab 	bl	60b8 <analogWrite>
      analogWrite(pinLED_B, 0);
     962:	2100      	movs	r1, #0
     964:	200b      	movs	r0, #11
}
     966:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 0);
     96a:	f005 bba5 	b.w	60b8 <analogWrite>
      analogWrite(pinLED_R, 10);
     96e:	210a      	movs	r1, #10
     970:	200c      	movs	r0, #12
     972:	f005 fba1 	bl	60b8 <analogWrite>
      analogWrite(pinLED_G, 0);
     976:	2100      	movs	r1, #0
     978:	e7f0      	b.n	95c <LED()+0x54>
}
     97a:	bd08      	pop	{r3, pc}
     97c:	20006954 	.word	0x20006954

00000980 <blinkLED(int, int, int, int, int)>:
void blinkLED(int duration, int flashes, int R, int G, int B) {
     980:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (int i = 0; i < flashes; i++) {
     984:	1e0e      	subs	r6, r1, #0
void blinkLED(int duration, int flashes, int R, int G, int B) {
     986:	f8dd 9020 	ldr.w	r9, [sp, #32]
  for (int i = 0; i < flashes; i++) {
     98a:	dd24      	ble.n	9d6 <blinkLED(int, int, int, int, int)+0x56>
     98c:	4605      	mov	r5, r0
     98e:	4617      	mov	r7, r2
     990:	4698      	mov	r8, r3
     992:	2400      	movs	r4, #0
    delay(duration);
     994:	4628      	mov	r0, r5
  for (int i = 0; i < flashes; i++) {
     996:	3401      	adds	r4, #1
    delay(duration);
     998:	f004 ff26 	bl	57e8 <delay>
    analogWrite(pinLED_R, R);
     99c:	4639      	mov	r1, r7
     99e:	200c      	movs	r0, #12
     9a0:	f005 fb8a 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, G);
     9a4:	4641      	mov	r1, r8
     9a6:	200a      	movs	r0, #10
     9a8:	f005 fb86 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, B);
     9ac:	4649      	mov	r1, r9
     9ae:	200b      	movs	r0, #11
     9b0:	f005 fb82 	bl	60b8 <analogWrite>
    delay(duration);
     9b4:	4628      	mov	r0, r5
     9b6:	f004 ff17 	bl	57e8 <delay>
    analogWrite(pinLED_R, 0);
     9ba:	2100      	movs	r1, #0
     9bc:	200c      	movs	r0, #12
     9be:	f005 fb7b 	bl	60b8 <analogWrite>
    analogWrite(pinLED_G, 0);
     9c2:	2100      	movs	r1, #0
     9c4:	200a      	movs	r0, #10
     9c6:	f005 fb77 	bl	60b8 <analogWrite>
    analogWrite(pinLED_B, 0);
     9ca:	2100      	movs	r1, #0
     9cc:	200b      	movs	r0, #11
     9ce:	f005 fb73 	bl	60b8 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     9d2:	42a6      	cmp	r6, r4
     9d4:	d1de      	bne.n	994 <blinkLED(int, int, int, int, int)+0x14>
  }
     9d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     9da:	bf00      	nop

000009dc <_GLOBAL__sub_I__Z15checkSwitchModev>:
     9dc:	f004 bffa 	b.w	59d4 <eeprom_initialize>

000009e0 <get_lockTarget_adjusted_value(unsigned char)>:

  return target;
}

static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
  if (state.mode == MODE_5050) {
     9e0:	4b1c      	ldr	r3, [pc, #112]	; (a54 <get_lockTarget_adjusted_value(unsigned char)+0x74>)
     9e2:	781a      	ldrb	r2, [r3, #0]
     9e4:	2a02      	cmp	r2, #2
     9e6:	d022      	beq.n	a2e <get_lockTarget_adjusted_value(unsigned char)+0x4e>
    }

    return 0;
  } else {
    // Potentially avoid doing math below..
    if (lockTarget == 0) {
     9e8:	4b1b      	ldr	r3, [pc, #108]	; (a58 <get_lockTarget_adjusted_value(unsigned char)+0x78>)
     9ea:	ed93 7a00 	vldr	s14, [r3]
     9ee:	eeb5 7a40 	vcmp.f32	s14, #0.0
     9f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     9f6:	d101      	bne.n	9fc <get_lockTarget_adjusted_value(unsigned char)+0x1c>
    return 0;
     9f8:	2000      	movs	r0, #0
     9fa:	4770      	bx	lr

    /* Hackery to get the response closer to the target... we are trying to control the
        Haldex as if it's linear.. but it's not. In future, I'd like to implement some sort
        of feedback loop to trim the calculation being made here but this will do for now.  */
    float target_fudge_factor = lockTarget;
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     9fc:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5

    return value * (target_fudge_factor / 100);
     a00:	ed9f 6a16 	vldr	s12, [pc, #88]	; a5c <get_lockTarget_adjusted_value(unsigned char)+0x7c>
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     a04:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    return value * (target_fudge_factor / 100);
     a08:	ee07 0a90 	vmov	s15, r0
static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
     a0c:	b082      	sub	sp, #8
    return value * (target_fudge_factor / 100);
     a0e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     a12:	eee7 6a25 	vfma.f32	s13, s14, s11
    return value * (target_fudge_factor / 100);
     a16:	ee86 7a86 	vdiv.f32	s14, s13, s12
     a1a:	ee67 7a87 	vmul.f32	s15, s15, s14
     a1e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
     a22:	edcd 7a01 	vstr	s15, [sp, #4]
     a26:	f89d 0004 	ldrb.w	r0, [sp, #4]
  }
}
     a2a:	b002      	add	sp, #8
     a2c:	4770      	bx	lr
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0) {
     a2e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     a32:	4a0b      	ldr	r2, [pc, #44]	; (a60 <get_lockTarget_adjusted_value(unsigned char)+0x80>)
     a34:	ee07 3a90 	vmov	s15, r3
     a38:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     a3c:	edd2 7a00 	vldr	s15, [r2]
     a40:	eeb4 7ae7 	vcmpe.f32	s14, s15
     a44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a48:	d903      	bls.n	a52 <get_lockTarget_adjusted_value(unsigned char)+0x72>
      return value;
     a4a:	2b00      	cmp	r3, #0
     a4c:	bf18      	it	ne
     a4e:	2000      	movne	r0, #0
     a50:	4770      	bx	lr
}
     a52:	4770      	bx	lr
     a54:	20006954 	.word	0x20006954
     a58:	200068c8 	.word	0x200068c8
     a5c:	42c80000 	.word	0x42c80000
     a60:	200068e4 	.word	0x200068e4

00000a64 <getLockData(CAN_message_t*)>:

void getLockData(CAN_message_t *frame) {
     a64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (state.mode == MODE_5050) {
     a68:	4d72      	ldr	r5, [pc, #456]	; (c34 <getLockData(CAN_message_t*)+0x1d0>)
void getLockData(CAN_message_t *frame) {
     a6a:	4604      	mov	r4, r0
  if (state.mode == MODE_5050) {
     a6c:	782b      	ldrb	r3, [r5, #0]
     a6e:	2b02      	cmp	r3, #2
     a70:	f000 8096 	beq.w	ba0 <getLockData(CAN_message_t*)+0x13c>
  } else if (state.mode == MODE_FWD) {
     a74:	2b01      	cmp	r3, #1
     a76:	d060      	beq.n	b3a <getLockData(CAN_message_t*)+0xd6>
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     a78:	f895 0021 	ldrb.w	r0, [r5, #33]	; 0x21
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     a7c:	f895 e001 	ldrb.w	lr, [r5, #1]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     a80:	1e43      	subs	r3, r0, #1
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     a82:	78af      	ldrb	r7, [r5, #2]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     a84:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     a88:	442b      	add	r3, r5
     a8a:	f893 8001 	ldrb.w	r8, [r3, #1]
     a8e:	789e      	ldrb	r6, [r3, #2]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     a90:	b1d8      	cbz	r0, aca <getLockData(CAN_message_t*)+0x66>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     a92:	4b69      	ldr	r3, [pc, #420]	; (c38 <getLockData(CAN_message_t*)+0x1d4>)
     a94:	462a      	mov	r2, r5
     a96:	4671      	mov	r1, lr
     a98:	f893 c000 	ldrb.w	ip, [r3]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     a9c:	2300      	movs	r3, #0
     a9e:	e003      	b.n	aa8 <getLockData(CAN_message_t*)+0x44>
     aa0:	3301      	adds	r3, #1
     aa2:	4298      	cmp	r0, r3
     aa4:	d011      	beq.n	aca <getLockData(CAN_message_t*)+0x66>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     aa6:	7851      	ldrb	r1, [r2, #1]
     aa8:	458c      	cmp	ip, r1
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     aaa:	f102 0203 	add.w	r2, r2, #3
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     aae:	d8f7      	bhi.n	aa0 <getLockData(CAN_message_t*)+0x3c>
      lp_upper = state.custom_mode.lockpoints[i];
     ab0:	eb03 0243 	add.w	r2, r3, r3, lsl #1
     ab4:	442a      	add	r2, r5
     ab6:	7896      	ldrb	r6, [r2, #2]
      lp_lower = state.custom_mode.lockpoints[(i == 0) ? 0 : i - 1];
     ab8:	b133      	cbz	r3, ac8 <getLockData(CAN_message_t*)+0x64>
     aba:	3b01      	subs	r3, #1
     abc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     ac0:	442b      	add	r3, r5
     ac2:	f893 e001 	ldrb.w	lr, [r3, #1]
     ac6:	789f      	ldrb	r7, [r3, #2]
      break;
     ac8:	4688      	mov	r8, r1
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     aca:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
     ace:	4a5b      	ldr	r2, [pc, #364]	; (c3c <getLockData(CAN_message_t*)+0x1d8>)
     ad0:	ee07 3a90 	vmov	s15, r3
     ad4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     ad8:	edd2 7a00 	vldr	s15, [r2]
     adc:	eeb4 7ae7 	vcmpe.f32	s14, s15
     ae0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     ae4:	d823      	bhi.n	b2e <getLockData(CAN_message_t*)+0xca>
    if (vehicleSpeed <= lp_lower.speed) {
     ae6:	4b54      	ldr	r3, [pc, #336]	; (c38 <getLockData(CAN_message_t*)+0x1d4>)
     ae8:	781b      	ldrb	r3, [r3, #0]
     aea:	4573      	cmp	r3, lr
     aec:	f240 809c 	bls.w	c28 <getLockData(CAN_message_t*)+0x1c4>
    if (vehicleSpeed >= lp_upper.speed) {
     af0:	4543      	cmp	r3, r8
     af2:	f080 8091 	bcs.w	c18 <getLockData(CAN_message_t*)+0x1b4>
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     af6:	eba8 080e 	sub.w	r8, r8, lr
     afa:	eba3 030e 	sub.w	r3, r3, lr
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     afe:	1bf6      	subs	r6, r6, r7
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     b00:	ee07 8a90 	vmov	s15, r8
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     b04:	ee06 6a90 	vmov	s13, r6
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     b08:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     b0c:	ee07 3a90 	vmov	s15, r3
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     b10:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     b14:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     b18:	ee87 6a27 	vdiv.f32	s12, s14, s15
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     b1c:	ee07 7a90 	vmov	s15, r7
     b20:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     b24:	eec6 7a86 	vdiv.f32	s15, s13, s12
     b28:	ee77 7a87 	vadd.f32	s15, s15, s14
     b2c:	e007      	b.n	b3e <getLockData(CAN_message_t*)+0xda>
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     b2e:	2b00      	cmp	r3, #0
     b30:	d0d9      	beq.n	ae6 <getLockData(CAN_message_t*)+0x82>
     b32:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
     b36:	2b00      	cmp	r3, #0
     b38:	d1d5      	bne.n	ae6 <getLockData(CAN_message_t*)+0x82>
      return 0;
     b3a:	eddf 7a41 	vldr	s15, [pc, #260]	; c40 <getLockData(CAN_message_t*)+0x1dc>
  uint8_t adjusted_slip;

  lockTarget = get_lockTarget_adjustment();

  switch (frame->id) {
     b3e:	6823      	ldr	r3, [r4, #0]
  lockTarget = get_lockTarget_adjustment();
     b40:	4a40      	ldr	r2, [pc, #256]	; (c44 <getLockData(CAN_message_t*)+0x1e0>)
  switch (frame->id) {
     b42:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
  lockTarget = get_lockTarget_adjustment();
     b46:	edc2 7a00 	vstr	s15, [r2]
  switch (frame->id) {
     b4a:	d05a      	beq.n	c02 <getLockData(CAN_message_t*)+0x19e>
     b4c:	d841      	bhi.n	bd2 <getLockData(CAN_message_t*)+0x16e>
     b4e:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
     b52:	d051      	beq.n	bf8 <getLockData(CAN_message_t*)+0x194>
     b54:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
     b58:	d120      	bne.n	b9c <getLockData(CAN_message_t*)+0x138>
    case MOTOR1_ID:
      frame->buf[0] = 0;
     b5a:	2300      	movs	r3, #0
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);
     b5c:	20fa      	movs	r0, #250	; 0xfa
      frame->buf[2] = 0x20;
     b5e:	2120      	movs	r1, #32
      frame->buf[0] = 0;
     b60:	7323      	strb	r3, [r4, #12]
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);
     b62:	f7ff ff3d 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     b66:	4603      	mov	r3, r0
      frame->buf[2] = 0x20;
     b68:	73a1      	strb	r1, [r4, #14]
      frame->buf[3] = get_lockTarget_adjusted_value(0x4E);
     b6a:	204e      	movs	r0, #78	; 0x4e
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);
     b6c:	7363      	strb	r3, [r4, #13]
      frame->buf[3] = get_lockTarget_adjusted_value(0x4E);
     b6e:	f7ff ff37 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     b72:	4603      	mov	r3, r0
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);
     b74:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[3] = get_lockTarget_adjusted_value(0x4E);
     b76:	73e3      	strb	r3, [r4, #15]
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);
     b78:	f7ff ff32 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     b7c:	4603      	mov	r3, r0
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);
     b7e:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);
     b80:	7423      	strb	r3, [r4, #16]
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);
     b82:	f7ff ff2d 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     b86:	4603      	mov	r3, r0
      frame->buf[6] = get_lockTarget_adjusted_value(0x20); // was 20;
     b88:	4608      	mov	r0, r1
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);
     b8a:	7463      	strb	r3, [r4, #17]
      frame->buf[6] = get_lockTarget_adjusted_value(0x20); // was 20;
     b8c:	f7ff ff28 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     b90:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);
     b92:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[6] = get_lockTarget_adjusted_value(0x20); // was 20;
     b94:	74a3      	strb	r3, [r4, #18]
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);
     b96:	f7ff ff23 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     b9a:	74e0      	strb	r0, [r4, #19]

      //frame->data->high = (0xa << 24) + (0xa << 8);
      //frame->data->low = frame->data->high + (adjusted_slip << 16) + adjusted_slip;
      break;
  }
     b9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     ba0:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
     ba4:	4a25      	ldr	r2, [pc, #148]	; (c3c <getLockData(CAN_message_t*)+0x1d8>)
     ba6:	ee07 3a90 	vmov	s15, r3
     baa:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     bae:	edd2 7a00 	vldr	s15, [r2]
     bb2:	eeb4 7ae7 	vcmpe.f32	s14, s15
     bb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     bba:	d932      	bls.n	c22 <getLockData(CAN_message_t*)+0x1be>
     bbc:	b38b      	cbz	r3, c22 <getLockData(CAN_message_t*)+0x1be>
     bbe:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
      return 100;
     bc2:	eddf 7a1f 	vldr	s15, [pc, #124]	; c40 <getLockData(CAN_message_t*)+0x1dc>
     bc6:	ed9f 7a20 	vldr	s14, [pc, #128]	; c48 <getLockData(CAN_message_t*)+0x1e4>
     bca:	2b00      	cmp	r3, #0
     bcc:	fe47 7a87 	vseleq.f32	s15, s15, s14
     bd0:	e7b5      	b.n	b3e <getLockData(CAN_message_t*)+0xda>
  switch (frame->id) {
     bd2:	f5b3 6f94 	cmp.w	r3, #1184	; 0x4a0
     bd6:	d1e1      	bne.n	b9c <getLockData(CAN_message_t*)+0x138>
      adjusted_slip = get_lockTarget_adjusted_value(0xA);
     bd8:	200a      	movs	r0, #10
     bda:	f7ff ff01 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
      frame->buf[0] = 0x00;
     bde:	f04f 230a 	mov.w	r3, #167774720	; 0xa000a00
      frame->buf[5] = 0xA - adjusted_slip;
     be2:	f1c0 000a 	rsb	r0, r0, #10
      frame->buf[4] = 0x00;
     be6:	2200      	movs	r2, #0
      frame->buf[0] = 0x00;
     be8:	60e3      	str	r3, [r4, #12]
      frame->buf[5] = 0xA - adjusted_slip;
     bea:	b2c3      	uxtb	r3, r0
      frame->buf[4] = 0x00;
     bec:	7422      	strb	r2, [r4, #16]
      frame->buf[6] = 0x00;
     bee:	74a2      	strb	r2, [r4, #18]
      frame->buf[5] = 0xA - adjusted_slip;
     bf0:	7463      	strb	r3, [r4, #17]
      frame->buf[7] = 0xA - adjusted_slip;
     bf2:	74e3      	strb	r3, [r4, #19]
     bf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = 0x0;
     bf8:	f44f 6320 	mov.w	r3, #2560	; 0xa00
     bfc:	81e3      	strh	r3, [r4, #14]
     bfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = get_lockTarget_adjusted_value(0xFA);
     c02:	20fa      	movs	r0, #250	; 0xfa
     c04:	f7ff feec 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     c08:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);
     c0a:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[2] = get_lockTarget_adjusted_value(0xFA);
     c0c:	73a3      	strb	r3, [r4, #14]
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);
     c0e:	f7ff fee7 	bl	9e0 <get_lockTarget_adjusted_value(unsigned char)>
     c12:	74e0      	strb	r0, [r4, #19]
     c14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return lp_upper.lock;
     c18:	ee07 6a90 	vmov	s15, r6
     c1c:	eef8 7a67 	vcvt.f32.u32	s15, s15
     c20:	e78d      	b.n	b3e <getLockData(CAN_message_t*)+0xda>
      return 100;
     c22:	eddf 7a09 	vldr	s15, [pc, #36]	; c48 <getLockData(CAN_message_t*)+0x1e4>
     c26:	e78a      	b.n	b3e <getLockData(CAN_message_t*)+0xda>
      return lp_lower.lock;
     c28:	ee07 7a90 	vmov	s15, r7
     c2c:	eef8 7a67 	vcvt.f32.u32	s15, s15
     c30:	e785      	b.n	b3e <getLockData(CAN_message_t*)+0xda>
     c32:	bf00      	nop
     c34:	20006954 	.word	0x20006954
     c38:	20006af3 	.word	0x20006af3
     c3c:	200068e4 	.word	0x200068e4
     c40:	00000000 	.word	0x00000000
     c44:	200068c8 	.word	0x200068c8
     c48:	42c80000 	.word	0x42c80000

00000c4c <_GLOBAL__sub_I_lockTarget>:
     c4c:	f004 bec2 	b.w	59d4 <eeprom_initialize>

00000c50 <CANListener::frameHandler(CAN_message_t&, int, unsigned char)>:
#define SIZE_LISTENERS 4

class CANListener {
  public:
    CANListener () { callbacksActive = 0; }
    virtual bool frameHandler (CAN_message_t &frame, int mailbox, uint8_t controller) { return false; }
     c50:	2000      	movs	r0, #0
     c52:	4770      	bx	lr

00000c54 <flexcan_isr_can1()>:
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
}

#if defined(__IMXRT1062__)
static void flexcan_isr_can1() {
  if ( _CAN1 ) _CAN1->flexcan_interrupt();
     c54:	4b03      	ldr	r3, [pc, #12]	; (c64 <flexcan_isr_can1()+0x10>)
     c56:	6818      	ldr	r0, [r3, #0]
     c58:	b110      	cbz	r0, c60 <flexcan_isr_can1()+0xc>
     c5a:	6803      	ldr	r3, [r0, #0]
     c5c:	681b      	ldr	r3, [r3, #0]
     c5e:	4718      	bx	r3
}
     c60:	4770      	bx	lr
     c62:	bf00      	nop
     c64:	20006870 	.word	0x20006870

00000c68 <flexcan_isr_can2()>:

static void flexcan_isr_can2() {
  if ( _CAN2 ) _CAN2->flexcan_interrupt();
     c68:	4b03      	ldr	r3, [pc, #12]	; (c78 <flexcan_isr_can2()+0x10>)
     c6a:	6818      	ldr	r0, [r3, #0]
     c6c:	b110      	cbz	r0, c74 <flexcan_isr_can2()+0xc>
     c6e:	6803      	ldr	r3, [r0, #0]
     c70:	681b      	ldr	r3, [r3, #0]
     c72:	4718      	bx	r3
}
     c74:	4770      	bx	lr
     c76:	bf00      	nop
     c78:	20006874 	.word	0x20006874

00000c7c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     c7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
     c80:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     c84:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     c86:	4c57      	ldr	r4, [pc, #348]	; (de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     c88:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     c8a:	4b57      	ldr	r3, [pc, #348]	; (de8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     c8c:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
     c8e:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     c92:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     c94:	4855      	ldr	r0, [pc, #340]	; (dec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     c96:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     c9a:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     c9c:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     c9e:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     ca2:	446b      	add	r3, sp
     ca4:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
     ca8:	4b51      	ldr	r3, [pc, #324]	; (df0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
     caa:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     cae:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     cb0:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     cb4:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     cb8:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     cbc:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     cbe:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     cc0:	6803      	ldr	r3, [r0, #0]
     cc2:	01df      	lsls	r7, r3, #7
     cc4:	d5fc      	bpl.n	cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
     cc6:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     cc8:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
     ccc:	d92a      	bls.n	d24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     cce:	4660      	mov	r0, ip
     cd0:	1c83      	adds	r3, r0, #2
    divisor++;
     cd2:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
     cd4:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
     cd8:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
     cda:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
     cde:	d8f7      	bhi.n	cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     ce0:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
     ce4:	fbb6 f3f3 	udiv	r3, r6, r3
     ce8:	1acb      	subs	r3, r1, r3
     cea:	2b00      	cmp	r3, #0
     cec:	bfb8      	it	lt
     cee:	425b      	neglt	r3, r3
      if (error < bestError) {
     cf0:	42ab      	cmp	r3, r5
     cf2:	db0b      	blt.n	d0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
     cf4:	f1a7 030c 	sub.w	r3, r7, #12
     cf8:	bf18      	it	ne
     cfa:	f04f 0800 	movne.w	r8, #0
     cfe:	2b06      	cmp	r3, #6
     d00:	d80a      	bhi.n	d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
     d02:	f1b8 0f00 	cmp.w	r8, #0
     d06:	d007      	beq.n	d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
     d08:	4684      	mov	ip, r0
     d0a:	e7e1      	b.n	cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     d0c:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
     d0e:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
     d12:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
     d14:	2b06      	cmp	r3, #6
     d16:	d9f4      	bls.n	d02 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
     d18:	2f05      	cmp	r7, #5
     d1a:	d8d9      	bhi.n	cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
     d1c:	f10c 0301 	add.w	r3, ip, #1
     d20:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
     d24:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
     d28:	f1a2 0205 	sub.w	r2, r2, #5
     d2c:	dc4c      	bgt.n	dc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
     d2e:	2a14      	cmp	r2, #20
     d30:	d84a      	bhi.n	dc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     d32:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
     d36:	4f2f      	ldr	r7, [pc, #188]	; (df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
     d38:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d3a:	f8df 80b0 	ldr.w	r8, [pc, #176]	; dec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     d3e:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     d42:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     d46:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
     d4a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     d4c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     d4e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     d50:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     d52:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     d54:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     d56:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
     d5a:	c607      	stmia	r6!, {r0, r1, r2}
     d5c:	f826 3b02 	strh.w	r3, [r6], #2
     d60:	ea4f 4313 	mov.w	r3, r3, lsr #16
     d64:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d66:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     d6a:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d6e:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     d72:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     d76:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d7a:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
     d7e:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     d82:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d86:	ea43 0302 	orr.w	r3, r3, r2
     d8a:	ea43 0301 	orr.w	r3, r3, r1
     d8e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     d92:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
     d96:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d9a:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     d9e:	f8d8 3004 	ldr.w	r3, [r8, #4]
     da2:	bf14      	ite	ne
     da4:	f023 0308 	bicne.w	r3, r3, #8
     da8:	f043 0308 	orreq.w	r3, r3, #8
     dac:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     db0:	b93c      	cbnz	r4, dc2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     db2:	4a0e      	ldr	r2, [pc, #56]	; (dec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     db4:	6813      	ldr	r3, [r2, #0]
     db6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     dba:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     dbc:	6813      	ldr	r3, [r2, #0]
     dbe:	01db      	lsls	r3, r3, #7
     dc0:	d4fc      	bmi.n	dbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
     dc2:	b010      	add	sp, #64	; 0x40
     dc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     dc8:	2c00      	cmp	r4, #0
     dca:	d1fa      	bne.n	dc2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     dcc:	4a07      	ldr	r2, [pc, #28]	; (dec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     dce:	6813      	ldr	r3, [r2, #0]
     dd0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     dd4:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     dd6:	6813      	ldr	r3, [r2, #0]
     dd8:	01d9      	lsls	r1, r3, #7
     dda:	d4fc      	bmi.n	dd6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
     ddc:	b010      	add	sp, #64	; 0x40
     dde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     de2:	bf00      	nop
     de4:	0050183c 	.word	0x0050183c
     de8:	400fc000 	.word	0x400fc000
     dec:	401d0000 	.word	0x401d0000
     df0:	000f4240 	.word	0x000f4240
     df4:	20000280 	.word	0x20000280

00000df8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     df8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
     dfc:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     e00:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     e02:	4c57      	ldr	r4, [pc, #348]	; (f60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     e04:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     e06:	4b57      	ldr	r3, [pc, #348]	; (f64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     e08:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
     e0a:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     e0e:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     e10:	4855      	ldr	r0, [pc, #340]	; (f68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     e12:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     e16:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     e18:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     e1a:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     e1e:	446b      	add	r3, sp
     e20:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
     e24:	4b51      	ldr	r3, [pc, #324]	; (f6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
     e26:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     e2a:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     e2c:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     e30:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     e34:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     e38:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     e3a:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     e3c:	6803      	ldr	r3, [r0, #0]
     e3e:	01df      	lsls	r7, r3, #7
     e40:	d5fc      	bpl.n	e3c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
     e42:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     e44:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
     e48:	d92a      	bls.n	ea0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     e4a:	4660      	mov	r0, ip
     e4c:	1c83      	adds	r3, r0, #2
    divisor++;
     e4e:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
     e50:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
     e54:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
     e56:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
     e5a:	d8f7      	bhi.n	e4c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     e5c:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
     e60:	fbb6 f3f3 	udiv	r3, r6, r3
     e64:	1acb      	subs	r3, r1, r3
     e66:	2b00      	cmp	r3, #0
     e68:	bfb8      	it	lt
     e6a:	425b      	neglt	r3, r3
      if (error < bestError) {
     e6c:	42ab      	cmp	r3, r5
     e6e:	db0b      	blt.n	e88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
     e70:	f1a7 030c 	sub.w	r3, r7, #12
     e74:	bf18      	it	ne
     e76:	f04f 0800 	movne.w	r8, #0
     e7a:	2b06      	cmp	r3, #6
     e7c:	d80a      	bhi.n	e94 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
     e7e:	f1b8 0f00 	cmp.w	r8, #0
     e82:	d007      	beq.n	e94 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
     e84:	4684      	mov	ip, r0
     e86:	e7e1      	b.n	e4c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     e88:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
     e8a:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
     e8e:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
     e90:	2b06      	cmp	r3, #6
     e92:	d9f4      	bls.n	e7e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
     e94:	2f05      	cmp	r7, #5
     e96:	d8d9      	bhi.n	e4c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
     e98:	f10c 0301 	add.w	r3, ip, #1
     e9c:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
     ea0:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
     ea4:	f1a2 0205 	sub.w	r2, r2, #5
     ea8:	dc4c      	bgt.n	f44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
     eaa:	2a14      	cmp	r2, #20
     eac:	d84a      	bhi.n	f44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     eae:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
     eb2:	4f2f      	ldr	r7, [pc, #188]	; (f70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
     eb4:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     eb6:	f8df 80b0 	ldr.w	r8, [pc, #176]	; f68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     eba:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     ebe:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     ec2:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
     ec6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     ec8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     eca:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     ecc:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     ece:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     ed0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     ed2:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
     ed6:	c607      	stmia	r6!, {r0, r1, r2}
     ed8:	f826 3b02 	strh.w	r3, [r6], #2
     edc:	ea4f 4313 	mov.w	r3, r3, lsr #16
     ee0:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     ee2:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     ee6:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     eea:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     eee:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     ef2:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     ef6:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
     efa:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     efe:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     f02:	ea43 0302 	orr.w	r3, r3, r2
     f06:	ea43 0301 	orr.w	r3, r3, r1
     f0a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     f0e:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
     f12:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     f16:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     f1a:	f8d8 3004 	ldr.w	r3, [r8, #4]
     f1e:	bf14      	ite	ne
     f20:	f023 0308 	bicne.w	r3, r3, #8
     f24:	f043 0308 	orreq.w	r3, r3, #8
     f28:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     f2c:	b93c      	cbnz	r4, f3e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     f2e:	4a0e      	ldr	r2, [pc, #56]	; (f68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     f30:	6813      	ldr	r3, [r2, #0]
     f32:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     f36:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     f38:	6813      	ldr	r3, [r2, #0]
     f3a:	01db      	lsls	r3, r3, #7
     f3c:	d4fc      	bmi.n	f38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
     f3e:	b010      	add	sp, #64	; 0x40
     f40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     f44:	2c00      	cmp	r4, #0
     f46:	d1fa      	bne.n	f3e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     f48:	4a07      	ldr	r2, [pc, #28]	; (f68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     f4a:	6813      	ldr	r3, [r2, #0]
     f4c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     f50:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     f52:	6813      	ldr	r3, [r2, #0]
     f54:	01d9      	lsls	r1, r3, #7
     f56:	d4fc      	bmi.n	f52 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
     f58:	b010      	add	sp, #64	; 0x40
     f5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     f5e:	bf00      	nop
     f60:	0050183c 	.word	0x0050183c
     f64:	400fc000 	.word	0x400fc000
     f68:	401d4000 	.word	0x401d4000
     f6c:	000f4240 	.word	0x000f4240
     f70:	20000280 	.word	0x20000280

00000f74 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3); /* input 3 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4); /* input 4 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4, uint32_t id5); /* input 5 ID's to be filtered */
    bool setMBFilterRange(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2); /* filter a range of ids */
    int write(const CAN_message_t &msg); /* use any available mailbox for transmitting */
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
     f74:	2000      	movs	r0, #0
     f76:	4770      	bx	lr

00000f78 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
     f78:	2000      	movs	r0, #0
     f7a:	4770      	bx	lr

00000f7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
#endif
    void enhanceFilter(FLEXCAN_MAILBOX mb_num);
    void distribute(bool state = 1) { distribution = state; }
    void enableDMA(bool state = 1);
    void disableDMA() { enableDMA(0); }
    uint8_t getFirstTxBoxSize(){ return 8; }
     f7c:	2008      	movs	r0, #8
     f7e:	4770      	bx	lr

00000f80 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
     f80:	2000      	movs	r0, #0
     f82:	4770      	bx	lr

00000f84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
     f84:	2000      	movs	r0, #0
     f86:	4770      	bx	lr

00000f88 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
    uint8_t getFirstTxBoxSize(){ return 8; }
     f88:	2008      	movs	r0, #8
     f8a:	4770      	bx	lr

00000f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     f8c:	4910      	ldr	r1, [pc, #64]	; (fd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     f8e:	680b      	ldr	r3, [r1, #0]
     f90:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
     f92:	680a      	ldr	r2, [r1, #0]
     f94:	6b49      	ldr	r1, [r1, #52]	; 0x34
     f96:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     f9a:	f3c1 6103 	ubfx	r1, r1, #24, #4
     f9e:	3201      	adds	r2, #1
     fa0:	3104      	adds	r1, #4
     fa2:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
     fa6:	d310      	bcc.n	fca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     fa8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     fac:	f3c0 6003 	ubfx	r0, r0, #24, #4
     fb0:	3b05      	subs	r3, #5
     fb2:	3001      	adds	r0, #1
     fb4:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
     fb8:	b2db      	uxtb	r3, r3
     fba:	4a05      	ldr	r2, [pc, #20]	; (fd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     fbc:	6810      	ldr	r0, [r2, #0]
     fbe:	f000 007f 	and.w	r0, r0, #127	; 0x7f
     fc2:	3001      	adds	r0, #1
     fc4:	1ac0      	subs	r0, r0, r3
}
     fc6:	b2c0      	uxtb	r0, r0
     fc8:	4770      	bx	lr
     fca:	2300      	movs	r3, #0
     fcc:	e7f5      	b.n	fba <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
     fce:	bf00      	nop
     fd0:	401d0000 	.word	0x401d0000

00000fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     fd4:	4910      	ldr	r1, [pc, #64]	; (1018 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     fd6:	680b      	ldr	r3, [r1, #0]
     fd8:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
     fda:	680a      	ldr	r2, [r1, #0]
     fdc:	6b49      	ldr	r1, [r1, #52]	; 0x34
     fde:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     fe2:	f3c1 6103 	ubfx	r1, r1, #24, #4
     fe6:	3201      	adds	r2, #1
     fe8:	3104      	adds	r1, #4
     fea:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
     fee:	d310      	bcc.n	1012 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     ff0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     ff4:	f3c0 6003 	ubfx	r0, r0, #24, #4
     ff8:	3b05      	subs	r3, #5
     ffa:	3001      	adds	r0, #1
     ffc:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
    1000:	b2db      	uxtb	r3, r3
    1002:	4a05      	ldr	r2, [pc, #20]	; (1018 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    1004:	6810      	ldr	r0, [r2, #0]
    1006:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    100a:	3001      	adds	r0, #1
    100c:	1ac0      	subs	r0, r0, r3
}
    100e:	b2c0      	uxtb	r0, r0
    1010:	4770      	bx	lr
    1012:	2300      	movs	r3, #0
    1014:	e7f5      	b.n	1002 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
    1016:	bf00      	nop
    1018:	401d4000 	.word	0x401d4000

0000101c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    101c:	4a63      	ldr	r2, [pc, #396]	; (11ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    101e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1022:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1024:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1026:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    102a:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    102e:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    1030:	6813      	ldr	r3, [r2, #0]
    1032:	01dd      	lsls	r5, r3, #7
    1034:	d5fc      	bpl.n	1030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1036:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    1038:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    103a:	f8df c178 	ldr.w	ip, [pc, #376]	; 11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    103e:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1042:	4f5b      	ldr	r7, [pc, #364]	; (11b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1044:	4e59      	ldr	r6, [pc, #356]	; (11ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1046:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1048:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    104a:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    104c:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    104e:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1050:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1054:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1056:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1058:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    105a:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    105c:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    105e:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1060:	6091      	str	r1, [r2, #8]
    1062:	6051      	str	r1, [r2, #4]
    1064:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1066:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1068:	6832      	ldr	r2, [r6, #0]
    106a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    106e:	3201      	adds	r2, #1
    1070:	4293      	cmp	r3, r2
    1072:	d3ed      	bcc.n	1050 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    1074:	64b1      	str	r1, [r6, #72]	; 0x48
    1076:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    1078:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    107a:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    107c:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    107e:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    1080:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    1082:	2800      	cmp	r0, #0
    1084:	d149      	bne.n	111a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1086:	f8df 812c 	ldr.w	r8, [pc, #300]	; 11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    108a:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    108c:	4e47      	ldr	r6, [pc, #284]	; (11ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    108e:	4f48      	ldr	r7, [pc, #288]	; (11b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    1090:	e019      	b.n	10c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    1092:	6833      	ldr	r3, [r6, #0]
    1094:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1098:	3301      	adds	r3, #1
    109a:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    109e:	bf34      	ite	cc
    10a0:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    10a4:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    10a8:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    10aa:	6b73      	ldr	r3, [r6, #52]	; 0x34
    10ac:	f3c3 4300 	ubfx	r3, r3, #16, #1
    10b0:	079b      	lsls	r3, r3, #30
    10b2:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    10b4:	6833      	ldr	r3, [r6, #0]
    10b6:	3501      	adds	r5, #1
    10b8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    10bc:	b2ed      	uxtb	r5, r5
    10be:	3301      	adds	r3, #1
    10c0:	4628      	mov	r0, r5
    10c2:	429d      	cmp	r5, r3
    10c4:	d21e      	bcs.n	1104 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    10c6:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    10c8:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    10cc:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    10ce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    10d2:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    10d4:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    10d6:	3301      	adds	r3, #1
    10d8:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    10dc:	d3d9      	bcc.n	1092 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    10de:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    10e2:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    10e4:	6833      	ldr	r3, [r6, #0]
    10e6:	009a      	lsls	r2, r3, #2
    10e8:	d503      	bpl.n	10f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    10ea:	f7ff ff4f 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    10ee:	42a8      	cmp	r0, r5
    10f0:	d8e0      	bhi.n	10b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    10f2:	2301      	movs	r3, #1
    10f4:	2d1f      	cmp	r5, #31
    10f6:	fa03 f305 	lsl.w	r3, r3, r5
    10fa:	d84c      	bhi.n	1196 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    10fc:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    10fe:	4313      	orrs	r3, r2
    1100:	62b3      	str	r3, [r6, #40]	; 0x28
    1102:	e7d7      	b.n	10b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1104:	b93c      	cbnz	r4, 1116 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1106:	4a29      	ldr	r2, [pc, #164]	; (11ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    1108:	6813      	ldr	r3, [r2, #0]
    110a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    110e:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1110:	6813      	ldr	r3, [r2, #0]
    1112:	01db      	lsls	r3, r3, #7
    1114:	d4fc      	bmi.n	1110 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    1116:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    111a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    111e:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1120:	6835      	ldr	r5, [r6, #0]
    1122:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    1126:	d03e      	beq.n	11a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    1128:	f7ff ff30 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    112c:	6833      	ldr	r3, [r6, #0]
    112e:	4605      	mov	r5, r0
    1130:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1134:	3301      	adds	r3, #1
    1136:	4283      	cmp	r3, r0
    1138:	d9e4      	bls.n	1104 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    113a:	4f1e      	ldr	r7, [pc, #120]	; (11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    113c:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1140:	f8df 8068 	ldr.w	r8, [pc, #104]	; 11ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    1144:	e00d      	b.n	1162 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1146:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    114a:	4313      	orrs	r3, r2
    114c:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1150:	f8d8 3000 	ldr.w	r3, [r8]
    1154:	3501      	adds	r5, #1
    1156:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    115a:	b2ed      	uxtb	r5, r5
    115c:	3301      	adds	r3, #1
    115e:	429d      	cmp	r5, r3
    1160:	d2d0      	bcs.n	1104 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1162:	19eb      	adds	r3, r5, r7
    1164:	011b      	lsls	r3, r3, #4
    1166:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1168:	f8d8 3000 	ldr.w	r3, [r8]
    116c:	0099      	lsls	r1, r3, #2
    116e:	d503      	bpl.n	1178 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    1170:	f7ff ff0c 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    1174:	4285      	cmp	r5, r0
    1176:	d3eb      	bcc.n	1150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1178:	2301      	movs	r3, #1
    117a:	2d1f      	cmp	r5, #31
    117c:	fa03 f305 	lsl.w	r3, r3, r5
    1180:	d9e1      	bls.n	1146 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    1182:	f1a5 0120 	sub.w	r1, r5, #32
    1186:	2301      	movs	r3, #1
    1188:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    118c:	408b      	lsls	r3, r1
    118e:	4313      	orrs	r3, r2
    1190:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    1194:	e7dc      	b.n	1150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    1196:	f1a5 0120 	sub.w	r1, r5, #32
    119a:	2301      	movs	r3, #1
    119c:	6a72      	ldr	r2, [r6, #36]	; 0x24
    119e:	408b      	lsls	r3, r1
    11a0:	4313      	orrs	r3, r2
    11a2:	6273      	str	r3, [r6, #36]	; 0x24
    11a4:	e786      	b.n	10b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    11a6:	6833      	ldr	r3, [r6, #0]
    11a8:	e7c7      	b.n	113a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    11aa:	bf00      	nop
    11ac:	401d0000 	.word	0x401d0000
    11b0:	10074220 	.word	0x10074220
    11b4:	0401d008 	.word	0x0401d008

000011b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    11b8:	4a63      	ldr	r2, [pc, #396]	; (1348 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    11ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    11be:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    11c0:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    11c2:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    11c6:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    11ca:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    11cc:	6813      	ldr	r3, [r2, #0]
    11ce:	01dd      	lsls	r5, r3, #7
    11d0:	d5fc      	bpl.n	11cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    11d2:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    11d4:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    11d6:	f8df c178 	ldr.w	ip, [pc, #376]	; 1350 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    11da:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    11de:	4f5b      	ldr	r7, [pc, #364]	; (134c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    11e0:	4e59      	ldr	r6, [pc, #356]	; (1348 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    11e2:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    11e4:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    11e6:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    11e8:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    11ea:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    11ec:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    11f0:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    11f2:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    11f4:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    11f6:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    11f8:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    11fa:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    11fc:	6091      	str	r1, [r2, #8]
    11fe:	6051      	str	r1, [r2, #4]
    1200:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1202:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1204:	6832      	ldr	r2, [r6, #0]
    1206:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    120a:	3201      	adds	r2, #1
    120c:	4293      	cmp	r3, r2
    120e:	d3ed      	bcc.n	11ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    1210:	64b1      	str	r1, [r6, #72]	; 0x48
    1212:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    1214:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    1216:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    1218:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    121a:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    121c:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    121e:	2800      	cmp	r0, #0
    1220:	d149      	bne.n	12b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1222:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1350 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1226:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1228:	4e47      	ldr	r6, [pc, #284]	; (1348 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    122a:	4f48      	ldr	r7, [pc, #288]	; (134c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    122c:	e019      	b.n	1262 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    122e:	6833      	ldr	r3, [r6, #0]
    1230:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1234:	3301      	adds	r3, #1
    1236:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    123a:	bf34      	ite	cc
    123c:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    1240:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    1244:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1246:	6b73      	ldr	r3, [r6, #52]	; 0x34
    1248:	f3c3 4300 	ubfx	r3, r3, #16, #1
    124c:	079b      	lsls	r3, r3, #30
    124e:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1250:	6833      	ldr	r3, [r6, #0]
    1252:	3501      	adds	r5, #1
    1254:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1258:	b2ed      	uxtb	r5, r5
    125a:	3301      	adds	r3, #1
    125c:	4628      	mov	r0, r5
    125e:	429d      	cmp	r5, r3
    1260:	d21e      	bcs.n	12a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1262:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1264:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1268:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    126a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    126e:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1270:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1272:	3301      	adds	r3, #1
    1274:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    1278:	d3d9      	bcc.n	122e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    127a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    127e:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1280:	6833      	ldr	r3, [r6, #0]
    1282:	009a      	lsls	r2, r3, #2
    1284:	d503      	bpl.n	128e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    1286:	f7ff fea5 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    128a:	42a8      	cmp	r0, r5
    128c:	d8e0      	bhi.n	1250 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    128e:	2301      	movs	r3, #1
    1290:	2d1f      	cmp	r5, #31
    1292:	fa03 f305 	lsl.w	r3, r3, r5
    1296:	d84c      	bhi.n	1332 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    1298:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    129a:	4313      	orrs	r3, r2
    129c:	62b3      	str	r3, [r6, #40]	; 0x28
    129e:	e7d7      	b.n	1250 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    12a0:	b93c      	cbnz	r4, 12b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    12a2:	4a29      	ldr	r2, [pc, #164]	; (1348 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    12a4:	6813      	ldr	r3, [r2, #0]
    12a6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    12aa:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    12ac:	6813      	ldr	r3, [r2, #0]
    12ae:	01db      	lsls	r3, r3, #7
    12b0:	d4fc      	bmi.n	12ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    12b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    12b6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    12ba:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    12bc:	6835      	ldr	r5, [r6, #0]
    12be:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    12c2:	d03e      	beq.n	1342 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    12c4:	f7ff fe86 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    12c8:	6833      	ldr	r3, [r6, #0]
    12ca:	4605      	mov	r5, r0
    12cc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    12d0:	3301      	adds	r3, #1
    12d2:	4283      	cmp	r3, r0
    12d4:	d9e4      	bls.n	12a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    12d6:	4f1e      	ldr	r7, [pc, #120]	; (1350 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    12d8:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    12dc:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1348 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    12e0:	e00d      	b.n	12fe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    12e2:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    12e6:	4313      	orrs	r3, r2
    12e8:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    12ec:	f8d8 3000 	ldr.w	r3, [r8]
    12f0:	3501      	adds	r5, #1
    12f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    12f6:	b2ed      	uxtb	r5, r5
    12f8:	3301      	adds	r3, #1
    12fa:	429d      	cmp	r5, r3
    12fc:	d2d0      	bcs.n	12a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    12fe:	19eb      	adds	r3, r5, r7
    1300:	011b      	lsls	r3, r3, #4
    1302:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1304:	f8d8 3000 	ldr.w	r3, [r8]
    1308:	0099      	lsls	r1, r3, #2
    130a:	d503      	bpl.n	1314 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    130c:	f7ff fe62 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    1310:	4285      	cmp	r5, r0
    1312:	d3eb      	bcc.n	12ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1314:	2301      	movs	r3, #1
    1316:	2d1f      	cmp	r5, #31
    1318:	fa03 f305 	lsl.w	r3, r3, r5
    131c:	d9e1      	bls.n	12e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    131e:	f1a5 0120 	sub.w	r1, r5, #32
    1322:	2301      	movs	r3, #1
    1324:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    1328:	408b      	lsls	r3, r1
    132a:	4313      	orrs	r3, r2
    132c:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    1330:	e7dc      	b.n	12ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    1332:	f1a5 0120 	sub.w	r1, r5, #32
    1336:	2301      	movs	r3, #1
    1338:	6a72      	ldr	r2, [r6, #36]	; 0x24
    133a:	408b      	lsls	r3, r1
    133c:	4313      	orrs	r3, r2
    133e:	6273      	str	r3, [r6, #36]	; 0x24
    1340:	e786      	b.n	1250 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1342:	6833      	ldr	r3, [r6, #0]
    1344:	e7c7      	b.n	12d6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    1346:	bf00      	nop
    1348:	401d4000 	.word	0x401d4000
    134c:	10075220 	.word	0x10075220
    1350:	0401d408 	.word	0x0401d408

00001354 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    1354:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    1358:	4db7      	ldr	r5, [pc, #732]	; (1638 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    135a:	682b      	ldr	r3, [r5, #0]
    135c:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    1360:	f040 819a 	bne.w	1698 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    1364:	211a      	movs	r1, #26
    1366:	48b5      	ldr	r0, [pc, #724]	; (163c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    1368:	f006 f88c 	bl	7484 <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    136c:	464c      	mov	r4, r9
    136e:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1370:	4fb3      	ldr	r7, [pc, #716]	; (1640 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1372:	4db4      	ldr	r5, [pc, #720]	; (1644 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1374:	4eb4      	ldr	r6, [pc, #720]	; (1648 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1376:	eb04 0805 	add.w	r8, r4, r5
    137a:	ea4f 1808 	mov.w	r8, r8, lsl #4
    137e:	f8d8 3000 	ldr.w	r3, [r8]
    1382:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1386:	2b0e      	cmp	r3, #14
    1388:	f200 809e 	bhi.w	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    138c:	e8df f013 	tbh	[pc, r3, lsl #1]
    1390:	01300142 	.word	0x01300142
    1394:	009c011e 	.word	0x009c011e
    1398:	009c0103 	.word	0x009c0103
    139c:	009c00f1 	.word	0x009c00f1
    13a0:	00cd00df 	.word	0x00cd00df
    13a4:	009c00bb 	.word	0x009c00bb
    13a8:	009c000f 	.word	0x009c000f
    13ac:	00a9      	.short	0x00a9
    13ae:	2104      	movs	r1, #4
    13b0:	48a6      	ldr	r0, [pc, #664]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    13b2:	f006 f867 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    13b6:	2300      	movs	r3, #0
    13b8:	4649      	mov	r1, r9
    13ba:	220a      	movs	r2, #10
    13bc:	48a4      	ldr	r0, [pc, #656]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    13be:	f004 f9b7 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    13c2:	211d      	movs	r1, #29
    13c4:	48a3      	ldr	r0, [pc, #652]	; (1654 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    13c6:	f006 f85d 	bl	7484 <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    13ca:	f8d8 3000 	ldr.w	r3, [r8]
    13ce:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    13d0:	029b      	lsls	r3, r3, #10
    13d2:	f140 81e3 	bpl.w	179c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    13d6:	48a0      	ldr	r0, [pc, #640]	; (1658 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    13d8:	f006 f854 	bl	7484 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    13dc:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    13e0:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    13e4:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    13e6:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    13ea:	2107      	movs	r1, #7
    13ec:	489b      	ldr	r0, [pc, #620]	; (165c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    13ee:	f006 f849 	bl	7484 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    13f2:	2300      	movs	r3, #0
    13f4:	2210      	movs	r2, #16
    13f6:	4651      	mov	r1, sl
    13f8:	4895      	ldr	r0, [pc, #596]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    13fa:	f004 f999 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    13fe:	2101      	movs	r1, #1
    1400:	4897      	ldr	r0, [pc, #604]	; (1660 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1402:	f006 f83f 	bl	7484 <usb_serial_write>
    1406:	210a      	movs	r1, #10
    1408:	4896      	ldr	r0, [pc, #600]	; (1664 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    140a:	f006 f83b 	bl	7484 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    140e:	2300      	movs	r3, #0
    1410:	2210      	movs	r2, #16
    1412:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1416:	488e      	ldr	r0, [pc, #568]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1418:	f004 f98a 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    141c:	2101      	movs	r1, #1
    141e:	4892      	ldr	r0, [pc, #584]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1420:	f006 f830 	bl	7484 <usb_serial_write>
    1424:	2300      	movs	r3, #0
    1426:	2210      	movs	r2, #16
    1428:	f3c9 4107 	ubfx	r1, r9, #16, #8
    142c:	4888      	ldr	r0, [pc, #544]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    142e:	f004 f97f 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1432:	2101      	movs	r1, #1
    1434:	488c      	ldr	r0, [pc, #560]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1436:	f006 f825 	bl	7484 <usb_serial_write>
    143a:	2300      	movs	r3, #0
    143c:	2210      	movs	r2, #16
    143e:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1442:	4883      	ldr	r0, [pc, #524]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1444:	f004 f974 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1448:	2101      	movs	r1, #1
    144a:	4887      	ldr	r0, [pc, #540]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    144c:	f006 f81a 	bl	7484 <usb_serial_write>
    1450:	2300      	movs	r3, #0
    1452:	2210      	movs	r2, #16
    1454:	fa5f f189 	uxtb.w	r1, r9
    1458:	487d      	ldr	r0, [pc, #500]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    145a:	f004 f969 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    145e:	f858 8007 	ldr.w	r8, [r8, r7]
    1462:	2101      	movs	r1, #1
    1464:	4880      	ldr	r0, [pc, #512]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1466:	f006 f80d 	bl	7484 <usb_serial_write>
    146a:	2300      	movs	r3, #0
    146c:	2210      	movs	r2, #16
    146e:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1472:	4877      	ldr	r0, [pc, #476]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1474:	f004 f95c 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1478:	2101      	movs	r1, #1
    147a:	487b      	ldr	r0, [pc, #492]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    147c:	f006 f802 	bl	7484 <usb_serial_write>
    1480:	2300      	movs	r3, #0
    1482:	2210      	movs	r2, #16
    1484:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1488:	4871      	ldr	r0, [pc, #452]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    148a:	f004 f951 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    148e:	2101      	movs	r1, #1
    1490:	4875      	ldr	r0, [pc, #468]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1492:	f005 fff7 	bl	7484 <usb_serial_write>
    1496:	2300      	movs	r3, #0
    1498:	2210      	movs	r2, #16
    149a:	f3c8 2107 	ubfx	r1, r8, #8, #8
    149e:	486c      	ldr	r0, [pc, #432]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14a0:	f004 f946 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14a4:	2101      	movs	r1, #1
    14a6:	4870      	ldr	r0, [pc, #448]	; (1668 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    14a8:	f005 ffec 	bl	7484 <usb_serial_write>
    14ac:	2300      	movs	r3, #0
    14ae:	fa5f f188 	uxtb.w	r1, r8
    14b2:	2210      	movs	r2, #16
    14b4:	4866      	ldr	r0, [pc, #408]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14b6:	f004 f93b 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14ba:	2101      	movs	r1, #1
    14bc:	4868      	ldr	r0, [pc, #416]	; (1660 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    14be:	f005 ffe1 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    14c2:	4863      	ldr	r0, [pc, #396]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14c4:	f004 f926 	bl	5714 <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    14c8:	4b5b      	ldr	r3, [pc, #364]	; (1638 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    14ca:	3401      	adds	r4, #1
    14cc:	681b      	ldr	r3, [r3, #0]
    14ce:	b2e4      	uxtb	r4, r4
    14d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    14d4:	46a1      	mov	r9, r4
    14d6:	3301      	adds	r3, #1
    14d8:	429c      	cmp	r4, r3
    14da:	f4ff af4c 	bcc.w	1376 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    14de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    14e2:	2104      	movs	r1, #4
    14e4:	4859      	ldr	r0, [pc, #356]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    14e6:	f005 ffcd 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    14ea:	4649      	mov	r1, r9
    14ec:	2300      	movs	r3, #0
    14ee:	220a      	movs	r2, #10
    14f0:	4857      	ldr	r0, [pc, #348]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14f2:	f004 f91d 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14f6:	2111      	movs	r1, #17
    14f8:	485c      	ldr	r0, [pc, #368]	; (166c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    14fa:	f005 ffc3 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    14fe:	4854      	ldr	r0, [pc, #336]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1500:	f004 f908 	bl	5714 <Print::println()>
    1504:	e7e0      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1506:	2104      	movs	r1, #4
    1508:	4850      	ldr	r0, [pc, #320]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    150a:	f005 ffbb 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    150e:	4649      	mov	r1, r9
    1510:	2300      	movs	r3, #0
    1512:	220a      	movs	r2, #10
    1514:	484e      	ldr	r0, [pc, #312]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1516:	f004 f90b 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    151a:	2111      	movs	r1, #17
    151c:	4854      	ldr	r0, [pc, #336]	; (1670 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    151e:	f005 ffb1 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1522:	484b      	ldr	r0, [pc, #300]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1524:	f004 f8f6 	bl	5714 <Print::println()>
    1528:	e7ce      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    152a:	2104      	movs	r1, #4
    152c:	4847      	ldr	r0, [pc, #284]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    152e:	f005 ffa9 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1532:	4649      	mov	r1, r9
    1534:	2300      	movs	r3, #0
    1536:	220a      	movs	r2, #10
    1538:	4845      	ldr	r0, [pc, #276]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    153a:	f004 f8f9 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    153e:	210f      	movs	r1, #15
    1540:	484c      	ldr	r0, [pc, #304]	; (1674 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    1542:	f005 ff9f 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1546:	4842      	ldr	r0, [pc, #264]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1548:	f004 f8e4 	bl	5714 <Print::println()>
    154c:	e7bc      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    154e:	2104      	movs	r1, #4
    1550:	483e      	ldr	r0, [pc, #248]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1552:	f005 ff97 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1556:	4649      	mov	r1, r9
    1558:	2300      	movs	r3, #0
    155a:	220a      	movs	r2, #10
    155c:	483c      	ldr	r0, [pc, #240]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    155e:	f004 f8e7 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1562:	2112      	movs	r1, #18
    1564:	4844      	ldr	r0, [pc, #272]	; (1678 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    1566:	f005 ff8d 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    156a:	4839      	ldr	r0, [pc, #228]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    156c:	f004 f8d2 	bl	5714 <Print::println()>
    1570:	e7aa      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1572:	2104      	movs	r1, #4
    1574:	4835      	ldr	r0, [pc, #212]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1576:	f005 ff85 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    157a:	4649      	mov	r1, r9
    157c:	2300      	movs	r3, #0
    157e:	220a      	movs	r2, #10
    1580:	4833      	ldr	r0, [pc, #204]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1582:	f004 f8d5 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1586:	2111      	movs	r1, #17
    1588:	483c      	ldr	r0, [pc, #240]	; (167c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    158a:	f005 ff7b 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    158e:	4830      	ldr	r0, [pc, #192]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1590:	f004 f8c0 	bl	5714 <Print::println()>
    1594:	e798      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1596:	2104      	movs	r1, #4
    1598:	482c      	ldr	r0, [pc, #176]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    159a:	f005 ff73 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    159e:	220a      	movs	r2, #10
    15a0:	4649      	mov	r1, r9
    15a2:	2300      	movs	r3, #0
    15a4:	482a      	ldr	r0, [pc, #168]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    15a6:	f004 f8c3 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    15aa:	210f      	movs	r1, #15
    15ac:	4834      	ldr	r0, [pc, #208]	; (1680 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    15ae:	f005 ff69 	bl	7484 <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    15b2:	f8d8 3000 	ldr.w	r3, [r8]
    15b6:	2111      	movs	r1, #17
    15b8:	029a      	lsls	r2, r3, #10
    15ba:	bf4c      	ite	mi
    15bc:	4831      	ldrmi	r0, [pc, #196]	; (1684 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    15be:	4832      	ldrpl	r0, [pc, #200]	; (1688 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    15c0:	f005 ff60 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    15c4:	4822      	ldr	r0, [pc, #136]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    15c6:	f004 f8a5 	bl	5714 <Print::println()>
    15ca:	e77d      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    15cc:	2104      	movs	r1, #4
    15ce:	481f      	ldr	r0, [pc, #124]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    15d0:	f005 ff58 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    15d4:	4649      	mov	r1, r9
    15d6:	2300      	movs	r3, #0
    15d8:	220a      	movs	r2, #10
    15da:	481d      	ldr	r0, [pc, #116]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    15dc:	f004 f8a8 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    15e0:	210e      	movs	r1, #14
    15e2:	482a      	ldr	r0, [pc, #168]	; (168c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    15e4:	f005 ff4e 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    15e8:	4819      	ldr	r0, [pc, #100]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    15ea:	f004 f893 	bl	5714 <Print::println()>
    15ee:	e76b      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    15f0:	2104      	movs	r1, #4
    15f2:	4816      	ldr	r0, [pc, #88]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    15f4:	f005 ff46 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    15f8:	4649      	mov	r1, r9
    15fa:	2300      	movs	r3, #0
    15fc:	220a      	movs	r2, #10
    15fe:	4814      	ldr	r0, [pc, #80]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1600:	f004 f896 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1604:	210e      	movs	r1, #14
    1606:	4822      	ldr	r0, [pc, #136]	; (1690 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    1608:	f005 ff3c 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    160c:	4810      	ldr	r0, [pc, #64]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    160e:	f004 f881 	bl	5714 <Print::println()>
    1612:	e759      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1614:	2104      	movs	r1, #4
    1616:	480d      	ldr	r0, [pc, #52]	; (164c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1618:	f005 ff34 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    161c:	4649      	mov	r1, r9
    161e:	2300      	movs	r3, #0
    1620:	220a      	movs	r2, #10
    1622:	480b      	ldr	r0, [pc, #44]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1624:	f004 f884 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1628:	2112      	movs	r1, #18
    162a:	481a      	ldr	r0, [pc, #104]	; (1694 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    162c:	f005 ff2a 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1630:	4807      	ldr	r0, [pc, #28]	; (1650 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1632:	f004 f86f 	bl	5714 <Print::println()>
    1636:	e747      	b.n	14c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1638:	401d4000 	.word	0x401d4000
    163c:	2000051c 	.word	0x2000051c
    1640:	401d408c 	.word	0x401d408c
    1644:	0401d408 	.word	0x0401d408
    1648:	bfe2bf80 	.word	0xbfe2bf80
    164c:	200003ec 	.word	0x200003ec
    1650:	20000a68 	.word	0x20000a68
    1654:	200004ac 	.word	0x200004ac
    1658:	200004cc 	.word	0x200004cc
    165c:	200004f4 	.word	0x200004f4
    1660:	20000428 	.word	0x20000428
    1664:	200004fc 	.word	0x200004fc
    1668:	20000390 	.word	0x20000390
    166c:	20000508 	.word	0x20000508
    1670:	20000464 	.word	0x20000464
    1674:	2000049c 	.word	0x2000049c
    1678:	20000488 	.word	0x20000488
    167c:	20000450 	.word	0x20000450
    1680:	20000408 	.word	0x20000408
    1684:	20000418 	.word	0x20000418
    1688:	2000042c 	.word	0x2000042c
    168c:	20000440 	.word	0x20000440
    1690:	20000478 	.word	0x20000478
    1694:	200003f4 	.word	0x200003f4
    1698:	2111      	movs	r1, #17
    169a:	48c4      	ldr	r0, [pc, #784]	; (19ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    169c:	f005 fef2 	bl	7484 <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    16a0:	6aab      	ldr	r3, [r5, #40]	; 0x28
    16a2:	069a      	lsls	r2, r3, #26
    16a4:	f100 81fa 	bmi.w	1a9c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    16a8:	2112      	movs	r1, #18
    16aa:	48c1      	ldr	r0, [pc, #772]	; (19b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    16ac:	f005 feea 	bl	7484 <usb_serial_write>
    16b0:	48c0      	ldr	r0, [pc, #768]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    16b2:	f004 f82f 	bl	5714 <Print::println()>
    16b6:	2116      	movs	r1, #22
    16b8:	48bf      	ldr	r0, [pc, #764]	; (19b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    16ba:	f005 fee3 	bl	7484 <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    16be:	4abf      	ldr	r2, [pc, #764]	; (19bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    16c0:	6814      	ldr	r4, [r2, #0]
    16c2:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    16c4:	6813      	ldr	r3, [r2, #0]
    16c6:	6b52      	ldr	r2, [r2, #52]	; 0x34
    16c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    16cc:	f3c2 6203 	ubfx	r2, r2, #24, #4
    16d0:	3301      	adds	r3, #1
    16d2:	3204      	adds	r2, #4
    16d4:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    16d8:	f0c0 81e8 	bcc.w	1aac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    16dc:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    16e0:	f3c1 6103 	ubfx	r1, r1, #24, #4
    16e4:	3c05      	subs	r4, #5
    16e6:	3101      	adds	r1, #1
    16e8:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    16ec:	b2e5      	uxtb	r5, r4
    16ee:	4eb3      	ldr	r6, [pc, #716]	; (19bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    16f0:	48b0      	ldr	r0, [pc, #704]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    16f2:	6831      	ldr	r1, [r6, #0]
    16f4:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    16f8:	3101      	adds	r1, #1
    16fa:	1b49      	subs	r1, r1, r5
    16fc:	b2c9      	uxtb	r1, r1
    16fe:	2920      	cmp	r1, #32
    1700:	bfa8      	it	ge
    1702:	2120      	movge	r1, #32
    1704:	f003 fffa 	bl	56fc <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    1708:	48aa      	ldr	r0, [pc, #680]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    170a:	f004 f803 	bl	5714 <Print::println()>
    170e:	2116      	movs	r1, #22
    1710:	48ab      	ldr	r0, [pc, #684]	; (19c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    1712:	f005 feb7 	bl	7484 <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1716:	6833      	ldr	r3, [r6, #0]
    1718:	6b72      	ldr	r2, [r6, #52]	; 0x34
    171a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    171e:	f3c2 6203 	ubfx	r2, r2, #24, #4
    1722:	3301      	adds	r3, #1
    1724:	3204      	adds	r2, #4
    1726:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    172a:	d201      	bcs.n	1730 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    172c:	2500      	movs	r5, #0
    172e:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1730:	2300      	movs	r3, #0
    1732:	4621      	mov	r1, r4
    1734:	220a      	movs	r2, #10
    1736:	489f      	ldr	r0, [pc, #636]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1738:	f003 fffa 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	// Print an unsigned number and newline
	size_t println(unsigned int n)			{ return print(n) + println(); }
	// Print a signed number and newline
	size_t println(long n)				{ return print(n) + println(); }
	// Print an unsigned number and newline
	size_t println(unsigned long n)			{ return print(n) + println(); }
    173c:	489d      	ldr	r0, [pc, #628]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    173e:	f003 ffe9 	bl	5714 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1742:	4b9e      	ldr	r3, [pc, #632]	; (19bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1744:	681c      	ldr	r4, [r3, #0]
    1746:	681b      	ldr	r3, [r3, #0]
    1748:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    174c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1750:	3401      	adds	r4, #1
    1752:	3301      	adds	r3, #1
    1754:	1b64      	subs	r4, r4, r5
    1756:	b2e4      	uxtb	r4, r4
    1758:	42a3      	cmp	r3, r4
    175a:	f67f aec0 	bls.w	14de <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    175e:	4d99      	ldr	r5, [pc, #612]	; (19c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1760:	4e99      	ldr	r6, [pc, #612]	; (19c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1762:	4f9a      	ldr	r7, [pc, #616]	; (19cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1764:	eb04 0805 	add.w	r8, r4, r5
    1768:	ea4f 1808 	mov.w	r8, r8, lsl #4
    176c:	f8d8 3000 	ldr.w	r3, [r8]
    1770:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1774:	2b0e      	cmp	r3, #14
    1776:	f200 80a9 	bhi.w	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    177a:	e8df f013 	tbh	[pc, r3, lsl #1]
    177e:	0147      	.short	0x0147
    1780:	00f20104 	.word	0x00f20104
    1784:	00d700a7 	.word	0x00d700a7
    1788:	016b00a7 	.word	0x016b00a7
    178c:	015900a7 	.word	0x015900a7
    1790:	00c5017d 	.word	0x00c5017d
    1794:	001a00a7 	.word	0x001a00a7
    1798:	00b300a7 	.word	0x00b300a7
    179c:	488c      	ldr	r0, [pc, #560]	; (19d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    179e:	f005 fe71 	bl	7484 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    17a2:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    17a6:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    17aa:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    17ac:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    17b0:	e61b      	b.n	13ea <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    17b2:	2104      	movs	r1, #4
    17b4:	4887      	ldr	r0, [pc, #540]	; (19d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    17b6:	f005 fe65 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17ba:	2300      	movs	r3, #0
    17bc:	220a      	movs	r2, #10
    17be:	4621      	mov	r1, r4
    17c0:	487c      	ldr	r0, [pc, #496]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    17c2:	f003 ffb5 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17c6:	211d      	movs	r1, #29
    17c8:	4883      	ldr	r0, [pc, #524]	; (19d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    17ca:	f005 fe5b 	bl	7484 <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    17ce:	f8d8 3000 	ldr.w	r3, [r8]
    17d2:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    17d4:	0298      	lsls	r0, r3, #10
    17d6:	f140 816c 	bpl.w	1ab2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    17da:	4880      	ldr	r0, [pc, #512]	; (19dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    17dc:	f005 fe52 	bl	7484 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    17e0:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    17e4:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    17e8:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    17ea:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    17ee:	2107      	movs	r1, #7
    17f0:	487b      	ldr	r0, [pc, #492]	; (19e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    17f2:	f005 fe47 	bl	7484 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    17f6:	2300      	movs	r3, #0
    17f8:	2210      	movs	r2, #16
    17fa:	4651      	mov	r1, sl
    17fc:	486d      	ldr	r0, [pc, #436]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    17fe:	f003 ff97 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1802:	2101      	movs	r1, #1
    1804:	4877      	ldr	r0, [pc, #476]	; (19e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1806:	f005 fe3d 	bl	7484 <usb_serial_write>
    180a:	210a      	movs	r1, #10
    180c:	4876      	ldr	r0, [pc, #472]	; (19e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    180e:	f005 fe39 	bl	7484 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1812:	2300      	movs	r3, #0
    1814:	2210      	movs	r2, #16
    1816:	ea4f 6119 	mov.w	r1, r9, lsr #24
    181a:	4866      	ldr	r0, [pc, #408]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    181c:	f003 ff88 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1820:	2101      	movs	r1, #1
    1822:	4872      	ldr	r0, [pc, #456]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1824:	f005 fe2e 	bl	7484 <usb_serial_write>
    1828:	2300      	movs	r3, #0
    182a:	2210      	movs	r2, #16
    182c:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1830:	4860      	ldr	r0, [pc, #384]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1832:	f003 ff7d 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1836:	2101      	movs	r1, #1
    1838:	486c      	ldr	r0, [pc, #432]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    183a:	f005 fe23 	bl	7484 <usb_serial_write>
    183e:	2300      	movs	r3, #0
    1840:	2210      	movs	r2, #16
    1842:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1846:	485b      	ldr	r0, [pc, #364]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1848:	f003 ff72 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    184c:	2101      	movs	r1, #1
    184e:	4867      	ldr	r0, [pc, #412]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1850:	f005 fe18 	bl	7484 <usb_serial_write>
    1854:	2300      	movs	r3, #0
    1856:	2210      	movs	r2, #16
    1858:	fa5f f189 	uxtb.w	r1, r9
    185c:	4855      	ldr	r0, [pc, #340]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    185e:	f003 ff67 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1862:	f858 8006 	ldr.w	r8, [r8, r6]
    1866:	2101      	movs	r1, #1
    1868:	4860      	ldr	r0, [pc, #384]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    186a:	f005 fe0b 	bl	7484 <usb_serial_write>
    186e:	2300      	movs	r3, #0
    1870:	2210      	movs	r2, #16
    1872:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1876:	484f      	ldr	r0, [pc, #316]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1878:	f003 ff5a 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    187c:	2101      	movs	r1, #1
    187e:	485b      	ldr	r0, [pc, #364]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1880:	f005 fe00 	bl	7484 <usb_serial_write>
    1884:	2300      	movs	r3, #0
    1886:	2210      	movs	r2, #16
    1888:	f3c8 4107 	ubfx	r1, r8, #16, #8
    188c:	4849      	ldr	r0, [pc, #292]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    188e:	f003 ff4f 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1892:	2101      	movs	r1, #1
    1894:	4855      	ldr	r0, [pc, #340]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1896:	f005 fdf5 	bl	7484 <usb_serial_write>
    189a:	2300      	movs	r3, #0
    189c:	2210      	movs	r2, #16
    189e:	f3c8 2107 	ubfx	r1, r8, #8, #8
    18a2:	4844      	ldr	r0, [pc, #272]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    18a4:	f003 ff44 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    18a8:	2101      	movs	r1, #1
    18aa:	4850      	ldr	r0, [pc, #320]	; (19ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    18ac:	f005 fdea 	bl	7484 <usb_serial_write>
    18b0:	2300      	movs	r3, #0
    18b2:	fa5f f188 	uxtb.w	r1, r8
    18b6:	2210      	movs	r2, #16
    18b8:	483e      	ldr	r0, [pc, #248]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    18ba:	f003 ff39 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    18be:	2101      	movs	r1, #1
    18c0:	4848      	ldr	r0, [pc, #288]	; (19e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    18c2:	f005 fddf 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    18c6:	483b      	ldr	r0, [pc, #236]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    18c8:	f003 ff24 	bl	5714 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    18cc:	4b3b      	ldr	r3, [pc, #236]	; (19bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    18ce:	3401      	adds	r4, #1
    18d0:	681b      	ldr	r3, [r3, #0]
    18d2:	b2e4      	uxtb	r4, r4
    18d4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    18d8:	3301      	adds	r3, #1
    18da:	429c      	cmp	r4, r3
    18dc:	f4ff af42 	bcc.w	1764 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    18e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    18e4:	2104      	movs	r1, #4
    18e6:	483b      	ldr	r0, [pc, #236]	; (19d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    18e8:	f005 fdcc 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    18ec:	2300      	movs	r3, #0
    18ee:	220a      	movs	r2, #10
    18f0:	4621      	mov	r1, r4
    18f2:	4830      	ldr	r0, [pc, #192]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    18f4:	f003 ff1c 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    18f8:	2111      	movs	r1, #17
    18fa:	483d      	ldr	r0, [pc, #244]	; (19f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    18fc:	f005 fdc2 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1900:	482c      	ldr	r0, [pc, #176]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1902:	f003 ff07 	bl	5714 <Print::println()>
    1906:	e7e1      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1908:	2104      	movs	r1, #4
    190a:	4832      	ldr	r0, [pc, #200]	; (19d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    190c:	f005 fdba 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1910:	2300      	movs	r3, #0
    1912:	220a      	movs	r2, #10
    1914:	4621      	mov	r1, r4
    1916:	4827      	ldr	r0, [pc, #156]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1918:	f003 ff0a 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    191c:	2111      	movs	r1, #17
    191e:	4835      	ldr	r0, [pc, #212]	; (19f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    1920:	f005 fdb0 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1924:	4823      	ldr	r0, [pc, #140]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1926:	f003 fef5 	bl	5714 <Print::println()>
    192a:	e7cf      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    192c:	2104      	movs	r1, #4
    192e:	4829      	ldr	r0, [pc, #164]	; (19d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1930:	f005 fda8 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1934:	220a      	movs	r2, #10
    1936:	2300      	movs	r3, #0
    1938:	4621      	mov	r1, r4
    193a:	481e      	ldr	r0, [pc, #120]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    193c:	f003 fef8 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1940:	210f      	movs	r1, #15
    1942:	482d      	ldr	r0, [pc, #180]	; (19f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    1944:	f005 fd9e 	bl	7484 <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1948:	f8d8 3000 	ldr.w	r3, [r8]
    194c:	2111      	movs	r1, #17
    194e:	029b      	lsls	r3, r3, #10
    1950:	bf4c      	ite	mi
    1952:	482a      	ldrmi	r0, [pc, #168]	; (19fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    1954:	482a      	ldrpl	r0, [pc, #168]	; (1a00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    1956:	f005 fd95 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    195a:	4816      	ldr	r0, [pc, #88]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    195c:	f003 feda 	bl	5714 <Print::println()>
    1960:	e7b4      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1962:	2104      	movs	r1, #4
    1964:	481b      	ldr	r0, [pc, #108]	; (19d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1966:	f005 fd8d 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    196a:	2300      	movs	r3, #0
    196c:	220a      	movs	r2, #10
    196e:	4621      	mov	r1, r4
    1970:	4810      	ldr	r0, [pc, #64]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1972:	f003 fedd 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1976:	210e      	movs	r1, #14
    1978:	4822      	ldr	r0, [pc, #136]	; (1a04 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    197a:	f005 fd83 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    197e:	480d      	ldr	r0, [pc, #52]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1980:	f003 fec8 	bl	5714 <Print::println()>
    1984:	e7a2      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1986:	2104      	movs	r1, #4
    1988:	4812      	ldr	r0, [pc, #72]	; (19d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    198a:	f005 fd7b 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    198e:	2300      	movs	r3, #0
    1990:	220a      	movs	r2, #10
    1992:	4621      	mov	r1, r4
    1994:	4807      	ldr	r0, [pc, #28]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1996:	f003 fecb 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    199a:	210e      	movs	r1, #14
    199c:	481a      	ldr	r0, [pc, #104]	; (1a08 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    199e:	f005 fd71 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    19a2:	4804      	ldr	r0, [pc, #16]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    19a4:	f003 feb6 	bl	5714 <Print::println()>
    19a8:	e790      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    19aa:	bf00      	nop
    19ac:	20000380 	.word	0x20000380
    19b0:	200003a8 	.word	0x200003a8
    19b4:	20000a68 	.word	0x20000a68
    19b8:	200003bc 	.word	0x200003bc
    19bc:	401d4000 	.word	0x401d4000
    19c0:	200003d4 	.word	0x200003d4
    19c4:	0401d408 	.word	0x0401d408
    19c8:	401d408c 	.word	0x401d408c
    19cc:	bfe2bf80 	.word	0xbfe2bf80
    19d0:	200004e0 	.word	0x200004e0
    19d4:	200003ec 	.word	0x200003ec
    19d8:	200004ac 	.word	0x200004ac
    19dc:	200004cc 	.word	0x200004cc
    19e0:	200004f4 	.word	0x200004f4
    19e4:	20000428 	.word	0x20000428
    19e8:	200004fc 	.word	0x200004fc
    19ec:	20000390 	.word	0x20000390
    19f0:	20000508 	.word	0x20000508
    19f4:	20000464 	.word	0x20000464
    19f8:	20000408 	.word	0x20000408
    19fc:	20000418 	.word	0x20000418
    1a00:	2000042c 	.word	0x2000042c
    1a04:	20000440 	.word	0x20000440
    1a08:	20000478 	.word	0x20000478
    1a0c:	2104      	movs	r1, #4
    1a0e:	482e      	ldr	r0, [pc, #184]	; (1ac8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1a10:	f005 fd38 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a14:	2300      	movs	r3, #0
    1a16:	220a      	movs	r2, #10
    1a18:	4621      	mov	r1, r4
    1a1a:	482c      	ldr	r0, [pc, #176]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a1c:	f003 fe88 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a20:	2112      	movs	r1, #18
    1a22:	482b      	ldr	r0, [pc, #172]	; (1ad0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    1a24:	f005 fd2e 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1a28:	4828      	ldr	r0, [pc, #160]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a2a:	f003 fe73 	bl	5714 <Print::println()>
    1a2e:	e74d      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1a30:	2104      	movs	r1, #4
    1a32:	4825      	ldr	r0, [pc, #148]	; (1ac8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1a34:	f005 fd26 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a38:	2300      	movs	r3, #0
    1a3a:	220a      	movs	r2, #10
    1a3c:	4621      	mov	r1, r4
    1a3e:	4823      	ldr	r0, [pc, #140]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a40:	f003 fe76 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a44:	2112      	movs	r1, #18
    1a46:	4823      	ldr	r0, [pc, #140]	; (1ad4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    1a48:	f005 fd1c 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1a4c:	481f      	ldr	r0, [pc, #124]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a4e:	f003 fe61 	bl	5714 <Print::println()>
    1a52:	e73b      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1a54:	2104      	movs	r1, #4
    1a56:	481c      	ldr	r0, [pc, #112]	; (1ac8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1a58:	f005 fd14 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a5c:	2300      	movs	r3, #0
    1a5e:	220a      	movs	r2, #10
    1a60:	4621      	mov	r1, r4
    1a62:	481a      	ldr	r0, [pc, #104]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a64:	f003 fe64 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a68:	2111      	movs	r1, #17
    1a6a:	481b      	ldr	r0, [pc, #108]	; (1ad8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    1a6c:	f005 fd0a 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1a70:	4816      	ldr	r0, [pc, #88]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a72:	f003 fe4f 	bl	5714 <Print::println()>
    1a76:	e729      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1a78:	2104      	movs	r1, #4
    1a7a:	4813      	ldr	r0, [pc, #76]	; (1ac8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1a7c:	f005 fd02 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a80:	2300      	movs	r3, #0
    1a82:	220a      	movs	r2, #10
    1a84:	4621      	mov	r1, r4
    1a86:	4811      	ldr	r0, [pc, #68]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a88:	f003 fe52 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a8c:	210f      	movs	r1, #15
    1a8e:	4813      	ldr	r0, [pc, #76]	; (1adc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    1a90:	f005 fcf8 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1a94:	480d      	ldr	r0, [pc, #52]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1a96:	f003 fe3d 	bl	5714 <Print::println()>
    1a9a:	e717      	b.n	18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1a9c:	2111      	movs	r1, #17
    1a9e:	4810      	ldr	r0, [pc, #64]	; (1ae0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    1aa0:	f005 fcf0 	bl	7484 <usb_serial_write>
    1aa4:	4809      	ldr	r0, [pc, #36]	; (1acc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1aa6:	f003 fe35 	bl	5714 <Print::println()>
    1aaa:	e604      	b.n	16b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    1aac:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1aae:	462c      	mov	r4, r5
    1ab0:	e61d      	b.n	16ee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    1ab2:	480c      	ldr	r0, [pc, #48]	; (1ae4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    1ab4:	f005 fce6 	bl	7484 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1ab8:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1abc:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1ac0:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1ac2:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    1ac6:	e692      	b.n	17ee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    1ac8:	200003ec 	.word	0x200003ec
    1acc:	20000a68 	.word	0x20000a68
    1ad0:	200003f4 	.word	0x200003f4
    1ad4:	20000488 	.word	0x20000488
    1ad8:	20000450 	.word	0x20000450
    1adc:	2000049c 	.word	0x2000049c
    1ae0:	20000394 	.word	0x20000394
    1ae4:	200004e0 	.word	0x200004e0

00001ae8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    1ae8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    1aec:	4db7      	ldr	r5, [pc, #732]	; (1dcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1aee:	682b      	ldr	r3, [r5, #0]
    1af0:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    1af4:	f040 819a 	bne.w	1e2c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    1af8:	211a      	movs	r1, #26
    1afa:	48b5      	ldr	r0, [pc, #724]	; (1dd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    1afc:	f005 fcc2 	bl	7484 <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1b00:	464c      	mov	r4, r9
    1b02:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1b04:	4fb3      	ldr	r7, [pc, #716]	; (1dd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1b06:	4db4      	ldr	r5, [pc, #720]	; (1dd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1b08:	4eb4      	ldr	r6, [pc, #720]	; (1ddc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1b0a:	eb04 0805 	add.w	r8, r4, r5
    1b0e:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1b12:	f8d8 3000 	ldr.w	r3, [r8]
    1b16:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1b1a:	2b0e      	cmp	r3, #14
    1b1c:	f200 809e 	bhi.w	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1b20:	e8df f013 	tbh	[pc, r3, lsl #1]
    1b24:	01300142 	.word	0x01300142
    1b28:	009c011e 	.word	0x009c011e
    1b2c:	009c0103 	.word	0x009c0103
    1b30:	009c00f1 	.word	0x009c00f1
    1b34:	00cd00df 	.word	0x00cd00df
    1b38:	009c00bb 	.word	0x009c00bb
    1b3c:	009c000f 	.word	0x009c000f
    1b40:	00a9      	.short	0x00a9
    1b42:	2104      	movs	r1, #4
    1b44:	48a6      	ldr	r0, [pc, #664]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1b46:	f005 fc9d 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1b4a:	2300      	movs	r3, #0
    1b4c:	4649      	mov	r1, r9
    1b4e:	220a      	movs	r2, #10
    1b50:	48a4      	ldr	r0, [pc, #656]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b52:	f003 fded 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b56:	211d      	movs	r1, #29
    1b58:	48a3      	ldr	r0, [pc, #652]	; (1de8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    1b5a:	f005 fc93 	bl	7484 <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1b5e:	f8d8 3000 	ldr.w	r3, [r8]
    1b62:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1b64:	029b      	lsls	r3, r3, #10
    1b66:	f140 81e3 	bpl.w	1f30 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    1b6a:	48a0      	ldr	r0, [pc, #640]	; (1dec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    1b6c:	f005 fc8a 	bl	7484 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1b70:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1b74:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1b78:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1b7a:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1b7e:	2107      	movs	r1, #7
    1b80:	489b      	ldr	r0, [pc, #620]	; (1df0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    1b82:	f005 fc7f 	bl	7484 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1b86:	2300      	movs	r3, #0
    1b88:	2210      	movs	r2, #16
    1b8a:	4651      	mov	r1, sl
    1b8c:	4895      	ldr	r0, [pc, #596]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b8e:	f003 fdcf 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b92:	2101      	movs	r1, #1
    1b94:	4897      	ldr	r0, [pc, #604]	; (1df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1b96:	f005 fc75 	bl	7484 <usb_serial_write>
    1b9a:	210a      	movs	r1, #10
    1b9c:	4896      	ldr	r0, [pc, #600]	; (1df8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    1b9e:	f005 fc71 	bl	7484 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1ba2:	2300      	movs	r3, #0
    1ba4:	2210      	movs	r2, #16
    1ba6:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1baa:	488e      	ldr	r0, [pc, #568]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bac:	f003 fdc0 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bb0:	2101      	movs	r1, #1
    1bb2:	4892      	ldr	r0, [pc, #584]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1bb4:	f005 fc66 	bl	7484 <usb_serial_write>
    1bb8:	2300      	movs	r3, #0
    1bba:	2210      	movs	r2, #16
    1bbc:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1bc0:	4888      	ldr	r0, [pc, #544]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bc2:	f003 fdb5 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bc6:	2101      	movs	r1, #1
    1bc8:	488c      	ldr	r0, [pc, #560]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1bca:	f005 fc5b 	bl	7484 <usb_serial_write>
    1bce:	2300      	movs	r3, #0
    1bd0:	2210      	movs	r2, #16
    1bd2:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1bd6:	4883      	ldr	r0, [pc, #524]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bd8:	f003 fdaa 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bdc:	2101      	movs	r1, #1
    1bde:	4887      	ldr	r0, [pc, #540]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1be0:	f005 fc50 	bl	7484 <usb_serial_write>
    1be4:	2300      	movs	r3, #0
    1be6:	2210      	movs	r2, #16
    1be8:	fa5f f189 	uxtb.w	r1, r9
    1bec:	487d      	ldr	r0, [pc, #500]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bee:	f003 fd9f 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1bf2:	f858 8007 	ldr.w	r8, [r8, r7]
    1bf6:	2101      	movs	r1, #1
    1bf8:	4880      	ldr	r0, [pc, #512]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1bfa:	f005 fc43 	bl	7484 <usb_serial_write>
    1bfe:	2300      	movs	r3, #0
    1c00:	2210      	movs	r2, #16
    1c02:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1c06:	4877      	ldr	r0, [pc, #476]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c08:	f003 fd92 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c0c:	2101      	movs	r1, #1
    1c0e:	487b      	ldr	r0, [pc, #492]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1c10:	f005 fc38 	bl	7484 <usb_serial_write>
    1c14:	2300      	movs	r3, #0
    1c16:	2210      	movs	r2, #16
    1c18:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1c1c:	4871      	ldr	r0, [pc, #452]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c1e:	f003 fd87 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c22:	2101      	movs	r1, #1
    1c24:	4875      	ldr	r0, [pc, #468]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1c26:	f005 fc2d 	bl	7484 <usb_serial_write>
    1c2a:	2300      	movs	r3, #0
    1c2c:	2210      	movs	r2, #16
    1c2e:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1c32:	486c      	ldr	r0, [pc, #432]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c34:	f003 fd7c 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c38:	2101      	movs	r1, #1
    1c3a:	4870      	ldr	r0, [pc, #448]	; (1dfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1c3c:	f005 fc22 	bl	7484 <usb_serial_write>
    1c40:	2300      	movs	r3, #0
    1c42:	fa5f f188 	uxtb.w	r1, r8
    1c46:	2210      	movs	r2, #16
    1c48:	4866      	ldr	r0, [pc, #408]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c4a:	f003 fd71 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c4e:	2101      	movs	r1, #1
    1c50:	4868      	ldr	r0, [pc, #416]	; (1df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1c52:	f005 fc17 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c56:	4863      	ldr	r0, [pc, #396]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c58:	f003 fd5c 	bl	5714 <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1c5c:	4b5b      	ldr	r3, [pc, #364]	; (1dcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1c5e:	3401      	adds	r4, #1
    1c60:	681b      	ldr	r3, [r3, #0]
    1c62:	b2e4      	uxtb	r4, r4
    1c64:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1c68:	46a1      	mov	r9, r4
    1c6a:	3301      	adds	r3, #1
    1c6c:	429c      	cmp	r4, r3
    1c6e:	f4ff af4c 	bcc.w	1b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    1c72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1c76:	2104      	movs	r1, #4
    1c78:	4859      	ldr	r0, [pc, #356]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1c7a:	f005 fc03 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c7e:	4649      	mov	r1, r9
    1c80:	2300      	movs	r3, #0
    1c82:	220a      	movs	r2, #10
    1c84:	4857      	ldr	r0, [pc, #348]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c86:	f003 fd53 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c8a:	2111      	movs	r1, #17
    1c8c:	485c      	ldr	r0, [pc, #368]	; (1e00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    1c8e:	f005 fbf9 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c92:	4854      	ldr	r0, [pc, #336]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c94:	f003 fd3e 	bl	5714 <Print::println()>
    1c98:	e7e0      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1c9a:	2104      	movs	r1, #4
    1c9c:	4850      	ldr	r0, [pc, #320]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1c9e:	f005 fbf1 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ca2:	4649      	mov	r1, r9
    1ca4:	2300      	movs	r3, #0
    1ca6:	220a      	movs	r2, #10
    1ca8:	484e      	ldr	r0, [pc, #312]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1caa:	f003 fd41 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cae:	2111      	movs	r1, #17
    1cb0:	4854      	ldr	r0, [pc, #336]	; (1e04 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    1cb2:	f005 fbe7 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1cb6:	484b      	ldr	r0, [pc, #300]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1cb8:	f003 fd2c 	bl	5714 <Print::println()>
    1cbc:	e7ce      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1cbe:	2104      	movs	r1, #4
    1cc0:	4847      	ldr	r0, [pc, #284]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1cc2:	f005 fbdf 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1cc6:	4649      	mov	r1, r9
    1cc8:	2300      	movs	r3, #0
    1cca:	220a      	movs	r2, #10
    1ccc:	4845      	ldr	r0, [pc, #276]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1cce:	f003 fd2f 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cd2:	210f      	movs	r1, #15
    1cd4:	484c      	ldr	r0, [pc, #304]	; (1e08 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    1cd6:	f005 fbd5 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1cda:	4842      	ldr	r0, [pc, #264]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1cdc:	f003 fd1a 	bl	5714 <Print::println()>
    1ce0:	e7bc      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1ce2:	2104      	movs	r1, #4
    1ce4:	483e      	ldr	r0, [pc, #248]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1ce6:	f005 fbcd 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1cea:	4649      	mov	r1, r9
    1cec:	2300      	movs	r3, #0
    1cee:	220a      	movs	r2, #10
    1cf0:	483c      	ldr	r0, [pc, #240]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1cf2:	f003 fd1d 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cf6:	2112      	movs	r1, #18
    1cf8:	4844      	ldr	r0, [pc, #272]	; (1e0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    1cfa:	f005 fbc3 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1cfe:	4839      	ldr	r0, [pc, #228]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d00:	f003 fd08 	bl	5714 <Print::println()>
    1d04:	e7aa      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1d06:	2104      	movs	r1, #4
    1d08:	4835      	ldr	r0, [pc, #212]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1d0a:	f005 fbbb 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d0e:	4649      	mov	r1, r9
    1d10:	2300      	movs	r3, #0
    1d12:	220a      	movs	r2, #10
    1d14:	4833      	ldr	r0, [pc, #204]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d16:	f003 fd0b 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d1a:	2111      	movs	r1, #17
    1d1c:	483c      	ldr	r0, [pc, #240]	; (1e10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    1d1e:	f005 fbb1 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1d22:	4830      	ldr	r0, [pc, #192]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d24:	f003 fcf6 	bl	5714 <Print::println()>
    1d28:	e798      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1d2a:	2104      	movs	r1, #4
    1d2c:	482c      	ldr	r0, [pc, #176]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1d2e:	f005 fba9 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d32:	220a      	movs	r2, #10
    1d34:	4649      	mov	r1, r9
    1d36:	2300      	movs	r3, #0
    1d38:	482a      	ldr	r0, [pc, #168]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d3a:	f003 fcf9 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d3e:	210f      	movs	r1, #15
    1d40:	4834      	ldr	r0, [pc, #208]	; (1e14 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    1d42:	f005 fb9f 	bl	7484 <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1d46:	f8d8 3000 	ldr.w	r3, [r8]
    1d4a:	2111      	movs	r1, #17
    1d4c:	029a      	lsls	r2, r3, #10
    1d4e:	bf4c      	ite	mi
    1d50:	4831      	ldrmi	r0, [pc, #196]	; (1e18 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    1d52:	4832      	ldrpl	r0, [pc, #200]	; (1e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    1d54:	f005 fb96 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1d58:	4822      	ldr	r0, [pc, #136]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d5a:	f003 fcdb 	bl	5714 <Print::println()>
    1d5e:	e77d      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1d60:	2104      	movs	r1, #4
    1d62:	481f      	ldr	r0, [pc, #124]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1d64:	f005 fb8e 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d68:	4649      	mov	r1, r9
    1d6a:	2300      	movs	r3, #0
    1d6c:	220a      	movs	r2, #10
    1d6e:	481d      	ldr	r0, [pc, #116]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d70:	f003 fcde 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d74:	210e      	movs	r1, #14
    1d76:	482a      	ldr	r0, [pc, #168]	; (1e20 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    1d78:	f005 fb84 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1d7c:	4819      	ldr	r0, [pc, #100]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d7e:	f003 fcc9 	bl	5714 <Print::println()>
    1d82:	e76b      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1d84:	2104      	movs	r1, #4
    1d86:	4816      	ldr	r0, [pc, #88]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1d88:	f005 fb7c 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d8c:	4649      	mov	r1, r9
    1d8e:	2300      	movs	r3, #0
    1d90:	220a      	movs	r2, #10
    1d92:	4814      	ldr	r0, [pc, #80]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d94:	f003 fccc 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d98:	210e      	movs	r1, #14
    1d9a:	4822      	ldr	r0, [pc, #136]	; (1e24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    1d9c:	f005 fb72 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1da0:	4810      	ldr	r0, [pc, #64]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1da2:	f003 fcb7 	bl	5714 <Print::println()>
    1da6:	e759      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1da8:	2104      	movs	r1, #4
    1daa:	480d      	ldr	r0, [pc, #52]	; (1de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1dac:	f005 fb6a 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1db0:	4649      	mov	r1, r9
    1db2:	2300      	movs	r3, #0
    1db4:	220a      	movs	r2, #10
    1db6:	480b      	ldr	r0, [pc, #44]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1db8:	f003 fcba 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1dbc:	2112      	movs	r1, #18
    1dbe:	481a      	ldr	r0, [pc, #104]	; (1e28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    1dc0:	f005 fb60 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1dc4:	4807      	ldr	r0, [pc, #28]	; (1de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1dc6:	f003 fca5 	bl	5714 <Print::println()>
    1dca:	e747      	b.n	1c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1dcc:	401d0000 	.word	0x401d0000
    1dd0:	2000051c 	.word	0x2000051c
    1dd4:	401d008c 	.word	0x401d008c
    1dd8:	0401d008 	.word	0x0401d008
    1ddc:	bfe2ff80 	.word	0xbfe2ff80
    1de0:	200003ec 	.word	0x200003ec
    1de4:	20000a68 	.word	0x20000a68
    1de8:	200004ac 	.word	0x200004ac
    1dec:	200004cc 	.word	0x200004cc
    1df0:	200004f4 	.word	0x200004f4
    1df4:	20000428 	.word	0x20000428
    1df8:	200004fc 	.word	0x200004fc
    1dfc:	20000390 	.word	0x20000390
    1e00:	20000508 	.word	0x20000508
    1e04:	20000464 	.word	0x20000464
    1e08:	2000049c 	.word	0x2000049c
    1e0c:	20000488 	.word	0x20000488
    1e10:	20000450 	.word	0x20000450
    1e14:	20000408 	.word	0x20000408
    1e18:	20000418 	.word	0x20000418
    1e1c:	2000042c 	.word	0x2000042c
    1e20:	20000440 	.word	0x20000440
    1e24:	20000478 	.word	0x20000478
    1e28:	200003f4 	.word	0x200003f4
    1e2c:	2111      	movs	r1, #17
    1e2e:	48c4      	ldr	r0, [pc, #784]	; (2140 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    1e30:	f005 fb28 	bl	7484 <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    1e34:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1e36:	069a      	lsls	r2, r3, #26
    1e38:	f100 81fa 	bmi.w	2230 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    1e3c:	2112      	movs	r1, #18
    1e3e:	48c1      	ldr	r0, [pc, #772]	; (2144 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    1e40:	f005 fb20 	bl	7484 <usb_serial_write>
    1e44:	48c0      	ldr	r0, [pc, #768]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1e46:	f003 fc65 	bl	5714 <Print::println()>
    1e4a:	2116      	movs	r1, #22
    1e4c:	48bf      	ldr	r0, [pc, #764]	; (214c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    1e4e:	f005 fb19 	bl	7484 <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1e52:	4abf      	ldr	r2, [pc, #764]	; (2150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1e54:	6814      	ldr	r4, [r2, #0]
    1e56:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1e58:	6813      	ldr	r3, [r2, #0]
    1e5a:	6b52      	ldr	r2, [r2, #52]	; 0x34
    1e5c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1e60:	f3c2 6203 	ubfx	r2, r2, #24, #4
    1e64:	3301      	adds	r3, #1
    1e66:	3204      	adds	r2, #4
    1e68:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1e6c:	f0c0 81e8 	bcc.w	2240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1e70:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1e74:	f3c1 6103 	ubfx	r1, r1, #24, #4
    1e78:	3c05      	subs	r4, #5
    1e7a:	3101      	adds	r1, #1
    1e7c:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    1e80:	b2e5      	uxtb	r5, r4
    1e82:	4eb3      	ldr	r6, [pc, #716]	; (2150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    1e84:	48b0      	ldr	r0, [pc, #704]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1e86:	6831      	ldr	r1, [r6, #0]
    1e88:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    1e8c:	3101      	adds	r1, #1
    1e8e:	1b49      	subs	r1, r1, r5
    1e90:	b2c9      	uxtb	r1, r1
    1e92:	2920      	cmp	r1, #32
    1e94:	bfa8      	it	ge
    1e96:	2120      	movge	r1, #32
    1e98:	f003 fc30 	bl	56fc <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    1e9c:	48aa      	ldr	r0, [pc, #680]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1e9e:	f003 fc39 	bl	5714 <Print::println()>
    1ea2:	2116      	movs	r1, #22
    1ea4:	48ab      	ldr	r0, [pc, #684]	; (2154 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    1ea6:	f005 faed 	bl	7484 <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1eaa:	6833      	ldr	r3, [r6, #0]
    1eac:	6b72      	ldr	r2, [r6, #52]	; 0x34
    1eae:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1eb2:	f3c2 6203 	ubfx	r2, r2, #24, #4
    1eb6:	3301      	adds	r3, #1
    1eb8:	3204      	adds	r2, #4
    1eba:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1ebe:	d201      	bcs.n	1ec4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    1ec0:	2500      	movs	r5, #0
    1ec2:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1ec4:	2300      	movs	r3, #0
    1ec6:	4621      	mov	r1, r4
    1ec8:	220a      	movs	r2, #10
    1eca:	489f      	ldr	r0, [pc, #636]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ecc:	f003 fc30 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1ed0:	489d      	ldr	r0, [pc, #628]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ed2:	f003 fc1f 	bl	5714 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1ed6:	4b9e      	ldr	r3, [pc, #632]	; (2150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1ed8:	681c      	ldr	r4, [r3, #0]
    1eda:	681b      	ldr	r3, [r3, #0]
    1edc:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1ee0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1ee4:	3401      	adds	r4, #1
    1ee6:	3301      	adds	r3, #1
    1ee8:	1b64      	subs	r4, r4, r5
    1eea:	b2e4      	uxtb	r4, r4
    1eec:	42a3      	cmp	r3, r4
    1eee:	f67f aec0 	bls.w	1c72 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1ef2:	4d99      	ldr	r5, [pc, #612]	; (2158 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1ef4:	4e99      	ldr	r6, [pc, #612]	; (215c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1ef6:	4f9a      	ldr	r7, [pc, #616]	; (2160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1ef8:	eb04 0805 	add.w	r8, r4, r5
    1efc:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1f00:	f8d8 3000 	ldr.w	r3, [r8]
    1f04:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1f08:	2b0e      	cmp	r3, #14
    1f0a:	f200 80a9 	bhi.w	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1f0e:	e8df f013 	tbh	[pc, r3, lsl #1]
    1f12:	0147      	.short	0x0147
    1f14:	00f20104 	.word	0x00f20104
    1f18:	00d700a7 	.word	0x00d700a7
    1f1c:	016b00a7 	.word	0x016b00a7
    1f20:	015900a7 	.word	0x015900a7
    1f24:	00c5017d 	.word	0x00c5017d
    1f28:	001a00a7 	.word	0x001a00a7
    1f2c:	00b300a7 	.word	0x00b300a7
    1f30:	488c      	ldr	r0, [pc, #560]	; (2164 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    1f32:	f005 faa7 	bl	7484 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1f36:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1f3a:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1f3e:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1f40:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    1f44:	e61b      	b.n	1b7e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    1f46:	2104      	movs	r1, #4
    1f48:	4887      	ldr	r0, [pc, #540]	; (2168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1f4a:	f005 fa9b 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f4e:	2300      	movs	r3, #0
    1f50:	220a      	movs	r2, #10
    1f52:	4621      	mov	r1, r4
    1f54:	487c      	ldr	r0, [pc, #496]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f56:	f003 fbeb 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f5a:	211d      	movs	r1, #29
    1f5c:	4883      	ldr	r0, [pc, #524]	; (216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    1f5e:	f005 fa91 	bl	7484 <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1f62:	f8d8 3000 	ldr.w	r3, [r8]
    1f66:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1f68:	0298      	lsls	r0, r3, #10
    1f6a:	f140 816c 	bpl.w	2246 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    1f6e:	4880      	ldr	r0, [pc, #512]	; (2170 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    1f70:	f005 fa88 	bl	7484 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1f74:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1f78:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1f7c:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1f7e:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1f82:	2107      	movs	r1, #7
    1f84:	487b      	ldr	r0, [pc, #492]	; (2174 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    1f86:	f005 fa7d 	bl	7484 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1f8a:	2300      	movs	r3, #0
    1f8c:	2210      	movs	r2, #16
    1f8e:	4651      	mov	r1, sl
    1f90:	486d      	ldr	r0, [pc, #436]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f92:	f003 fbcd 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f96:	2101      	movs	r1, #1
    1f98:	4877      	ldr	r0, [pc, #476]	; (2178 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1f9a:	f005 fa73 	bl	7484 <usb_serial_write>
    1f9e:	210a      	movs	r1, #10
    1fa0:	4876      	ldr	r0, [pc, #472]	; (217c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    1fa2:	f005 fa6f 	bl	7484 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1fa6:	2300      	movs	r3, #0
    1fa8:	2210      	movs	r2, #16
    1faa:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1fae:	4866      	ldr	r0, [pc, #408]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1fb0:	f003 fbbe 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fb4:	2101      	movs	r1, #1
    1fb6:	4872      	ldr	r0, [pc, #456]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1fb8:	f005 fa64 	bl	7484 <usb_serial_write>
    1fbc:	2300      	movs	r3, #0
    1fbe:	2210      	movs	r2, #16
    1fc0:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1fc4:	4860      	ldr	r0, [pc, #384]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1fc6:	f003 fbb3 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fca:	2101      	movs	r1, #1
    1fcc:	486c      	ldr	r0, [pc, #432]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1fce:	f005 fa59 	bl	7484 <usb_serial_write>
    1fd2:	2300      	movs	r3, #0
    1fd4:	2210      	movs	r2, #16
    1fd6:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1fda:	485b      	ldr	r0, [pc, #364]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1fdc:	f003 fba8 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fe0:	2101      	movs	r1, #1
    1fe2:	4867      	ldr	r0, [pc, #412]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1fe4:	f005 fa4e 	bl	7484 <usb_serial_write>
    1fe8:	2300      	movs	r3, #0
    1fea:	2210      	movs	r2, #16
    1fec:	fa5f f189 	uxtb.w	r1, r9
    1ff0:	4855      	ldr	r0, [pc, #340]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ff2:	f003 fb9d 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1ff6:	f858 8006 	ldr.w	r8, [r8, r6]
    1ffa:	2101      	movs	r1, #1
    1ffc:	4860      	ldr	r0, [pc, #384]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1ffe:	f005 fa41 	bl	7484 <usb_serial_write>
    2002:	2300      	movs	r3, #0
    2004:	2210      	movs	r2, #16
    2006:	ea4f 6118 	mov.w	r1, r8, lsr #24
    200a:	484f      	ldr	r0, [pc, #316]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    200c:	f003 fb90 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2010:	2101      	movs	r1, #1
    2012:	485b      	ldr	r0, [pc, #364]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2014:	f005 fa36 	bl	7484 <usb_serial_write>
    2018:	2300      	movs	r3, #0
    201a:	2210      	movs	r2, #16
    201c:	f3c8 4107 	ubfx	r1, r8, #16, #8
    2020:	4849      	ldr	r0, [pc, #292]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2022:	f003 fb85 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2026:	2101      	movs	r1, #1
    2028:	4855      	ldr	r0, [pc, #340]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    202a:	f005 fa2b 	bl	7484 <usb_serial_write>
    202e:	2300      	movs	r3, #0
    2030:	2210      	movs	r2, #16
    2032:	f3c8 2107 	ubfx	r1, r8, #8, #8
    2036:	4844      	ldr	r0, [pc, #272]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2038:	f003 fb7a 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    203c:	2101      	movs	r1, #1
    203e:	4850      	ldr	r0, [pc, #320]	; (2180 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2040:	f005 fa20 	bl	7484 <usb_serial_write>
    2044:	2300      	movs	r3, #0
    2046:	fa5f f188 	uxtb.w	r1, r8
    204a:	2210      	movs	r2, #16
    204c:	483e      	ldr	r0, [pc, #248]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    204e:	f003 fb6f 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2052:	2101      	movs	r1, #1
    2054:	4848      	ldr	r0, [pc, #288]	; (2178 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    2056:	f005 fa15 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    205a:	483b      	ldr	r0, [pc, #236]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    205c:	f003 fb5a 	bl	5714 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    2060:	4b3b      	ldr	r3, [pc, #236]	; (2150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    2062:	3401      	adds	r4, #1
    2064:	681b      	ldr	r3, [r3, #0]
    2066:	b2e4      	uxtb	r4, r4
    2068:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    206c:	3301      	adds	r3, #1
    206e:	429c      	cmp	r4, r3
    2070:	f4ff af42 	bcc.w	1ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    2074:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2078:	2104      	movs	r1, #4
    207a:	483b      	ldr	r0, [pc, #236]	; (2168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    207c:	f005 fa02 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2080:	2300      	movs	r3, #0
    2082:	220a      	movs	r2, #10
    2084:	4621      	mov	r1, r4
    2086:	4830      	ldr	r0, [pc, #192]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2088:	f003 fb52 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    208c:	2111      	movs	r1, #17
    208e:	483d      	ldr	r0, [pc, #244]	; (2184 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    2090:	f005 f9f8 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2094:	482c      	ldr	r0, [pc, #176]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2096:	f003 fb3d 	bl	5714 <Print::println()>
    209a:	e7e1      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    209c:	2104      	movs	r1, #4
    209e:	4832      	ldr	r0, [pc, #200]	; (2168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    20a0:	f005 f9f0 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20a4:	2300      	movs	r3, #0
    20a6:	220a      	movs	r2, #10
    20a8:	4621      	mov	r1, r4
    20aa:	4827      	ldr	r0, [pc, #156]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20ac:	f003 fb40 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    20b0:	2111      	movs	r1, #17
    20b2:	4835      	ldr	r0, [pc, #212]	; (2188 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    20b4:	f005 f9e6 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    20b8:	4823      	ldr	r0, [pc, #140]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20ba:	f003 fb2b 	bl	5714 <Print::println()>
    20be:	e7cf      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    20c0:	2104      	movs	r1, #4
    20c2:	4829      	ldr	r0, [pc, #164]	; (2168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    20c4:	f005 f9de 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20c8:	220a      	movs	r2, #10
    20ca:	2300      	movs	r3, #0
    20cc:	4621      	mov	r1, r4
    20ce:	481e      	ldr	r0, [pc, #120]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20d0:	f003 fb2e 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    20d4:	210f      	movs	r1, #15
    20d6:	482d      	ldr	r0, [pc, #180]	; (218c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    20d8:	f005 f9d4 	bl	7484 <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    20dc:	f8d8 3000 	ldr.w	r3, [r8]
    20e0:	2111      	movs	r1, #17
    20e2:	029b      	lsls	r3, r3, #10
    20e4:	bf4c      	ite	mi
    20e6:	482a      	ldrmi	r0, [pc, #168]	; (2190 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    20e8:	482a      	ldrpl	r0, [pc, #168]	; (2194 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    20ea:	f005 f9cb 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    20ee:	4816      	ldr	r0, [pc, #88]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20f0:	f003 fb10 	bl	5714 <Print::println()>
    20f4:	e7b4      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    20f6:	2104      	movs	r1, #4
    20f8:	481b      	ldr	r0, [pc, #108]	; (2168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    20fa:	f005 f9c3 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20fe:	2300      	movs	r3, #0
    2100:	220a      	movs	r2, #10
    2102:	4621      	mov	r1, r4
    2104:	4810      	ldr	r0, [pc, #64]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2106:	f003 fb13 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    210a:	210e      	movs	r1, #14
    210c:	4822      	ldr	r0, [pc, #136]	; (2198 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    210e:	f005 f9b9 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2112:	480d      	ldr	r0, [pc, #52]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2114:	f003 fafe 	bl	5714 <Print::println()>
    2118:	e7a2      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    211a:	2104      	movs	r1, #4
    211c:	4812      	ldr	r0, [pc, #72]	; (2168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    211e:	f005 f9b1 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2122:	2300      	movs	r3, #0
    2124:	220a      	movs	r2, #10
    2126:	4621      	mov	r1, r4
    2128:	4807      	ldr	r0, [pc, #28]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    212a:	f003 fb01 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    212e:	210e      	movs	r1, #14
    2130:	481a      	ldr	r0, [pc, #104]	; (219c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    2132:	f005 f9a7 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2136:	4804      	ldr	r0, [pc, #16]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2138:	f003 faec 	bl	5714 <Print::println()>
    213c:	e790      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    213e:	bf00      	nop
    2140:	20000380 	.word	0x20000380
    2144:	200003a8 	.word	0x200003a8
    2148:	20000a68 	.word	0x20000a68
    214c:	200003bc 	.word	0x200003bc
    2150:	401d0000 	.word	0x401d0000
    2154:	200003d4 	.word	0x200003d4
    2158:	0401d008 	.word	0x0401d008
    215c:	401d008c 	.word	0x401d008c
    2160:	bfe2ff80 	.word	0xbfe2ff80
    2164:	200004e0 	.word	0x200004e0
    2168:	200003ec 	.word	0x200003ec
    216c:	200004ac 	.word	0x200004ac
    2170:	200004cc 	.word	0x200004cc
    2174:	200004f4 	.word	0x200004f4
    2178:	20000428 	.word	0x20000428
    217c:	200004fc 	.word	0x200004fc
    2180:	20000390 	.word	0x20000390
    2184:	20000508 	.word	0x20000508
    2188:	20000464 	.word	0x20000464
    218c:	20000408 	.word	0x20000408
    2190:	20000418 	.word	0x20000418
    2194:	2000042c 	.word	0x2000042c
    2198:	20000440 	.word	0x20000440
    219c:	20000478 	.word	0x20000478
    21a0:	2104      	movs	r1, #4
    21a2:	482e      	ldr	r0, [pc, #184]	; (225c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    21a4:	f005 f96e 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    21a8:	2300      	movs	r3, #0
    21aa:	220a      	movs	r2, #10
    21ac:	4621      	mov	r1, r4
    21ae:	482c      	ldr	r0, [pc, #176]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    21b0:	f003 fabe 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    21b4:	2112      	movs	r1, #18
    21b6:	482b      	ldr	r0, [pc, #172]	; (2264 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    21b8:	f005 f964 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    21bc:	4828      	ldr	r0, [pc, #160]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    21be:	f003 faa9 	bl	5714 <Print::println()>
    21c2:	e74d      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    21c4:	2104      	movs	r1, #4
    21c6:	4825      	ldr	r0, [pc, #148]	; (225c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    21c8:	f005 f95c 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    21cc:	2300      	movs	r3, #0
    21ce:	220a      	movs	r2, #10
    21d0:	4621      	mov	r1, r4
    21d2:	4823      	ldr	r0, [pc, #140]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    21d4:	f003 faac 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    21d8:	2112      	movs	r1, #18
    21da:	4823      	ldr	r0, [pc, #140]	; (2268 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    21dc:	f005 f952 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    21e0:	481f      	ldr	r0, [pc, #124]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    21e2:	f003 fa97 	bl	5714 <Print::println()>
    21e6:	e73b      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    21e8:	2104      	movs	r1, #4
    21ea:	481c      	ldr	r0, [pc, #112]	; (225c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    21ec:	f005 f94a 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    21f0:	2300      	movs	r3, #0
    21f2:	220a      	movs	r2, #10
    21f4:	4621      	mov	r1, r4
    21f6:	481a      	ldr	r0, [pc, #104]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    21f8:	f003 fa9a 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    21fc:	2111      	movs	r1, #17
    21fe:	481b      	ldr	r0, [pc, #108]	; (226c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    2200:	f005 f940 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2204:	4816      	ldr	r0, [pc, #88]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2206:	f003 fa85 	bl	5714 <Print::println()>
    220a:	e729      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    220c:	2104      	movs	r1, #4
    220e:	4813      	ldr	r0, [pc, #76]	; (225c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    2210:	f005 f938 	bl	7484 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2214:	2300      	movs	r3, #0
    2216:	220a      	movs	r2, #10
    2218:	4621      	mov	r1, r4
    221a:	4811      	ldr	r0, [pc, #68]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    221c:	f003 fa88 	bl	5730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2220:	210f      	movs	r1, #15
    2222:	4813      	ldr	r0, [pc, #76]	; (2270 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    2224:	f005 f92e 	bl	7484 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2228:	480d      	ldr	r0, [pc, #52]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    222a:	f003 fa73 	bl	5714 <Print::println()>
    222e:	e717      	b.n	2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2230:	2111      	movs	r1, #17
    2232:	4810      	ldr	r0, [pc, #64]	; (2274 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    2234:	f005 f926 	bl	7484 <usb_serial_write>
    2238:	4809      	ldr	r0, [pc, #36]	; (2260 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    223a:	f003 fa6b 	bl	5714 <Print::println()>
    223e:	e604      	b.n	1e4a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    2240:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    2242:	462c      	mov	r4, r5
    2244:	e61d      	b.n	1e82 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    2246:	480c      	ldr	r0, [pc, #48]	; (2278 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    2248:	f005 f91c 	bl	7484 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    224c:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    2250:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2254:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    2256:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    225a:	e692      	b.n	1f82 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    225c:	200003ec 	.word	0x200003ec
    2260:	20000a68 	.word	0x20000a68
    2264:	200003f4 	.word	0x200003f4
    2268:	20000488 	.word	0x20000488
    226c:	20000450 	.word	0x20000450
    2270:	2000049c 	.word	0x2000049c
    2274:	20000394 	.word	0x20000394
    2278:	200004e0 	.word	0x200004e0

0000227c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    227c:	b570      	push	{r4, r5, r6, lr}
    227e:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2280:	bb39      	cbnz	r1, 22d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    2282:	4a3b      	ldr	r2, [pc, #236]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2284:	6a13      	ldr	r3, [r2, #32]
    2286:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    228a:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    228e:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    2290:	4b38      	ldr	r3, [pc, #224]	; (2374 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    2292:	6818      	ldr	r0, [r3, #0]
    2294:	b158      	cbz	r0, 22ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    2296:	4a38      	ldr	r2, [pc, #224]	; (2378 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2298:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    229c:	6805      	ldr	r5, [r0, #0]
    229e:	6852      	ldr	r2, [r2, #4]
    22a0:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    22a4:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    22a8:	686b      	ldr	r3, [r5, #4]
    22aa:	0052      	lsls	r2, r2, #1
    22ac:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    22ae:	4b33      	ldr	r3, [pc, #204]	; (237c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    22b0:	6818      	ldr	r0, [r3, #0]
    22b2:	2800      	cmp	r0, #0
    22b4:	d05b      	beq.n	236e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    22b6:	4a30      	ldr	r2, [pc, #192]	; (2378 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    22b8:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    22bc:	6803      	ldr	r3, [r0, #0]
    22be:	6852      	ldr	r2, [r2, #4]
    22c0:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    22c4:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    22c8:	685b      	ldr	r3, [r3, #4]
    22ca:	0052      	lsls	r2, r2, #1
}
    22cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    22d0:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    22d2:	2908      	cmp	r1, #8
    22d4:	d107      	bne.n	22e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    22d6:	4a26      	ldr	r2, [pc, #152]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    22d8:	6a13      	ldr	r3, [r2, #32]
    22da:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    22de:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    22e2:	6213      	str	r3, [r2, #32]
    22e4:	e7d4      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    22e6:	2910      	cmp	r1, #16
    22e8:	d107      	bne.n	22fa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    22ea:	4a21      	ldr	r2, [pc, #132]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    22ec:	6a13      	ldr	r3, [r2, #32]
    22ee:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    22f2:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    22f6:	6213      	str	r3, [r2, #32]
    22f8:	e7ca      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    22fa:	2918      	cmp	r1, #24
    22fc:	d107      	bne.n	230e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    22fe:	4a1c      	ldr	r2, [pc, #112]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2300:	6a13      	ldr	r3, [r2, #32]
    2302:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2306:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    230a:	6213      	str	r3, [r2, #32]
    230c:	e7c0      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    230e:	2914      	cmp	r1, #20
    2310:	d107      	bne.n	2322 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    2312:	4a17      	ldr	r2, [pc, #92]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2314:	6a13      	ldr	r3, [r2, #32]
    2316:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    231a:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    231e:	6213      	str	r3, [r2, #32]
    2320:	e7b6      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2322:	291e      	cmp	r1, #30
    2324:	d107      	bne.n	2336 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    2326:	4a12      	ldr	r2, [pc, #72]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2328:	6a13      	ldr	r3, [r2, #32]
    232a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    232e:	f043 0304 	orr.w	r3, r3, #4
    2332:	6213      	str	r3, [r2, #32]
    2334:	e7ac      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2336:	2928      	cmp	r1, #40	; 0x28
    2338:	d107      	bne.n	234a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    233a:	4a0d      	ldr	r2, [pc, #52]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    233c:	6a13      	ldr	r3, [r2, #32]
    233e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2342:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    2346:	6213      	str	r3, [r2, #32]
    2348:	e7a2      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    234a:	293c      	cmp	r1, #60	; 0x3c
    234c:	d105      	bne.n	235a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    234e:	4a08      	ldr	r2, [pc, #32]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2350:	6a13      	ldr	r3, [r2, #32]
    2352:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2356:	6213      	str	r3, [r2, #32]
    2358:	e79a      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    235a:	2950      	cmp	r1, #80	; 0x50
    235c:	d198      	bne.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    235e:	4a04      	ldr	r2, [pc, #16]	; (2370 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2360:	6a13      	ldr	r3, [r2, #32]
    2362:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2366:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    236a:	6213      	str	r3, [r2, #32]
    236c:	e790      	b.n	2290 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    236e:	bd70      	pop	{r4, r5, r6, pc}
    2370:	400fc000 	.word	0x400fc000
    2374:	20006870 	.word	0x20006870
    2378:	401d0000 	.word	0x401d0000
    237c:	20006874 	.word	0x20006874

00002380 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    2380:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    2382:	494e      	ldr	r1, [pc, #312]	; (24bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    2384:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    2386:	4b4e      	ldr	r3, [pc, #312]	; (24c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    2388:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    238a:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    238c:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    238e:	6a1b      	ldr	r3, [r3, #32]
    2390:	f3c3 2301 	ubfx	r3, r3, #8, #2
    2394:	3308      	adds	r3, #8
    2396:	446b      	add	r3, sp
    2398:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    239c:	e9c0 2201 	strd	r2, r2, [r0, #4]
    23a0:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    23a4:	2b00      	cmp	r3, #0
    23a6:	f000 8085 	beq.w	24b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C000;
    23aa:	4945      	ldr	r1, [pc, #276]	; (24c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN1;
    23ac:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    23b0:	2024      	movs	r0, #36	; 0x24
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    23b2:	4b44      	ldr	r3, [pc, #272]	; (24c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    23b4:	4a44      	ldr	r2, [pc, #272]	; (24c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 1;
    23b6:	2401      	movs	r4, #1
    nvicIrq = IRQ_CAN1;
    23b8:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    23bc:	2602      	movs	r6, #2
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    23be:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    23c2:	2012      	movs	r0, #18
    CCM_CCGR0 |= 0x3C000;
    23c4:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    23c6:	4b41      	ldr	r3, [pc, #260]	; (24cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C000;
    23c8:	f442 3270 	orr.w	r2, r2, #245760	; 0x3c000
    23cc:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    23ce:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 1;
    23d2:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    23d6:	4a3e      	ldr	r2, [pc, #248]	; (24d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    23d8:	4c3e      	ldr	r4, [pc, #248]	; (24d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    23da:	f8c3 011c 	str.w	r0, [r3, #284]	; 0x11c
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    23de:	f8c3 130c 	str.w	r1, [r3, #780]	; 0x30c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    23e2:	64e6      	str	r6, [r4, #76]	; 0x4c
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 0x12; // pin 23 T4B1+B2
    23e4:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09 = 0x10B0; // pin 23 T4B1+B2
    23e8:	f8c3 1310 	str.w	r1, [r3, #784]	; 0x310
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    23ec:	6813      	ldr	r3, [r2, #0]
    23ee:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    23f2:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    23f4:	6813      	ldr	r3, [r2, #0]
    23f6:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    23fa:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    23fc:	6813      	ldr	r3, [r2, #0]
    23fe:	01dc      	lsls	r4, r3, #7
    2400:	d5fc      	bpl.n	23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2402:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2404:	4932      	ldr	r1, [pc, #200]	; (24d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2406:	f043 0308 	orr.w	r3, r3, #8
    240a:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    240c:	6813      	ldr	r3, [r2, #0]
    240e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    2412:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2414:	680b      	ldr	r3, [r1, #0]
    2416:	02d8      	lsls	r0, r3, #11
    2418:	d4fc      	bmi.n	2414 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    241a:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    241c:	4a2c      	ldr	r2, [pc, #176]	; (24d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    241e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    2422:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2424:	6813      	ldr	r3, [r2, #0]
    2426:	0199      	lsls	r1, r3, #6
    2428:	d4fc      	bmi.n	2424 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    242a:	4c29      	ldr	r4, [pc, #164]	; (24d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    242c:	6823      	ldr	r3, [r4, #0]
    242e:	01da      	lsls	r2, r3, #7
    2430:	d5fc      	bpl.n	242c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    2432:	6823      	ldr	r3, [r4, #0]
    void disableFIFO() { enableFIFO(0); }
    2434:	2000      	movs	r0, #0
    2436:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    243a:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    243c:	6823      	ldr	r3, [r4, #0]
    243e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    2442:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    2444:	6823      	ldr	r3, [r4, #0]
    2446:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    244a:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    244c:	6823      	ldr	r3, [r4, #0]
    244e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    2452:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    2454:	6823      	ldr	r3, [r4, #0]
    2456:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    245a:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    245c:	6823      	ldr	r3, [r4, #0]
    245e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    2462:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    2464:	6823      	ldr	r3, [r4, #0]
    2466:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    246a:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    246c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    246e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    2472:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    2474:	6823      	ldr	r3, [r4, #0]
    2476:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    247a:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    247c:	6823      	ldr	r3, [r4, #0]
    247e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    2482:	6023      	str	r3, [r4, #0]
    2484:	f7fe fdca 	bl	101c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2488:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    248a:	4a11      	ldr	r2, [pc, #68]	; (24d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    248c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2490:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2492:	6813      	ldr	r3, [r2, #0]
    2494:	01db      	lsls	r3, r3, #7
    2496:	d4fc      	bmi.n	2492 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    2498:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    249c:	2101      	movs	r1, #1
    249e:	4b0e      	ldr	r3, [pc, #56]	; (24d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    24a0:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    24a4:	f002 021f 	and.w	r2, r2, #31
    24a8:	009b      	lsls	r3, r3, #2
    24aa:	fa01 f202 	lsl.w	r2, r1, r2
    24ae:	601a      	str	r2, [r3, #0]
}
    24b0:	b002      	add	sp, #8
    24b2:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    24b4:	2118      	movs	r1, #24
    24b6:	f7ff fee1 	bl	227c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    24ba:	e776      	b.n	23aa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    24bc:	0050183c 	.word	0x0050183c
    24c0:	400fc000 	.word	0x400fc000
    24c4:	20001000 	.word	0x20001000
    24c8:	00000c55 	.word	0x00000c55
    24cc:	401f8000 	.word	0x401f8000
    24d0:	401d0000 	.word	0x401d0000
    24d4:	401f8400 	.word	0x401f8400
    24d8:	38003840 	.word	0x38003840

000024dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    24dc:	b570      	push	{r4, r5, r6, lr}
    24de:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    24e0:	bb39      	cbnz	r1, 2532 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    24e2:	4a3b      	ldr	r2, [pc, #236]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    24e4:	6a13      	ldr	r3, [r2, #32]
    24e6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    24ea:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    24ee:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    24f0:	4b38      	ldr	r3, [pc, #224]	; (25d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    24f2:	6818      	ldr	r0, [r3, #0]
    24f4:	b158      	cbz	r0, 250e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    24f6:	4a38      	ldr	r2, [pc, #224]	; (25d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    24f8:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    24fc:	6805      	ldr	r5, [r0, #0]
    24fe:	6852      	ldr	r2, [r2, #4]
    2500:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    2504:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2508:	686b      	ldr	r3, [r5, #4]
    250a:	0052      	lsls	r2, r2, #1
    250c:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    250e:	4b33      	ldr	r3, [pc, #204]	; (25dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    2510:	6818      	ldr	r0, [r3, #0]
    2512:	2800      	cmp	r0, #0
    2514:	d05b      	beq.n	25ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    2516:	4a30      	ldr	r2, [pc, #192]	; (25d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2518:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    251c:	6803      	ldr	r3, [r0, #0]
    251e:	6852      	ldr	r2, [r2, #4]
    2520:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    2524:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2528:	685b      	ldr	r3, [r3, #4]
    252a:	0052      	lsls	r2, r2, #1
}
    252c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    2530:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    2532:	2908      	cmp	r1, #8
    2534:	d107      	bne.n	2546 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    2536:	4a26      	ldr	r2, [pc, #152]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2538:	6a13      	ldr	r3, [r2, #32]
    253a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    253e:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    2542:	6213      	str	r3, [r2, #32]
    2544:	e7d4      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    2546:	2910      	cmp	r1, #16
    2548:	d107      	bne.n	255a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    254a:	4a21      	ldr	r2, [pc, #132]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    254c:	6a13      	ldr	r3, [r2, #32]
    254e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2552:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    2556:	6213      	str	r3, [r2, #32]
    2558:	e7ca      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    255a:	2918      	cmp	r1, #24
    255c:	d107      	bne.n	256e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    255e:	4a1c      	ldr	r2, [pc, #112]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2560:	6a13      	ldr	r3, [r2, #32]
    2562:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2566:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    256a:	6213      	str	r3, [r2, #32]
    256c:	e7c0      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    256e:	2914      	cmp	r1, #20
    2570:	d107      	bne.n	2582 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    2572:	4a17      	ldr	r2, [pc, #92]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2574:	6a13      	ldr	r3, [r2, #32]
    2576:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    257a:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    257e:	6213      	str	r3, [r2, #32]
    2580:	e7b6      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2582:	291e      	cmp	r1, #30
    2584:	d107      	bne.n	2596 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    2586:	4a12      	ldr	r2, [pc, #72]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2588:	6a13      	ldr	r3, [r2, #32]
    258a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    258e:	f043 0304 	orr.w	r3, r3, #4
    2592:	6213      	str	r3, [r2, #32]
    2594:	e7ac      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2596:	2928      	cmp	r1, #40	; 0x28
    2598:	d107      	bne.n	25aa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    259a:	4a0d      	ldr	r2, [pc, #52]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    259c:	6a13      	ldr	r3, [r2, #32]
    259e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25a2:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    25a6:	6213      	str	r3, [r2, #32]
    25a8:	e7a2      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    25aa:	293c      	cmp	r1, #60	; 0x3c
    25ac:	d105      	bne.n	25ba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    25ae:	4a08      	ldr	r2, [pc, #32]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25b0:	6a13      	ldr	r3, [r2, #32]
    25b2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25b6:	6213      	str	r3, [r2, #32]
    25b8:	e79a      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    25ba:	2950      	cmp	r1, #80	; 0x50
    25bc:	d198      	bne.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    25be:	4a04      	ldr	r2, [pc, #16]	; (25d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25c0:	6a13      	ldr	r3, [r2, #32]
    25c2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25c6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    25ca:	6213      	str	r3, [r2, #32]
    25cc:	e790      	b.n	24f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    25ce:	bd70      	pop	{r4, r5, r6, pc}
    25d0:	400fc000 	.word	0x400fc000
    25d4:	20006870 	.word	0x20006870
    25d8:	401d4000 	.word	0x401d4000
    25dc:	20006874 	.word	0x20006874

000025e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    25e0:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    25e2:	494e      	ldr	r1, [pc, #312]	; (271c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    25e4:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    25e6:	4b4e      	ldr	r3, [pc, #312]	; (2720 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    25e8:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    25ea:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    25ec:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    25ee:	6a1b      	ldr	r3, [r3, #32]
    25f0:	f3c3 2301 	ubfx	r3, r3, #8, #2
    25f4:	3308      	adds	r3, #8
    25f6:	446b      	add	r3, sp
    25f8:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    25fc:	e9c0 2201 	strd	r2, r2, [r0, #4]
    2600:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2604:	2b00      	cmp	r3, #0
    2606:	f000 8085 	beq.w	2714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C0000;
    260a:	4945      	ldr	r1, [pc, #276]	; (2720 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN2;
    260c:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    2610:	2025      	movs	r0, #37	; 0x25
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    2612:	4b44      	ldr	r3, [pc, #272]	; (2724 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    2614:	4a44      	ldr	r2, [pc, #272]	; (2728 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 2;
    2616:	2402      	movs	r4, #2
    nvicIrq = IRQ_CAN2;
    2618:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    261c:	2601      	movs	r6, #1
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    261e:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    2622:	2010      	movs	r0, #16
    CCM_CCGR0 |= 0x3C0000;
    2624:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    2626:	4b41      	ldr	r3, [pc, #260]	; (272c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C0000;
    2628:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
    262c:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    262e:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 2;
    2632:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2636:	4a3e      	ldr	r2, [pc, #248]	; (2730 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    2638:	4c3e      	ldr	r4, [pc, #248]	; (2734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    263a:	f8c3 00c4 	str.w	r0, [r3, #196]	; 0xc4
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    263e:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    2642:	6526      	str	r6, [r4, #80]	; 0x50
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03 = 0x10; // pin 0 T4B1+B2
    2644:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03 = 0x10B0; // pin 0 T4B1+B2
    2648:	f8c3 12b8 	str.w	r1, [r3, #696]	; 0x2b8
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    264c:	6813      	ldr	r3, [r2, #0]
    264e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    2652:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2654:	6813      	ldr	r3, [r2, #0]
    2656:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    265a:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    265c:	6813      	ldr	r3, [r2, #0]
    265e:	01dc      	lsls	r4, r3, #7
    2660:	d5fc      	bpl.n	265c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2662:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2664:	4932      	ldr	r1, [pc, #200]	; (2730 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2666:	f043 0308 	orr.w	r3, r3, #8
    266a:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    266c:	6813      	ldr	r3, [r2, #0]
    266e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    2672:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2674:	680b      	ldr	r3, [r1, #0]
    2676:	02d8      	lsls	r0, r3, #11
    2678:	d4fc      	bmi.n	2674 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    267a:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    267c:	4a2c      	ldr	r2, [pc, #176]	; (2730 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    267e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    2682:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2684:	6813      	ldr	r3, [r2, #0]
    2686:	0199      	lsls	r1, r3, #6
    2688:	d4fc      	bmi.n	2684 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    268a:	4c29      	ldr	r4, [pc, #164]	; (2730 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    268c:	6823      	ldr	r3, [r4, #0]
    268e:	01da      	lsls	r2, r3, #7
    2690:	d5fc      	bpl.n	268c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    2692:	6823      	ldr	r3, [r4, #0]
    2694:	2000      	movs	r0, #0
    2696:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    269a:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    269c:	6823      	ldr	r3, [r4, #0]
    269e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    26a2:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    26a4:	6823      	ldr	r3, [r4, #0]
    26a6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    26aa:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    26ac:	6823      	ldr	r3, [r4, #0]
    26ae:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    26b2:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    26b4:	6823      	ldr	r3, [r4, #0]
    26b6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    26ba:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    26bc:	6823      	ldr	r3, [r4, #0]
    26be:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    26c2:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    26c4:	6823      	ldr	r3, [r4, #0]
    26c6:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    26ca:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    26cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
    26ce:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    26d2:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    26d4:	6823      	ldr	r3, [r4, #0]
    26d6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    26da:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    26dc:	6823      	ldr	r3, [r4, #0]
    26de:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    26e2:	6023      	str	r3, [r4, #0]
    26e4:	f7fe fd68 	bl	11b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    26e8:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    26ea:	4a11      	ldr	r2, [pc, #68]	; (2730 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    26ec:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    26f0:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    26f2:	6813      	ldr	r3, [r2, #0]
    26f4:	01db      	lsls	r3, r3, #7
    26f6:	d4fc      	bmi.n	26f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    26f8:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    26fc:	2101      	movs	r1, #1
    26fe:	4b0e      	ldr	r3, [pc, #56]	; (2738 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    2700:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2704:	f002 021f 	and.w	r2, r2, #31
    2708:	009b      	lsls	r3, r3, #2
    270a:	fa01 f202 	lsl.w	r2, r1, r2
    270e:	601a      	str	r2, [r3, #0]
}
    2710:	b002      	add	sp, #8
    2712:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2714:	2118      	movs	r1, #24
    2716:	f7ff fee1 	bl	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    271a:	e776      	b.n	260a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    271c:	0050183c 	.word	0x0050183c
    2720:	400fc000 	.word	0x400fc000
    2724:	20001000 	.word	0x20001000
    2728:	00000c69 	.word	0x00000c69
    272c:	401f8000 	.word	0x401f8000
    2730:	401d4000 	.word	0x401d4000
    2734:	401f8400 	.word	0x401f8400
    2738:	38003840 	.word	0x38003840

0000273c <canInit()>:
void canInit(void) {
    273c:	b538      	push	{r3, r4, r5, lr}
  HaldexCAN.begin();
    273e:	484a      	ldr	r0, [pc, #296]	; (2868 <canInit()+0x12c>)
    2740:	f7ff fe1e 	bl	2380 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2744:	4c49      	ldr	r4, [pc, #292]	; (286c <canInit()+0x130>)
  HaldexCAN.setClock(CLK_60MHz);
    2746:	213c      	movs	r1, #60	; 0x3c
    2748:	4847      	ldr	r0, [pc, #284]	; (2868 <canInit()+0x12c>)
    274a:	f7ff fd97 	bl	227c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  HaldexCAN.setBaudRate(500000);
    274e:	2200      	movs	r2, #0
    2750:	4947      	ldr	r1, [pc, #284]	; (2870 <canInit()+0x134>)
    2752:	4845      	ldr	r0, [pc, #276]	; (2868 <canInit()+0x12c>)
    2754:	f7fe fa92 	bl	c7c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    2758:	6823      	ldr	r3, [r4, #0]
    275a:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    275e:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2760:	6823      	ldr	r3, [r4, #0]
    2762:	01dd      	lsls	r5, r3, #7
    2764:	d5fc      	bpl.n	2760 <canInit()+0x24>
    2766:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    2768:	6825      	ldr	r5, [r4, #0]
    276a:	f7fe fc57 	bl	101c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    276e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2770:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    2772:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    2774:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    2776:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    2778:	6823      	ldr	r3, [r4, #0]
    277a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    277e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    2780:	6823      	ldr	r3, [r4, #0]
    2782:	f043 030f 	orr.w	r3, r3, #15
    2786:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    2788:	d469      	bmi.n	285e <canInit()+0x122>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    278a:	4c38      	ldr	r4, [pc, #224]	; (286c <canInit()+0x130>)
    278c:	6823      	ldr	r3, [r4, #0]
    278e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2792:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2794:	6823      	ldr	r3, [r4, #0]
    2796:	01d9      	lsls	r1, r3, #7
    2798:	d4fc      	bmi.n	2794 <canInit()+0x58>
  _mainHandler = handler;
    279a:	4b36      	ldr	r3, [pc, #216]	; (2874 <canInit()+0x138>)
  HaldexCAN.enableFIFO();
    279c:	2001      	movs	r0, #1
    279e:	4a36      	ldr	r2, [pc, #216]	; (2878 <canInit()+0x13c>)
    27a0:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    27a4:	f7fe fc3a 	bl	101c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    27a8:	6823      	ldr	r3, [r4, #0]
    27aa:	009a      	lsls	r2, r3, #2
    27ac:	d50a      	bpl.n	27c4 <canInit()+0x88>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    27ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    27b0:	069b      	lsls	r3, r3, #26
    27b2:	d407      	bmi.n	27c4 <canInit()+0x88>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    27b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    27b6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    27ba:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    27bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    27be:	f043 0320 	orr.w	r3, r3, #32
    27c2:	62a3      	str	r3, [r4, #40]	; 0x28
  HaldexCAN.mailboxStatus();
    27c4:	f7ff f990 	bl	1ae8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  ChassisCAN.begin();
    27c8:	482c      	ldr	r0, [pc, #176]	; (287c <canInit()+0x140>)
    27ca:	f7ff ff09 	bl	25e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    27ce:	4c2c      	ldr	r4, [pc, #176]	; (2880 <canInit()+0x144>)
  ChassisCAN.setClock(CLK_60MHz);
    27d0:	213c      	movs	r1, #60	; 0x3c
    27d2:	482a      	ldr	r0, [pc, #168]	; (287c <canInit()+0x140>)
    27d4:	f7ff fe82 	bl	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  ChassisCAN.setBaudRate(500000);
    27d8:	2200      	movs	r2, #0
    27da:	4925      	ldr	r1, [pc, #148]	; (2870 <canInit()+0x134>)
    27dc:	4827      	ldr	r0, [pc, #156]	; (287c <canInit()+0x140>)
    27de:	f7fe fb0b 	bl	df8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    27e2:	6823      	ldr	r3, [r4, #0]
    27e4:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    27e8:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    27ea:	6823      	ldr	r3, [r4, #0]
    27ec:	01dd      	lsls	r5, r3, #7
    27ee:	d5fc      	bpl.n	27ea <canInit()+0xae>
    27f0:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    27f2:	6825      	ldr	r5, [r4, #0]
    27f4:	f7fe fce0 	bl	11b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    27f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    27fa:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    27fc:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    27fe:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    2800:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    2802:	6823      	ldr	r3, [r4, #0]
    2804:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    2808:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    280a:	6823      	ldr	r3, [r4, #0]
    280c:	f043 030f 	orr.w	r3, r3, #15
    2810:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    2812:	d420      	bmi.n	2856 <canInit()+0x11a>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2814:	4c1a      	ldr	r4, [pc, #104]	; (2880 <canInit()+0x144>)
    2816:	6823      	ldr	r3, [r4, #0]
    2818:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    281c:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    281e:	6823      	ldr	r3, [r4, #0]
    2820:	01d9      	lsls	r1, r3, #7
    2822:	d4fc      	bmi.n	281e <canInit()+0xe2>
  _mainHandler = handler;
    2824:	4b17      	ldr	r3, [pc, #92]	; (2884 <canInit()+0x148>)
  ChassisCAN.enableFIFO();
    2826:	2001      	movs	r0, #1
    2828:	4a17      	ldr	r2, [pc, #92]	; (2888 <canInit()+0x14c>)
    282a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    282e:	f7fe fcc3 	bl	11b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    2832:	6823      	ldr	r3, [r4, #0]
    2834:	009a      	lsls	r2, r3, #2
    2836:	d50a      	bpl.n	284e <canInit()+0x112>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    2838:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    283a:	069b      	lsls	r3, r3, #26
    283c:	d407      	bmi.n	284e <canInit()+0x112>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    283e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2840:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2844:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2846:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2848:	f043 0320 	orr.w	r3, r3, #32
    284c:	62a3      	str	r3, [r4, #40]	; 0x28
}
    284e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ChassisCAN.mailboxStatus();
    2852:	f7fe bd7f 	b.w	1354 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  if ( fifo_was_cleared ) enableFIFO();
    2856:	2001      	movs	r0, #1
    2858:	f7fe fcae 	bl	11b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    285c:	e7da      	b.n	2814 <canInit()+0xd8>
    285e:	2001      	movs	r0, #1
    2860:	f7fe fbdc 	bl	101c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2864:	e791      	b.n	278a <canInit()+0x4e>
    2866:	bf00      	nop
    2868:	20003da0 	.word	0x20003da0
    286c:	401d0000 	.word	0x401d0000
    2870:	0007a120 	.word	0x0007a120
    2874:	20005da0 	.word	0x20005da0
    2878:	0000322d 	.word	0x0000322d
    287c:	20001488 	.word	0x20001488
    2880:	401d4000 	.word	0x401d4000
    2884:	20003488 	.word	0x20003488
    2888:	00002fd9 	.word	0x00002fd9

0000288c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
}
#endif


FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
  if ( mb_num == FIFO ) {
    288c:	780b      	ldrb	r3, [r1, #0]
    288e:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2890:	b510      	push	{r4, lr}
    2892:	4604      	mov	r4, r0
    2894:	b082      	sub	sp, #8
    2896:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2898:	d013      	beq.n	28c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    if ( _mainHandler ) _mainHandler(msg);
    return;
  }
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    289a:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    289e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    28a2:	685b      	ldr	r3, [r3, #4]
    28a4:	b113      	cbz	r3, 28ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    28a6:	9201      	str	r2, [sp, #4]
    28a8:	4798      	blx	r3
    28aa:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    28ac:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    28b0:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    28b4:	b11b      	cbz	r3, 28be <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    28b6:	b002      	add	sp, #8
    28b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    28bc:	4718      	bx	r3
}
    28be:	b002      	add	sp, #8
    28c0:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    28c2:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    28c6:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    28ca:	2b00      	cmp	r3, #0
    28cc:	d0f0      	beq.n	28b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    28ce:	9201      	str	r2, [sp, #4]
    28d0:	4798      	blx	r3
    28d2:	9801      	ldr	r0, [sp, #4]
    28d4:	e7ec      	b.n	28b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    28d6:	bf00      	nop

000028d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    28d8:	291f      	cmp	r1, #31
    28da:	481c      	ldr	r0, [pc, #112]	; (294c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    28dc:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    28de:	d823      	bhi.n	2928 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    28e0:	2301      	movs	r3, #1
    28e2:	6b04      	ldr	r4, [r0, #48]	; 0x30
    28e4:	408b      	lsls	r3, r1
    28e6:	4323      	orrs	r3, r4
    28e8:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    28ea:	4b19      	ldr	r3, [pc, #100]	; (2950 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    28ec:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    28f0:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    28f2:	440b      	add	r3, r1
    28f4:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    28f6:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    28f8:	b1f8      	cbz	r0, 293a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    28fa:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    28fc:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    28fe:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2900:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2904:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2908:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    290a:	68d0      	ldr	r0, [r2, #12]
}
    290c:	f85d 4b04 	ldr.w	r4, [sp], #4
    2910:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2912:	6098      	str	r0, [r3, #8]
    2914:	6910      	ldr	r0, [r2, #16]
    2916:	ba00      	rev	r0, r0
    2918:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    291a:	7ad2      	ldrb	r2, [r2, #11]
    291c:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2920:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2924:	601a      	str	r2, [r3, #0]
}
    2926:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2928:	f1a1 0c20 	sub.w	ip, r1, #32
    292c:	2301      	movs	r3, #1
    292e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2930:	fa03 f30c 	lsl.w	r3, r3, ip
    2934:	4323      	orrs	r3, r4
    2936:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2938:	e7d7      	b.n	28ea <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    293a:	6814      	ldr	r4, [r2, #0]
    293c:	4805      	ldr	r0, [pc, #20]	; (2954 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    293e:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2940:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2944:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2946:	6058      	str	r0, [r3, #4]
    2948:	e7df      	b.n	290a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    294a:	bf00      	nop
    294c:	401d0000 	.word	0x401d0000
    2950:	0401d008 	.word	0x0401d008
    2954:	1ffc0000 	.word	0x1ffc0000

00002958 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2958:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    295c:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2960:	b08f      	sub	sp, #60	; 0x3c
    2962:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2964:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2968:	b913      	cbnz	r3, 2970 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    296a:	2301      	movs	r3, #1
    296c:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        T readBytes(T *buffer, uint16_t length);
        void flush() { clear(); }
        void clear() { head = tail = _available = 0; }
        void print(const char *p);
        void println(const char *p);
        uint16_t size() { return _available; }
    2970:	8b23      	ldrh	r3, [r4, #24]
    2972:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2974:	2b00      	cmp	r3, #0
    2976:	d157      	bne.n	2a28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2978:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    297c:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2980:	4b72      	ldr	r3, [pc, #456]	; (2b4c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2982:	f002 011f 	and.w	r1, r2, #31
    2986:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    298a:	2201      	movs	r2, #1
    298c:	009b      	lsls	r3, r3, #2
    298e:	408a      	lsls	r2, r1
    2990:	601a      	str	r2, [r3, #0]
    2992:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2996:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2998:	b383      	cbz	r3, 29fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>


template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::peek_front(T *buffer, uint16_t length, uint32_t entry) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    299a:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    299e:	221a      	movs	r2, #26
    29a0:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    29a2:	f10d 0c08 	add.w	ip, sp, #8
    29a6:	f003 030f 	and.w	r3, r3, #15
    29aa:	46ae      	mov	lr, r5
    29ac:	fb02 4303 	mla	r3, r2, r3, r4
    29b0:	f641 3232 	movw	r2, #6962	; 0x1b32
    29b4:	eb03 0802 	add.w	r8, r3, r2
    29b8:	5898      	ldr	r0, [r3, r2]
    29ba:	f8d8 1004 	ldr.w	r1, [r8, #4]
    29be:	f8d8 2008 	ldr.w	r2, [r8, #8]
    29c2:	f8d8 300c 	ldr.w	r3, [r8, #12]
    29c6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    29c8:	f8d8 0010 	ldr.w	r0, [r8, #16]
    29cc:	f8d8 1014 	ldr.w	r1, [r8, #20]
    29d0:	c503      	stmia	r5!, {r0, r1}
    29d2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    29d6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    29da:	e89e 0003 	ldmia.w	lr, {r0, r1}
    29de:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    29e2:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    29e6:	1c4b      	adds	r3, r1, #1
    29e8:	d054      	beq.n	2a94 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    29ea:	4b59      	ldr	r3, [pc, #356]	; (2b50 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    29ec:	440b      	add	r3, r1
    29ee:	011b      	lsls	r3, r3, #4
    29f0:	681b      	ldr	r3, [r3, #0]
    29f2:	f3c3 6303 	ubfx	r3, r3, #24, #4
    29f6:	2b08      	cmp	r3, #8
    29f8:	f000 808b 	beq.w	2b12 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    29fc:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2a00:	4b54      	ldr	r3, [pc, #336]	; (2b54 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2a02:	f002 011f 	and.w	r1, r2, #31
    2a06:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2a0a:	2201      	movs	r2, #1
    2a0c:	009b      	lsls	r3, r3, #2
    2a0e:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2a10:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2a12:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2a14:	8b23      	ldrh	r3, [r4, #24]
    2a16:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2a1a:	b29b      	uxth	r3, r3
    2a1c:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2a1e:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2a22:	b00f      	add	sp, #60	; 0x3c
    2a24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
}

template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::readBytes(T *buffer, uint16_t length) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2a28:	8aa6      	ldrh	r6, [r4, #20]
    2a2a:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2a2c:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2a30:	ad08      	add	r5, sp, #32
    2a32:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2a34:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2a38:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2a3c:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2a40:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2a44:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2a48:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2a4c:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2a50:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2a52:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2a56:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2a5a:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2a5e:	8b23      	ldrh	r3, [r4, #24]
    2a60:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2a62:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2a64:	b11b      	cbz	r3, 2a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2a66:	8b23      	ldrh	r3, [r4, #24]
    2a68:	3b01      	subs	r3, #1
    2a6a:	b29b      	uxth	r3, r3
    2a6c:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2a6e:	ad08      	add	r5, sp, #32
    2a70:	ae02      	add	r6, sp, #8
    2a72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2a74:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2a76:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2a7a:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2a7c:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2a80:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2a84:	f10d 0107 	add.w	r1, sp, #7
    2a88:	4620      	mov	r0, r4
    2a8a:	f88d 3007 	strb.w	r3, [sp, #7]
    2a8e:	f7ff fefd 	bl	288c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    2a92:	e771      	b.n	2978 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2a94:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2b58 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2a98:	f8d8 5000 	ldr.w	r5, [r8]
    2a9c:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    2aa0:	d050      	beq.n	2b44 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    2aa2:	f7fe fa73 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2aa6:	f8d8 3000 	ldr.w	r3, [r8]
    2aaa:	4605      	mov	r5, r0
    2aac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2ab0:	3301      	adds	r3, #1
    2ab2:	4283      	cmp	r3, r0
    2ab4:	d9a2      	bls.n	29fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2ab6:	f8df 9098 	ldr.w	r9, [pc, #152]	; 2b50 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2aba:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2b58 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2abe:	e008      	b.n	2ad2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    2ac0:	f8d8 3000 	ldr.w	r3, [r8]
    2ac4:	3501      	adds	r5, #1
    2ac6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2aca:	b2ed      	uxtb	r5, r5
    2acc:	3301      	adds	r3, #1
    2ace:	429d      	cmp	r5, r3
    2ad0:	d294      	bcs.n	29fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2ad2:	eb05 0309 	add.w	r3, r5, r9
    2ad6:	011b      	lsls	r3, r3, #4
    2ad8:	681b      	ldr	r3, [r3, #0]
    2ada:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2ade:	2b08      	cmp	r3, #8
    2ae0:	d1ee      	bne.n	2ac0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    2ae2:	aa02      	add	r2, sp, #8
    2ae4:	4629      	mov	r1, r5
    2ae6:	4620      	mov	r0, r4
    2ae8:	f7ff fef6 	bl	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2aec:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2af0:	3301      	adds	r3, #1
    2af2:	f003 031f 	and.w	r3, r3, #31
    2af6:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2afa:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2afe:	b29b      	uxth	r3, r3
    2b00:	2b00      	cmp	r3, #0
    2b02:	d0dd      	beq.n	2ac0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    2b04:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2b08:	3b01      	subs	r3, #1
    2b0a:	b29b      	uxth	r3, r3
    2b0c:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2b10:	e7d6      	b.n	2ac0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    2b12:	aa02      	add	r2, sp, #8
    2b14:	b2c9      	uxtb	r1, r1
    2b16:	4620      	mov	r0, r4
    2b18:	f7ff fede 	bl	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2b1c:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2b20:	3301      	adds	r3, #1
    2b22:	f003 031f 	and.w	r3, r3, #31
    2b26:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2b2a:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2b2e:	b29b      	uxth	r3, r3
    2b30:	2b00      	cmp	r3, #0
    2b32:	f43f af63 	beq.w	29fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    2b36:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2b3a:	3b01      	subs	r3, #1
    2b3c:	b29b      	uxth	r3, r3
    2b3e:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2b42:	e75b      	b.n	29fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2b44:	f8d8 3000 	ldr.w	r3, [r8]
    2b48:	e7b5      	b.n	2ab6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    2b4a:	bf00      	nop
    2b4c:	38003860 	.word	0x38003860
    2b50:	0401d008 	.word	0x0401d008
    2b54:	38003840 	.word	0x38003840
    2b58:	401d0000 	.word	0x401d0000

00002b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
  if ( mb_num == FIFO ) {
    2b5c:	780b      	ldrb	r3, [r1, #0]
    2b5e:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2b60:	b510      	push	{r4, lr}
    2b62:	4604      	mov	r4, r0
    2b64:	b082      	sub	sp, #8
    2b66:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2b68:	d013      	beq.n	2b92 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2b6a:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    2b6e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2b72:	685b      	ldr	r3, [r3, #4]
    2b74:	b113      	cbz	r3, 2b7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2b76:	9201      	str	r2, [sp, #4]
    2b78:	4798      	blx	r3
    2b7a:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2b7c:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2b80:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2b84:	b11b      	cbz	r3, 2b8e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2b86:	b002      	add	sp, #8
    2b88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2b8c:	4718      	bx	r3
}
    2b8e:	b002      	add	sp, #8
    2b90:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    2b92:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2b96:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    2b9a:	2b00      	cmp	r3, #0
    2b9c:	d0f0      	beq.n	2b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2b9e:	9201      	str	r2, [sp, #4]
    2ba0:	4798      	blx	r3
    2ba2:	9801      	ldr	r0, [sp, #4]
    2ba4:	e7ec      	b.n	2b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2ba6:	bf00      	nop

00002ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2ba8:	291f      	cmp	r1, #31
    2baa:	481c      	ldr	r0, [pc, #112]	; (2c1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    2bac:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2bae:	d823      	bhi.n	2bf8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    2bb0:	2301      	movs	r3, #1
    2bb2:	6b04      	ldr	r4, [r0, #48]	; 0x30
    2bb4:	408b      	lsls	r3, r1
    2bb6:	4323      	orrs	r3, r4
    2bb8:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2bba:	4b19      	ldr	r3, [pc, #100]	; (2c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2bbc:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bc0:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2bc2:	440b      	add	r3, r1
    2bc4:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2bc6:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bc8:	b1f8      	cbz	r0, 2c0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    2bca:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bcc:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    2bce:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bd0:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2bd4:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bd8:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2bda:	68d0      	ldr	r0, [r2, #12]
}
    2bdc:	f85d 4b04 	ldr.w	r4, [sp], #4
    2be0:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2be2:	6098      	str	r0, [r3, #8]
    2be4:	6910      	ldr	r0, [r2, #16]
    2be6:	ba00      	rev	r0, r0
    2be8:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    2bea:	7ad2      	ldrb	r2, [r2, #11]
    2bec:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2bf0:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2bf4:	601a      	str	r2, [r3, #0]
}
    2bf6:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2bf8:	f1a1 0c20 	sub.w	ip, r1, #32
    2bfc:	2301      	movs	r3, #1
    2bfe:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2c00:	fa03 f30c 	lsl.w	r3, r3, ip
    2c04:	4323      	orrs	r3, r4
    2c06:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2c08:	e7d7      	b.n	2bba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2c0a:	6814      	ldr	r4, [r2, #0]
    2c0c:	4805      	ldr	r0, [pc, #20]	; (2c24 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    2c0e:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2c10:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2c14:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2c16:	6058      	str	r0, [r3, #4]
    2c18:	e7df      	b.n	2bda <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2c1a:	bf00      	nop
    2c1c:	401d4000 	.word	0x401d4000
    2c20:	0401d408 	.word	0x0401d408
    2c24:	1ffc0000 	.word	0x1ffc0000

00002c28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2c28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2c2c:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2c30:	b08f      	sub	sp, #60	; 0x3c
    2c32:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2c34:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2c38:	b913      	cbnz	r3, 2c40 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2c3a:	2301      	movs	r3, #1
    2c3c:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        uint16_t size() { return _available; }
    2c40:	8b23      	ldrh	r3, [r4, #24]
    2c42:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2c44:	2b00      	cmp	r3, #0
    2c46:	d157      	bne.n	2cf8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2c48:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2c4c:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2c50:	4b72      	ldr	r3, [pc, #456]	; (2e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2c52:	f002 011f 	and.w	r1, r2, #31
    2c56:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2c5a:	2201      	movs	r2, #1
    2c5c:	009b      	lsls	r3, r3, #2
    2c5e:	408a      	lsls	r2, r1
    2c60:	601a      	str	r2, [r3, #0]
    2c62:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2c66:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2c68:	b383      	cbz	r3, 2ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c6a:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2c6e:	221a      	movs	r2, #26
    2c70:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    2c72:	f10d 0c08 	add.w	ip, sp, #8
    2c76:	f003 030f 	and.w	r3, r3, #15
    2c7a:	46ae      	mov	lr, r5
    2c7c:	fb02 4303 	mla	r3, r2, r3, r4
    2c80:	f641 3232 	movw	r2, #6962	; 0x1b32
    2c84:	eb03 0802 	add.w	r8, r3, r2
    2c88:	5898      	ldr	r0, [r3, r2]
    2c8a:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2c8e:	f8d8 2008 	ldr.w	r2, [r8, #8]
    2c92:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2c96:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2c98:	f8d8 0010 	ldr.w	r0, [r8, #16]
    2c9c:	f8d8 1014 	ldr.w	r1, [r8, #20]
    2ca0:	c503      	stmia	r5!, {r0, r1}
    2ca2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2ca6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2caa:	e89e 0003 	ldmia.w	lr, {r0, r1}
    2cae:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    2cb2:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    2cb6:	1c4b      	adds	r3, r1, #1
    2cb8:	d054      	beq.n	2d64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2cba:	4b59      	ldr	r3, [pc, #356]	; (2e20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    2cbc:	440b      	add	r3, r1
    2cbe:	011b      	lsls	r3, r3, #4
    2cc0:	681b      	ldr	r3, [r3, #0]
    2cc2:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2cc6:	2b08      	cmp	r3, #8
    2cc8:	f000 808b 	beq.w	2de2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    2ccc:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2cd0:	4b54      	ldr	r3, [pc, #336]	; (2e24 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2cd2:	f002 011f 	and.w	r1, r2, #31
    2cd6:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2cda:	2201      	movs	r2, #1
    2cdc:	009b      	lsls	r3, r3, #2
    2cde:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2ce0:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2ce2:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2ce4:	8b23      	ldrh	r3, [r4, #24]
    2ce6:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2cea:	b29b      	uxth	r3, r3
    2cec:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2cee:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2cf2:	b00f      	add	sp, #60	; 0x3c
    2cf4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2cf8:	8aa6      	ldrh	r6, [r4, #20]
    2cfa:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2cfc:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2d00:	ad08      	add	r5, sp, #32
    2d02:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2d04:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2d08:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2d0c:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2d10:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2d14:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2d18:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2d1c:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2d20:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2d22:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2d26:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2d2a:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2d2e:	8b23      	ldrh	r3, [r4, #24]
    2d30:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2d32:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2d34:	b11b      	cbz	r3, 2d3e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2d36:	8b23      	ldrh	r3, [r4, #24]
    2d38:	3b01      	subs	r3, #1
    2d3a:	b29b      	uxth	r3, r3
    2d3c:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2d3e:	ad08      	add	r5, sp, #32
    2d40:	ae02      	add	r6, sp, #8
    2d42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d44:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2d46:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2d4a:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2d4c:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2d50:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2d54:	f10d 0107 	add.w	r1, sp, #7
    2d58:	4620      	mov	r0, r4
    2d5a:	f88d 3007 	strb.w	r3, [sp, #7]
    2d5e:	f7ff fefd 	bl	2b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    2d62:	e771      	b.n	2c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2d64:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2e28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2d68:	f8d8 5000 	ldr.w	r5, [r8]
    2d6c:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    2d70:	d050      	beq.n	2e14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    2d72:	f7fe f92f 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d76:	f8d8 3000 	ldr.w	r3, [r8]
    2d7a:	4605      	mov	r5, r0
    2d7c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2d80:	3301      	adds	r3, #1
    2d82:	4283      	cmp	r3, r0
    2d84:	d9a2      	bls.n	2ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2d86:	f8df 9098 	ldr.w	r9, [pc, #152]	; 2e20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d8a:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2e28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2d8e:	e008      	b.n	2da2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    2d90:	f8d8 3000 	ldr.w	r3, [r8]
    2d94:	3501      	adds	r5, #1
    2d96:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2d9a:	b2ed      	uxtb	r5, r5
    2d9c:	3301      	adds	r3, #1
    2d9e:	429d      	cmp	r5, r3
    2da0:	d294      	bcs.n	2ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2da2:	eb05 0309 	add.w	r3, r5, r9
    2da6:	011b      	lsls	r3, r3, #4
    2da8:	681b      	ldr	r3, [r3, #0]
    2daa:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2dae:	2b08      	cmp	r3, #8
    2db0:	d1ee      	bne.n	2d90 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    2db2:	aa02      	add	r2, sp, #8
    2db4:	4629      	mov	r1, r5
    2db6:	4620      	mov	r0, r4
    2db8:	f7ff fef6 	bl	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2dbc:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2dc0:	3301      	adds	r3, #1
    2dc2:	f003 031f 	and.w	r3, r3, #31
    2dc6:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2dca:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2dce:	b29b      	uxth	r3, r3
    2dd0:	2b00      	cmp	r3, #0
    2dd2:	d0dd      	beq.n	2d90 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    2dd4:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2dd8:	3b01      	subs	r3, #1
    2dda:	b29b      	uxth	r3, r3
    2ddc:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2de0:	e7d6      	b.n	2d90 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    2de2:	aa02      	add	r2, sp, #8
    2de4:	b2c9      	uxtb	r1, r1
    2de6:	4620      	mov	r0, r4
    2de8:	f7ff fede 	bl	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2dec:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2df0:	3301      	adds	r3, #1
    2df2:	f003 031f 	and.w	r3, r3, #31
    2df6:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2dfa:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2dfe:	b29b      	uxth	r3, r3
    2e00:	2b00      	cmp	r3, #0
    2e02:	f43f af63 	beq.w	2ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    2e06:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2e0a:	3b01      	subs	r3, #1
    2e0c:	b29b      	uxth	r3, r3
    2e0e:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2e12:	e75b      	b.n	2ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2e14:	f8d8 3000 	ldr.w	r3, [r8]
    2e18:	e7b5      	b.n	2d86 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    2e1a:	bf00      	nop
    2e1c:	38003860 	.word	0x38003860
    2e20:	0401d408 	.word	0x0401d408
    2e24:	38003840 	.word	0x38003840
    2e28:	401d4000 	.word	0x401d4000

00002e2c <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    2e2c:	8843      	ldrh	r3, [r0, #2]
    2e2e:	f04f 0c1a 	mov.w	ip, #26
    2e32:	f003 030f 	and.w	r3, r3, #15
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    2e36:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    2e38:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    2e3c:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    2e3e:	2000      	movs	r0, #0
    2e40:	7598      	strb	r0, [r3, #22]
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    2e42:	8863      	ldrh	r3, [r4, #2]
    2e44:	f003 030f 	and.w	r3, r3, #15
    2e48:	fb0c 4303 	mla	r3, ip, r3, r4
    2e4c:	75da      	strb	r2, [r3, #23]
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    2e4e:	8860      	ldrh	r0, [r4, #2]
    2e50:	f000 000f 	and.w	r0, r0, #15
    2e54:	fb0c 4000 	mla	r0, ip, r0, r4
    2e58:	3018      	adds	r0, #24
    2e5a:	f004 fd95 	bl	7988 <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    2e5e:	8862      	ldrh	r2, [r4, #2]
    2e60:	8823      	ldrh	r3, [r4, #0]
    2e62:	b292      	uxth	r2, r2
    2e64:	b29b      	uxth	r3, r3
    2e66:	f083 0310 	eor.w	r3, r3, #16
    2e6a:	429a      	cmp	r2, r3
    2e6c:	d104      	bne.n	2e78 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    2e6e:	8823      	ldrh	r3, [r4, #0]
    2e70:	3301      	adds	r3, #1
    2e72:	f003 031f 	and.w	r3, r3, #31
    2e76:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    2e78:	8863      	ldrh	r3, [r4, #2]
    2e7a:	3301      	adds	r3, #1
    2e7c:	f003 031f 	and.w	r3, r3, #31
    2e80:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    2e82:	88a3      	ldrh	r3, [r4, #4]
    2e84:	b29b      	uxth	r3, r3
    2e86:	2b0f      	cmp	r3, #15
    2e88:	d803      	bhi.n	2e92 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    2e8a:	88a3      	ldrh	r3, [r4, #4]
    2e8c:	3301      	adds	r3, #1
    2e8e:	b29b      	uxth	r3, r3
    2e90:	80a3      	strh	r3, [r4, #4]
}
    2e92:	bd10      	pop	{r4, pc}

00002e94 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    2e94:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    2e96:	b5f0      	push	{r4, r5, r6, r7, lr}
    2e98:	460d      	mov	r5, r1
    2e9a:	b08d      	sub	sp, #52	; 0x34
    2e9c:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2e9e:	4e4b      	ldr	r6, [pc, #300]	; (2fcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    2ea0:	2b00      	cmp	r3, #0
    2ea2:	d14c      	bne.n	2f3e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2ea4:	6833      	ldr	r3, [r6, #0]
    2ea6:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    2eaa:	d025      	beq.n	2ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    2eac:	f7fe f86e 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2eb0:	6833      	ldr	r3, [r6, #0]
    2eb2:	4684      	mov	ip, r0
    2eb4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2eb8:	3301      	adds	r3, #1
    2eba:	4298      	cmp	r0, r3
    2ebc:	d21e      	bcs.n	2efc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2ebe:	4944      	ldr	r1, [pc, #272]	; (2fd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2ec0:	4842      	ldr	r0, [pc, #264]	; (2fcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    2ec2:	e007      	b.n	2ed4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    2ec4:	6803      	ldr	r3, [r0, #0]
    2ec6:	fa5f fc82 	uxtb.w	ip, r2
    2eca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2ece:	3301      	adds	r3, #1
    2ed0:	459c      	cmp	ip, r3
    2ed2:	d213      	bcs.n	2efc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2ed4:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2ed8:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2edc:	011b      	lsls	r3, r3, #4
    2ede:	681b      	ldr	r3, [r3, #0]
    2ee0:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2ee4:	2b08      	cmp	r3, #8
    2ee6:	d1ed      	bne.n	2ec4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    2ee8:	4620      	mov	r0, r4
    2eea:	462a      	mov	r2, r5
    2eec:	4661      	mov	r1, ip
    2eee:	f7ff fcf3 	bl	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    2ef2:	2001      	movs	r0, #1
}
    2ef4:	b00d      	add	sp, #52	; 0x34
    2ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2ef8:	6833      	ldr	r3, [r6, #0]
    2efa:	e7e0      	b.n	2ebe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    2efc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2efe:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    2f00:	27ff      	movs	r7, #255	; 0xff
    2f02:	466e      	mov	r6, sp
    2f04:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    2f08:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2f0c:	e895 0003 	ldmia.w	r5, {r0, r1}
    2f10:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    2f14:	f88d 7014 	strb.w	r7, [sp, #20]
    2f18:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    2f1a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    2f1e:	e89c 0003 	ldmia.w	ip, {r0, r1}
    2f22:	e88e 0003 	stmia.w	lr, {r0, r1}
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    2f26:	2218      	movs	r2, #24
    2f28:	f641 301a 	movw	r0, #6938	; 0x1b1a
    2f2c:	eb0d 0102 	add.w	r1, sp, r2
    2f30:	4420      	add	r0, r4
    2f32:	f7ff ff7b 	bl	2e2c <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    2f36:	f04f 30ff 	mov.w	r0, #4294967295
}
    2f3a:	b00d      	add	sp, #52	; 0x34
    2f3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2f3e:	6830      	ldr	r0, [r6, #0]
    2f40:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    2f44:	d040      	beq.n	2fc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    2f46:	f7fe f821 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2f4a:	6833      	ldr	r3, [r6, #0]
    2f4c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2f50:	3301      	adds	r3, #1
    2f52:	4283      	cmp	r3, r0
    2f54:	d927      	bls.n	2fa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2f56:	491e      	ldr	r1, [pc, #120]	; (2fd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2f58:	4e1c      	ldr	r6, [pc, #112]	; (2fcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    2f5a:	e005      	b.n	2f68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    2f5c:	6833      	ldr	r3, [r6, #0]
    2f5e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2f62:	3301      	adds	r3, #1
    2f64:	4298      	cmp	r0, r3
    2f66:	d21e      	bcs.n	2fa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2f68:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2f6a:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2f6c:	4684      	mov	ip, r0
    2f6e:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2f70:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2f72:	681a      	ldr	r2, [r3, #0]
    2f74:	0112      	lsls	r2, r2, #4
    2f76:	d5f1      	bpl.n	2f5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2f78:	681b      	ldr	r3, [r3, #0]
    2f7a:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2f7e:	2b08      	cmp	r3, #8
    2f80:	d019      	beq.n	2fb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    2f82:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    2f84:	466f      	mov	r7, sp
    2f86:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    2f8a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2f8c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2f8e:	e895 0003 	ldmia.w	r5, {r0, r1}
    2f92:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    2f96:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    2f9a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    2f9c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    2fa0:	e896 0003 	ldmia.w	r6, {r0, r1}
    2fa4:	e7bd      	b.n	2f22 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2fa6:	4b0b      	ldr	r3, [pc, #44]	; (2fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    2fa8:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2fac:	681b      	ldr	r3, [r3, #0]
    2fae:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2fb2:	2b08      	cmp	r3, #8
    2fb4:	d1e5      	bne.n	2f82 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    2fb6:	4620      	mov	r0, r4
    2fb8:	462a      	mov	r2, r5
    2fba:	fa5f f18c 	uxtb.w	r1, ip
    2fbe:	f7ff fc8b 	bl	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    2fc2:	2001      	movs	r0, #1
}
    2fc4:	b00d      	add	sp, #52	; 0x34
    2fc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2fc8:	6833      	ldr	r3, [r6, #0]
    2fca:	e7c4      	b.n	2f56 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    2fcc:	401d0000 	.word	0x401d0000
    2fd0:	0401d008 	.word	0x0401d008
    2fd4:	401d0070 	.word	0x401d0070

00002fd8 <onBodyRX(CAN_message_t const&)>:
void onBodyRX(const CAN_message_t &frame) {
    2fd8:	b5f0      	push	{r4, r5, r6, r7, lr}
  CAN_message_t frame_out;
    2fda:	4c3b      	ldr	r4, [pc, #236]	; (30c8 <onBodyRX(CAN_message_t const&)+0xf0>)
void onBodyRX(const CAN_message_t &frame) {
    2fdc:	b087      	sub	sp, #28
  frame_out.len = frame.len;
    2fde:	7ac7      	ldrb	r7, [r0, #11]
void onBodyRX(const CAN_message_t &frame) {
    2fe0:	4605      	mov	r5, r0
  frame_out.id = frame.id;
    2fe2:	6806      	ldr	r6, [r0, #0]
  CAN_message_t frame_out;
    2fe4:	46ec      	mov	ip, sp
  frame_out.flags = frame.flags;
    2fe6:	f8d0 e007 	ldr.w	lr, [r0, #7]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    2fea:	2f08      	cmp	r7, #8
  CAN_message_t frame_out;
    2fec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2fee:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2ff2:	e894 0003 	ldmia.w	r4, {r0, r1}
  frame_out.flags = frame.flags;
    2ff6:	f8cd e007 	str.w	lr, [sp, #7]
  frame_out.id = frame.id;
    2ffa:	9600      	str	r6, [sp, #0]
  frame_out.len = frame.len;
    2ffc:	f88d 700b 	strb.w	r7, [sp, #11]
  CAN_message_t frame_out;
    3000:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3004:	d955      	bls.n	30b2 <onBodyRX(CAN_message_t const&)+0xda>
  switch (frame.id) {
    3006:	f5b6 7f20 	cmp.w	r6, #640	; 0x280
    300a:	d039      	beq.n	3080 <onBodyRX(CAN_message_t const&)+0xa8>
    300c:	f5b6 7f22 	cmp.w	r6, #648	; 0x288
    3010:	d10d      	bne.n	302e <onBodyRX(CAN_message_t const&)+0x56>
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    3012:	f44f 5248 	mov.w	r2, #12800	; 0x3200
    3016:	7beb      	ldrb	r3, [r5, #15]
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    3018:	492c      	ldr	r1, [pc, #176]	; (30cc <onBodyRX(CAN_message_t const&)+0xf4>)
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    301a:	fb02 f303 	mul.w	r3, r2, r3
    301e:	4a2c      	ldr	r2, [pc, #176]	; (30d0 <onBodyRX(CAN_message_t const&)+0xf8>)
    3020:	fba2 2303 	umull	r2, r3, r2, r3
    3024:	0b5b      	lsrs	r3, r3, #13
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    3026:	2bff      	cmp	r3, #255	; 0xff
    3028:	bfa8      	it	ge
    302a:	23ff      	movge	r3, #255	; 0xff
    302c:	700b      	strb	r3, [r1, #0]
  if (state.mode == MODE_STOCK) {
    302e:	4b29      	ldr	r3, [pc, #164]	; (30d4 <onBodyRX(CAN_message_t const&)+0xfc>)
    3030:	781b      	ldrb	r3, [r3, #0]
    3032:	2b00      	cmp	r3, #0
    3034:	d036      	beq.n	30a4 <onBodyRX(CAN_message_t const&)+0xcc>
  if (state.mode == MODE_FWD) {
    3036:	2b01      	cmp	r3, #1
    3038:	d00c      	beq.n	3054 <onBodyRX(CAN_message_t const&)+0x7c>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    303a:	3b02      	subs	r3, #2
    303c:	2b01      	cmp	r3, #1
    303e:	d802      	bhi.n	3046 <onBodyRX(CAN_message_t const&)+0x6e>
    getLockData(&frame_out);
    3040:	4668      	mov	r0, sp
    3042:	f7fd fd0f 	bl	a64 <getLockData(CAN_message_t*)>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    3046:	4669      	mov	r1, sp
    3048:	4823      	ldr	r0, [pc, #140]	; (30d8 <onBodyRX(CAN_message_t const&)+0x100>)
    304a:	f7ff ff23 	bl	2e94 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    304e:	b160      	cbz	r0, 306a <onBodyRX(CAN_message_t const&)+0x92>
}
    3050:	b007      	add	sp, #28
    3052:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memset(frame_out.buf, 0xFF, frame_out.len);
    3054:	21ff      	movs	r1, #255	; 0xff
    3056:	463a      	mov	r2, r7
    3058:	a803      	add	r0, sp, #12
    305a:	f004 fd11 	bl	7a80 <memset>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    305e:	4669      	mov	r1, sp
    3060:	481d      	ldr	r0, [pc, #116]	; (30d8 <onBodyRX(CAN_message_t const&)+0x100>)
    3062:	f7ff ff17 	bl	2e94 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3066:	2800      	cmp	r0, #0
    3068:	d1f2      	bne.n	3050 <onBodyRX(CAN_message_t const&)+0x78>
    306a:	2113      	movs	r1, #19
    306c:	481b      	ldr	r0, [pc, #108]	; (30dc <onBodyRX(CAN_message_t const&)+0x104>)
    306e:	f004 fa09 	bl	7484 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    3072:	481b      	ldr	r0, [pc, #108]	; (30e0 <onBodyRX(CAN_message_t const&)+0x108>)
    3074:	f002 fb4e 	bl	5714 <Print::println()>
    HaldexCAN.mailboxStatus();                 // print the mailbox status if there's a failure
    3078:	f7fe fd36 	bl	1ae8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    307c:	b007      	add	sp, #28
    307e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pedValue = frame.buf[5] * 0.4;
    3080:	7c6b      	ldrb	r3, [r5, #17]
    3082:	ee07 3a10 	vmov	s14, r3
    3086:	4b17      	ldr	r3, [pc, #92]	; (30e4 <onBodyRX(CAN_message_t const&)+0x10c>)
    3088:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 30c0 <onBodyRX(CAN_message_t const&)+0xe8>
    308c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    3090:	ee27 7b06 	vmul.f64	d7, d7, d6
    3094:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    3098:	ed83 7a00 	vstr	s14, [r3]
  if (state.mode == MODE_STOCK) {
    309c:	4b0d      	ldr	r3, [pc, #52]	; (30d4 <onBodyRX(CAN_message_t const&)+0xfc>)
    309e:	781b      	ldrb	r3, [r3, #0]
    30a0:	2b00      	cmp	r3, #0
    30a2:	d1c8      	bne.n	3036 <onBodyRX(CAN_message_t const&)+0x5e>
    memcpy(frame_out.buf, frame.buf, frame.len);
    30a4:	463a      	mov	r2, r7
    30a6:	f105 010c 	add.w	r1, r5, #12
    30aa:	a803      	add	r0, sp, #12
    30ac:	f002 fede 	bl	5e6c <memcpy>
  if (state.mode == MODE_FWD) {
    30b0:	e7c9      	b.n	3046 <onBodyRX(CAN_message_t const&)+0x6e>
    memcpy(frame_out.buf, frame.buf, frame.len);
    30b2:	463a      	mov	r2, r7
    30b4:	f105 010c 	add.w	r1, r5, #12
    30b8:	a803      	add	r0, sp, #12
    30ba:	f002 fed7 	bl	5e6c <memcpy>
    30be:	e7a2      	b.n	3006 <onBodyRX(CAN_message_t const&)+0x2e>
    30c0:	9999999a 	.word	0x9999999a
    30c4:	3fd99999 	.word	0x3fd99999
    30c8:	200002c0 	.word	0x200002c0
    30cc:	20006af3 	.word	0x20006af3
    30d0:	d1b71759 	.word	0xd1b71759
    30d4:	20006954 	.word	0x20006954
    30d8:	20003da0 	.word	0x20003da0
    30dc:	2000034c 	.word	0x2000034c
    30e0:	20000a68 	.word	0x20000a68
    30e4:	200068e4 	.word	0x200068e4

000030e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    30e8:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    30ea:	b5f0      	push	{r4, r5, r6, r7, lr}
    30ec:	460d      	mov	r5, r1
    30ee:	b08d      	sub	sp, #52	; 0x34
    30f0:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    30f2:	4e4b      	ldr	r6, [pc, #300]	; (3220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    30f4:	2b00      	cmp	r3, #0
    30f6:	d14c      	bne.n	3192 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    30f8:	6833      	ldr	r3, [r6, #0]
    30fa:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    30fe:	d025      	beq.n	314c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    3100:	f7fd ff68 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3104:	6833      	ldr	r3, [r6, #0]
    3106:	4684      	mov	ip, r0
    3108:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    310c:	3301      	adds	r3, #1
    310e:	4298      	cmp	r0, r3
    3110:	d21e      	bcs.n	3150 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3112:	4944      	ldr	r1, [pc, #272]	; (3224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3114:	4842      	ldr	r0, [pc, #264]	; (3220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    3116:	e007      	b.n	3128 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    3118:	6803      	ldr	r3, [r0, #0]
    311a:	fa5f fc82 	uxtb.w	ip, r2
    311e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3122:	3301      	adds	r3, #1
    3124:	459c      	cmp	ip, r3
    3126:	d213      	bcs.n	3150 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3128:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    312c:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3130:	011b      	lsls	r3, r3, #4
    3132:	681b      	ldr	r3, [r3, #0]
    3134:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3138:	2b08      	cmp	r3, #8
    313a:	d1ed      	bne.n	3118 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    313c:	4620      	mov	r0, r4
    313e:	462a      	mov	r2, r5
    3140:	4661      	mov	r1, ip
    3142:	f7ff fd31 	bl	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    3146:	2001      	movs	r0, #1
}
    3148:	b00d      	add	sp, #52	; 0x34
    314a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    314c:	6833      	ldr	r3, [r6, #0]
    314e:	e7e0      	b.n	3112 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    3150:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3152:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    3154:	27ff      	movs	r7, #255	; 0xff
    3156:	466e      	mov	r6, sp
    3158:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    315c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3160:	e895 0003 	ldmia.w	r5, {r0, r1}
    3164:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    3168:	f88d 7014 	strb.w	r7, [sp, #20]
    316c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    316e:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3172:	e89c 0003 	ldmia.w	ip, {r0, r1}
    3176:	e88e 0003 	stmia.w	lr, {r0, r1}
    317a:	2218      	movs	r2, #24
    317c:	f641 301a 	movw	r0, #6938	; 0x1b1a
    3180:	eb0d 0102 	add.w	r1, sp, r2
    3184:	4420      	add	r0, r4
    3186:	f7ff fe51 	bl	2e2c <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    318a:	f04f 30ff 	mov.w	r0, #4294967295
}
    318e:	b00d      	add	sp, #52	; 0x34
    3190:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3192:	6830      	ldr	r0, [r6, #0]
    3194:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    3198:	d040      	beq.n	321c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    319a:	f7fd ff1b 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    319e:	6833      	ldr	r3, [r6, #0]
    31a0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    31a4:	3301      	adds	r3, #1
    31a6:	4283      	cmp	r3, r0
    31a8:	d927      	bls.n	31fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31aa:	491e      	ldr	r1, [pc, #120]	; (3224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31ac:	4e1c      	ldr	r6, [pc, #112]	; (3220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    31ae:	e005      	b.n	31bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    31b0:	6833      	ldr	r3, [r6, #0]
    31b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    31b6:	3301      	adds	r3, #1
    31b8:	4298      	cmp	r0, r3
    31ba:	d21e      	bcs.n	31fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31bc:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31be:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31c0:	4684      	mov	ip, r0
    31c2:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31c4:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31c6:	681a      	ldr	r2, [r3, #0]
    31c8:	0112      	lsls	r2, r2, #4
    31ca:	d5f1      	bpl.n	31b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    31cc:	681b      	ldr	r3, [r3, #0]
    31ce:	f3c3 6303 	ubfx	r3, r3, #24, #4
    31d2:	2b08      	cmp	r3, #8
    31d4:	d019      	beq.n	320a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    31d6:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    31d8:	466f      	mov	r7, sp
    31da:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    31de:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    31e0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    31e2:	e895 0003 	ldmia.w	r5, {r0, r1}
    31e6:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    31ea:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    31ee:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    31f0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    31f4:	e896 0003 	ldmia.w	r6, {r0, r1}
    31f8:	e7bd      	b.n	3176 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    31fa:	4b0b      	ldr	r3, [pc, #44]	; (3228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    31fc:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3200:	681b      	ldr	r3, [r3, #0]
    3202:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3206:	2b08      	cmp	r3, #8
    3208:	d1e5      	bne.n	31d6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    320a:	4620      	mov	r0, r4
    320c:	462a      	mov	r2, r5
    320e:	fa5f f18c 	uxtb.w	r1, ip
    3212:	f7ff fcc9 	bl	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    3216:	2001      	movs	r0, #1
}
    3218:	b00d      	add	sp, #52	; 0x34
    321a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    321c:	6833      	ldr	r3, [r6, #0]
    321e:	e7c4      	b.n	31aa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    3220:	401d4000 	.word	0x401d4000
    3224:	0401d408 	.word	0x0401d408
    3228:	401d4070 	.word	0x401d4070

0000322c <onHaldexRX(CAN_message_t const&)>:
void onHaldexRX(const CAN_message_t &frame) {
    322c:	b570      	push	{r4, r5, r6, lr}
  haldexState = frame.buf[0];
    322e:	4b1d      	ldr	r3, [pc, #116]	; (32a4 <onHaldexRX(CAN_message_t const&)+0x78>)
void onHaldexRX(const CAN_message_t &frame) {
    3230:	b086      	sub	sp, #24
  haldexState = frame.buf[0];
    3232:	7b02      	ldrb	r2, [r0, #12]
void onHaldexRX(const CAN_message_t &frame) {
    3234:	4686      	mov	lr, r0
  CAN_message_t frame_out;
    3236:	4c1c      	ldr	r4, [pc, #112]	; (32a8 <onHaldexRX(CAN_message_t const&)+0x7c>)
    3238:	46ec      	mov	ip, sp
  haldexState = frame.buf[0];
    323a:	701a      	strb	r2, [r3, #0]
  haldexEngagement = frame.buf[1];
    323c:	4b1b      	ldr	r3, [pc, #108]	; (32ac <onHaldexRX(CAN_message_t const&)+0x80>)
    323e:	7b42      	ldrb	r2, [r0, #13]
  frame_out.len = frame.len;
    3240:	7ac5      	ldrb	r5, [r0, #11]
  frame_out.flags = frame.flags;
    3242:	f8d0 6007 	ldr.w	r6, [r0, #7]
  haldexEngagement = frame.buf[1];
    3246:	701a      	strb	r2, [r3, #0]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3248:	2d08      	cmp	r5, #8
  CAN_message_t frame_out;
    324a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    324c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  frame_out.id = frame.id;
    3250:	f8de 3000 	ldr.w	r3, [lr]
  frame_out.flags = frame.flags;
    3254:	f8cd 6007 	str.w	r6, [sp, #7]
  frame_out.id = frame.id;
    3258:	9300      	str	r3, [sp, #0]
  frame_out.len = frame.len;
    325a:	f88d 500b 	strb.w	r5, [sp, #11]
  CAN_message_t frame_out;
    325e:	e894 0003 	ldmia.w	r4, {r0, r1}
    3262:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3266:	d906      	bls.n	3276 <onHaldexRX(CAN_message_t const&)+0x4a>
  if (!ChassisCAN.write(frame_out)) {
    3268:	4669      	mov	r1, sp
    326a:	4811      	ldr	r0, [pc, #68]	; (32b0 <onHaldexRX(CAN_message_t const&)+0x84>)
    326c:	f7ff ff3c 	bl	30e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3270:	b168      	cbz	r0, 328e <onHaldexRX(CAN_message_t const&)+0x62>
}
    3272:	b006      	add	sp, #24
    3274:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(frame_out.buf, frame.buf, frame.len);
    3276:	f10e 010c 	add.w	r1, lr, #12
    327a:	462a      	mov	r2, r5
    327c:	a803      	add	r0, sp, #12
    327e:	f002 fdf5 	bl	5e6c <memcpy>
  if (!ChassisCAN.write(frame_out)) {
    3282:	4669      	mov	r1, sp
    3284:	480a      	ldr	r0, [pc, #40]	; (32b0 <onHaldexRX(CAN_message_t const&)+0x84>)
    3286:	f7ff ff2f 	bl	30e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    328a:	2800      	cmp	r0, #0
    328c:	d1f1      	bne.n	3272 <onHaldexRX(CAN_message_t const&)+0x46>
    328e:	2111      	movs	r1, #17
    3290:	4808      	ldr	r0, [pc, #32]	; (32b4 <onHaldexRX(CAN_message_t const&)+0x88>)
    3292:	f004 f8f7 	bl	7484 <usb_serial_write>
    3296:	4808      	ldr	r0, [pc, #32]	; (32b8 <onHaldexRX(CAN_message_t const&)+0x8c>)
    3298:	f002 fa3c 	bl	5714 <Print::println()>
    ChassisCAN.mailboxStatus();
    329c:	f7fe f85a 	bl	1354 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    32a0:	b006      	add	sp, #24
    32a2:	bd70      	pop	{r4, r5, r6, pc}
    32a4:	20006ae4 	.word	0x20006ae4
    32a8:	200002c0 	.word	0x200002c0
    32ac:	20006ae3 	.word	0x20006ae3
    32b0:	20001488 	.word	0x20001488
    32b4:	200002ec 	.word	0x200002ec
    32b8:	20000a68 	.word	0x20000a68

000032bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( mb_num == FIFO ) fifo_filter_table[0][0] |= (1UL << 28); /* enable fifo enhancement */
  else mb_filter_table[mb_num][0] |= (1UL << 28); /* enable mb enhancement */
}

FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    32bc:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    32c0:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    32c4:	00db      	lsls	r3, r3, #3
    32c6:	d569      	bpl.n	339c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32c8:	4b37      	ldr	r3, [pc, #220]	; (33a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    32ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32ce:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    32d0:	f04f 0e00 	mov.w	lr, #0
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    }
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    32d4:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    32d8:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32dc:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    32e0:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32e4:	00f6      	lsls	r6, r6, #3
    32e6:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    32e8:	e009      	b.n	32fe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    32ea:	6813      	ldr	r3, [r2, #0]
    32ec:	0f5b      	lsrs	r3, r3, #29
    32ee:	2b05      	cmp	r3, #5
    32f0:	d034      	beq.n	335c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    32f2:	f10e 0e01 	add.w	lr, lr, #1
    32f6:	fa5f f38e 	uxtb.w	r3, lr
    32fa:	429e      	cmp	r6, r3
    32fc:	d950      	bls.n	33a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    32fe:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    3302:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    3306:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    330a:	6813      	ldr	r3, [r2, #0]
    330c:	0f5b      	lsrs	r3, r3, #29
    330e:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3310:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3312:	d00d      	beq.n	3330 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3314:	0f5b      	lsrs	r3, r3, #29
    3316:	2b02      	cmp	r3, #2
    3318:	d1e7      	bne.n	32ea <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    331a:	f85c 3007 	ldr.w	r3, [ip, r7]
    331e:	428b      	cmp	r3, r1
    3320:	d8e7      	bhi.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3322:	f85c 3008 	ldr.w	r3, [ip, r8]
    3326:	428b      	cmp	r3, r1
    3328:	d3e3      	bcc.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    332a:	2001      	movs	r0, #1
      }
    }
  }
  return 0;
}
    332c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3330:	f413 7f60 	tst.w	r3, #896	; 0x380
    3334:	d0dd      	beq.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3336:	006d      	lsls	r5, r5, #1
    3338:	2300      	movs	r3, #0
    333a:	e004      	b.n	3346 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    333c:	6814      	ldr	r4, [r2, #0]
    333e:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3342:	4563      	cmp	r3, ip
    3344:	d2d5      	bcs.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3346:	3301      	adds	r3, #1
    3348:	eb05 0c03 	add.w	ip, r5, r3
    334c:	b2db      	uxtb	r3, r3
    334e:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    3352:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3356:	428c      	cmp	r4, r1
    3358:	d1f0      	bne.n	333c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    335a:	e7e6      	b.n	332a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    335c:	6813      	ldr	r3, [r2, #0]
    335e:	f413 7f60 	tst.w	r3, #896	; 0x380
    3362:	d0c6      	beq.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3364:	44cc      	add	ip, r9
    3366:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3368:	2401      	movs	r4, #1
    336a:	e005      	b.n	3378 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    336c:	6813      	ldr	r3, [r2, #0]
    336e:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    3372:	3301      	adds	r3, #1
    3374:	429c      	cmp	r4, r3
    3376:	d2bc      	bcs.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3378:	192b      	adds	r3, r5, r4
    337a:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    337e:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3380:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    3384:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3388:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    338a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    338e:	f8dc b000 	ldr.w	fp, [ip]
    3392:	ea03 030b 	and.w	r3, r3, fp
    3396:	459a      	cmp	sl, r3
    3398:	d1e8      	bne.n	336c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    339a:	e7c6      	b.n	332a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    339c:	2001      	movs	r0, #1
}
    339e:	4770      	bx	lr
  return 0;
    33a0:	2000      	movs	r0, #0
}
    33a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    33a6:	bf00      	nop
    33a8:	401d4000 	.word	0x401d4000

000033ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:

FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    33ac:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    33b0:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    33b2:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    33b6:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    33ba:	f8de 3000 	ldr.w	r3, [lr]
    33be:	00db      	lsls	r3, r3, #3
    33c0:	d528      	bpl.n	3414 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    33c2:	f8de 3000 	ldr.w	r3, [lr]
    33c6:	0f5b      	lsrs	r3, r3, #29
    33c8:	2b01      	cmp	r3, #1
    33ca:	d00b      	beq.n	33e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    33cc:	f8de 3000 	ldr.w	r3, [lr]
    33d0:	0f5b      	lsrs	r3, r3, #29
    33d2:	2b02      	cmp	r3, #2
    33d4:	d042      	beq.n	345c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    33d6:	f8de 3000 	ldr.w	r3, [lr]
    33da:	0f5b      	lsrs	r3, r3, #29
    33dc:	2b05      	cmp	r3, #5
    33de:	d01b      	beq.n	3418 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    }
  }
  return 0;
    33e0:	2000      	movs	r0, #0
}
    33e2:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    33e4:	f8de 4000 	ldr.w	r4, [lr]
    33e8:	f414 7f60 	tst.w	r4, #896	; 0x380
    33ec:	d0f8      	beq.n	33e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    33ee:	2300      	movs	r3, #0
    33f0:	004d      	lsls	r5, r1, #1
    33f2:	e005      	b.n	3400 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    33f4:	f8de 1000 	ldr.w	r1, [lr]
    33f8:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    33fc:	4563      	cmp	r3, ip
    33fe:	d2ef      	bcs.n	33e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3400:	3301      	adds	r3, #1
    3402:	eb05 0c03 	add.w	ip, r5, r3
    3406:	b2db      	uxtb	r3, r3
    3408:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    340c:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3410:	4294      	cmp	r4, r2
    3412:	d1ef      	bne.n	33f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3414:	2001      	movs	r0, #1
}
    3416:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3418:	f8de 5000 	ldr.w	r5, [lr]
    341c:	f415 7f60 	tst.w	r5, #896	; 0x380
    3420:	d0de      	beq.n	33e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3422:	f242 1514 	movw	r5, #8468	; 0x2114
    3426:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3428:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    342a:	4425      	add	r5, r4
    342c:	e007      	b.n	343e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    342e:	f8de 4000 	ldr.w	r4, [lr]
    3432:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3436:	f10c 0c01 	add.w	ip, ip, #1
    343a:	4563      	cmp	r3, ip
    343c:	d2d0      	bcs.n	33e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    343e:	682c      	ldr	r4, [r5, #0]
    3440:	ea04 0c02 	and.w	ip, r4, r2
    3444:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3446:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3448:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    344c:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    344e:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    3452:	682e      	ldr	r6, [r5, #0]
    3454:	4034      	ands	r4, r6
    3456:	45a4      	cmp	ip, r4
    3458:	d1e9      	bne.n	342e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    345a:	e7db      	b.n	3414 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    345c:	f242 1304 	movw	r3, #8452	; 0x2104
    3460:	58e3      	ldr	r3, [r4, r3]
    3462:	4293      	cmp	r3, r2
    3464:	d8bc      	bhi.n	33e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3466:	f242 1308 	movw	r3, #8456	; 0x2108
    346a:	58e0      	ldr	r0, [r4, r3]
    346c:	4290      	cmp	r0, r2
    346e:	bf34      	ite	cc
    3470:	2000      	movcc	r0, #0
    3472:	2001      	movcs	r0, #1
}
    3474:	bd70      	pop	{r4, r5, r6, pc}
    3476:	bf00      	nop

00003478 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>:
  if ( _available < _size ) _available++;
    3478:	8883      	ldrh	r3, [r0, #4]
    347a:	b29b      	uxth	r3, r3
    347c:	2b0f      	cmp	r3, #15
    347e:	d803      	bhi.n	3488 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x10>
    3480:	8883      	ldrh	r3, [r0, #4]
    3482:	3301      	adds	r3, #1
    3484:	b29b      	uxth	r3, r3
    3486:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    3488:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    348a:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    348e:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    3490:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3494:	fa1f fc8c 	uxth.w	ip, ip
    3498:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    349a:	3202      	adds	r2, #2
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    349c:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    34a0:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34a4:	459c      	cmp	ip, r3
    34a6:	d104      	bne.n	34b2 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x3a>
    34a8:	8803      	ldrh	r3, [r0, #0]
    34aa:	3301      	adds	r3, #1
    34ac:	f003 031f 	and.w	r3, r3, #31
    34b0:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    34b2:	8843      	ldrh	r3, [r0, #2]
    34b4:	3301      	adds	r3, #1
    34b6:	f003 031f 	and.w	r3, r3, #31
    34ba:	8043      	strh	r3, [r0, #2]
}
    34bc:	4770      	bx	lr
    34be:	bf00      	nop

000034c0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>:
  if ( _available < _size ) _available++;
    34c0:	8883      	ldrh	r3, [r0, #4]
    34c2:	b29b      	uxth	r3, r3
    34c4:	2b0f      	cmp	r3, #15
    34c6:	d803      	bhi.n	34d0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x10>
    34c8:	8883      	ldrh	r3, [r0, #4]
    34ca:	3301      	adds	r3, #1
    34cc:	b29b      	uxth	r3, r3
    34ce:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    34d0:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34d2:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    34d6:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    34d8:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34dc:	fa1f fc8c 	uxth.w	ip, ip
    34e0:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    34e2:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34e6:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    34ea:	80d1      	strh	r1, [r2, #6]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34ec:	459c      	cmp	ip, r3
    34ee:	d104      	bne.n	34fa <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x3a>
    34f0:	8803      	ldrh	r3, [r0, #0]
    34f2:	3301      	adds	r3, #1
    34f4:	f003 031f 	and.w	r3, r3, #31
    34f8:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    34fa:	8843      	ldrh	r3, [r0, #2]
    34fc:	3301      	adds	r3, #1
    34fe:	f003 031f 	and.w	r3, r3, #31
    3502:	8043      	strh	r3, [r0, #2]
}
    3504:	4770      	bx	lr
    3506:	bf00      	nop

00003508 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3508:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    350c:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    3510:	00db      	lsls	r3, r3, #3
    3512:	d569      	bpl.n	35e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3514:	4b37      	ldr	r3, [pc, #220]	; (35f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    3516:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    351a:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    351c:	f04f 0e00 	mov.w	lr, #0
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3520:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3524:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3528:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    352c:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3530:	00f6      	lsls	r6, r6, #3
    3532:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3534:	e009      	b.n	354a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    3536:	6813      	ldr	r3, [r2, #0]
    3538:	0f5b      	lsrs	r3, r3, #29
    353a:	2b05      	cmp	r3, #5
    353c:	d034      	beq.n	35a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    353e:	f10e 0e01 	add.w	lr, lr, #1
    3542:	fa5f f38e 	uxtb.w	r3, lr
    3546:	429e      	cmp	r6, r3
    3548:	d950      	bls.n	35ec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    354a:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    354e:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    3552:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    3556:	6813      	ldr	r3, [r2, #0]
    3558:	0f5b      	lsrs	r3, r3, #29
    355a:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    355c:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    355e:	d00d      	beq.n	357c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3560:	0f5b      	lsrs	r3, r3, #29
    3562:	2b02      	cmp	r3, #2
    3564:	d1e7      	bne.n	3536 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3566:	f85c 3007 	ldr.w	r3, [ip, r7]
    356a:	428b      	cmp	r3, r1
    356c:	d8e7      	bhi.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    356e:	f85c 3008 	ldr.w	r3, [ip, r8]
    3572:	428b      	cmp	r3, r1
    3574:	d3e3      	bcc.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3576:	2001      	movs	r0, #1
}
    3578:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    357c:	f413 7f60 	tst.w	r3, #896	; 0x380
    3580:	d0dd      	beq.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3582:	006d      	lsls	r5, r5, #1
    3584:	2300      	movs	r3, #0
    3586:	e004      	b.n	3592 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    3588:	6814      	ldr	r4, [r2, #0]
    358a:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    358e:	4563      	cmp	r3, ip
    3590:	d2d5      	bcs.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3592:	3301      	adds	r3, #1
    3594:	eb05 0c03 	add.w	ip, r5, r3
    3598:	b2db      	uxtb	r3, r3
    359a:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    359e:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    35a2:	428c      	cmp	r4, r1
    35a4:	d1f0      	bne.n	3588 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    35a6:	e7e6      	b.n	3576 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35a8:	6813      	ldr	r3, [r2, #0]
    35aa:	f413 7f60 	tst.w	r3, #896	; 0x380
    35ae:	d0c6      	beq.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35b0:	44cc      	add	ip, r9
    35b2:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35b4:	2401      	movs	r4, #1
    35b6:	e005      	b.n	35c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    35b8:	6813      	ldr	r3, [r2, #0]
    35ba:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    35be:	3301      	adds	r3, #1
    35c0:	429c      	cmp	r4, r3
    35c2:	d2bc      	bcs.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35c4:	192b      	adds	r3, r5, r4
    35c6:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35ca:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35cc:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    35d0:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35d4:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35d6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    35da:	f8dc b000 	ldr.w	fp, [ip]
    35de:	ea03 030b 	and.w	r3, r3, fp
    35e2:	459a      	cmp	sl, r3
    35e4:	d1e8      	bne.n	35b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    35e6:	e7c6      	b.n	3576 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    35e8:	2001      	movs	r0, #1
}
    35ea:	4770      	bx	lr
  return 0;
    35ec:	2000      	movs	r0, #0
}
    35ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    35f2:	bf00      	nop
    35f4:	401d0000 	.word	0x401d0000

000035f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    35f8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    35fc:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    35fe:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    3602:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    3606:	f8de 3000 	ldr.w	r3, [lr]
    360a:	00db      	lsls	r3, r3, #3
    360c:	d528      	bpl.n	3660 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    360e:	f8de 3000 	ldr.w	r3, [lr]
    3612:	0f5b      	lsrs	r3, r3, #29
    3614:	2b01      	cmp	r3, #1
    3616:	d00b      	beq.n	3630 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3618:	f8de 3000 	ldr.w	r3, [lr]
    361c:	0f5b      	lsrs	r3, r3, #29
    361e:	2b02      	cmp	r3, #2
    3620:	d042      	beq.n	36a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    3622:	f8de 3000 	ldr.w	r3, [lr]
    3626:	0f5b      	lsrs	r3, r3, #29
    3628:	2b05      	cmp	r3, #5
    362a:	d01b      	beq.n	3664 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
  return 0;
    362c:	2000      	movs	r0, #0
}
    362e:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    3630:	f8de 4000 	ldr.w	r4, [lr]
    3634:	f414 7f60 	tst.w	r4, #896	; 0x380
    3638:	d0f8      	beq.n	362c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    363a:	2300      	movs	r3, #0
    363c:	004d      	lsls	r5, r1, #1
    363e:	e005      	b.n	364c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    3640:	f8de 1000 	ldr.w	r1, [lr]
    3644:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    3648:	4563      	cmp	r3, ip
    364a:	d2ef      	bcs.n	362c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    364c:	3301      	adds	r3, #1
    364e:	eb05 0c03 	add.w	ip, r5, r3
    3652:	b2db      	uxtb	r3, r3
    3654:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    3658:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    365c:	4294      	cmp	r4, r2
    365e:	d1ef      	bne.n	3640 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3660:	2001      	movs	r0, #1
}
    3662:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3664:	f8de 5000 	ldr.w	r5, [lr]
    3668:	f415 7f60 	tst.w	r5, #896	; 0x380
    366c:	d0de      	beq.n	362c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    366e:	f242 1514 	movw	r5, #8468	; 0x2114
    3672:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3674:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3676:	4425      	add	r5, r4
    3678:	e007      	b.n	368a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    367a:	f8de 4000 	ldr.w	r4, [lr]
    367e:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3682:	f10c 0c01 	add.w	ip, ip, #1
    3686:	4563      	cmp	r3, ip
    3688:	d2d0      	bcs.n	362c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    368a:	682c      	ldr	r4, [r5, #0]
    368c:	ea04 0c02 	and.w	ip, r4, r2
    3690:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3692:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3694:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3698:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    369a:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    369e:	682e      	ldr	r6, [r5, #0]
    36a0:	4034      	ands	r4, r6
    36a2:	45a4      	cmp	ip, r4
    36a4:	d1e9      	bne.n	367a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    36a6:	e7db      	b.n	3660 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    36a8:	f242 1304 	movw	r3, #8452	; 0x2104
    36ac:	58e3      	ldr	r3, [r4, r3]
    36ae:	4293      	cmp	r3, r2
    36b0:	d8bc      	bhi.n	362c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    36b2:	f242 1308 	movw	r3, #8456	; 0x2108
    36b6:	58e0      	ldr	r0, [r4, r3]
    36b8:	4290      	cmp	r0, r2
    36ba:	bf34      	ite	cc
    36bc:	2000      	movcc	r0, #0
    36be:	2001      	movcs	r0, #1
}
    36c0:	bd70      	pop	{r4, r5, r6, pc}
    36c2:	bf00      	nop

000036c4 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    36c4:	8843      	ldrh	r3, [r0, #2]
    36c6:	f04f 0c1a 	mov.w	ip, #26
    36ca:	b2db      	uxtb	r3, r3
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    36cc:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    36ce:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    36d2:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    36d4:	2000      	movs	r0, #0
    36d6:	f883 0106 	strb.w	r0, [r3, #262]	; 0x106
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    36da:	8863      	ldrh	r3, [r4, #2]
    36dc:	b2db      	uxtb	r3, r3
    36de:	fb0c 4303 	mla	r3, ip, r3, r4
    36e2:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    36e6:	8860      	ldrh	r0, [r4, #2]
    36e8:	b2c0      	uxtb	r0, r0
    36ea:	fb0c 4000 	mla	r0, ip, r0, r4
    36ee:	f500 7084 	add.w	r0, r0, #264	; 0x108
    36f2:	f004 f949 	bl	7988 <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    36f6:	8862      	ldrh	r2, [r4, #2]
    36f8:	8823      	ldrh	r3, [r4, #0]
    36fa:	b292      	uxth	r2, r2
    36fc:	b29b      	uxth	r3, r3
    36fe:	f483 7380 	eor.w	r3, r3, #256	; 0x100
    3702:	429a      	cmp	r2, r3
    3704:	d104      	bne.n	3710 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    3706:	8823      	ldrh	r3, [r4, #0]
    3708:	3301      	adds	r3, #1
    370a:	f3c3 0308 	ubfx	r3, r3, #0, #9
    370e:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    3710:	8863      	ldrh	r3, [r4, #2]
    3712:	3301      	adds	r3, #1
    3714:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3718:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    371a:	88a3      	ldrh	r3, [r4, #4]
    371c:	b29b      	uxth	r3, r3
    371e:	2bff      	cmp	r3, #255	; 0xff
    3720:	d803      	bhi.n	372a <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    3722:	88a3      	ldrh	r3, [r4, #4]
    3724:	3301      	adds	r3, #1
    3726:	b29b      	uxth	r3, r3
    3728:	80a3      	strh	r3, [r4, #4]
}
    372a:	bd10      	pop	{r4, pc}

0000372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    372c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    3730:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    3732:	b08d      	sub	sp, #52	; 0x34
    3734:	460e      	mov	r6, r1
    3736:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    3738:	466c      	mov	r4, sp
    373a:	4605      	mov	r5, r0
    373c:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3740:	f04f 0901 	mov.w	r9, #1
    3744:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 37e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    3748:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    374c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    374e:	e89c 0003 	ldmia.w	ip, {r0, r1}
    3752:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    3756:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    375a:	b15c      	cbz	r4, 3774 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    375c:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    3760:	68a3      	ldr	r3, [r4, #8]
    3762:	fa09 f102 	lsl.w	r1, r9, r2
    3766:	4219      	tst	r1, r3
    3768:	d023      	beq.n	37b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    376a:	6823      	ldr	r3, [r4, #0]
    376c:	f8d3 b000 	ldr.w	fp, [r3]
    3770:	45d3      	cmp	fp, sl
    3772:	d119      	bne.n	37a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    3774:	4545      	cmp	r5, r8
    3776:	d1ee      	bne.n	3756 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    3778:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    377c:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    3780:	b33b      	cbz	r3, 37d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    3782:	6830      	ldr	r0, [r6, #0]
    3784:	ac06      	add	r4, sp, #24
    3786:	6871      	ldr	r1, [r6, #4]
    3788:	68b2      	ldr	r2, [r6, #8]
    378a:	68f3      	ldr	r3, [r6, #12]
    378c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    378e:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    3790:	2218      	movs	r2, #24
    3792:	6971      	ldr	r1, [r6, #20]
    3794:	c403      	stmia	r4!, {r0, r1}
    3796:	eb0d 0102 	add.w	r1, sp, r2
    379a:	f107 0014 	add.w	r0, r7, #20
    379e:	f7ff ff91 	bl	36c4 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    37a2:	b00d      	add	sp, #52	; 0x34
    37a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    37a8:	f89d 3015 	ldrb.w	r3, [sp, #21]
    37ac:	4669      	mov	r1, sp
    37ae:	4620      	mov	r0, r4
    37b0:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    37b2:	7c23      	ldrb	r3, [r4, #16]
    37b4:	2b00      	cmp	r3, #0
    37b6:	d0dd      	beq.n	3774 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    37b8:	6823      	ldr	r3, [r4, #0]
    37ba:	f8d3 b000 	ldr.w	fp, [r3]
    37be:	f89d 3015 	ldrb.w	r3, [sp, #21]
    37c2:	45d3      	cmp	fp, sl
    37c4:	d0d6      	beq.n	3774 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    37c6:	4620      	mov	r0, r4
    37c8:	f04f 32ff 	mov.w	r2, #4294967295
    37cc:	4669      	mov	r1, sp
    37ce:	47d8      	blx	fp
    37d0:	e7d0      	b.n	3774 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    37d2:	7d33      	ldrb	r3, [r6, #20]
    37d4:	4632      	mov	r2, r6
    37d6:	a906      	add	r1, sp, #24
    37d8:	4638      	mov	r0, r7
    37da:	f88d 3018 	strb.w	r3, [sp, #24]
    37de:	f7ff f9bd 	bl	2b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    37e2:	b00d      	add	sp, #52	; 0x34
    37e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    37e8:	00000c51 	.word	0x00000c51

000037ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  mb_filter_table[mb_num][4] = id4; // id4
  mb_filter_table[mb_num][5] = id5; // id5
}

FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
  if ( !distribution ) return; /* distribution not enabled */
    37ec:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    37f0:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    37f4:	2b00      	cmp	r3, #0
    37f6:	f000 80db 	beq.w	39b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  CAN_message_t frame = msg;

  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    37fa:	f8df c26c 	ldr.w	ip, [pc, #620]	; 3a68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    37fe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    3802:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    3804:	b089      	sub	sp, #36	; 0x24
    3806:	4605      	mov	r5, r0
    3808:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    380a:	ac02      	add	r4, sp, #8
    380c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    380e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3810:	e897 0003 	ldmia.w	r7, {r0, r1}
    3814:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3818:	f8dc 3000 	ldr.w	r3, [ip]
    381c:	009b      	lsls	r3, r3, #2
    381e:	d552      	bpl.n	38c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3820:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    3824:	2400      	movs	r4, #0
        }
      }
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
            frame.mb = FIFO;
    3826:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    382a:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    382e:	4622      	mov	r2, r4
    3830:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    3834:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3838:	e00c      	b.n	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    383a:	0f5b      	lsrs	r3, r3, #29
    383c:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    383e:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3840:	f000 809a 	beq.w	3978 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    3844:	0f5b      	lsrs	r3, r3, #29
    3846:	2b05      	cmp	r3, #5
    3848:	f000 80dd 	beq.w	3a06 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    384c:	3401      	adds	r4, #1
    384e:	b2e2      	uxtb	r2, r4
    3850:	4592      	cmp	sl, r2
    3852:	d938      	bls.n	38c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    3854:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3858:	2b63      	cmp	r3, #99	; 0x63
    385a:	d034      	beq.n	38c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    385c:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    3860:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    3864:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    3868:	683b      	ldr	r3, [r7, #0]
    386a:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    386e:	d0ed      	beq.n	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3870:	683b      	ldr	r3, [r7, #0]
    3872:	0f5b      	lsrs	r3, r3, #29
    3874:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3876:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3878:	d1df      	bne.n	383a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    387a:	f3c3 4300 	ubfx	r3, r3, #16, #1
    387e:	79f2      	ldrb	r2, [r6, #7]
    3880:	429a      	cmp	r2, r3
    3882:	d1e3      	bne.n	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3884:	683b      	ldr	r3, [r7, #0]
    3886:	f413 7f60 	tst.w	r3, #896	; 0x380
    388a:	d0df      	beq.n	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    388c:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3890:	2300      	movs	r3, #0
    3892:	e006      	b.n	38a2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    3894:	683a      	ldr	r2, [r7, #0]
    3896:	fa5f f388 	uxtb.w	r3, r8
    389a:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    389e:	4293      	cmp	r3, r2
    38a0:	d2d4      	bcs.n	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    38a2:	f103 0801 	add.w	r8, r3, #1
    38a6:	9a02      	ldr	r2, [sp, #8]
    38a8:	eb0b 0308 	add.w	r3, fp, r8
    38ac:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    38b0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    38b4:	429a      	cmp	r2, r3
    38b6:	d1ed      	bne.n	3894 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    38b8:	a902      	add	r1, sp, #8
    38ba:	4628      	mov	r0, r5
            frame.mb = FIFO;
    38bc:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    38c0:	f7ff ff34 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    38c4:	e7e6      	b.n	3894 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
        }
      }
    } /* end of fifo scan */
  } /* end of fifo checking */

  frame.idhit = 0;
    38c6:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    38c8:	4f67      	ldr	r7, [pc, #412]	; (3a68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    38ca:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    38ce:	683c      	ldr	r4, [r7, #0]
    38d0:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    38d4:	d03f      	beq.n	3956 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    38d6:	f7fd fb7d 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>

  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    38da:	683b      	ldr	r3, [r7, #0]
    38dc:	4604      	mov	r4, r0
    38de:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    38e2:	3301      	adds	r3, #1
    38e4:	4283      	cmp	r3, r0
    38e6:	d933      	bls.n	3950 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
          struct2queueRx(frame);
        }
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    38e8:	f242 1704 	movw	r7, #8452	; 0x2104
    38ec:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    38f0:	f8df 9174 	ldr.w	r9, [pc, #372]	; 3a68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    38f4:	f996 3014 	ldrsb.w	r3, [r6, #20]
    38f8:	42a3      	cmp	r3, r4
    38fa:	d020      	beq.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    38fc:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    3900:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    3904:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    3908:	f8da 3000 	ldr.w	r3, [sl]
    390c:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3910:	d015      	beq.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    3912:	f8da 3000 	ldr.w	r3, [sl]
    3916:	79f0      	ldrb	r0, [r6, #7]
    3918:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    391c:	4298      	cmp	r0, r3
    391e:	d10e      	bne.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3920:	f8da 3000 	ldr.w	r3, [sl]
    3924:	0f5b      	lsrs	r3, r3, #29
    3926:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3928:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    392c:	d041      	beq.n	39b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    392e:	0f5b      	lsrs	r3, r3, #29
    3930:	2b02      	cmp	r3, #2
    3932:	d012      	beq.n	395a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    3934:	f8da 3000 	ldr.w	r3, [sl]
    3938:	0f5b      	lsrs	r3, r3, #29
    393a:	2b05      	cmp	r3, #5
    393c:	d05b      	beq.n	39f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    393e:	f8d9 3000 	ldr.w	r3, [r9]
    3942:	3401      	adds	r4, #1
    3944:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3948:	b2e4      	uxtb	r4, r4
    394a:	3301      	adds	r3, #1
    394c:	429c      	cmp	r4, r3
    394e:	d3d1      	bcc.n	38f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
  } /* end of mb scan */
}
    3950:	b009      	add	sp, #36	; 0x24
    3952:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3956:	683b      	ldr	r3, [r7, #0]
    3958:	e7c6      	b.n	38e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    395a:	59d1      	ldr	r1, [r2, r7]
    395c:	9b02      	ldr	r3, [sp, #8]
    395e:	428b      	cmp	r3, r1
    3960:	d3ed      	bcc.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3962:	f852 2008 	ldr.w	r2, [r2, r8]
    3966:	4293      	cmp	r3, r2
    3968:	d8e9      	bhi.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    396a:	a902      	add	r1, sp, #8
    396c:	4628      	mov	r0, r5
        frame.mb = i;
    396e:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    3972:	f7ff fedb 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3976:	e7e2      	b.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3978:	f3c3 4300 	ubfx	r3, r3, #16, #1
    397c:	79f2      	ldrb	r2, [r6, #7]
    397e:	429a      	cmp	r2, r3
    3980:	f47f af64 	bne.w	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    3984:	f641 6304 	movw	r3, #7684	; 0x1e04
    3988:	f85b 2003 	ldr.w	r2, [fp, r3]
    398c:	9b02      	ldr	r3, [sp, #8]
    398e:	4293      	cmp	r3, r2
    3990:	f4ff af5c 	bcc.w	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    3994:	f641 6208 	movw	r2, #7688	; 0x1e08
    3998:	f85b 2002 	ldr.w	r2, [fp, r2]
    399c:	4293      	cmp	r3, r2
    399e:	f63f af55 	bhi.w	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    39a2:	a902      	add	r1, sp, #8
    39a4:	4628      	mov	r0, r5
          frame.mb = FIFO;
    39a6:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    39aa:	f7ff febf 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    39ae:	e74d      	b.n	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    39b0:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    39b2:	f413 7f60 	tst.w	r3, #896	; 0x380
    39b6:	d0c2      	beq.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    39b8:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    39ba:	2300      	movs	r3, #0
    39bc:	e007      	b.n	39ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    39be:	f8da 1000 	ldr.w	r1, [sl]
    39c2:	fa5f f38b 	uxtb.w	r3, fp
    39c6:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    39ca:	428b      	cmp	r3, r1
    39cc:	d2b7      	bcs.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    39ce:	f103 0b01 	add.w	fp, r3, #1
    39d2:	9902      	ldr	r1, [sp, #8]
    39d4:	eb02 030b 	add.w	r3, r2, fp
    39d8:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    39dc:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    39e0:	4299      	cmp	r1, r3
    39e2:	d1ec      	bne.n	39be <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    39e4:	a902      	add	r1, sp, #8
    39e6:	4628      	mov	r0, r5
    39e8:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    39ea:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    39ee:	f7ff fe9d 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    39f2:	9a00      	ldr	r2, [sp, #0]
    39f4:	e7e3      	b.n	39be <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    39f6:	9a02      	ldr	r2, [sp, #8]
    39f8:	4621      	mov	r1, r4
    39fa:	4628      	mov	r0, r5
    39fc:	f7ff fcd6 	bl	33ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3a00:	2800      	cmp	r0, #0
    3a02:	d09c      	beq.n	393e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3a04:	e7b1      	b.n	396a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3a06:	683b      	ldr	r3, [r7, #0]
    3a08:	f413 7f60 	tst.w	r3, #896	; 0x380
    3a0c:	f43f af1e 	beq.w	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3a10:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3a14:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3a16:	445b      	add	r3, fp
    3a18:	e00a      	b.n	3a30 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3a1a:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    3a1e:	3701      	adds	r7, #1
    3a20:	6809      	ldr	r1, [r1, #0]
    3a22:	b2ff      	uxtb	r7, r7
    3a24:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    3a28:	3101      	adds	r1, #1
    3a2a:	428f      	cmp	r7, r1
    3a2c:	f4bf af0e 	bcs.w	384c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3a30:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    3a34:	6818      	ldr	r0, [r3, #0]
    3a36:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    3a3a:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    3a3e:	9902      	ldr	r1, [sp, #8]
    3a40:	f8d3 c000 	ldr.w	ip, [r3]
    3a44:	4008      	ands	r0, r1
    3a46:	ea0e 010c 	and.w	r1, lr, ip
    3a4a:	4288      	cmp	r0, r1
    3a4c:	d1e5      	bne.n	3a1a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    3a4e:	a902      	add	r1, sp, #8
    3a50:	4628      	mov	r0, r5
    3a52:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    3a54:	f88d 200e 	strb.w	r2, [sp, #14]
    3a58:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    3a5a:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    3a5e:	f7ff fe65 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3a62:	e9dd 2300 	ldrd	r2, r3, [sp]
    3a66:	e7d8      	b.n	3a1a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    3a68:	401d4000 	.word	0x401d4000

00003a6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3a6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    3a70:	4d94      	ldr	r5, [pc, #592]	; (3cc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3a72:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3a74:	4f94      	ldr	r7, [pc, #592]	; (3cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    3a76:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3a78:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    3a7a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3a7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3a7e:	e895 0003 	ldmia.w	r5, {r0, r1}
    3a82:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3a86:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    3a88:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3a8a:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    3a8e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3a90:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3a92:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3a94:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3a98:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3a9a:	d103      	bne.n	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    3a9c:	683a      	ldr	r2, [r7, #0]
    3a9e:	0094      	lsls	r4, r2, #2
    3aa0:	f100 811a 	bmi.w	3cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3aa4:	9b03      	ldr	r3, [sp, #12]
    3aa6:	f043 0301 	orr.w	r3, r3, #1
    3aaa:	f1bb 0f00 	cmp.w	fp, #0
    3aae:	f000 8105 	beq.w	3cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    3ab2:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ab6:	4d84      	ldr	r5, [pc, #528]	; (3cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3ab8:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3abc:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3abe:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ac0:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3ac4:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ac6:	f000 8284 	beq.w	3fd2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    3aca:	f7fd fa83 	bl	fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3ace:	682b      	ldr	r3, [r5, #0]
    3ad0:	4604      	mov	r4, r0
    3ad2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3ad6:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    3ad8:	4283      	cmp	r3, r0
    3ada:	f240 80c2 	bls.w	3c62 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    3ade:	4287      	cmp	r7, r0
    3ae0:	f240 80bf 	bls.w	3c62 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    3ae4:	9b04      	ldr	r3, [sp, #16]
    3ae6:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3ae8:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 3cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    3aec:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    3af0:	b2fd      	uxtb	r5, r7
    3af2:	9305      	str	r3, [sp, #20]
    3af4:	e018      	b.n	3b28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    3af6:	2a04      	cmp	r2, #4
    3af8:	f000 8162 	beq.w	3dc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3afc:	2a08      	cmp	r2, #8
    3afe:	f000 8203 	beq.w	3f08 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3b02:	f8d9 3000 	ldr.w	r3, [r9]
    3b06:	b2fc      	uxtb	r4, r7
    3b08:	9a01      	ldr	r2, [sp, #4]
    3b0a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3b0e:	3301      	adds	r3, #1
    3b10:	42a2      	cmp	r2, r4
    3b12:	bf88      	it	hi
    3b14:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    3b16:	f105 0501 	add.w	r5, r5, #1
    3b1a:	bf94      	ite	ls
    3b1c:	2301      	movls	r3, #1
    3b1e:	2300      	movhi	r3, #0
    3b20:	2b00      	cmp	r3, #0
    3b22:	f040 809e 	bne.w	3c62 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    3b26:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    3b28:	f1c4 0220 	rsb	r2, r4, #32
    3b2c:	9b02      	ldr	r3, [sp, #8]
    3b2e:	f1a4 0a20 	sub.w	sl, r4, #32
    3b32:	fa06 f102 	lsl.w	r1, r6, r2
    3b36:	40e3      	lsrs	r3, r4
    3b38:	430b      	orrs	r3, r1
    3b3a:	fa26 f10a 	lsr.w	r1, r6, sl
    3b3e:	430b      	orrs	r3, r1
    3b40:	07d8      	lsls	r0, r3, #31
    3b42:	d5de      	bpl.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    3b44:	9b03      	ldr	r3, [sp, #12]
    3b46:	fa0b f202 	lsl.w	r2, fp, r2
    3b4a:	40e3      	lsrs	r3, r4
    3b4c:	4313      	orrs	r3, r2
    3b4e:	fa2b f20a 	lsr.w	r2, fp, sl
    3b52:	4313      	orrs	r3, r2
    3b54:	07d9      	lsls	r1, r3, #31
    3b56:	d5d4      	bpl.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    3b58:	f8df 8178 	ldr.w	r8, [pc, #376]	; 3cd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    3b5c:	44a0      	add	r8, r4
    3b5e:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    3b62:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    3b66:	0e19      	lsrs	r1, r3, #24
    3b68:	f3c3 6203 	ubfx	r2, r3, #24, #4
    3b6c:	f001 010b 	and.w	r1, r1, #11
    3b70:	2902      	cmp	r1, #2
    3b72:	d1c0      	bne.n	3af6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b74:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3b78:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b7c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    3b80:	2800      	cmp	r0, #0
    3b82:	bf12      	itee	ne
    3b84:	f04f 0c01 	movne.w	ip, #1
    3b88:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b8c:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    3b8e:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    3b90:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b94:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    3b96:	d102      	bne.n	3b9e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    3b98:	2201      	movs	r2, #1
    3b9a:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    3b9e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3ba2:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3ba6:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3baa:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    3bac:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    3bb0:	9b05      	ldr	r3, [sp, #20]
    3bb2:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    3bb6:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3bba:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bbe:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3bc2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bc6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3bca:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3bce:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bd2:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3bd6:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3bda:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bde:	ea4f 6313 	mov.w	r3, r3, lsr #24
    3be2:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3be6:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3bea:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3bee:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3bf2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3bf6:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3bfa:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3bfe:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3c02:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    3c06:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3c0a:	ea4f 6313 	mov.w	r3, r3, lsr #24
    3c0e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3c12:	bf14      	ite	ne
    3c14:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    3c18:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3c1c:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3c1e:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    3c22:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3c26:	f04f 0301 	mov.w	r3, #1
    3c2a:	d834      	bhi.n	3c96 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    3c2c:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    3c30:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3c32:	4621      	mov	r1, r4
    3c34:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3c36:	4313      	orrs	r3, r2
    3c38:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3c3c:	9a08      	ldr	r2, [sp, #32]
    3c3e:	f7ff fbb5 	bl	33ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3c42:	2800      	cmp	r0, #0
    3c44:	d135      	bne.n	3cb2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    3c46:	a908      	add	r1, sp, #32
    3c48:	9804      	ldr	r0, [sp, #16]
    3c4a:	f7ff fdcf 	bl	37ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    3c4e:	a808      	add	r0, sp, #32
    3c50:	f3af 8000 	nop.w
      ext_output2(msg);
    3c54:	a808      	add	r0, sp, #32
    3c56:	f3af 8000 	nop.w
      ext_output3(msg);
    3c5a:	a808      	add	r0, sp, #32
    3c5c:	f3af 8000 	nop.w
    3c60:	e74f      	b.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    3c62:	4e19      	ldr	r6, [pc, #100]	; (3cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    3c64:	4d19      	ldr	r5, [pc, #100]	; (3ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    3c66:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    3c68:	682a      	ldr	r2, [r5, #0]
    3c6a:	4b19      	ldr	r3, [pc, #100]	; (3cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    3c6c:	4062      	eors	r2, r4
    3c6e:	4013      	ands	r3, r2
    3c70:	b143      	cbz	r3, 3c84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    3c72:	9b04      	ldr	r3, [sp, #16]
    3c74:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    3c78:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    3c7c:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    3c7e:	2b0f      	cmp	r3, #15
    3c80:	f240 81a9 	bls.w	3fd6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    3c84:	4a10      	ldr	r2, [pc, #64]	; (3cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    3c86:	6a13      	ldr	r3, [r2, #32]
    3c88:	4323      	orrs	r3, r4
    3c8a:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    3c8c:	f3bf 8f4f 	dsb	sy
}
    3c90:	b01b      	add	sp, #108	; 0x6c
    3c92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3c96:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    3c9a:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3c9e:	4621      	mov	r1, r4
    3ca0:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3ca2:	4313      	orrs	r3, r2
    3ca4:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3ca8:	9a08      	ldr	r2, [sp, #32]
    3caa:	f7ff fb7f 	bl	33ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3cae:	2800      	cmp	r0, #0
    3cb0:	d0c9      	beq.n	3c46 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    3cb2:	a908      	add	r1, sp, #32
    3cb4:	9804      	ldr	r0, [sp, #16]
    3cb6:	f7ff fd39 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3cba:	e7c4      	b.n	3c46 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3cbc:	fab3 f383 	clz	r3, r3
    3cc0:	3320      	adds	r3, #32
    3cc2:	e6f8      	b.n	3ab6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    3cc4:	200002c0 	.word	0x200002c0
    3cc8:	401d4000 	.word	0x401d4000
    3ccc:	200068a8 	.word	0x200068a8
    3cd0:	0007ffbf 	.word	0x0007ffbf
    3cd4:	0401d408 	.word	0x0401d408
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    3cd8:	0689      	lsls	r1, r1, #26
    3cda:	f57f aee3 	bpl.w	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    3cde:	0682      	lsls	r2, r0, #26
    3ce0:	f57f aee0 	bpl.w	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    3ce4:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3ce8:	4cc3      	ldr	r4, [pc, #780]	; (3ff8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    3cea:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    3cee:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    3cf2:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    3cf6:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    3cf8:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    3cfc:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    3d00:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d04:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    3d08:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    3d0c:	bf18      	it	ne
    3d0e:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d10:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    3d14:	bf08      	it	eq
    3d16:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    3d18:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    3d1c:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d20:	bf08      	it	eq
    3d22:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    3d24:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    3d28:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d2a:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3d2c:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    3d30:	40d1      	lsrs	r1, r2
    3d32:	3208      	adds	r2, #8
    3d34:	2a20      	cmp	r2, #32
    3d36:	f800 1d01 	strb.w	r1, [r0, #-1]!
    3d3a:	d1f7      	bne.n	3d2c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    3d3c:	a80d      	add	r0, sp, #52	; 0x34
    3d3e:	49ae      	ldr	r1, [pc, #696]	; (3ff8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    3d40:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    3d44:	40da      	lsrs	r2, r3
    3d46:	3308      	adds	r3, #8
    3d48:	2b20      	cmp	r3, #32
    3d4a:	f800 2d01 	strb.w	r2, [r0, #-1]!
    3d4e:	d1f7      	bne.n	3d40 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    3d50:	9b04      	ldr	r3, [sp, #16]
    3d52:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    3d56:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    3d5a:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    3d5e:	2363      	movs	r3, #99	; 0x63
    3d60:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    3d64:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3d66:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    3d68:	f043 0320 	orr.w	r3, r3, #32
    3d6c:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    3d6e:	9b03      	ldr	r3, [sp, #12]
    3d70:	065d      	lsls	r5, r3, #25
    3d72:	d503      	bpl.n	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3d74:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    3d76:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3d7a:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    3d7c:	9b03      	ldr	r3, [sp, #12]
    3d7e:	061c      	lsls	r4, r3, #24
    3d80:	d504      	bpl.n	3d8c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3d82:	4a9d      	ldr	r2, [pc, #628]	; (3ff8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    3d84:	6b13      	ldr	r3, [r2, #48]	; 0x30
    3d86:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3d8a:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    3d8c:	9c04      	ldr	r4, [sp, #16]
    3d8e:	a908      	add	r1, sp, #32
    3d90:	4620      	mov	r0, r4
    3d92:	f7ff fd2b 	bl	37ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    3d96:	a808      	add	r0, sp, #32
    3d98:	f3af 8000 	nop.w
      ext_output2(msg);
    3d9c:	a808      	add	r0, sp, #32
    3d9e:	f3af 8000 	nop.w
      ext_output3(msg);
    3da2:	a808      	add	r0, sp, #32
    3da4:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    3da8:	9908      	ldr	r1, [sp, #32]
    3daa:	4620      	mov	r0, r4
    3dac:	f7ff fa86 	bl	32bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    3db0:	2800      	cmp	r0, #0
    3db2:	f43f ae77 	beq.w	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    3db6:	a908      	add	r1, sp, #32
    3db8:	9804      	ldr	r0, [sp, #16]
    3dba:	f7ff fcb7 	bl	372c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3dbe:	e671      	b.n	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    3dc0:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    3dc4:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3dc6:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    3dca:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3dce:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3dd2:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3dd6:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    3dda:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    3dde:	bf18      	it	ne
    3de0:	2101      	movne	r1, #1
      msg.bus = busNumber;
    3de2:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3de4:	bf04      	itt	eq
    3de6:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    3de8:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    3dea:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3dee:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    3df0:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3df4:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3df8:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3dfa:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3dfe:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3e02:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3e06:	0a1b      	lsrs	r3, r3, #8
    3e08:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3e0c:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3e10:	0c1b      	lsrs	r3, r3, #16
    3e12:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3e16:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3e1a:	0e1b      	lsrs	r3, r3, #24
    3e1c:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3e20:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3e24:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3e28:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3e2c:	0a1b      	lsrs	r3, r3, #8
    3e2e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3e32:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3e36:	0c1b      	lsrs	r3, r3, #16
    3e38:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3e3c:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    3e40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3e44:	f8d8 200c 	ldr.w	r2, [r8, #12]
    3e48:	0e12      	lsrs	r2, r2, #24
    3e4a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3e4e:	b10b      	cbz	r3, 3e54 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    3e50:	a808      	add	r0, sp, #32
    3e52:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    3e54:	9b05      	ldr	r3, [sp, #20]
    3e56:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    3e5a:	b10b      	cbz	r3, 3e60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    3e5c:	a808      	add	r0, sp, #32
    3e5e:	4798      	blx	r3
    3e60:	9904      	ldr	r1, [sp, #16]
    3e62:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    3e66:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3e6a:	9207      	str	r2, [sp, #28]
    3e6c:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    3e6e:	2b00      	cmp	r3, #0
    3e70:	f000 80c4 	beq.w	3ffc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    3e74:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    3e78:	221a      	movs	r2, #26
    3e7a:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    3e7e:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    3e82:	46e0      	mov	r8, ip
    3e84:	fb02 1303 	mla	r3, r2, r3, r1
    3e88:	f641 3232 	movw	r2, #6962	; 0x1b32
    3e8c:	a90e      	add	r1, sp, #56	; 0x38
    3e8e:	eb03 0a02 	add.w	sl, r3, r2
    3e92:	9106      	str	r1, [sp, #24]
    3e94:	468e      	mov	lr, r1
    3e96:	5898      	ldr	r0, [r3, r2]
    3e98:	f8da 1004 	ldr.w	r1, [sl, #4]
    3e9c:	f8da 2008 	ldr.w	r2, [sl, #8]
    3ea0:	f8da 300c 	ldr.w	r3, [sl, #12]
    3ea4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3ea8:	f8da 0010 	ldr.w	r0, [sl, #16]
    3eac:	f8da 1014 	ldr.w	r1, [sl, #20]
    3eb0:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    3eb4:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    3eb8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3ebc:	e898 0003 	ldmia.w	r8, {r0, r1}
    3ec0:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    3ec4:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    3ec8:	1c5a      	adds	r2, r3, #1
    3eca:	f000 80a6 	beq.w	401a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    3ece:	429c      	cmp	r4, r3
    3ed0:	f47f ae17 	bne.w	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    3ed4:	9a06      	ldr	r2, [sp, #24]
    3ed6:	b2e1      	uxtb	r1, r4
    3ed8:	9804      	ldr	r0, [sp, #16]
    3eda:	f7fe fe65 	bl	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    3ede:	9a07      	ldr	r2, [sp, #28]
    3ee0:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    3ee4:	3301      	adds	r3, #1
    3ee6:	f003 031f 	and.w	r3, r3, #31
    3eea:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    3eee:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3ef2:	b29b      	uxth	r3, r3
    3ef4:	2b00      	cmp	r3, #0
    3ef6:	f43f ae04 	beq.w	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    3efa:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3efe:	3b01      	subs	r3, #1
    3f00:	b29b      	uxth	r3, r3
    3f02:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    3f06:	e5fc      	b.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f08:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    3f0c:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f0e:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    3f12:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3f16:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3f1a:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f1e:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    3f22:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f26:	bf18      	it	ne
    3f28:	2101      	movne	r1, #1
      msg.bus = busNumber;
    3f2a:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f2c:	bf04      	itt	eq
    3f2e:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f30:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    3f32:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f36:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    3f38:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f3c:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3f40:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f42:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3f46:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f4a:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f4e:	0a1b      	lsrs	r3, r3, #8
    3f50:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3f54:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f58:	0c1b      	lsrs	r3, r3, #16
    3f5a:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3f5e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f62:	0e1b      	lsrs	r3, r3, #24
    3f64:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3f68:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f6c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3f70:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f74:	0a1b      	lsrs	r3, r3, #8
    3f76:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3f7a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f7e:	0c1b      	lsrs	r3, r3, #16
    3f80:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    3f84:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f88:	0e1b      	lsrs	r3, r3, #24
    3f8a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3f8e:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    3f92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3f96:	b10b      	cbz	r3, 3f9c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    3f98:	a808      	add	r0, sp, #32
    3f9a:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    3f9c:	9b05      	ldr	r3, [sp, #20]
    3f9e:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    3fa2:	b10b      	cbz	r3, 3fa8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    3fa4:	a808      	add	r0, sp, #32
    3fa6:	4798      	blx	r3
        uint16_t size() { return _available; }
    3fa8:	9904      	ldr	r1, [sp, #16]
    3faa:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    3fae:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3fb2:	9207      	str	r2, [sp, #28]
    3fb4:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    3fb6:	2b00      	cmp	r3, #0
    3fb8:	f47f af5c 	bne.w	3e74 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3fbc:	2c1f      	cmp	r4, #31
    3fbe:	f04f 0301 	mov.w	r3, #1
    3fc2:	d835      	bhi.n	4030 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    3fc4:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    3fc8:	40a3      	lsls	r3, r4
    3fca:	4313      	orrs	r3, r2
    3fcc:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    3fd0:	e597      	b.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3fd2:	682b      	ldr	r3, [r5, #0]
    3fd4:	e586      	b.n	3ae4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    3fd6:	9f04      	ldr	r7, [sp, #16]
    3fd8:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    3fdc:	4621      	mov	r1, r4
    3fde:	4438      	add	r0, r7
    3fe0:	f7ff fa4a 	bl	3478 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    3fe4:	69f1      	ldr	r1, [r6, #28]
    3fe6:	f641 5098 	movw	r0, #7576	; 0x1d98
    3fea:	b289      	uxth	r1, r1
    3fec:	4438      	add	r0, r7
    3fee:	f7ff fa67 	bl	34c0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    3ff2:	602c      	str	r4, [r5, #0]
    3ff4:	e646      	b.n	3c84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    3ff6:	bf00      	nop
    3ff8:	401d4000 	.word	0x401d4000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3ffc:	2c1f      	cmp	r4, #31
    3ffe:	f04f 0301 	mov.w	r3, #1
    4002:	d80d      	bhi.n	4020 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    4004:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4008:	40a3      	lsls	r3, r4
    400a:	4313      	orrs	r3, r2
    400c:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4010:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    4014:	f8c8 3000 	str.w	r3, [r8]
    4018:	e573      	b.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    401a:	9a06      	ldr	r2, [sp, #24]
    401c:	4621      	mov	r1, r4
    401e:	e75b      	b.n	3ed8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4020:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4024:	fa03 f30a 	lsl.w	r3, r3, sl
    4028:	4313      	orrs	r3, r2
    402a:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    402e:	e7ef      	b.n	4010 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4030:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4034:	fa03 f30a 	lsl.w	r3, r3, sl
    4038:	4313      	orrs	r3, r2
    403a:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    403e:	e560      	b.n	3b02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

00004040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    4040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    4044:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    4046:	b08d      	sub	sp, #52	; 0x34
    4048:	460e      	mov	r6, r1
    404a:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    404c:	466c      	mov	r4, sp
    404e:	4605      	mov	r5, r0
    4050:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    4054:	f04f 0901 	mov.w	r9, #1
    4058:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 40fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    405c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    4060:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4062:	e89c 0003 	ldmia.w	ip, {r0, r1}
    4066:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    406a:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    406e:	b15c      	cbz	r4, 4088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    4070:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    4074:	68a3      	ldr	r3, [r4, #8]
    4076:	fa09 f102 	lsl.w	r1, r9, r2
    407a:	4219      	tst	r1, r3
    407c:	d023      	beq.n	40c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    407e:	6823      	ldr	r3, [r4, #0]
    4080:	f8d3 b000 	ldr.w	fp, [r3]
    4084:	45d3      	cmp	fp, sl
    4086:	d119      	bne.n	40bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    4088:	4545      	cmp	r5, r8
    408a:	d1ee      	bne.n	406a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    408c:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    4090:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    4094:	b33b      	cbz	r3, 40e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    4096:	6830      	ldr	r0, [r6, #0]
    4098:	ac06      	add	r4, sp, #24
    409a:	6871      	ldr	r1, [r6, #4]
    409c:	68b2      	ldr	r2, [r6, #8]
    409e:	68f3      	ldr	r3, [r6, #12]
    40a0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    40a2:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    40a4:	2218      	movs	r2, #24
    40a6:	6971      	ldr	r1, [r6, #20]
    40a8:	c403      	stmia	r4!, {r0, r1}
    40aa:	eb0d 0102 	add.w	r1, sp, r2
    40ae:	f107 0014 	add.w	r0, r7, #20
    40b2:	f7ff fb07 	bl	36c4 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    40b6:	b00d      	add	sp, #52	; 0x34
    40b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    40bc:	f89d 3015 	ldrb.w	r3, [sp, #21]
    40c0:	4669      	mov	r1, sp
    40c2:	4620      	mov	r0, r4
    40c4:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    40c6:	7c23      	ldrb	r3, [r4, #16]
    40c8:	2b00      	cmp	r3, #0
    40ca:	d0dd      	beq.n	4088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    40cc:	6823      	ldr	r3, [r4, #0]
    40ce:	f8d3 b000 	ldr.w	fp, [r3]
    40d2:	f89d 3015 	ldrb.w	r3, [sp, #21]
    40d6:	45d3      	cmp	fp, sl
    40d8:	d0d6      	beq.n	4088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    40da:	4620      	mov	r0, r4
    40dc:	f04f 32ff 	mov.w	r2, #4294967295
    40e0:	4669      	mov	r1, sp
    40e2:	47d8      	blx	fp
    40e4:	e7d0      	b.n	4088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    40e6:	7d33      	ldrb	r3, [r6, #20]
    40e8:	4632      	mov	r2, r6
    40ea:	a906      	add	r1, sp, #24
    40ec:	4638      	mov	r0, r7
    40ee:	f88d 3018 	strb.w	r3, [sp, #24]
    40f2:	f7fe fbcb 	bl	288c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    40f6:	b00d      	add	sp, #52	; 0x34
    40f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    40fc:	00000c51 	.word	0x00000c51

00004100 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  if ( !distribution ) return; /* distribution not enabled */
    4100:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    4104:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    4108:	2b00      	cmp	r3, #0
    410a:	f000 80db 	beq.w	42c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    410e:	f8df c26c 	ldr.w	ip, [pc, #620]	; 437c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    4112:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    4116:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    4118:	b089      	sub	sp, #36	; 0x24
    411a:	4605      	mov	r5, r0
    411c:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    411e:	ac02      	add	r4, sp, #8
    4120:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    4122:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4124:	e897 0003 	ldmia.w	r7, {r0, r1}
    4128:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    412c:	f8dc 3000 	ldr.w	r3, [ip]
    4130:	009b      	lsls	r3, r3, #2
    4132:	d552      	bpl.n	41da <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    4134:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    4138:	2400      	movs	r4, #0
            frame.mb = FIFO;
    413a:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    413e:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    4142:	4622      	mov	r2, r4
    4144:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    4148:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    414c:	e00c      	b.n	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    414e:	0f5b      	lsrs	r3, r3, #29
    4150:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4152:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    4154:	f000 809a 	beq.w	428c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    4158:	0f5b      	lsrs	r3, r3, #29
    415a:	2b05      	cmp	r3, #5
    415c:	f000 80dd 	beq.w	431a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    4160:	3401      	adds	r4, #1
    4162:	b2e2      	uxtb	r2, r4
    4164:	4592      	cmp	sl, r2
    4166:	d938      	bls.n	41da <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    4168:	f996 3014 	ldrsb.w	r3, [r6, #20]
    416c:	2b63      	cmp	r3, #99	; 0x63
    416e:	d034      	beq.n	41da <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    4170:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    4174:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    4178:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    417c:	683b      	ldr	r3, [r7, #0]
    417e:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    4182:	d0ed      	beq.n	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4184:	683b      	ldr	r3, [r7, #0]
    4186:	0f5b      	lsrs	r3, r3, #29
    4188:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    418a:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    418c:	d1df      	bne.n	414e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    418e:	f3c3 4300 	ubfx	r3, r3, #16, #1
    4192:	79f2      	ldrb	r2, [r6, #7]
    4194:	429a      	cmp	r2, r3
    4196:	d1e3      	bne.n	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    4198:	683b      	ldr	r3, [r7, #0]
    419a:	f413 7f60 	tst.w	r3, #896	; 0x380
    419e:	d0df      	beq.n	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    41a0:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    41a4:	2300      	movs	r3, #0
    41a6:	e006      	b.n	41b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    41a8:	683a      	ldr	r2, [r7, #0]
    41aa:	fa5f f388 	uxtb.w	r3, r8
    41ae:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    41b2:	4293      	cmp	r3, r2
    41b4:	d2d4      	bcs.n	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    41b6:	f103 0801 	add.w	r8, r3, #1
    41ba:	9a02      	ldr	r2, [sp, #8]
    41bc:	eb0b 0308 	add.w	r3, fp, r8
    41c0:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    41c4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    41c8:	429a      	cmp	r2, r3
    41ca:	d1ed      	bne.n	41a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    41cc:	a902      	add	r1, sp, #8
    41ce:	4628      	mov	r0, r5
            frame.mb = FIFO;
    41d0:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    41d4:	f7ff ff34 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    41d8:	e7e6      	b.n	41a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
  frame.idhit = 0;
    41da:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    41dc:	4f67      	ldr	r7, [pc, #412]	; (437c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    41de:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    41e2:	683c      	ldr	r4, [r7, #0]
    41e4:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    41e8:	d03f      	beq.n	426a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    41ea:	f7fc fecf 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    41ee:	683b      	ldr	r3, [r7, #0]
    41f0:	4604      	mov	r4, r0
    41f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    41f6:	3301      	adds	r3, #1
    41f8:	4283      	cmp	r3, r0
    41fa:	d933      	bls.n	4264 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    41fc:	f242 1704 	movw	r7, #8452	; 0x2104
    4200:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    4204:	f8df 9174 	ldr.w	r9, [pc, #372]	; 437c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    4208:	f996 3014 	ldrsb.w	r3, [r6, #20]
    420c:	42a3      	cmp	r3, r4
    420e:	d020      	beq.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    4210:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    4214:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    4218:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    421c:	f8da 3000 	ldr.w	r3, [sl]
    4220:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    4224:	d015      	beq.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    4226:	f8da 3000 	ldr.w	r3, [sl]
    422a:	79f0      	ldrb	r0, [r6, #7]
    422c:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    4230:	4298      	cmp	r0, r3
    4232:	d10e      	bne.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4234:	f8da 3000 	ldr.w	r3, [sl]
    4238:	0f5b      	lsrs	r3, r3, #29
    423a:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    423c:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4240:	d041      	beq.n	42c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    4242:	0f5b      	lsrs	r3, r3, #29
    4244:	2b02      	cmp	r3, #2
    4246:	d012      	beq.n	426e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    4248:	f8da 3000 	ldr.w	r3, [sl]
    424c:	0f5b      	lsrs	r3, r3, #29
    424e:	2b05      	cmp	r3, #5
    4250:	d05b      	beq.n	430a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    4252:	f8d9 3000 	ldr.w	r3, [r9]
    4256:	3401      	adds	r4, #1
    4258:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    425c:	b2e4      	uxtb	r4, r4
    425e:	3301      	adds	r3, #1
    4260:	429c      	cmp	r4, r3
    4262:	d3d1      	bcc.n	4208 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
}
    4264:	b009      	add	sp, #36	; 0x24
    4266:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    426a:	683b      	ldr	r3, [r7, #0]
    426c:	e7c6      	b.n	41fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    426e:	59d1      	ldr	r1, [r2, r7]
    4270:	9b02      	ldr	r3, [sp, #8]
    4272:	428b      	cmp	r3, r1
    4274:	d3ed      	bcc.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    4276:	f852 2008 	ldr.w	r2, [r2, r8]
    427a:	4293      	cmp	r3, r2
    427c:	d8e9      	bhi.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    427e:	a902      	add	r1, sp, #8
    4280:	4628      	mov	r0, r5
        frame.mb = i;
    4282:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    4286:	f7ff fedb 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    428a:	e7e2      	b.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    428c:	f3c3 4300 	ubfx	r3, r3, #16, #1
    4290:	79f2      	ldrb	r2, [r6, #7]
    4292:	429a      	cmp	r2, r3
    4294:	f47f af64 	bne.w	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    4298:	f641 6304 	movw	r3, #7684	; 0x1e04
    429c:	f85b 2003 	ldr.w	r2, [fp, r3]
    42a0:	9b02      	ldr	r3, [sp, #8]
    42a2:	4293      	cmp	r3, r2
    42a4:	f4ff af5c 	bcc.w	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    42a8:	f641 6208 	movw	r2, #7688	; 0x1e08
    42ac:	f85b 2002 	ldr.w	r2, [fp, r2]
    42b0:	4293      	cmp	r3, r2
    42b2:	f63f af55 	bhi.w	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    42b6:	a902      	add	r1, sp, #8
    42b8:	4628      	mov	r0, r5
          frame.mb = FIFO;
    42ba:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    42be:	f7ff febf 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    42c2:	e74d      	b.n	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    42c4:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    42c6:	f413 7f60 	tst.w	r3, #896	; 0x380
    42ca:	d0c2      	beq.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    42cc:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    42ce:	2300      	movs	r3, #0
    42d0:	e007      	b.n	42e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    42d2:	f8da 1000 	ldr.w	r1, [sl]
    42d6:	fa5f f38b 	uxtb.w	r3, fp
    42da:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    42de:	428b      	cmp	r3, r1
    42e0:	d2b7      	bcs.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    42e2:	f103 0b01 	add.w	fp, r3, #1
    42e6:	9902      	ldr	r1, [sp, #8]
    42e8:	eb02 030b 	add.w	r3, r2, fp
    42ec:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    42f0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    42f4:	4299      	cmp	r1, r3
    42f6:	d1ec      	bne.n	42d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    42f8:	a902      	add	r1, sp, #8
    42fa:	4628      	mov	r0, r5
    42fc:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    42fe:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    4302:	f7ff fe9d 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4306:	9a00      	ldr	r2, [sp, #0]
    4308:	e7e3      	b.n	42d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    430a:	9a02      	ldr	r2, [sp, #8]
    430c:	4621      	mov	r1, r4
    430e:	4628      	mov	r0, r5
    4310:	f7ff f972 	bl	35f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4314:	2800      	cmp	r0, #0
    4316:	d09c      	beq.n	4252 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    4318:	e7b1      	b.n	427e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    431a:	683b      	ldr	r3, [r7, #0]
    431c:	f413 7f60 	tst.w	r3, #896	; 0x380
    4320:	f43f af1e 	beq.w	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    4324:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    4328:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    432a:	445b      	add	r3, fp
    432c:	e00a      	b.n	4344 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    432e:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    4332:	3701      	adds	r7, #1
    4334:	6809      	ldr	r1, [r1, #0]
    4336:	b2ff      	uxtb	r7, r7
    4338:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    433c:	3101      	adds	r1, #1
    433e:	428f      	cmp	r7, r1
    4340:	f4bf af0e 	bcs.w	4160 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    4344:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    4348:	6818      	ldr	r0, [r3, #0]
    434a:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    434e:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    4352:	9902      	ldr	r1, [sp, #8]
    4354:	f8d3 c000 	ldr.w	ip, [r3]
    4358:	4008      	ands	r0, r1
    435a:	ea0e 010c 	and.w	r1, lr, ip
    435e:	4288      	cmp	r0, r1
    4360:	d1e5      	bne.n	432e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    4362:	a902      	add	r1, sp, #8
    4364:	4628      	mov	r0, r5
    4366:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    4368:	f88d 200e 	strb.w	r2, [sp, #14]
    436c:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    436e:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    4372:	f7ff fe65 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4376:	e9dd 2300 	ldrd	r2, r3, [sp]
    437a:	e7d8      	b.n	432e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    437c:	401d0000 	.word	0x401d0000

00004380 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    4380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    4384:	4d94      	ldr	r5, [pc, #592]	; (45d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    4386:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    4388:	4f94      	ldr	r7, [pc, #592]	; (45dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    438a:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    438c:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    438e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    4390:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4392:	e895 0003 	ldmia.w	r5, {r0, r1}
    4396:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    439a:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    439c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    439e:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    43a2:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    43a4:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    43a6:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    43a8:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    43ac:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    43ae:	d103      	bne.n	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    43b0:	683a      	ldr	r2, [r7, #0]
    43b2:	0094      	lsls	r4, r2, #2
    43b4:	f100 811a 	bmi.w	45ec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43b8:	9b03      	ldr	r3, [sp, #12]
    43ba:	f043 0301 	orr.w	r3, r3, #1
    43be:	f1bb 0f00 	cmp.w	fp, #0
    43c2:	f000 8105 	beq.w	45d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    43c6:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43ca:	4d84      	ldr	r5, [pc, #528]	; (45dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43cc:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43d0:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43d2:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43d4:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43d8:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43da:	f000 8284 	beq.w	48e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    43de:	f7fc fdd5 	bl	f8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    43e2:	682b      	ldr	r3, [r5, #0]
    43e4:	4604      	mov	r4, r0
    43e6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    43ea:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    43ec:	4283      	cmp	r3, r0
    43ee:	f240 80c2 	bls.w	4576 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    43f2:	4287      	cmp	r7, r0
    43f4:	f240 80bf 	bls.w	4576 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    43f8:	9b04      	ldr	r3, [sp, #16]
    43fa:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    43fc:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 45dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    4400:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    4404:	b2fd      	uxtb	r5, r7
    4406:	9305      	str	r3, [sp, #20]
    4408:	e018      	b.n	443c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    440a:	2a04      	cmp	r2, #4
    440c:	f000 8162 	beq.w	46d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    4410:	2a08      	cmp	r2, #8
    4412:	f000 8203 	beq.w	481c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4416:	f8d9 3000 	ldr.w	r3, [r9]
    441a:	b2fc      	uxtb	r4, r7
    441c:	9a01      	ldr	r2, [sp, #4]
    441e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4422:	3301      	adds	r3, #1
    4424:	42a2      	cmp	r2, r4
    4426:	bf88      	it	hi
    4428:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    442a:	f105 0501 	add.w	r5, r5, #1
    442e:	bf94      	ite	ls
    4430:	2301      	movls	r3, #1
    4432:	2300      	movhi	r3, #0
    4434:	2b00      	cmp	r3, #0
    4436:	f040 809e 	bne.w	4576 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    443a:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    443c:	f1c4 0220 	rsb	r2, r4, #32
    4440:	9b02      	ldr	r3, [sp, #8]
    4442:	f1a4 0a20 	sub.w	sl, r4, #32
    4446:	fa06 f102 	lsl.w	r1, r6, r2
    444a:	40e3      	lsrs	r3, r4
    444c:	430b      	orrs	r3, r1
    444e:	fa26 f10a 	lsr.w	r1, r6, sl
    4452:	430b      	orrs	r3, r1
    4454:	07d8      	lsls	r0, r3, #31
    4456:	d5de      	bpl.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    4458:	9b03      	ldr	r3, [sp, #12]
    445a:	fa0b f202 	lsl.w	r2, fp, r2
    445e:	40e3      	lsrs	r3, r4
    4460:	4313      	orrs	r3, r2
    4462:	fa2b f20a 	lsr.w	r2, fp, sl
    4466:	4313      	orrs	r3, r2
    4468:	07d9      	lsls	r1, r3, #31
    446a:	d5d4      	bpl.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    446c:	f8df 8178 	ldr.w	r8, [pc, #376]	; 45e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    4470:	44a0      	add	r8, r4
    4472:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    4476:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    447a:	0e19      	lsrs	r1, r3, #24
    447c:	f3c3 6203 	ubfx	r2, r3, #24, #4
    4480:	f001 010b 	and.w	r1, r1, #11
    4484:	2902      	cmp	r1, #2
    4486:	d1c0      	bne.n	440a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4488:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    448c:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4490:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    4494:	2800      	cmp	r0, #0
    4496:	bf12      	itee	ne
    4498:	f04f 0c01 	movne.w	ip, #1
    449c:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    44a0:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    44a2:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    44a4:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    44a8:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    44aa:	d102      	bne.n	44b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    44ac:	2201      	movs	r2, #1
    44ae:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    44b2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    44b6:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    44ba:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    44be:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    44c0:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    44c4:	9b05      	ldr	r3, [sp, #20]
    44c6:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    44ca:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    44ce:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44d2:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    44d6:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44da:	ea4f 2313 	mov.w	r3, r3, lsr #8
    44de:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    44e2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44e6:	ea4f 4313 	mov.w	r3, r3, lsr #16
    44ea:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    44ee:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44f2:	ea4f 6313 	mov.w	r3, r3, lsr #24
    44f6:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    44fa:	f8d8 300c 	ldr.w	r3, [r8, #12]
    44fe:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4502:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4506:	ea4f 2313 	mov.w	r3, r3, lsr #8
    450a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    450e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4512:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4516:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    451a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    451e:	ea4f 6313 	mov.w	r3, r3, lsr #24
    4522:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    4526:	bf14      	ite	ne
    4528:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    452c:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4530:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    4532:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    4536:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    453a:	f04f 0301 	mov.w	r3, #1
    453e:	d834      	bhi.n	45aa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    4540:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4544:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4546:	4621      	mov	r1, r4
    4548:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    454a:	4313      	orrs	r3, r2
    454c:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4550:	9a08      	ldr	r2, [sp, #32]
    4552:	f7ff f851 	bl	35f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4556:	2800      	cmp	r0, #0
    4558:	d135      	bne.n	45c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    455a:	a908      	add	r1, sp, #32
    455c:	9804      	ldr	r0, [sp, #16]
    455e:	f7ff fdcf 	bl	4100 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    4562:	a808      	add	r0, sp, #32
    4564:	f3af 8000 	nop.w
      ext_output2(msg);
    4568:	a808      	add	r0, sp, #32
    456a:	f3af 8000 	nop.w
      ext_output3(msg);
    456e:	a808      	add	r0, sp, #32
    4570:	f3af 8000 	nop.w
    4574:	e74f      	b.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    4576:	4e19      	ldr	r6, [pc, #100]	; (45dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4578:	4d19      	ldr	r5, [pc, #100]	; (45e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    457a:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    457c:	682a      	ldr	r2, [r5, #0]
    457e:	4b19      	ldr	r3, [pc, #100]	; (45e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    4580:	4062      	eors	r2, r4
    4582:	4013      	ands	r3, r2
    4584:	b143      	cbz	r3, 4598 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    4586:	9b04      	ldr	r3, [sp, #16]
    4588:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    458c:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    4590:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    4592:	2b0f      	cmp	r3, #15
    4594:	f240 81a9 	bls.w	48ea <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    4598:	4a10      	ldr	r2, [pc, #64]	; (45dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    459a:	6a13      	ldr	r3, [r2, #32]
    459c:	4323      	orrs	r3, r4
    459e:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    45a0:	f3bf 8f4f 	dsb	sy
}
    45a4:	b01b      	add	sp, #108	; 0x6c
    45a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    45aa:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    45ae:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    45b2:	4621      	mov	r1, r4
    45b4:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    45b6:	4313      	orrs	r3, r2
    45b8:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    45bc:	9a08      	ldr	r2, [sp, #32]
    45be:	f7ff f81b 	bl	35f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    45c2:	2800      	cmp	r0, #0
    45c4:	d0c9      	beq.n	455a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    45c6:	a908      	add	r1, sp, #32
    45c8:	9804      	ldr	r0, [sp, #16]
    45ca:	f7ff fd39 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    45ce:	e7c4      	b.n	455a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    45d0:	fab3 f383 	clz	r3, r3
    45d4:	3320      	adds	r3, #32
    45d6:	e6f8      	b.n	43ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    45d8:	200002c0 	.word	0x200002c0
    45dc:	401d0000 	.word	0x401d0000
    45e0:	200068a4 	.word	0x200068a4
    45e4:	0007ffbf 	.word	0x0007ffbf
    45e8:	0401d008 	.word	0x0401d008
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    45ec:	0689      	lsls	r1, r1, #26
    45ee:	f57f aee3 	bpl.w	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    45f2:	0682      	lsls	r2, r0, #26
    45f4:	f57f aee0 	bpl.w	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    45f8:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    45fc:	4cc3      	ldr	r4, [pc, #780]	; (490c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    45fe:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    4602:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    4606:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    460a:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    460c:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    4610:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    4614:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4618:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    461c:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    4620:	bf18      	it	ne
    4622:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4624:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    4628:	bf08      	it	eq
    462a:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    462c:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    4630:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4634:	bf08      	it	eq
    4636:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4638:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    463c:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    463e:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4640:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    4644:	40d1      	lsrs	r1, r2
    4646:	3208      	adds	r2, #8
    4648:	2a20      	cmp	r2, #32
    464a:	f800 1d01 	strb.w	r1, [r0, #-1]!
    464e:	d1f7      	bne.n	4640 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    4650:	a80d      	add	r0, sp, #52	; 0x34
    4652:	49ae      	ldr	r1, [pc, #696]	; (490c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    4654:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    4658:	40da      	lsrs	r2, r3
    465a:	3308      	adds	r3, #8
    465c:	2b20      	cmp	r3, #32
    465e:	f800 2d01 	strb.w	r2, [r0, #-1]!
    4662:	d1f7      	bne.n	4654 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    4664:	9b04      	ldr	r3, [sp, #16]
    4666:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    466a:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    466e:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    4672:	2363      	movs	r3, #99	; 0x63
    4674:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    4678:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    467a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    467c:	f043 0320 	orr.w	r3, r3, #32
    4680:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    4682:	9b03      	ldr	r3, [sp, #12]
    4684:	065d      	lsls	r5, r3, #25
    4686:	d503      	bpl.n	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4688:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    468a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    468e:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    4690:	9b03      	ldr	r3, [sp, #12]
    4692:	061c      	lsls	r4, r3, #24
    4694:	d504      	bpl.n	46a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4696:	4a9d      	ldr	r2, [pc, #628]	; (490c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    4698:	6b13      	ldr	r3, [r2, #48]	; 0x30
    469a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    469e:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    46a0:	9c04      	ldr	r4, [sp, #16]
    46a2:	a908      	add	r1, sp, #32
    46a4:	4620      	mov	r0, r4
    46a6:	f7ff fd2b 	bl	4100 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    46aa:	a808      	add	r0, sp, #32
    46ac:	f3af 8000 	nop.w
      ext_output2(msg);
    46b0:	a808      	add	r0, sp, #32
    46b2:	f3af 8000 	nop.w
      ext_output3(msg);
    46b6:	a808      	add	r0, sp, #32
    46b8:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    46bc:	9908      	ldr	r1, [sp, #32]
    46be:	4620      	mov	r0, r4
    46c0:	f7fe ff22 	bl	3508 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    46c4:	2800      	cmp	r0, #0
    46c6:	f43f ae77 	beq.w	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    46ca:	a908      	add	r1, sp, #32
    46cc:	9804      	ldr	r0, [sp, #16]
    46ce:	f7ff fcb7 	bl	4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    46d2:	e671      	b.n	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    46d4:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    46d8:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    46da:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    46de:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    46e2:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    46e6:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    46ea:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    46ee:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    46f2:	bf18      	it	ne
    46f4:	2101      	movne	r1, #1
      msg.bus = busNumber;
    46f6:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    46f8:	bf04      	itt	eq
    46fa:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    46fc:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    46fe:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4702:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4704:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4708:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    470c:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    470e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4712:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4716:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    471a:	0a1b      	lsrs	r3, r3, #8
    471c:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4720:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4724:	0c1b      	lsrs	r3, r3, #16
    4726:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    472a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    472e:	0e1b      	lsrs	r3, r3, #24
    4730:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4734:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4738:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    473c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4740:	0a1b      	lsrs	r3, r3, #8
    4742:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4746:	f8d8 300c 	ldr.w	r3, [r8, #12]
    474a:	0c1b      	lsrs	r3, r3, #16
    474c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4750:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    4754:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4758:	f8d8 200c 	ldr.w	r2, [r8, #12]
    475c:	0e12      	lsrs	r2, r2, #24
    475e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4762:	b10b      	cbz	r3, 4768 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    4764:	a808      	add	r0, sp, #32
    4766:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4768:	9b05      	ldr	r3, [sp, #20]
    476a:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    476e:	b10b      	cbz	r3, 4774 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    4770:	a808      	add	r0, sp, #32
    4772:	4798      	blx	r3
    4774:	9904      	ldr	r1, [sp, #16]
    4776:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    477a:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    477e:	9207      	str	r2, [sp, #28]
    4780:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    4782:	2b00      	cmp	r3, #0
    4784:	f000 80c4 	beq.w	4910 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    4788:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    478c:	221a      	movs	r2, #26
    478e:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    4792:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    4796:	46e0      	mov	r8, ip
    4798:	fb02 1303 	mla	r3, r2, r3, r1
    479c:	f641 3232 	movw	r2, #6962	; 0x1b32
    47a0:	a90e      	add	r1, sp, #56	; 0x38
    47a2:	eb03 0a02 	add.w	sl, r3, r2
    47a6:	9106      	str	r1, [sp, #24]
    47a8:	468e      	mov	lr, r1
    47aa:	5898      	ldr	r0, [r3, r2]
    47ac:	f8da 1004 	ldr.w	r1, [sl, #4]
    47b0:	f8da 2008 	ldr.w	r2, [sl, #8]
    47b4:	f8da 300c 	ldr.w	r3, [sl, #12]
    47b8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    47bc:	f8da 0010 	ldr.w	r0, [sl, #16]
    47c0:	f8da 1014 	ldr.w	r1, [sl, #20]
    47c4:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    47c8:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    47cc:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    47d0:	e898 0003 	ldmia.w	r8, {r0, r1}
    47d4:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    47d8:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    47dc:	1c5a      	adds	r2, r3, #1
    47de:	f000 80a6 	beq.w	492e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    47e2:	429c      	cmp	r4, r3
    47e4:	f47f ae17 	bne.w	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    47e8:	9a06      	ldr	r2, [sp, #24]
    47ea:	b2e1      	uxtb	r1, r4
    47ec:	9804      	ldr	r0, [sp, #16]
    47ee:	f7fe f873 	bl	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    47f2:	9a07      	ldr	r2, [sp, #28]
    47f4:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    47f8:	3301      	adds	r3, #1
    47fa:	f003 031f 	and.w	r3, r3, #31
    47fe:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    4802:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4806:	b29b      	uxth	r3, r3
    4808:	2b00      	cmp	r3, #0
    480a:	f43f ae04 	beq.w	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    480e:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4812:	3b01      	subs	r3, #1
    4814:	b29b      	uxth	r3, r3
    4816:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    481a:	e5fc      	b.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    481c:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4820:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4822:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4826:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    482a:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    482e:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4832:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4836:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    483a:	bf18      	it	ne
    483c:	2101      	movne	r1, #1
      msg.bus = busNumber;
    483e:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4840:	bf04      	itt	eq
    4842:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4844:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4846:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    484a:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    484c:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4850:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4854:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4856:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    485a:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    485e:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4862:	0a1b      	lsrs	r3, r3, #8
    4864:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4868:	f8d8 3008 	ldr.w	r3, [r8, #8]
    486c:	0c1b      	lsrs	r3, r3, #16
    486e:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4872:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4876:	0e1b      	lsrs	r3, r3, #24
    4878:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    487c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4880:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4884:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4888:	0a1b      	lsrs	r3, r3, #8
    488a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    488e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4892:	0c1b      	lsrs	r3, r3, #16
    4894:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4898:	f8d8 300c 	ldr.w	r3, [r8, #12]
    489c:	0e1b      	lsrs	r3, r3, #24
    489e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    48a2:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    48a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    48aa:	b10b      	cbz	r3, 48b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    48ac:	a808      	add	r0, sp, #32
    48ae:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    48b0:	9b05      	ldr	r3, [sp, #20]
    48b2:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    48b6:	b10b      	cbz	r3, 48bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    48b8:	a808      	add	r0, sp, #32
    48ba:	4798      	blx	r3
        uint16_t size() { return _available; }
    48bc:	9904      	ldr	r1, [sp, #16]
    48be:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    48c2:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    48c6:	9207      	str	r2, [sp, #28]
    48c8:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    48ca:	2b00      	cmp	r3, #0
    48cc:	f47f af5c 	bne.w	4788 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    48d0:	2c1f      	cmp	r4, #31
    48d2:	f04f 0301 	mov.w	r3, #1
    48d6:	d835      	bhi.n	4944 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    48d8:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    48dc:	40a3      	lsls	r3, r4
    48de:	4313      	orrs	r3, r2
    48e0:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    48e4:	e597      	b.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    48e6:	682b      	ldr	r3, [r5, #0]
    48e8:	e586      	b.n	43f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    48ea:	9f04      	ldr	r7, [sp, #16]
    48ec:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    48f0:	4621      	mov	r1, r4
    48f2:	4438      	add	r0, r7
    48f4:	f7fe fdc0 	bl	3478 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    48f8:	69f1      	ldr	r1, [r6, #28]
    48fa:	f641 5098 	movw	r0, #7576	; 0x1d98
    48fe:	b289      	uxth	r1, r1
    4900:	4438      	add	r0, r7
    4902:	f7fe fddd 	bl	34c0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    4906:	602c      	str	r4, [r5, #0]
    4908:	e646      	b.n	4598 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    490a:	bf00      	nop
    490c:	401d0000 	.word	0x401d0000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4910:	2c1f      	cmp	r4, #31
    4912:	f04f 0301 	mov.w	r3, #1
    4916:	d80d      	bhi.n	4934 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    4918:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    491c:	40a3      	lsls	r3, r4
    491e:	4313      	orrs	r3, r2
    4920:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4924:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    4928:	f8c8 3000 	str.w	r3, [r8]
    492c:	e573      	b.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    492e:	9a06      	ldr	r2, [sp, #24]
    4930:	4621      	mov	r1, r4
    4932:	e75b      	b.n	47ec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4934:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4938:	fa03 f30a 	lsl.w	r3, r3, sl
    493c:	4313      	orrs	r3, r2
    493e:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4942:	e7ef      	b.n	4924 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4944:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4948:	fa03 f30a 	lsl.w	r3, r3, sl
    494c:	4313      	orrs	r3, r2
    494e:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4952:	e560      	b.n	4416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

00004954 <_GLOBAL__sub_I_HaldexCAN>:
}
    4954:	b538      	push	{r3, r4, r5, lr}
    4956:	f001 f83d 	bl	59d4 <eeprom_initialize>
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    495a:	4829      	ldr	r0, [pc, #164]	; (4a00 <_GLOBAL__sub_I_HaldexCAN+0xac>)
    495c:	4929      	ldr	r1, [pc, #164]	; (4a04 <_GLOBAL__sub_I_HaldexCAN+0xb0>)
class Circular_Buffer {
    495e:	2300      	movs	r3, #0
    4960:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
  if ( _bus == CAN1 ) _CAN1 = this;
    4964:	4c28      	ldr	r4, [pc, #160]	; (4a08 <_GLOBAL__sub_I_HaldexCAN+0xb4>)
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4966:	6001      	str	r1, [r0, #0]
    4968:	f500 5c00 	add.w	ip, r0, #8192	; 0x2000
    496c:	4927      	ldr	r1, [pc, #156]	; (4a0c <_GLOBAL__sub_I_HaldexCAN+0xb8>)
    496e:	8283      	strh	r3, [r0, #20]
  if ( _bus == CAN1 ) _CAN1 = this;
    4970:	6020      	str	r0, [r4, #0]
    4972:	82c3      	strh	r3, [r0, #22]
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4974:	4d26      	ldr	r5, [pc, #152]	; (4a10 <_GLOBAL__sub_I_HaldexCAN+0xbc>)
    4976:	8303      	strh	r3, [r0, #24]
    4978:	f501 5000 	add.w	r0, r1, #8192	; 0x2000
    497c:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
  if ( _bus == CAN2 ) _CAN2 = this;
    4980:	4c24      	ldr	r4, [pc, #144]	; (4a14 <_GLOBAL__sub_I_HaldexCAN+0xc0>)
    4982:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    4986:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    498a:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    498e:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    4992:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    4996:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    499a:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    499e:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    49a2:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    49a6:	f88c 3700 	strb.w	r3, [ip, #1792]	; 0x700
    49aa:	f8cc 390c 	str.w	r3, [ip, #2316]	; 0x90c
    49ae:	f88c 3701 	strb.w	r3, [ip, #1793]	; 0x701
    49b2:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
    49b6:	828b      	strh	r3, [r1, #20]
    49b8:	f88c 3914 	strb.w	r3, [ip, #2324]	; 0x914
    49bc:	82cb      	strh	r3, [r1, #22]
    49be:	600d      	str	r5, [r1, #0]
    49c0:	830b      	strh	r3, [r1, #24]
    49c2:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    49c6:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    49ca:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    49ce:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    49d2:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    49d6:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    49da:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    49de:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    49e2:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    49e6:	f880 3700 	strb.w	r3, [r0, #1792]	; 0x700
    49ea:	f880 3701 	strb.w	r3, [r0, #1793]	; 0x701
    49ee:	f8c0 390c 	str.w	r3, [r0, #2316]	; 0x90c
    49f2:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
    49f6:	f880 3914 	strb.w	r3, [r0, #2324]	; 0x914
  if ( _bus == CAN2 ) _CAN2 = this;
    49fa:	6021      	str	r1, [r4, #0]
    49fc:	bd38      	pop	{r3, r4, r5, pc}
    49fe:	bf00      	nop
    4a00:	20003da0 	.word	0x20003da0
    4a04:	20000630 	.word	0x20000630
    4a08:	20006870 	.word	0x20006870
    4a0c:	20001488 	.word	0x20001488
    4a10:	20000654 	.word	0x20000654
    4a14:	20006874 	.word	0x20006874

00004a18 <readEEP()>:
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4a18:	2000      	movs	r0, #0
#include "openhaldex.h"

void readEEP() {
    4a1a:	b510      	push	{r4, lr}
    4a1c:	f000 fffe 	bl	5a1c <eeprom_read_byte>
#if stateDebug
  Serial.println(F("EEPROM initialising!"));
#endif /* stateDebug */

  if (EEPROM.read(0) == 255) {
    4a20:	28ff      	cmp	r0, #255	; 0xff
    4a22:	d014      	beq.n	4a4e <readEEP()+0x36>
    EERef( const int index )
    4a24:	4603      	mov	r3, r0
    EEPROM.write(1, 0);                    // EEP Address 1: isCustom
    EEPROM.write(2, 0);                    // EEP Address 2: lastMode
    EEPROM.write(3, 0);                    // EEP Address 2: isStandalone
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
  } else {
    softwareVersion = EEPROM.read(0);
    4a26:	4a2c      	ldr	r2, [pc, #176]	; (4ad8 <readEEP()+0xc0>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4a28:	2001      	movs	r0, #1
    4a2a:	6013      	str	r3, [r2, #0]
    4a2c:	f000 fff6 	bl	5a1c <eeprom_read_byte>
    4a30:	4603      	mov	r3, r0
    isCustom = EEPROM.read(1);
    4a32:	4a2a      	ldr	r2, [pc, #168]	; (4adc <readEEP()+0xc4>)
    4a34:	2002      	movs	r0, #2
    4a36:	3b00      	subs	r3, #0
    4a38:	bf18      	it	ne
    4a3a:	2301      	movne	r3, #1
    4a3c:	7013      	strb	r3, [r2, #0]
    4a3e:	f000 ffed 	bl	5a1c <eeprom_read_byte>

    switch (EEPROM.read(2)) {
    4a42:	2803      	cmp	r0, #3
    4a44:	d846      	bhi.n	4ad4 <readEEP()+0xbc>
    4a46:	e8df f000 	tbb	[pc, r0]
    4a4a:	3a34      	.short	0x3a34
    4a4c:	1d42      	.short	0x1d42
    btInit();
    4a4e:	f7fb fdd5 	bl	5fc <btInit()>
    EEPROM.write(0, softwareVersion);      // EEP Address 0: SW Version
    4a52:	4b21      	ldr	r3, [pc, #132]	; (4ad8 <readEEP()+0xc0>)
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4a54:	2000      	movs	r0, #0
    4a56:	7819      	ldrb	r1, [r3, #0]
    4a58:	f001 f8ec 	bl	5c34 <eeprom_write_byte>
    4a5c:	2100      	movs	r1, #0
    4a5e:	2001      	movs	r0, #1
    4a60:	f001 f8e8 	bl	5c34 <eeprom_write_byte>
    4a64:	2100      	movs	r1, #0
    4a66:	2002      	movs	r0, #2
    4a68:	f001 f8e4 	bl	5c34 <eeprom_write_byte>
    4a6c:	2100      	movs	r1, #0
    4a6e:	2003      	movs	r0, #3
    4a70:	f001 f8e0 	bl	5c34 <eeprom_write_byte>
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
    4a74:	4b1a      	ldr	r3, [pc, #104]	; (4ae0 <readEEP()+0xc8>)
    4a76:	2004      	movs	r0, #4
    4a78:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
    state.ped_threshold = EEPROM.read(4);
  }
#if stateDebug
  Serial.println(F("EEPROM initialised!"));
#endif /* stateDebug */
}
    4a7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4a80:	f001 b8d8 	b.w	5c34 <eeprom_write_byte>
        state.mode_override = true;
    4a84:	4c16      	ldr	r4, [pc, #88]	; (4ae0 <readEEP()+0xc8>)
        state.mode = MODE_CUSTOM;
    4a86:	2303      	movs	r3, #3
        state.mode_override = true;
    4a88:	2101      	movs	r1, #1
        lastMode = 3;
    4a8a:	4a16      	ldr	r2, [pc, #88]	; (4ae4 <readEEP()+0xcc>)
        state.mode = MODE_CUSTOM;
    4a8c:	7023      	strb	r3, [r4, #0]
        state.mode_override = true;
    4a8e:	f884 1023 	strb.w	r1, [r4, #35]	; 0x23
        lastMode = 3;
    4a92:	6013      	str	r3, [r2, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4a94:	2003      	movs	r0, #3
    4a96:	f000 ffc1 	bl	5a1c <eeprom_read_byte>
    4a9a:	4603      	mov	r3, r0
    isStandalone = EEPROM.read(3);
    4a9c:	4a12      	ldr	r2, [pc, #72]	; (4ae8 <readEEP()+0xd0>)
    4a9e:	2004      	movs	r0, #4
    4aa0:	3b00      	subs	r3, #0
    4aa2:	bf18      	it	ne
    4aa4:	2301      	movne	r3, #1
    4aa6:	7013      	strb	r3, [r2, #0]
    4aa8:	f000 ffb8 	bl	5a1c <eeprom_read_byte>
    state.ped_threshold = EEPROM.read(4);
    4aac:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
}
    4ab0:	bd10      	pop	{r4, pc}
        state.mode = MODE_STOCK;
    4ab2:	2300      	movs	r3, #0
    4ab4:	4c0a      	ldr	r4, [pc, #40]	; (4ae0 <readEEP()+0xc8>)
        lastMode = 0;
    4ab6:	4a0b      	ldr	r2, [pc, #44]	; (4ae4 <readEEP()+0xcc>)
        state.mode = MODE_STOCK;
    4ab8:	7023      	strb	r3, [r4, #0]
        lastMode = 0;
    4aba:	6013      	str	r3, [r2, #0]
        break;
    4abc:	e7ea      	b.n	4a94 <readEEP()+0x7c>
        state.mode_override = true;
    4abe:	2301      	movs	r3, #1
    4ac0:	4c07      	ldr	r4, [pc, #28]	; (4ae0 <readEEP()+0xc8>)
        lastMode = 1;
    4ac2:	4a08      	ldr	r2, [pc, #32]	; (4ae4 <readEEP()+0xcc>)
        state.mode_override = true;
    4ac4:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
        state.mode = MODE_FWD;
    4ac8:	7023      	strb	r3, [r4, #0]
        lastMode = 1;
    4aca:	6013      	str	r3, [r2, #0]
        break;
    4acc:	e7e2      	b.n	4a94 <readEEP()+0x7c>
        state.mode_override = true;
    4ace:	4c04      	ldr	r4, [pc, #16]	; (4ae0 <readEEP()+0xc8>)
        state.mode = MODE_5050;
    4ad0:	2302      	movs	r3, #2
    4ad2:	e7d9      	b.n	4a88 <readEEP()+0x70>
    4ad4:	4c02      	ldr	r4, [pc, #8]	; (4ae0 <readEEP()+0xc8>)
    4ad6:	e7dd      	b.n	4a94 <readEEP()+0x7c>
    4ad8:	20000d2c 	.word	0x20000d2c
    4adc:	20006ae6 	.word	0x20006ae6
    4ae0:	20006954 	.word	0x20006954
    4ae4:	200068c0 	.word	0x200068c0
    4ae8:	20006ae8 	.word	0x20006ae8

00004aec <writeEEP(void*)>:

bool writeEEP(void *params) {
    4aec:	b570      	push	{r4, r5, r6, lr}
  // only update if the value has changed
  switch (state.mode) {
    4aee:	4c26      	ldr	r4, [pc, #152]	; (4b88 <writeEEP(void*)+0x9c>)
    4af0:	4d26      	ldr	r5, [pc, #152]	; (4b8c <writeEEP(void*)+0xa0>)
    4af2:	7823      	ldrb	r3, [r4, #0]
    4af4:	2b03      	cmp	r3, #3
    4af6:	d805      	bhi.n	4b04 <writeEEP(void*)+0x18>
    4af8:	e8df f003 	tbb	[pc, r3]
    4afc:	023c3f42 	.word	0x023c3f42
      break;
    case MODE_5050:
      lastMode = 2;
      break;
    case MODE_CUSTOM:
      lastMode = 3;
    4b00:	2303      	movs	r3, #3
    4b02:	602b      	str	r3, [r5, #0]
      break;
  }

  // update EEP only if changes have been made
  EEPROM.update(0, softwareVersion);
    4b04:	4b22      	ldr	r3, [pc, #136]	; (4b90 <writeEEP(void*)+0xa4>)
    4b06:	2000      	movs	r0, #0
    4b08:	781e      	ldrb	r6, [r3, #0]
    4b0a:	f000 ff87 	bl	5a1c <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b0e:	4286      	cmp	r6, r0
    4b10:	d003      	beq.n	4b1a <writeEEP(void*)+0x2e>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b12:	4631      	mov	r1, r6
    4b14:	2000      	movs	r0, #0
    4b16:	f001 f88d 	bl	5c34 <eeprom_write_byte>
  EEPROM.update(1, isCustom);
    4b1a:	4b1e      	ldr	r3, [pc, #120]	; (4b94 <writeEEP(void*)+0xa8>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b1c:	2001      	movs	r0, #1
    4b1e:	781e      	ldrb	r6, [r3, #0]
    4b20:	f000 ff7c 	bl	5a1c <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b24:	4286      	cmp	r6, r0
    4b26:	d003      	beq.n	4b30 <writeEEP(void*)+0x44>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b28:	4631      	mov	r1, r6
    4b2a:	2001      	movs	r0, #1
    4b2c:	f001 f882 	bl	5c34 <eeprom_write_byte>
  EEPROM.update(2, lastMode);
    4b30:	782d      	ldrb	r5, [r5, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b32:	2002      	movs	r0, #2
    4b34:	f000 ff72 	bl	5a1c <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b38:	4285      	cmp	r5, r0
    4b3a:	d003      	beq.n	4b44 <writeEEP(void*)+0x58>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b3c:	4629      	mov	r1, r5
    4b3e:	2002      	movs	r0, #2
    4b40:	f001 f878 	bl	5c34 <eeprom_write_byte>
  EEPROM.update(3, isStandalone);
    4b44:	4b14      	ldr	r3, [pc, #80]	; (4b98 <writeEEP(void*)+0xac>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b46:	2003      	movs	r0, #3
    4b48:	781d      	ldrb	r5, [r3, #0]
    4b4a:	f000 ff67 	bl	5a1c <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b4e:	4285      	cmp	r5, r0
    4b50:	d003      	beq.n	4b5a <writeEEP(void*)+0x6e>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b52:	4629      	mov	r1, r5
    4b54:	2003      	movs	r0, #3
    4b56:	f001 f86d 	bl	5c34 <eeprom_write_byte>
  EEPROM.update(4, state.ped_threshold);
    4b5a:	f894 4022 	ldrb.w	r4, [r4, #34]	; 0x22
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b5e:	2004      	movs	r0, #4
    4b60:	f000 ff5c 	bl	5a1c <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b64:	4284      	cmp	r4, r0
    4b66:	d003      	beq.n	4b70 <writeEEP(void*)+0x84>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b68:	4621      	mov	r1, r4
    4b6a:	2004      	movs	r0, #4
    4b6c:	f001 f862 	bl	5c34 <eeprom_write_byte>
  Serial.printf("Is Standalone: %d\n", isStandalone);
  Serial.printf("Minimum Pedal: %d%\n", state.ped_threshold);
#endif /* stateDebug */

  return true;
}
    4b70:	2001      	movs	r0, #1
    4b72:	bd70      	pop	{r4, r5, r6, pc}
      lastMode = 2;
    4b74:	2302      	movs	r3, #2
    4b76:	602b      	str	r3, [r5, #0]
      break;
    4b78:	e7c4      	b.n	4b04 <writeEEP(void*)+0x18>
      lastMode = 1;
    4b7a:	2301      	movs	r3, #1
    4b7c:	602b      	str	r3, [r5, #0]
      break;
    4b7e:	e7c1      	b.n	4b04 <writeEEP(void*)+0x18>
      lastMode = 0;
    4b80:	2300      	movs	r3, #0
    4b82:	602b      	str	r3, [r5, #0]
      break;
    4b84:	e7be      	b.n	4b04 <writeEEP(void*)+0x18>
    4b86:	bf00      	nop
    4b88:	20006954 	.word	0x20006954
    4b8c:	200068c0 	.word	0x200068c0
    4b90:	20000d2c 	.word	0x20000d2c
    4b94:	20006ae6 	.word	0x20006ae6
    4b98:	20006ae8 	.word	0x20006ae8

00004b9c <_GLOBAL__sub_I__Z7readEEPv>:
    EEPROMClass()                        { eeprom_initialize(); }
    4b9c:	f000 bf1a 	b.w	59d4 <eeprom_initialize>

00004ba0 <EventResponder::triggerEvent(int, void*)>:
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    4ba0:	f890 c01c 	ldrb.w	ip, [r0, #28]
		_status = status;
    4ba4:	6041      	str	r1, [r0, #4]
		if (_type == EventTypeImmediate) {
    4ba6:	f1bc 0f02 	cmp.w	ip, #2
		_data = data;
    4baa:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    4bac:	d101      	bne.n	4bb2 <EventResponder::triggerEvent(int, void*)+0x12>
			(*_function)(*this);
    4bae:	6883      	ldr	r3, [r0, #8]
    4bb0:	4718      	bx	r3
		} else {
			triggerEventNotImmediate();
    4bb2:	f000 b917 	b.w	4de4 <EventResponder::triggerEventNotImmediate()>
    4bb6:	bf00      	nop

00004bb8 <_spi_dma_rxISR1()>:

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    4bb8:	4b32      	ldr	r3, [pc, #200]	; (4c84 <_spi_dma_rxISR1()+0xcc>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    4bba:	4933      	ldr	r1, [pc, #204]	; (4c88 <_spi_dma_rxISR1()+0xd0>)
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4bbc:	b530      	push	{r4, r5, lr}
	_dmaTX->clearComplete();
    4bbe:	e9d3 5411 	ldrd	r5, r4, [r3, #68]	; 0x44
    4bc2:	7920      	ldrb	r0, [r4, #4]
    4bc4:	77c8      	strb	r0, [r1, #31]
	_dmaRX->clearComplete();

	if (_dma_count_remaining) {
    4bc6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    4bc8:	f895 c004 	ldrb.w	ip, [r5, #4]
    4bcc:	f881 c01c 	strb.w	ip, [r1, #28]
    4bd0:	7708      	strb	r0, [r1, #28]
    4bd2:	b152      	cbz	r2, 4bea <_spi_dma_rxISR1()+0x32>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > MAX_DMA_COUNT) {
    4bd4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    4bd8:	d323      	bcc.n	4c22 <_spi_dma_rxISR1()+0x6a>
			_dma_count_remaining -= MAX_DMA_COUNT;
    4bda:	492c      	ldr	r1, [pc, #176]	; (4c8c <_spi_dma_rxISR1()+0xd4>)
    4bdc:	4411      	add	r1, r2
		DMA_SERQ = channel;
    4bde:	4a2a      	ldr	r2, [pc, #168]	; (4c88 <_spi_dma_rxISR1()+0xd0>)
    4be0:	6419      	str	r1, [r3, #64]	; 0x40
    4be2:	76d0      	strb	r0, [r2, #27]
    4be4:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4be8:	bd30      	pop	{r4, r5, pc}
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    4bea:	6819      	ldr	r1, [r3, #0]
		}
		_dmaRX->enable();
		_dmaTX->enable();
	} else {

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4bec:	240f      	movs	r4, #15

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    4bee:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4bf0:	658c      	str	r4, [r1, #88]	; 0x58
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4bf2:	f240 3401 	movw	r4, #769	; 0x301
 		port().DER = 0;		// DMA no longer doing TX (or RX)
    4bf6:	61ca      	str	r2, [r1, #28]
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4bf8:	610c      	str	r4, [r1, #16]
		port().SR = 0x3f00;	// clear out all of the other status...
    4bfa:	f44f 547c 	mov.w	r4, #16128	; 0x3f00
    4bfe:	614c      	str	r4, [r1, #20]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4c00:	2103      	movs	r1, #3
		_dma_event_responder->triggerEvent();
    4c02:	6804      	ldr	r4, [r0, #0]
    4c04:	6824      	ldr	r4, [r4, #0]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4c06:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
		_dma_event_responder->triggerEvent();
    4c0a:	4b21      	ldr	r3, [pc, #132]	; (4c90 <_spi_dma_rxISR1()+0xd8>)
    4c0c:	429c      	cmp	r4, r3
    4c0e:	d126      	bne.n	4c5e <_spi_dma_rxISR1()+0xa6>
		if (_type == EventTypeImmediate) {
    4c10:	7f03      	ldrb	r3, [r0, #28]
		_status = status;
    4c12:	6042      	str	r2, [r0, #4]
		if (_type == EventTypeImmediate) {
    4c14:	2b02      	cmp	r3, #2
		_data = data;
    4c16:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    4c18:	d126      	bne.n	4c68 <_spi_dma_rxISR1()+0xb0>
			(*_function)(*this);
    4c1a:	6883      	ldr	r3, [r0, #8]
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c1c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    4c20:	4718      	bx	r3
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
    4c22:	682d      	ldr	r5, [r5, #0]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4c24:	8be9      	ldrh	r1, [r5, #30]
    4c26:	0409      	lsls	r1, r1, #16
    4c28:	d422      	bmi.n	4c70 <_spi_dma_rxISR1()+0xb8>
		tcd->BITER = len & 0x7fff;
    4c2a:	b292      	uxth	r2, r2
    4c2c:	83ea      	strh	r2, [r5, #30]
	tcd->CITER = tcd->BITER; 
    4c2e:	6821      	ldr	r1, [r4, #0]
    4c30:	8bec      	ldrh	r4, [r5, #30]
    4c32:	b2a4      	uxth	r4, r4
    4c34:	82ec      	strh	r4, [r5, #22]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4c36:	8bcc      	ldrh	r4, [r1, #30]
    4c38:	0424      	lsls	r4, r4, #16
    4c3a:	d505      	bpl.n	4c48 <_spi_dma_rxISR1()+0x90>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4c3c:	8bcc      	ldrh	r4, [r1, #30]
    4c3e:	f3c2 0208 	ubfx	r2, r2, #0, #9
    4c42:	f404 447e 	and.w	r4, r4, #65024	; 0xfe00
    4c46:	4322      	orrs	r2, r4
    4c48:	83ca      	strh	r2, [r1, #30]
	tcd->CITER = tcd->BITER; 
    4c4a:	8bca      	ldrh	r2, [r1, #30]
    4c4c:	b292      	uxth	r2, r2
    4c4e:	82ca      	strh	r2, [r1, #22]
    4c50:	2100      	movs	r1, #0
    4c52:	4a0d      	ldr	r2, [pc, #52]	; (4c88 <_spi_dma_rxISR1()+0xd0>)
			_dma_count_remaining -= MAX_DMA_COUNT;
    4c54:	6419      	str	r1, [r3, #64]	; 0x40
    4c56:	76d0      	strb	r0, [r2, #27]
    4c58:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c5c:	bd30      	pop	{r4, r5, pc}
		_dma_event_responder->triggerEvent();
    4c5e:	4623      	mov	r3, r4
    4c60:	4611      	mov	r1, r2
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c62:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		_dma_event_responder->triggerEvent();
    4c66:	4718      	bx	r3
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			triggerEventNotImmediate();
    4c6c:	f000 b8ba 	b.w	4de4 <EventResponder::triggerEventNotImmediate()>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4c70:	8be9      	ldrh	r1, [r5, #30]
    4c72:	f3c2 0e08 	ubfx	lr, r2, #0, #9
    4c76:	b292      	uxth	r2, r2
    4c78:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
    4c7c:	ea41 010e 	orr.w	r1, r1, lr
    4c80:	83e9      	strh	r1, [r5, #30]
    4c82:	e7d4      	b.n	4c2e <_spi_dma_rxISR1()+0x76>
    4c84:	20006708 	.word	0x20006708
    4c88:	400e8000 	.word	0x400e8000
    4c8c:	ffff8001 	.word	0xffff8001
    4c90:	00004ba1 	.word	0x00004ba1

00004c94 <_spi_dma_rxISR0()>:
	_dmaRX->clearInterrupt();
    4c94:	4b32      	ldr	r3, [pc, #200]	; (4d60 <_spi_dma_rxISR0()+0xcc>)
		DMA_CINT = channel;
    4c96:	4933      	ldr	r1, [pc, #204]	; (4d64 <_spi_dma_rxISR0()+0xd0>)
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4c98:	b530      	push	{r4, r5, lr}
	_dmaTX->clearComplete();
    4c9a:	e9d3 5411 	ldrd	r5, r4, [r3, #68]	; 0x44
    4c9e:	7920      	ldrb	r0, [r4, #4]
    4ca0:	77c8      	strb	r0, [r1, #31]
	if (_dma_count_remaining) {
    4ca2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
		DMA_CDNE = channel;
    4ca4:	f895 c004 	ldrb.w	ip, [r5, #4]
    4ca8:	f881 c01c 	strb.w	ip, [r1, #28]
    4cac:	7708      	strb	r0, [r1, #28]
    4cae:	b152      	cbz	r2, 4cc6 <_spi_dma_rxISR0()+0x32>
		if (_dma_count_remaining > MAX_DMA_COUNT) {
    4cb0:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    4cb4:	d323      	bcc.n	4cfe <_spi_dma_rxISR0()+0x6a>
			_dma_count_remaining -= MAX_DMA_COUNT;
    4cb6:	492c      	ldr	r1, [pc, #176]	; (4d68 <_spi_dma_rxISR0()+0xd4>)
    4cb8:	4411      	add	r1, r2
		DMA_SERQ = channel;
    4cba:	4a2a      	ldr	r2, [pc, #168]	; (4d64 <_spi_dma_rxISR0()+0xd0>)
    4cbc:	6419      	str	r1, [r3, #64]	; 0x40
    4cbe:	76d0      	strb	r0, [r2, #27]
    4cc0:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4cc4:	bd30      	pop	{r4, r5, pc}
    4cc6:	6819      	ldr	r1, [r3, #0]
		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4cc8:	240f      	movs	r4, #15
		_dma_event_responder->triggerEvent();
    4cca:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4ccc:	658c      	str	r4, [r1, #88]	; 0x58
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4cce:	f240 3401 	movw	r4, #769	; 0x301
 		port().DER = 0;		// DMA no longer doing TX (or RX)
    4cd2:	61ca      	str	r2, [r1, #28]
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4cd4:	610c      	str	r4, [r1, #16]
		port().SR = 0x3f00;	// clear out all of the other status...
    4cd6:	f44f 547c 	mov.w	r4, #16128	; 0x3f00
    4cda:	614c      	str	r4, [r1, #20]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4cdc:	2103      	movs	r1, #3
		_dma_event_responder->triggerEvent();
    4cde:	6804      	ldr	r4, [r0, #0]
    4ce0:	6824      	ldr	r4, [r4, #0]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4ce2:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
		_dma_event_responder->triggerEvent();
    4ce6:	4b21      	ldr	r3, [pc, #132]	; (4d6c <_spi_dma_rxISR0()+0xd8>)
    4ce8:	429c      	cmp	r4, r3
    4cea:	d126      	bne.n	4d3a <_spi_dma_rxISR0()+0xa6>
		if (_type == EventTypeImmediate) {
    4cec:	7f03      	ldrb	r3, [r0, #28]
		_status = status;
    4cee:	6042      	str	r2, [r0, #4]
		if (_type == EventTypeImmediate) {
    4cf0:	2b02      	cmp	r3, #2
		_data = data;
    4cf2:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    4cf4:	d126      	bne.n	4d44 <_spi_dma_rxISR0()+0xb0>
			(*_function)(*this);
    4cf6:	6883      	ldr	r3, [r0, #8]
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4cf8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    4cfc:	4718      	bx	r3
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
    4cfe:	682d      	ldr	r5, [r5, #0]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4d00:	8be9      	ldrh	r1, [r5, #30]
    4d02:	0409      	lsls	r1, r1, #16
    4d04:	d422      	bmi.n	4d4c <_spi_dma_rxISR0()+0xb8>
		tcd->BITER = len & 0x7fff;
    4d06:	b292      	uxth	r2, r2
    4d08:	83ea      	strh	r2, [r5, #30]
	tcd->CITER = tcd->BITER; 
    4d0a:	6821      	ldr	r1, [r4, #0]
    4d0c:	8bec      	ldrh	r4, [r5, #30]
    4d0e:	b2a4      	uxth	r4, r4
    4d10:	82ec      	strh	r4, [r5, #22]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4d12:	8bcc      	ldrh	r4, [r1, #30]
    4d14:	0424      	lsls	r4, r4, #16
    4d16:	d505      	bpl.n	4d24 <_spi_dma_rxISR0()+0x90>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4d18:	8bcc      	ldrh	r4, [r1, #30]
    4d1a:	f3c2 0208 	ubfx	r2, r2, #0, #9
    4d1e:	f404 447e 	and.w	r4, r4, #65024	; 0xfe00
    4d22:	4322      	orrs	r2, r4
    4d24:	83ca      	strh	r2, [r1, #30]
	tcd->CITER = tcd->BITER; 
    4d26:	8bca      	ldrh	r2, [r1, #30]
    4d28:	b292      	uxth	r2, r2
    4d2a:	82ca      	strh	r2, [r1, #22]
    4d2c:	2100      	movs	r1, #0
    4d2e:	4a0d      	ldr	r2, [pc, #52]	; (4d64 <_spi_dma_rxISR0()+0xd0>)
			_dma_count_remaining -= MAX_DMA_COUNT;
    4d30:	6419      	str	r1, [r3, #64]	; 0x40
    4d32:	76d0      	strb	r0, [r2, #27]
    4d34:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d38:	bd30      	pop	{r4, r5, pc}
		_dma_event_responder->triggerEvent();
    4d3a:	4623      	mov	r3, r4
    4d3c:	4611      	mov	r1, r2
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d3e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		_dma_event_responder->triggerEvent();
    4d42:	4718      	bx	r3
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d44:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			triggerEventNotImmediate();
    4d48:	f000 b84c 	b.w	4de4 <EventResponder::triggerEventNotImmediate()>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4d4c:	8be9      	ldrh	r1, [r5, #30]
    4d4e:	f3c2 0e08 	ubfx	lr, r2, #0, #9
    4d52:	b292      	uxth	r2, r2
    4d54:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
    4d58:	ea41 010e 	orr.w	r1, r1, lr
    4d5c:	83e9      	strh	r1, [r5, #30]
    4d5e:	e7d4      	b.n	4d0a <_spi_dma_rxISR0()+0x76>
    4d60:	200066b8 	.word	0x200066b8
    4d64:	400e8000 	.word	0x400e8000
    4d68:	ffff8001 	.word	0xffff8001
    4d6c:	00004ba1 	.word	0x00004ba1

00004d70 <SPIClass::SPIClass(unsigned int, unsigned int)>:
		: port_addr(myport), hardware_addr(myhardware) {
    4d70:	2300      	movs	r3, #0
    4d72:	e9c0 1200 	strd	r1, r2, [r0]
    4d76:	e9c0 3302 	strd	r3, r3, [r0, #8]
    4d7a:	e9c0 3304 	strd	r3, r3, [r0, #16]
    4d7e:	e9c0 3306 	strd	r3, r3, [r0, #24]
    4d82:	e9c0 3308 	strd	r3, r3, [r0, #32]
    4d86:	e9c0 330a 	strd	r3, r3, [r0, #40]	; 0x28
    4d8a:	e9c0 330c 	strd	r3, r3, [r0, #48]	; 0x30
    4d8e:	6383      	str	r3, [r0, #56]	; 0x38
    4d90:	8783      	strh	r3, [r0, #60]	; 0x3c
    4d92:	e9c0 3310 	strd	r3, r3, [r0, #64]	; 0x40
    4d96:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
	}
    4d9a:	4770      	bx	lr

00004d9c <_GLOBAL__sub_I__ZN8SPIClass5beginEv>:

	}
}
    4d9c:	b508      	push	{r3, lr}
SPIClass SPI((uintptr_t)&IMXRT_LPSPI4_S, (uintptr_t)&SPIClass::spiclass_lpspi4_hardware);
    4d9e:	4a08      	ldr	r2, [pc, #32]	; (4dc0 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x24>)
    4da0:	4908      	ldr	r1, [pc, #32]	; (4dc4 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x28>)
    4da2:	4809      	ldr	r0, [pc, #36]	; (4dc8 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x2c>)
    4da4:	f7ff ffe4 	bl	4d70 <SPIClass::SPIClass(unsigned int, unsigned int)>
SPIClass SPI1((uintptr_t)&IMXRT_LPSPI3_S, (uintptr_t)&SPIClass::spiclass_lpspi3_hardware);
    4da8:	4a08      	ldr	r2, [pc, #32]	; (4dcc <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x30>)
    4daa:	4909      	ldr	r1, [pc, #36]	; (4dd0 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x34>)
    4dac:	4809      	ldr	r0, [pc, #36]	; (4dd4 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x38>)
    4dae:	f7ff ffdf 	bl	4d70 <SPIClass::SPIClass(unsigned int, unsigned int)>
SPIClass SPI2((uintptr_t)&IMXRT_LPSPI1_S, (uintptr_t)&SPIClass::spiclass_lpspi1_hardware);
    4db2:	4a09      	ldr	r2, [pc, #36]	; (4dd8 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x3c>)
    4db4:	4909      	ldr	r1, [pc, #36]	; (4ddc <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x40>)
    4db6:	480a      	ldr	r0, [pc, #40]	; (4de0 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x44>)
    4db8:	f7ff ffda 	bl	4d70 <SPIClass::SPIClass(unsigned int, unsigned int)>
}
    4dbc:	bd08      	pop	{r3, pc}
    4dbe:	bf00      	nop
    4dc0:	200005d8 	.word	0x200005d8
    4dc4:	403a0000 	.word	0x403a0000
    4dc8:	200066b8 	.word	0x200066b8
    4dcc:	20000588 	.word	0x20000588
    4dd0:	4039c000 	.word	0x4039c000
    4dd4:	20006708 	.word	0x20006708
    4dd8:	20000538 	.word	0x20000538
    4ddc:	40394000 	.word	0x40394000
    4de0:	20006758 	.word	0x20006758

00004de4 <EventResponder::triggerEventNotImmediate()>:
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4de4:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4de8:	b672      	cpsid	i
	if (_triggered == false) {
    4dea:	7f43      	ldrb	r3, [r0, #29]
    4dec:	b95b      	cbnz	r3, 4e06 <EventResponder::triggerEventNotImmediate()+0x22>
		if (_type == EventTypeYield) {
    4dee:	7f01      	ldrb	r1, [r0, #28]
    4df0:	2901      	cmp	r1, #1
{
    4df2:	b430      	push	{r4, r5}
		if (_type == EventTypeYield) {
    4df4:	d00b      	beq.n	4e0e <EventResponder::triggerEventNotImmediate()+0x2a>
		} else if (_type == EventTypeInterrupt) {
    4df6:	2903      	cmp	r1, #3
    4df8:	d013      	beq.n	4e22 <EventResponder::triggerEventNotImmediate()+0x3e>
		_triggered = true;
    4dfa:	2301      	movs	r3, #1
    4dfc:	7743      	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4dfe:	b902      	cbnz	r2, 4e02 <EventResponder::triggerEventNotImmediate()+0x1e>
    4e00:	b662      	cpsie	i
}
    4e02:	bc30      	pop	{r4, r5}
    4e04:	4770      	bx	lr
    4e06:	b90a      	cbnz	r2, 4e0c <EventResponder::triggerEventNotImmediate()+0x28>
    4e08:	b662      	cpsie	i
    4e0a:	4770      	bx	lr
    4e0c:	4770      	bx	lr
			if (firstYield == nullptr) {
    4e0e:	4c12      	ldr	r4, [pc, #72]	; (4e58 <EventResponder::triggerEventNotImmediate()+0x74>)
    4e10:	6821      	ldr	r1, [r4, #0]
    4e12:	b1b1      	cbz	r1, 4e42 <EventResponder::triggerEventNotImmediate()+0x5e>
				_prev = lastYield;
    4e14:	4911      	ldr	r1, [pc, #68]	; (4e5c <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
    4e16:	6143      	str	r3, [r0, #20]
				_prev = lastYield;
    4e18:	680b      	ldr	r3, [r1, #0]
				lastYield = this;
    4e1a:	6008      	str	r0, [r1, #0]
				_prev = lastYield;
    4e1c:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
    4e1e:	6158      	str	r0, [r3, #20]
				lastYield = this;
    4e20:	e7eb      	b.n	4dfa <EventResponder::triggerEventNotImmediate()+0x16>
			if (firstInterrupt == nullptr) {
    4e22:	4d0f      	ldr	r5, [pc, #60]	; (4e60 <EventResponder::triggerEventNotImmediate()+0x7c>)
    4e24:	490f      	ldr	r1, [pc, #60]	; (4e64 <EventResponder::triggerEventNotImmediate()+0x80>)
    4e26:	682c      	ldr	r4, [r5, #0]
    4e28:	b18c      	cbz	r4, 4e4e <EventResponder::triggerEventNotImmediate()+0x6a>
				_next = nullptr;
    4e2a:	6143      	str	r3, [r0, #20]
				_prev = lastInterrupt;
    4e2c:	680b      	ldr	r3, [r1, #0]
    4e2e:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
    4e30:	6158      	str	r0, [r3, #20]
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    4e32:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    4e36:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
				lastInterrupt = this;
    4e3a:	6008      	str	r0, [r1, #0]
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    4e3c:	f8c3 4d04 	str.w	r4, [r3, #3332]	; 0xd04
    4e40:	e7db      	b.n	4dfa <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
    4e42:	4b06      	ldr	r3, [pc, #24]	; (4e5c <EventResponder::triggerEventNotImmediate()+0x78>)
				firstYield = this;
    4e44:	6020      	str	r0, [r4, #0]
				lastYield = this;
    4e46:	6018      	str	r0, [r3, #0]
				_prev = nullptr;
    4e48:	e9c0 1105 	strd	r1, r1, [r0, #20]
				lastYield = this;
    4e4c:	e7d5      	b.n	4dfa <EventResponder::triggerEventNotImmediate()+0x16>
				_prev = nullptr;
    4e4e:	e9c0 4405 	strd	r4, r4, [r0, #20]
				firstInterrupt = this;
    4e52:	6028      	str	r0, [r5, #0]
				lastInterrupt = this;
    4e54:	e7ed      	b.n	4e32 <EventResponder::triggerEventNotImmediate()+0x4e>
    4e56:	bf00      	nop
    4e58:	20006878 	.word	0x20006878
    4e5c:	20006884 	.word	0x20006884
    4e60:	20006880 	.word	0x20006880
    4e64:	2000687c 	.word	0x2000687c

00004e68 <EventResponder::runFromInterrupt()>:
{
    4e68:	b570      	push	{r4, r5, r6, lr}
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4e6a:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4e6e:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    4e70:	4c0c      	ldr	r4, [pc, #48]	; (4ea4 <EventResponder::runFromInterrupt()+0x3c>)
    4e72:	6820      	ldr	r0, [r4, #0]
		if (first) {
    4e74:	b180      	cbz	r0, 4e98 <EventResponder::runFromInterrupt()+0x30>
				lastInterrupt = nullptr;
    4e76:	4e0c      	ldr	r6, [pc, #48]	; (4ea8 <EventResponder::runFromInterrupt()+0x40>)
				firstInterrupt->_prev = nullptr;
    4e78:	2500      	movs	r5, #0
			firstInterrupt = first->_next;
    4e7a:	6943      	ldr	r3, [r0, #20]
    4e7c:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    4e7e:	b173      	cbz	r3, 4e9e <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    4e80:	619d      	str	r5, [r3, #24]
		if (doit) __enable_irq();
    4e82:	b902      	cbnz	r2, 4e86 <EventResponder::runFromInterrupt()+0x1e>
    4e84:	b662      	cpsie	i
			(*(first->_function))(*first);
    4e86:	6883      	ldr	r3, [r0, #8]
			first->_triggered = false;
    4e88:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    4e8a:	4798      	blx	r3
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4e8c:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4e90:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    4e92:	6820      	ldr	r0, [r4, #0]
		if (first) {
    4e94:	2800      	cmp	r0, #0
    4e96:	d1f0      	bne.n	4e7a <EventResponder::runFromInterrupt()+0x12>
		if (doit) __enable_irq();
    4e98:	b902      	cbnz	r2, 4e9c <EventResponder::runFromInterrupt()+0x34>
    4e9a:	b662      	cpsie	i
}
    4e9c:	bd70      	pop	{r4, r5, r6, pc}
				lastInterrupt = nullptr;
    4e9e:	6033      	str	r3, [r6, #0]
    4ea0:	e7ef      	b.n	4e82 <EventResponder::runFromInterrupt()+0x1a>
    4ea2:	bf00      	nop
    4ea4:	20006880 	.word	0x20006880
    4ea8:	2000687c 	.word	0x2000687c

00004eac <pendablesrvreq_isr>:
	EventResponder::runFromInterrupt();
    4eac:	f7ff bfdc 	b.w	4e68 <EventResponder::runFromInterrupt()>

00004eb0 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    4eb0:	4904      	ldr	r1, [pc, #16]	; (4ec4 <systick_isr+0x14>)
	systick_millis_count++;
    4eb2:	4a05      	ldr	r2, [pc, #20]	; (4ec8 <systick_isr+0x18>)
	systick_cycle_count = ARM_DWT_CYCCNT;
    4eb4:	6849      	ldr	r1, [r1, #4]
    4eb6:	4b05      	ldr	r3, [pc, #20]	; (4ecc <systick_isr+0x1c>)
    4eb8:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    4eba:	6813      	ldr	r3, [r2, #0]
    4ebc:	3301      	adds	r3, #1
    4ebe:	6013      	str	r3, [r2, #0]
}
    4ec0:	4770      	bx	lr
    4ec2:	bf00      	nop
    4ec4:	e0001000 	.word	0xe0001000
    4ec8:	2000697c 	.word	0x2000697c
    4ecc:	20006978 	.word	0x20006978

00004ed0 <HardwareSerial::availableForWrite()>:

int HardwareSerial::availableForWrite(void)
{
	uint32_t head, tail;

	head = tx_buffer_head_;
    4ed0:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
	tail = tx_buffer_tail_;
    4ed4:	f8b0 2048 	ldrh.w	r2, [r0, #72]	; 0x48
	head = tx_buffer_head_;
    4ed8:	b29b      	uxth	r3, r3
	tail = tx_buffer_tail_;
    4eda:	b292      	uxth	r2, r2
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    4edc:	4293      	cmp	r3, r2
    4ede:	d202      	bcs.n	4ee6 <HardwareSerial::availableForWrite()+0x16>
	return tail - head - 1;
    4ee0:	3a01      	subs	r2, #1
    4ee2:	1ad0      	subs	r0, r2, r3
}
    4ee4:	4770      	bx	lr
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    4ee6:	6b41      	ldr	r1, [r0, #52]	; 0x34
    4ee8:	3901      	subs	r1, #1
    4eea:	440a      	add	r2, r1
    4eec:	1ad0      	subs	r0, r2, r3
    4eee:	4770      	bx	lr

00004ef0 <HardwareSerial::available()>:
int HardwareSerial::available(void)
{
	uint32_t head, tail;

	// WATER> 0 so IDLE involved may want to check if port has already has RX data to retrieve
	__disable_irq();
    4ef0:	b672      	cpsid	i
	head = rx_buffer_head_;
    4ef2:	f8b0 204a 	ldrh.w	r2, [r0, #74]	; 0x4a
	tail = rx_buffer_tail_;
    4ef6:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    4efa:	b292      	uxth	r2, r2
	tail = rx_buffer_tail_;
    4efc:	b29b      	uxth	r3, r3
	int avail;
	if (head >= tail) avail = head - tail;
    4efe:	429a      	cmp	r2, r3
	else avail = rx_buffer_total_size_ + head - tail;	
    4f00:	bf3c      	itt	cc
    4f02:	6b81      	ldrcc	r1, [r0, #56]	; 0x38
    4f04:	1852      	addcc	r2, r2, r1
    4f06:	1ad3      	subs	r3, r2, r3
	avail += (port->WATER >> 24) & 0x7;
    4f08:	6902      	ldr	r2, [r0, #16]
    4f0a:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
	__enable_irq();
    4f0c:	b662      	cpsie	i
	avail += (port->WATER >> 24) & 0x7;
    4f0e:	f3c0 6002 	ubfx	r0, r0, #24, #3
	return avail;
}
    4f12:	4418      	add	r0, r3
    4f14:	4770      	bx	lr
    4f16:	bf00      	nop

00004f18 <HardwareSerial::peek()>:

int HardwareSerial::peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head_;
    4f18:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    4f1c:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    4f1e:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    4f22:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    4f24:	b29b      	uxth	r3, r3
	if (head == tail) {
    4f26:	4299      	cmp	r1, r3
    4f28:	d010      	beq.n	4f4c <HardwareSerial::peek()+0x34>
			return c;
		}
		__enable_irq();

	} 
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4f2a:	3301      	adds	r3, #1
    4f2c:	6b90      	ldr	r0, [r2, #56]	; 0x38
	if (tail < rx_buffer_size_) {
    4f2e:	6b11      	ldr	r1, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4f30:	4298      	cmp	r0, r3
    4f32:	bf98      	it	ls
    4f34:	2300      	movls	r3, #0
	if (tail < rx_buffer_size_) {
    4f36:	4299      	cmp	r1, r3
    4f38:	d903      	bls.n	4f42 <HardwareSerial::peek()+0x2a>
		return rx_buffer_[tail];
    4f3a:	6a12      	ldr	r2, [r2, #32]
    4f3c:	5cd0      	ldrb	r0, [r2, r3]
    4f3e:	b2c0      	uxtb	r0, r0
    4f40:	4770      	bx	lr
	} else {
		return rx_buffer_storage_[tail-rx_buffer_size_];
    4f42:	1a5b      	subs	r3, r3, r1
    4f44:	6a52      	ldr	r2, [r2, #36]	; 0x24
    4f46:	5cd0      	ldrb	r0, [r2, r3]
    4f48:	b2c0      	uxtb	r0, r0
	}
}
    4f4a:	4770      	bx	lr
		__disable_irq();
    4f4c:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    4f4e:	f8b0 004a 	ldrh.w	r0, [r0, #74]	; 0x4a
    4f52:	b280      	uxth	r0, r0
		if (head == tail) {
    4f54:	4281      	cmp	r1, r0
    4f56:	d001      	beq.n	4f5c <HardwareSerial::peek()+0x44>
		__enable_irq();
    4f58:	b662      	cpsie	i
    4f5a:	e7e6      	b.n	4f2a <HardwareSerial::peek()+0x12>
			if (port->WATER & 0x7000000) {
    4f5c:	6913      	ldr	r3, [r2, #16]
    4f5e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    4f60:	f011 6fe0 	tst.w	r1, #117440512	; 0x7000000
    4f64:	d103      	bne.n	4f6e <HardwareSerial::peek()+0x56>
			int c = -1;	// assume nothing to return
    4f66:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    4f6a:	b662      	cpsie	i
			return c;
    4f6c:	4770      	bx	lr
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    4f6e:	69db      	ldr	r3, [r3, #28]
				rx_buffer_head_ = 1;
    4f70:	2001      	movs	r0, #1
				rx_buffer_tail_ = 0; 
    4f72:	f04f 0c00 	mov.w	ip, #0
				rx_buffer_[1] = c;
    4f76:	6a11      	ldr	r1, [r2, #32]
				rx_buffer_head_ = 1;
    4f78:	f8a2 004a 	strh.w	r0, [r2, #74]	; 0x4a
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    4f7c:	f3c3 0009 	ubfx	r0, r3, #0, #10
				rx_buffer_[1] = c;
    4f80:	b2db      	uxtb	r3, r3
				rx_buffer_tail_ = 0; 
    4f82:	f8a2 c04c 	strh.w	ip, [r2, #76]	; 0x4c
				rx_buffer_[1] = c;
    4f86:	704b      	strb	r3, [r1, #1]
    4f88:	e7ef      	b.n	4f6a <HardwareSerial::peek()+0x52>
    4f8a:	bf00      	nop

00004f8c <HardwareSerial::read()>:
int HardwareSerial::read(void)
{
	uint32_t head, tail;
	int c;

	head = rx_buffer_head_;
    4f8c:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    4f90:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    4f92:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    4f96:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    4f98:	b29b      	uxth	r3, r3
	if (head == tail) {
    4f9a:	4299      	cmp	r1, r3
    4f9c:	d026      	beq.n	4fec <HardwareSerial::read()+0x60>
			return c;
		}
		__enable_irq();

	}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4f9e:	3301      	adds	r3, #1
{
    4fa0:	b430      	push	{r4, r5}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4fa2:	6b94      	ldr	r4, [r2, #56]	; 0x38
    4fa4:	429c      	cmp	r4, r3
    4fa6:	d916      	bls.n	4fd6 <HardwareSerial::read()+0x4a>
	if (tail < rx_buffer_size_) {
    4fa8:	6b10      	ldr	r0, [r2, #48]	; 0x30
		c = rx_buffer_[tail];
	} else {
		c = rx_buffer_storage_[tail-rx_buffer_size_];
	}
	rx_buffer_tail_ = tail;
    4faa:	fa1f fc83 	uxth.w	ip, r3
	if (tail < rx_buffer_size_) {
    4fae:	4298      	cmp	r0, r3
    4fb0:	d917      	bls.n	4fe2 <HardwareSerial::read()+0x56>
		c = rx_buffer_[tail];
    4fb2:	6a10      	ldr	r0, [r2, #32]
    4fb4:	5cc0      	ldrb	r0, [r0, r3]
    4fb6:	b2c0      	uxtb	r0, r0
	if (rts_pin_baseReg_) {
    4fb8:	6d95      	ldr	r5, [r2, #88]	; 0x58
	rx_buffer_tail_ = tail;
    4fba:	f8a2 c04c 	strh.w	ip, [r2, #76]	; 0x4c
	if (rts_pin_baseReg_) {
    4fbe:	b145      	cbz	r5, 4fd2 <HardwareSerial::read()+0x46>
		uint32_t avail;
		if (head >= tail) avail = head - tail;
    4fc0:	4299      	cmp	r1, r3
    4fc2:	d31c      	bcc.n	4ffe <HardwareSerial::read()+0x72>
    4fc4:	1acb      	subs	r3, r1, r3
		else avail = rx_buffer_total_size_ + head - tail;

		if (avail <= rts_low_watermark_) rts_assert();
    4fc6:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
    4fc8:	4299      	cmp	r1, r3
    4fca:	d302      	bcc.n	4fd2 <HardwareSerial::read()+0x46>
	DIRECT_WRITE_LOW(rts_pin_baseReg_, rts_pin_bitmask_);
    4fcc:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    4fce:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
	}
	return c;
}	
    4fd2:	bc30      	pop	{r4, r5}
    4fd4:	4770      	bx	lr
    4fd6:	f04f 0c00 	mov.w	ip, #0
	if (tail < rx_buffer_size_) {
    4fda:	6b10      	ldr	r0, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4fdc:	4663      	mov	r3, ip
	if (tail < rx_buffer_size_) {
    4fde:	4298      	cmp	r0, r3
    4fe0:	d8e7      	bhi.n	4fb2 <HardwareSerial::read()+0x26>
		c = rx_buffer_storage_[tail-rx_buffer_size_];
    4fe2:	1a18      	subs	r0, r3, r0
    4fe4:	6a55      	ldr	r5, [r2, #36]	; 0x24
    4fe6:	5c28      	ldrb	r0, [r5, r0]
    4fe8:	b2c0      	uxtb	r0, r0
    4fea:	e7e5      	b.n	4fb8 <HardwareSerial::read()+0x2c>
    4fec:	4608      	mov	r0, r1
		__disable_irq();
    4fee:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    4ff0:	f8b2 104a 	ldrh.w	r1, [r2, #74]	; 0x4a
    4ff4:	b289      	uxth	r1, r1
		if (head == tail) {
    4ff6:	4288      	cmp	r0, r1
    4ff8:	d004      	beq.n	5004 <HardwareSerial::read()+0x78>
		__enable_irq();
    4ffa:	b662      	cpsie	i
    4ffc:	e7cf      	b.n	4f9e <HardwareSerial::read()+0x12>
		else avail = rx_buffer_total_size_ + head - tail;
    4ffe:	440c      	add	r4, r1
    5000:	1ae3      	subs	r3, r4, r3
    5002:	e7e0      	b.n	4fc6 <HardwareSerial::read()+0x3a>
			if (port->WATER & 0x7000000) {
    5004:	6913      	ldr	r3, [r2, #16]
    5006:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    5008:	f012 6fe0 	tst.w	r2, #117440512	; 0x7000000
    500c:	d103      	bne.n	5016 <HardwareSerial::read()+0x8a>
			c = -1;	// assume nothing to return
    500e:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    5012:	b662      	cpsie	i
}	
    5014:	4770      	bx	lr
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5016:	69d8      	ldr	r0, [r3, #28]
    5018:	f3c0 0009 	ubfx	r0, r0, #0, #10
    501c:	e7f9      	b.n	5012 <HardwareSerial::read()+0x86>
    501e:	bf00      	nop

00005020 <HardwareSerial::flush()>:

void HardwareSerial::flush(void)
{
	while (transmitting_) yield(); // wait
    5020:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
    5024:	b143      	cbz	r3, 5038 <HardwareSerial::flush()+0x18>
{
    5026:	b510      	push	{r4, lr}
    5028:	4604      	mov	r4, r0
	while (transmitting_) yield(); // wait
    502a:	f002 faa9 	bl	7580 <yield>
    502e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    5032:	2b00      	cmp	r3, #0
    5034:	d1f9      	bne.n	502a <HardwareSerial::flush()+0xa>
}
    5036:	bd10      	pop	{r4, pc}
    5038:	4770      	bx	lr
    503a:	bf00      	nop

0000503c <nvic_execution_priority()>:
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
    503c:	f3ef 8013 	mrs	r0, FAULTMASK
	if (faultmask) return -1;
    5040:	b9b8      	cbnz	r0, 5072 <nvic_execution_priority()+0x36>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    5042:	f3ef 8310 	mrs	r3, PRIMASK
	if (primask) return 0;
    5046:	b94b      	cbnz	r3, 505c <nvic_execution_priority()+0x20>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    5048:	f3ef 8205 	mrs	r2, IPSR
	if (ipsr) {
    504c:	b93a      	cbnz	r2, 505e <nvic_execution_priority()+0x22>
	uint32_t priority=256;
    504e:	f44f 7380 	mov.w	r3, #256	; 0x100
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    5052:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    5056:	b150      	cbz	r0, 506e <nvic_execution_priority()+0x32>
    5058:	4298      	cmp	r0, r3
    505a:	d208      	bcs.n	506e <nvic_execution_priority()+0x32>
}
    505c:	4770      	bx	lr
		if (ipsr < 16) priority = 0; // could be non-zero
    505e:	2a0f      	cmp	r2, #15
    5060:	d9f7      	bls.n	5052 <nvic_execution_priority()+0x16>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
    5062:	4b05      	ldr	r3, [pc, #20]	; (5078 <nvic_execution_priority()+0x3c>)
    5064:	5c9b      	ldrb	r3, [r3, r2]
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    5066:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    506a:	2800      	cmp	r0, #0
    506c:	d1f4      	bne.n	5058 <nvic_execution_priority()+0x1c>
    506e:	4618      	mov	r0, r3
	return priority;
    5070:	4770      	bx	lr
	if (faultmask) return -1;
    5072:	f04f 30ff 	mov.w	r0, #4294967295
    5076:	e7f1      	b.n	505c <nvic_execution_priority()+0x20>
    5078:	e000e3f0 	.word	0xe000e3f0

0000507c <HardwareSerial::begin(unsigned long, unsigned short)>:
	float base = (float)UART_CLOCK / (float)baud;
    507c:	ee07 1a90 	vmov	s15, r1
    5080:	ed9f 7a91 	vldr	s14, [pc, #580]	; 52c8 <HardwareSerial::begin(unsigned long, unsigned short)+0x24c>
	for (int osr=4; osr <= 32; osr++) {
    5084:	2104      	movs	r1, #4
		int divint = (int)(div + 0.5f);
    5086:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
	float base = (float)UART_CLOCK / (float)baud;
    508a:	eef8 7a67 	vcvt.f32.u32	s15, s15
	float besterr = 1e20;
    508e:	ed9f 6a8f 	vldr	s12, [pc, #572]	; 52cc <HardwareSerial::begin(unsigned long, unsigned short)+0x250>
    5092:	f641 7cff 	movw	ip, #8191	; 0x1fff
	float base = (float)UART_CLOCK / (float)baud;
    5096:	eec7 5a27 	vdiv.f32	s11, s14, s15
{
    509a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int bestosr = 4;
    509e:	468e      	mov	lr, r1
	int bestdiv = 1;
    50a0:	2401      	movs	r4, #1
		float div = base / (float)osr;
    50a2:	ee07 1a90 	vmov	s15, r1
    50a6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    50aa:	ee85 7aa7 	vdiv.f32	s14, s11, s15
		int divint = (int)(div + 0.5f);
    50ae:	ee77 7a05 	vadd.f32	s15, s14, s10
    50b2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    50b6:	ee17 3a90 	vmov	r3, s15
    50ba:	4563      	cmp	r3, ip
    50bc:	bfa8      	it	ge
    50be:	4663      	movge	r3, ip
    50c0:	2b01      	cmp	r3, #1
    50c2:	bfb8      	it	lt
    50c4:	2301      	movlt	r3, #1
		float err = ((float)divint - div) / div;
    50c6:	ee07 3a90 	vmov	s15, r3
    50ca:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    50ce:	ee76 6ac7 	vsub.f32	s13, s13, s14
    50d2:	eec6 7a87 	vdiv.f32	s15, s13, s14
		if (err < 0.0f) err = -err;
    50d6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    50da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    50de:	bf48      	it	mi
    50e0:	eef1 7a67 	vnegmi.f32	s15, s15
		if (err <= besterr) {
    50e4:	eef4 7ac6 	vcmpe.f32	s15, s12
    50e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    50ec:	d803      	bhi.n	50f6 <HardwareSerial::begin(unsigned long, unsigned short)+0x7a>
			besterr = err;
    50ee:	eeb0 6a67 	vmov.f32	s12, s15
		if (err <= besterr) {
    50f2:	468e      	mov	lr, r1
			bestdiv = divint;
    50f4:	461c      	mov	r4, r3
	for (int osr=4; osr <= 32; osr++) {
    50f6:	3101      	adds	r1, #1
    50f8:	2921      	cmp	r1, #33	; 0x21
    50fa:	d1d2      	bne.n	50a2 <HardwareSerial::begin(unsigned long, unsigned short)+0x26>
	rx_buffer_head_ = 0;
    50fc:	2100      	movs	r1, #0
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    50fe:	6943      	ldr	r3, [r0, #20]
    5100:	f402 7500 	and.w	r5, r2, #512	; 0x200
	rx_buffer_head_ = 0;
    5104:	f8a0 104a 	strh.w	r1, [r0, #74]	; 0x4a
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    5108:	f8b3 c05e 	ldrh.w	ip, [r3, #94]	; 0x5e
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    510c:	428d      	cmp	r5, r1
	rx_buffer_tail_ = 0;
    510e:	f8a0 104c 	strh.w	r1, [r0, #76]	; 0x4c
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    5112:	f8b3 505c 	ldrh.w	r5, [r3, #92]	; 0x5c
	tx_buffer_head_ = 0;
    5116:	f8a0 1046 	strh.w	r1, [r0, #70]	; 0x46
	tx_buffer_tail_ = 0;
    511a:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	transmitting_ = 0;
    511e:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    5122:	6b81      	ldr	r1, [r0, #56]	; 0x38
	hardware->ccm_register |= hardware->ccm_value;
    5124:	691e      	ldr	r6, [r3, #16]
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    5126:	eba1 0505 	sub.w	r5, r1, r5
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    512a:	eba1 010c 	sub.w	r1, r1, ip
    512e:	e9c0 510f 	strd	r5, r1, [r0, #60]	; 0x3c
	hardware->ccm_register |= hardware->ccm_value;
    5132:	6831      	ldr	r1, [r6, #0]
    5134:	695d      	ldr	r5, [r3, #20]
    5136:	ea41 0105 	orr.w	r1, r1, r5
    513a:	6031      	str	r1, [r6, #0]
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    513c:	bf14      	ite	ne
    513e:	2101      	movne	r1, #1
    5140:	2100      	moveq	r1, #0
    5142:	7681      	strb	r1, [r0, #26]
	if (!half_duplex_mode_)  {
    5144:	f040 8091 	bne.w	526a <HardwareSerial::begin(unsigned long, unsigned short)+0x1ee>
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5148:	7e05      	ldrb	r5, [r0, #24]
    514a:	f8df 8198 	ldr.w	r8, [pc, #408]	; 52e4 <HardwareSerial::begin(unsigned long, unsigned short)+0x268>
    514e:	eb03 1c05 	add.w	ip, r3, r5, lsl #4
    5152:	4e5f      	ldr	r6, [pc, #380]	; (52d0 <HardwareSerial::begin(unsigned long, unsigned short)+0x254>)
    5154:	f89c 5018 	ldrb.w	r5, [ip, #24]
    5158:	eb08 1505 	add.w	r5, r8, r5, lsl #4
    515c:	68a9      	ldr	r1, [r5, #8]
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
    515e:	686d      	ldr	r5, [r5, #4]
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5160:	600e      	str	r6, [r1, #0]
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
    5162:	f8dc 601c 	ldr.w	r6, [ip, #28]
    5166:	602e      	str	r6, [r5, #0]
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
    5168:	f8dc 5020 	ldr.w	r5, [ip, #32]
    516c:	b115      	cbz	r5, 5174 <HardwareSerial::begin(unsigned long, unsigned short)+0xf8>
		 	*(hardware->rx_pins[rx_pin_index_].select_input_register) =  hardware->rx_pins[rx_pin_index_].select_val;		
    516e:	f8dc 6024 	ldr.w	r6, [ip, #36]	; 0x24
    5172:	602e      	str	r6, [r5, #0]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
    5174:	7e45      	ldrb	r5, [r0, #25]
    5176:	27d9      	movs	r7, #217	; 0xd9
    5178:	eb03 1505 	add.w	r5, r3, r5, lsl #4
    517c:	f895 6038 	ldrb.w	r6, [r5, #56]	; 0x38
    5180:	eb08 1106 	add.w	r1, r8, r6, lsl #4
    5184:	688e      	ldr	r6, [r1, #8]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    5186:	6849      	ldr	r1, [r1, #4]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
    5188:	6037      	str	r7, [r6, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    518a:	6bed      	ldr	r5, [r5, #60]	; 0x3c
    518c:	600d      	str	r5, [r1, #0]
	if (hardware->tx_pins[tx_pin_index_].select_input_register) {
    518e:	7e41      	ldrb	r1, [r0, #25]
    5190:	eb03 1101 	add.w	r1, r3, r1, lsl #4
    5194:	6c0d      	ldr	r5, [r1, #64]	; 0x40
    5196:	b10d      	cbz	r5, 519c <HardwareSerial::begin(unsigned long, unsigned short)+0x120>
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
    5198:	6c49      	ldr	r1, [r1, #68]	; 0x44
    519a:	6029      	str	r1, [r5, #0]
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    519c:	f10e 31ff 	add.w	r1, lr, #4294967295
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51a0:	f1be 0f08 	cmp.w	lr, #8
	attachInterruptVector(hardware->irq, hardware->irq_handler);
    51a4:	685d      	ldr	r5, [r3, #4]
	port->PINCFG = 0;
    51a6:	f04f 0600 	mov.w	r6, #0
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51aa:	bfcc      	ite	gt
    51ac:	f04f 0e00 	movgt.w	lr, #0
    51b0:	f04f 0e01 	movle.w	lr, #1
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51b4:	0609      	lsls	r1, r1, #24
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51b6:	ea44 444e 	orr.w	r4, r4, lr, lsl #17
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51ba:	f001 51f8 	and.w	r1, r1, #520093696	; 0x1f000000
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51be:	4321      	orrs	r1, r4
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    51c0:	785c      	ldrb	r4, [r3, #1]
    51c2:	f104 0310 	add.w	r3, r4, #16
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51c6:	6904      	ldr	r4, [r0, #16]
    51c8:	6121      	str	r1, [r4, #16]
    51ca:	4942      	ldr	r1, [pc, #264]	; (52d4 <HardwareSerial::begin(unsigned long, unsigned short)+0x258>)
	port->PINCFG = 0;
    51cc:	60e6      	str	r6, [r4, #12]
    51ce:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    51d2:	6943      	ldr	r3, [r0, #20]
	NVIC_ENABLE_IRQ(hardware->irq);
    51d4:	f04f 0c01 	mov.w	ip, #1
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    51d8:	493f      	ldr	r1, [pc, #252]	; (52d8 <HardwareSerial::begin(unsigned long, unsigned short)+0x25c>)
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    51da:	f002 0503 	and.w	r5, r2, #3
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    51de:	785c      	ldrb	r4, [r3, #1]
    51e0:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
    51e4:	5463      	strb	r3, [r4, r1]
	NVIC_ENABLE_IRQ(hardware->irq);
    51e6:	6944      	ldr	r4, [r0, #20]
    51e8:	4b3c      	ldr	r3, [pc, #240]	; (52dc <HardwareSerial::begin(unsigned long, unsigned short)+0x260>)
    51ea:	7861      	ldrb	r1, [r4, #1]
    51ec:	eb03 1351 	add.w	r3, r3, r1, lsr #5
    51f0:	f001 011f 	and.w	r1, r1, #31
    51f4:	009b      	lsls	r3, r3, #2
    51f6:	fa0c f101 	lsl.w	r1, ip, r1
    51fa:	6019      	str	r1, [r3, #0]
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
    51fc:	f04f 1102 	mov.w	r1, #131074	; 0x20002
    5200:	6903      	ldr	r3, [r0, #16]
    5202:	62d9      	str	r1, [r3, #44]	; 0x2c
	port->FIFO |= LPUART_FIFO_TXFE | LPUART_FIFO_RXFE;
    5204:	6a99      	ldr	r1, [r3, #40]	; 0x28
    5206:	f041 0188 	orr.w	r1, r1, #136	; 0x88
    520a:	6299      	str	r1, [r3, #40]	; 0x28
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    520c:	0751      	lsls	r1, r2, #29
    520e:	d429      	bmi.n	5264 <HardwareSerial::begin(unsigned long, unsigned short)+0x1e8>
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    5210:	f445 1170 	orr.w	r1, r5, #3932160	; 0x3c0000
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
    5214:	f002 050f 	and.w	r5, r2, #15
    5218:	2d04      	cmp	r5, #4
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    521a:	7e85      	ldrb	r5, [r0, #26]
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
    521c:	bf08      	it	eq
    521e:	f041 4180 	orreq.w	r1, r1, #1073741824	; 0x40000000
	if (format & 0x20) ctrl |= LPUART_CTRL_TXINV;		// tx invert
    5222:	0697      	lsls	r7, r2, #26
    5224:	bf48      	it	mi
    5226:	f041 5180 	orrmi.w	r1, r1, #268435456	; 0x10000000
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    522a:	b10d      	cbz	r5, 5230 <HardwareSerial::begin(unsigned long, unsigned short)+0x1b4>
    522c:	f041 01a0 	orr.w	r1, r1, #160	; 0xa0
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    5230:	0716      	lsls	r6, r2, #28
	port->CTRL = ctrl;
    5232:	6199      	str	r1, [r3, #24]
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    5234:	d503      	bpl.n	523e <HardwareSerial::begin(unsigned long, unsigned short)+0x1c2>
    5236:	6919      	ldr	r1, [r3, #16]
    5238:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
    523c:	6119      	str	r1, [r3, #16]
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    523e:	6959      	ldr	r1, [r3, #20]
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    5240:	06d5      	lsls	r5, r2, #27
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    5242:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    5246:	bf48      	it	mi
    5248:	f041 5180 	orrmi.w	r1, r1, #268435456	; 0x10000000
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
    524c:	05d2      	lsls	r2, r2, #23
	port->STAT = c;
    524e:	6159      	str	r1, [r3, #20]
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
    5250:	d503      	bpl.n	525a <HardwareSerial::begin(unsigned long, unsigned short)+0x1de>
    5252:	691a      	ldr	r2, [r3, #16]
    5254:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    5258:	611a      	str	r2, [r3, #16]
	if (!(*hardware->serial_event_handler_default)) addToSerialEventsList(); 		// Enable the processing of serialEvent for this object
    525a:	68e3      	ldr	r3, [r4, #12]
    525c:	781b      	ldrb	r3, [r3, #0]
    525e:	b1a3      	cbz	r3, 528a <HardwareSerial::begin(unsigned long, unsigned short)+0x20e>
};
    5260:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    5264:	491e      	ldr	r1, [pc, #120]	; (52e0 <HardwareSerial::begin(unsigned long, unsigned short)+0x264>)
    5266:	4329      	orrs	r1, r5
    5268:	e7d4      	b.n	5214 <HardwareSerial::begin(unsigned long, unsigned short)+0x198>
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    526a:	7e41      	ldrb	r1, [r0, #25]
    526c:	f24f 07d9 	movw	r7, #61657	; 0xf0d9
    5270:	4d1c      	ldr	r5, [pc, #112]	; (52e4 <HardwareSerial::begin(unsigned long, unsigned short)+0x268>)
    5272:	eb03 1101 	add.w	r1, r3, r1, lsl #4
    5276:	f891 6038 	ldrb.w	r6, [r1, #56]	; 0x38
    527a:	eb05 1506 	add.w	r5, r5, r6, lsl #4
    527e:	68ae      	ldr	r6, [r5, #8]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    5280:	686d      	ldr	r5, [r5, #4]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    5282:	6037      	str	r7, [r6, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    5284:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
    5286:	6029      	str	r1, [r5, #0]
    5288:	e781      	b.n	518e <HardwareSerial::begin(unsigned long, unsigned short)+0x112>
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    528a:	4e17      	ldr	r6, [pc, #92]	; (52e8 <HardwareSerial::begin(unsigned long, unsigned short)+0x26c>)
    528c:	7834      	ldrb	r4, [r6, #0]
    528e:	b1bc      	cbz	r4, 52c0 <HardwareSerial::begin(unsigned long, unsigned short)+0x244>
    5290:	1e61      	subs	r1, r4, #1
    5292:	4d16      	ldr	r5, [pc, #88]	; (52ec <HardwareSerial::begin(unsigned long, unsigned short)+0x270>)
    5294:	b2c9      	uxtb	r1, r1
    5296:	1f2b      	subs	r3, r5, #4
    5298:	eb05 0181 	add.w	r1, r5, r1, lsl #2
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
    529c:	f853 2f04 	ldr.w	r2, [r3, #4]!
    52a0:	4290      	cmp	r0, r2
    52a2:	d0dd      	beq.n	5260 <HardwareSerial::begin(unsigned long, unsigned short)+0x1e4>
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    52a4:	4299      	cmp	r1, r3
    52a6:	d1f9      	bne.n	529c <HardwareSerial::begin(unsigned long, unsigned short)+0x220>
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    52a8:	1c63      	adds	r3, r4, #1
    52aa:	b2db      	uxtb	r3, r3
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    52ac:	4a10      	ldr	r2, [pc, #64]	; (52f0 <HardwareSerial::begin(unsigned long, unsigned short)+0x274>)
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    52ae:	7033      	strb	r3, [r6, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    52b0:	7813      	ldrb	r3, [r2, #0]
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    52b2:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    52b6:	f043 0302 	orr.w	r3, r3, #2
    52ba:	7013      	strb	r3, [r2, #0]
};
    52bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    52c0:	2301      	movs	r3, #1
    52c2:	4d0a      	ldr	r5, [pc, #40]	; (52ec <HardwareSerial::begin(unsigned long, unsigned short)+0x270>)
    52c4:	e7f2      	b.n	52ac <HardwareSerial::begin(unsigned long, unsigned short)+0x230>
    52c6:	bf00      	nop
    52c8:	4bb71b00 	.word	0x4bb71b00
    52cc:	60ad78ec 	.word	0x60ad78ec
    52d0:	0001f038 	.word	0x0001f038
    52d4:	20001000 	.word	0x20001000
    52d8:	e000e400 	.word	0xe000e400
    52dc:	38003840 	.word	0x38003840
    52e0:	003c0010 	.word	0x003c0010
    52e4:	200006bc 	.word	0x200006bc
    52e8:	20006adf 	.word	0x20006adf
    52ec:	20006888 	.word	0x20006888
    52f0:	20000d47 	.word	0x20000d47

000052f4 <HardwareSerial::end()>:
{
    52f4:	b538      	push	{r3, r4, r5, lr}
	if (!(hardware->ccm_register & hardware->ccm_value)) return;
    52f6:	6943      	ldr	r3, [r0, #20]
    52f8:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
    52fc:	6809      	ldr	r1, [r1, #0]
    52fe:	4211      	tst	r1, r2
    5300:	d02a      	beq.n	5358 <HardwareSerial::end()+0x64>
	while (transmitting_) yield();  // wait for buffered data to send
    5302:	f890 2044 	ldrb.w	r2, [r0, #68]	; 0x44
    5306:	4604      	mov	r4, r0
    5308:	b132      	cbz	r2, 5318 <HardwareSerial::end()+0x24>
    530a:	f002 f939 	bl	7580 <yield>
    530e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    5312:	2b00      	cmp	r3, #0
    5314:	d1f9      	bne.n	530a <HardwareSerial::end()+0x16>
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    5316:	6963      	ldr	r3, [r4, #20]
	port->CTRL = 0;	// disable the TX and RX ...
    5318:	6920      	ldr	r0, [r4, #16]
    531a:	2100      	movs	r1, #0
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    531c:	4a0f      	ldr	r2, [pc, #60]	; (535c <HardwareSerial::end()+0x68>)
	port->CTRL = 0;	// disable the TX and RX ...
    531e:	6181      	str	r1, [r0, #24]
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    5320:	7e20      	ldrb	r0, [r4, #24]
    5322:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    5326:	7e00      	ldrb	r0, [r0, #24]
    5328:	eb02 1000 	add.w	r0, r2, r0, lsl #4
    532c:	6845      	ldr	r5, [r0, #4]
    532e:	2005      	movs	r0, #5
    5330:	6028      	str	r0, [r5, #0]
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    5332:	f894 c019 	ldrb.w	ip, [r4, #25]
    5336:	eb03 130c 	add.w	r3, r3, ip, lsl #4
    533a:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    533e:	eb02 1203 	add.w	r2, r2, r3, lsl #4
	if (rts_pin_baseReg_) rts_deassert();
    5342:	6da3      	ldr	r3, [r4, #88]	; 0x58
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    5344:	6852      	ldr	r2, [r2, #4]
    5346:	6010      	str	r0, [r2, #0]
	rx_buffer_head_ = 0;
    5348:	f8a4 104a 	strh.w	r1, [r4, #74]	; 0x4a
	rx_buffer_tail_ = 0;
    534c:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
	if (rts_pin_baseReg_) rts_deassert();
    5350:	b113      	cbz	r3, 5358 <HardwareSerial::end()+0x64>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    5352:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    5354:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    5358:	bd38      	pop	{r3, r4, r5, pc}
    535a:	bf00      	nop
    535c:	200006bc 	.word	0x200006bc

00005360 <HardwareSerial::write9bit(unsigned long)>:
{
    5360:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5362:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    5364:	4604      	mov	r4, r0
    5366:	460e      	mov	r6, r1
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5368:	b113      	cbz	r3, 5370 <HardwareSerial::write9bit(unsigned long)+0x10>
    536a:	6d42      	ldr	r2, [r0, #84]	; 0x54
    536c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	if(half_duplex_mode_) {		
    5370:	7ea3      	ldrb	r3, [r4, #26]
    5372:	b133      	cbz	r3, 5382 <HardwareSerial::write9bit(unsigned long)+0x22>
		__disable_irq();
    5374:	b672      	cpsid	i
	    port->CTRL |= LPUART_CTRL_TXDIR;
    5376:	6922      	ldr	r2, [r4, #16]
    5378:	6993      	ldr	r3, [r2, #24]
    537a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    537e:	6193      	str	r3, [r2, #24]
		__enable_irq();
    5380:	b662      	cpsie	i
	head = tx_buffer_head_;
    5382:	f8b4 5046 	ldrh.w	r5, [r4, #70]	; 0x46
	if (++head >= tx_buffer_total_size_) head = 0;
    5386:	6b63      	ldr	r3, [r4, #52]	; 0x34
	head = tx_buffer_head_;
    5388:	b2ad      	uxth	r5, r5
	if (++head >= tx_buffer_total_size_) head = 0;
    538a:	3501      	adds	r5, #1
    538c:	42ab      	cmp	r3, r5
    538e:	d84c      	bhi.n	542a <HardwareSerial::write9bit(unsigned long)+0xca>
    5390:	2700      	movs	r7, #0
    5392:	463d      	mov	r5, r7
	while (tx_buffer_tail_ == head) {
    5394:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    5398:	b29b      	uxth	r3, r3
    539a:	429d      	cmp	r5, r3
    539c:	d01a      	beq.n	53d4 <HardwareSerial::write9bit(unsigned long)+0x74>
    539e:	e029      	b.n	53f4 <HardwareSerial::write9bit(unsigned long)+0x94>
			if ((port->STAT & LPUART_STAT_TDRE)) {
    53a0:	6921      	ldr	r1, [r4, #16]
    53a2:	694b      	ldr	r3, [r1, #20]
    53a4:	021b      	lsls	r3, r3, #8
    53a6:	d510      	bpl.n	53ca <HardwareSerial::write9bit(unsigned long)+0x6a>
				uint32_t tail = tx_buffer_tail_;
    53a8:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
				if (++tail >= tx_buffer_total_size_) tail = 0;
    53ac:	6b62      	ldr	r2, [r4, #52]	; 0x34
				uint32_t tail = tx_buffer_tail_;
    53ae:	b29b      	uxth	r3, r3
				if (++tail >= tx_buffer_total_size_) tail = 0;
    53b0:	3301      	adds	r3, #1
    53b2:	429a      	cmp	r2, r3
    53b4:	d936      	bls.n	5424 <HardwareSerial::write9bit(unsigned long)+0xc4>
				tx_buffer_tail_ = tail;
    53b6:	b29a      	uxth	r2, r3
				if (tail < tx_buffer_size_) {
    53b8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    53ba:	4298      	cmp	r0, r3
    53bc:	d92d      	bls.n	541a <HardwareSerial::write9bit(unsigned long)+0xba>
					n = tx_buffer_[tail];
    53be:	69e0      	ldr	r0, [r4, #28]
    53c0:	5cc3      	ldrb	r3, [r0, r3]
    53c2:	b2db      	uxtb	r3, r3
				port->DATA  = n;
    53c4:	61cb      	str	r3, [r1, #28]
				tx_buffer_tail_ = tail;
    53c6:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
	while (tx_buffer_tail_ == head) {
    53ca:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    53ce:	b29b      	uxth	r3, r3
    53d0:	42ab      	cmp	r3, r5
    53d2:	d10f      	bne.n	53f4 <HardwareSerial::write9bit(unsigned long)+0x94>
		int priority = nvic_execution_priority();
    53d4:	f7ff fe32 	bl	503c <nvic_execution_priority()>
		if (priority <= hardware->irq_priority) {
    53d8:	6963      	ldr	r3, [r4, #20]
    53da:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
    53de:	4283      	cmp	r3, r0
    53e0:	dade      	bge.n	53a0 <HardwareSerial::write9bit(unsigned long)+0x40>
		} else if (priority >= 256) 
    53e2:	28ff      	cmp	r0, #255	; 0xff
    53e4:	ddf1      	ble.n	53ca <HardwareSerial::write9bit(unsigned long)+0x6a>
			yield(); // wait
    53e6:	f002 f8cb 	bl	7580 <yield>
	while (tx_buffer_tail_ == head) {
    53ea:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    53ee:	b29b      	uxth	r3, r3
    53f0:	42ab      	cmp	r3, r5
    53f2:	d0ef      	beq.n	53d4 <HardwareSerial::write9bit(unsigned long)+0x74>
	if (head < tx_buffer_size_) {
    53f4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    53f6:	42ab      	cmp	r3, r5
    53f8:	d919      	bls.n	542e <HardwareSerial::write9bit(unsigned long)+0xce>
		tx_buffer_[head] = c;
    53fa:	69e3      	ldr	r3, [r4, #28]
    53fc:	b2f6      	uxtb	r6, r6
    53fe:	555e      	strb	r6, [r3, r5]
	__disable_irq();
    5400:	b672      	cpsid	i
	transmitting_ = 1;
    5402:	2001      	movs	r0, #1
	port->CTRL |= LPUART_CTRL_TIE; // (may need to handle this issue)BITBAND_SET_BIT(LPUART0_CTRL, TIE_BIT);
    5404:	6922      	ldr	r2, [r4, #16]
	transmitting_ = 1;
    5406:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
	tx_buffer_head_ = head;
    540a:	f8a4 7046 	strh.w	r7, [r4, #70]	; 0x46
	port->CTRL |= LPUART_CTRL_TIE; // (may need to handle this issue)BITBAND_SET_BIT(LPUART0_CTRL, TIE_BIT);
    540e:	6993      	ldr	r3, [r2, #24]
    5410:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    5414:	6193      	str	r3, [r2, #24]
	__enable_irq();
    5416:	b662      	cpsie	i
}
    5418:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					n = tx_buffer_storage_[tail-tx_buffer_size_];
    541a:	1a1b      	subs	r3, r3, r0
    541c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    541e:	5cc3      	ldrb	r3, [r0, r3]
    5420:	b2db      	uxtb	r3, r3
    5422:	e7cf      	b.n	53c4 <HardwareSerial::write9bit(unsigned long)+0x64>
    5424:	2200      	movs	r2, #0
				if (++tail >= tx_buffer_total_size_) tail = 0;
    5426:	4613      	mov	r3, r2
    5428:	e7c6      	b.n	53b8 <HardwareSerial::write9bit(unsigned long)+0x58>
	tx_buffer_head_ = head;
    542a:	b2af      	uxth	r7, r5
    542c:	e7b2      	b.n	5394 <HardwareSerial::write9bit(unsigned long)+0x34>
		tx_buffer_storage_[head - tx_buffer_size_] = c;
    542e:	1aed      	subs	r5, r5, r3
    5430:	b2f6      	uxtb	r6, r6
    5432:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    5434:	555e      	strb	r6, [r3, r5]
    5436:	e7e3      	b.n	5400 <HardwareSerial::write9bit(unsigned long)+0xa0>

00005438 <HardwareSerial::write(unsigned char)>:
	return write9bit(c);
    5438:	f7ff bf92 	b.w	5360 <HardwareSerial::write9bit(unsigned long)>

0000543c <HardwareSerial::IRQHandler()>:
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    543c:	6902      	ldr	r2, [r0, #16]
    543e:	6953      	ldr	r3, [r2, #20]
    5440:	f413 1f40 	tst.w	r3, #3145728	; 0x300000
{
    5444:	b570      	push	{r4, r5, r6, lr}
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    5446:	4615      	mov	r5, r2
    5448:	d047      	beq.n	54da <HardwareSerial::IRQHandler()+0x9e>
		uint8_t avail = (port->WATER >> 24) & 0x7;
    544a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
		if (avail) {
    544c:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
		uint8_t avail = (port->WATER >> 24) & 0x7;
    5450:	f3c3 6e02 	ubfx	lr, r3, #24, #3
		if (avail) {
    5454:	d03e      	beq.n	54d4 <HardwareSerial::IRQHandler()+0x98>
			head = rx_buffer_head_;
    5456:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
			tail = rx_buffer_tail_;
    545a:	f8b0 504c 	ldrh.w	r5, [r0, #76]	; 0x4c
			head = rx_buffer_head_;
    545e:	b2a4      	uxth	r4, r4
			tail = rx_buffer_tail_;
    5460:	b2ad      	uxth	r5, r5
    5462:	e008      	b.n	5476 <HardwareSerial::IRQHandler()+0x3a>
						rx_buffer_[head] = n;
    5464:	6a02      	ldr	r2, [r0, #32]
    5466:	f802 c003 	strb.w	ip, [r2, r3]
    546a:	6902      	ldr	r2, [r0, #16]
			} while (--avail > 0) ;
    546c:	f10e 33ff 	add.w	r3, lr, #4294967295
    5470:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    5474:	d01e      	beq.n	54b4 <HardwareSerial::IRQHandler()+0x78>
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5476:	69d1      	ldr	r1, [r2, #28]
				newhead = head + 1;
    5478:	1c63      	adds	r3, r4, #1
				if (newhead != rx_buffer_tail_) {
    547a:	f8b0 c04c 	ldrh.w	ip, [r0, #76]	; 0x4c
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    547e:	6b86      	ldr	r6, [r0, #56]	; 0x38
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5480:	f3c1 0109 	ubfx	r1, r1, #0, #10
				if (newhead != rx_buffer_tail_) {
    5484:	fa1f fc8c 	uxth.w	ip, ip
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    5488:	429e      	cmp	r6, r3
    548a:	bf98      	it	ls
    548c:	2300      	movls	r3, #0
				if (newhead != rx_buffer_tail_) {
    548e:	459c      	cmp	ip, r3
    5490:	d0ec      	beq.n	546c <HardwareSerial::IRQHandler()+0x30>
					if (newhead < rx_buffer_size_) {
    5492:	6b02      	ldr	r2, [r0, #48]	; 0x30
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    5494:	fa5f fc81 	uxtb.w	ip, r1
    5498:	461c      	mov	r4, r3
					if (newhead < rx_buffer_size_) {
    549a:	429a      	cmp	r2, r3
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    549c:	eba3 0602 	sub.w	r6, r3, r2
					if (newhead < rx_buffer_size_) {
    54a0:	d8e0      	bhi.n	5464 <HardwareSerial::IRQHandler()+0x28>
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    54a2:	6a43      	ldr	r3, [r0, #36]	; 0x24
    54a4:	f803 c006 	strb.w	ip, [r3, r6]
			} while (--avail > 0) ;
    54a8:	f10e 33ff 	add.w	r3, lr, #4294967295
    54ac:	6902      	ldr	r2, [r0, #16]
    54ae:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    54b2:	d1e0      	bne.n	5476 <HardwareSerial::IRQHandler()+0x3a>
			rx_buffer_head_ = head;
    54b4:	b2a3      	uxth	r3, r4
    54b6:	f8a0 304a 	strh.w	r3, [r0, #74]	; 0x4a
			if (rts_pin_baseReg_) {
    54ba:	6d83      	ldr	r3, [r0, #88]	; 0x58
    54bc:	2b00      	cmp	r3, #0
    54be:	d05a      	beq.n	5576 <HardwareSerial::IRQHandler()+0x13a>
				if (head >= tail) avail = head - tail;
    54c0:	42ac      	cmp	r4, r5
    54c2:	d35d      	bcc.n	5580 <HardwareSerial::IRQHandler()+0x144>
    54c4:	1b64      	subs	r4, r4, r5
				if (avail >= rts_high_watermark_) rts_deassert();
    54c6:	6c01      	ldr	r1, [r0, #64]	; 0x40
    54c8:	42a1      	cmp	r1, r4
    54ca:	d854      	bhi.n	5576 <HardwareSerial::IRQHandler()+0x13a>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    54cc:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
		if (port->STAT & LPUART_STAT_IDLE) {
    54ce:	4615      	mov	r5, r2
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    54d0:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
		if (port->STAT & LPUART_STAT_IDLE) {
    54d4:	6953      	ldr	r3, [r2, #20]
    54d6:	02dc      	lsls	r4, r3, #11
    54d8:	d448      	bmi.n	556c <HardwareSerial::IRQHandler()+0x130>
	ctrl = port->CTRL;
    54da:	6996      	ldr	r6, [r2, #24]
	if ((ctrl & LPUART_CTRL_TIE) && (port->STAT & LPUART_STAT_TDRE))
    54dc:	0231      	lsls	r1, r6, #8
    54de:	d529      	bpl.n	5534 <HardwareSerial::IRQHandler()+0xf8>
    54e0:	6953      	ldr	r3, [r2, #20]
    54e2:	021b      	lsls	r3, r3, #8
    54e4:	d526      	bpl.n	5534 <HardwareSerial::IRQHandler()+0xf8>
		head = tx_buffer_head_;
    54e6:	f8b0 c046 	ldrh.w	ip, [r0, #70]	; 0x46
		tail = tx_buffer_tail_;
    54ea:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
		head = tx_buffer_head_;
    54ee:	fa1f fc8c 	uxth.w	ip, ip
		tail = tx_buffer_tail_;
    54f2:	b29b      	uxth	r3, r3
    54f4:	e006      	b.n	5504 <HardwareSerial::IRQHandler()+0xc8>
				n = tx_buffer_[tail];
    54f6:	69c1      	ldr	r1, [r0, #28]
    54f8:	5cc9      	ldrb	r1, [r1, r3]
    54fa:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    54fc:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    54fe:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    5500:	054c      	lsls	r4, r1, #21
    5502:	d412      	bmi.n	552a <HardwareSerial::IRQHandler()+0xee>
			if (head == tail) break;
    5504:	4563      	cmp	r3, ip
    5506:	d03f      	beq.n	5588 <HardwareSerial::IRQHandler()+0x14c>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5508:	6b44      	ldr	r4, [r0, #52]	; 0x34
    550a:	3301      	adds	r3, #1
			if (tail < tx_buffer_size_) {
    550c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
			if (++tail >= tx_buffer_total_size_) tail = 0;
    550e:	429c      	cmp	r4, r3
    5510:	bf98      	it	ls
    5512:	2300      	movls	r3, #0
			if (tail < tx_buffer_size_) {
    5514:	4299      	cmp	r1, r3
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    5516:	eba3 0401 	sub.w	r4, r3, r1
			if (tail < tx_buffer_size_) {
    551a:	d8ec      	bhi.n	54f6 <HardwareSerial::IRQHandler()+0xba>
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    551c:	6a81      	ldr	r1, [r0, #40]	; 0x28
    551e:	5d09      	ldrb	r1, [r1, r4]
    5520:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    5522:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    5524:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    5526:	054c      	lsls	r4, r1, #21
    5528:	d5ec      	bpl.n	5504 <HardwareSerial::IRQHandler()+0xc8>
		tx_buffer_tail_ = tail;
    552a:	b299      	uxth	r1, r3
		if (head == tail) {
    552c:	4563      	cmp	r3, ip
		tx_buffer_tail_ = tail;
    552e:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
		if (head == tail) {
    5532:	d02c      	beq.n	558e <HardwareSerial::IRQHandler()+0x152>
	if ((ctrl & LPUART_CTRL_TCIE) && (port->STAT & LPUART_STAT_TC))
    5534:	0271      	lsls	r1, r6, #9
    5536:	d518      	bpl.n	556a <HardwareSerial::IRQHandler()+0x12e>
    5538:	6953      	ldr	r3, [r2, #20]
    553a:	025b      	lsls	r3, r3, #9
    553c:	d515      	bpl.n	556a <HardwareSerial::IRQHandler()+0x12e>
		transmitting_ = 0;
    553e:	2200      	movs	r2, #0
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5540:	6d03      	ldr	r3, [r0, #80]	; 0x50
		transmitting_ = 0;
    5542:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5546:	b113      	cbz	r3, 554e <HardwareSerial::IRQHandler()+0x112>
    5548:	6d42      	ldr	r2, [r0, #84]	; 0x54
    554a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		if(half_duplex_mode_) {		
    554e:	7e83      	ldrb	r3, [r0, #26]
    5550:	b13b      	cbz	r3, 5562 <HardwareSerial::IRQHandler()+0x126>
			__disable_irq();
    5552:	b672      	cpsid	i
		    port->CTRL &= ~LPUART_CTRL_TXDIR;
    5554:	6902      	ldr	r2, [r0, #16]
    5556:	6993      	ldr	r3, [r2, #24]
    5558:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
    555c:	6193      	str	r3, [r2, #24]
			__enable_irq();
    555e:	b662      	cpsie	i
		port->CTRL &= ~LPUART_CTRL_TCIE;
    5560:	6905      	ldr	r5, [r0, #16]
    5562:	69ab      	ldr	r3, [r5, #24]
    5564:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
    5568:	61ab      	str	r3, [r5, #24]
}
    556a:	bd70      	pop	{r4, r5, r6, pc}
			port->STAT |= LPUART_STAT_IDLE;	// writing a 1 to idle should clear it. 
    556c:	6953      	ldr	r3, [r2, #20]
    556e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    5572:	6153      	str	r3, [r2, #20]
    5574:	e7b1      	b.n	54da <HardwareSerial::IRQHandler()+0x9e>
		if (port->STAT & LPUART_STAT_IDLE) {
    5576:	6953      	ldr	r3, [r2, #20]
    5578:	4615      	mov	r5, r2
    557a:	02dc      	lsls	r4, r3, #11
    557c:	d5ad      	bpl.n	54da <HardwareSerial::IRQHandler()+0x9e>
    557e:	e7f5      	b.n	556c <HardwareSerial::IRQHandler()+0x130>
				else avail = rx_buffer_total_size_ + head - tail;
    5580:	6b81      	ldr	r1, [r0, #56]	; 0x38
    5582:	1b49      	subs	r1, r1, r5
    5584:	440c      	add	r4, r1
    5586:	e79e      	b.n	54c6 <HardwareSerial::IRQHandler()+0x8a>
		tx_buffer_tail_ = tail;
    5588:	b29b      	uxth	r3, r3
    558a:	f8a0 3048 	strh.w	r3, [r0, #72]	; 0x48
			port->CTRL &= ~LPUART_CTRL_TIE; 
    558e:	6993      	ldr	r3, [r2, #24]
    5590:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    5594:	6193      	str	r3, [r2, #24]
  			port->CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
    5596:	6993      	ldr	r3, [r2, #24]
    5598:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    559c:	6193      	str	r3, [r2, #24]
    559e:	e7c9      	b.n	5534 <HardwareSerial::IRQHandler()+0xf8>

000055a0 <IRQHandler_Serial2>:
#define IRQ_PRIORITY  64  // 0 = highest priority, 255 = lowest


void IRQHandler_Serial2()
{
	Serial2.IRQHandler();
    55a0:	4801      	ldr	r0, [pc, #4]	; (55a8 <IRQHandler_Serial2+0x8>)
    55a2:	f7ff bf4b 	b.w	543c <HardwareSerial::IRQHandler()>
    55a6:	bf00      	nop
    55a8:	200067a8 	.word	0x200067a8

000055ac <_GLOBAL__sub_I_IRQHandler_Serial2>:
	0, // No CTS
	IRQ_PRIORITY, 38, 24, // IRQ, rts_low_watermark, rts_high_watermark
	XBARA1_OUT_LPUART4_TRG_INPUT
};
HardwareSerial Serial2(&IMXRT_LPUART4, &UART4_Hardware, tx_buffer2, SERIAL2_TX_BUFFER_SIZE, 
	rx_buffer2,  SERIAL2_RX_BUFFER_SIZE);
    55ac:	b410      	push	{r4}
	constexpr Print() : write_error(0) {}
    55ae:	4b17      	ldr	r3, [pc, #92]	; (560c <_GLOBAL__sub_I_IRQHandler_Serial2+0x60>)
	constexpr Stream() : _timeout(1000), read_error(0) {}
    55b0:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    55b4:	2200      	movs	r2, #0
public:
	constexpr HardwareSerial(IMXRT_LPUART_t *myport, const hardware_t *myhardware, 
		volatile BUFTYPE *_tx_buffer, size_t _tx_buffer_size, 
		volatile BUFTYPE *_rx_buffer, size_t _rx_buffer_size) :
		port(myport), hardware(myhardware),
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55b6:	2028      	movs	r0, #40	; 0x28
    55b8:	609c      	str	r4, [r3, #8]
    55ba:	2140      	movs	r1, #64	; 0x40
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55bc:	4c14      	ldr	r4, [pc, #80]	; (5610 <_GLOBAL__sub_I_IRQHandler_Serial2+0x64>)
    55be:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    55c2:	601c      	str	r4, [r3, #0]
		port(myport), hardware(myhardware),
    55c4:	4c13      	ldr	r4, [pc, #76]	; (5614 <_GLOBAL__sub_I_IRQHandler_Serial2+0x68>)
    55c6:	731a      	strb	r2, [r3, #12]
    55c8:	611c      	str	r4, [r3, #16]
    55ca:	4c13      	ldr	r4, [pc, #76]	; (5618 <_GLOBAL__sub_I_IRQHandler_Serial2+0x6c>)
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55cc:	831a      	strh	r2, [r3, #24]
		port(myport), hardware(myhardware),
    55ce:	615c      	str	r4, [r3, #20]
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55d0:	4c12      	ldr	r4, [pc, #72]	; (561c <_GLOBAL__sub_I_IRQHandler_Serial2+0x70>)
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55d2:	769a      	strb	r2, [r3, #26]
    55d4:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55d8:	61dc      	str	r4, [r3, #28]
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55da:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
    55de:	f85d 4b04 	ldr.w	r4, [sp], #4
    55e2:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
    55e6:	605a      	str	r2, [r3, #4]
    55e8:	625a      	str	r2, [r3, #36]	; 0x24
    55ea:	641a      	str	r2, [r3, #64]	; 0x40
    55ec:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55f0:	e9c3 200a 	strd	r2, r0, [r3, #40]	; 0x28
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55f4:	e9c3 100c 	strd	r1, r0, [r3, #48]	; 0x30
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55f8:	4809      	ldr	r0, [pc, #36]	; (5620 <_GLOBAL__sub_I_IRQHandler_Serial2+0x74>)
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55fa:	e9c3 120e 	strd	r1, r2, [r3, #56]	; 0x38
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55fe:	6218      	str	r0, [r3, #32]
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    5600:	e9c3 2214 	strd	r2, r2, [r3, #80]	; 0x50
    5604:	e9c3 2216 	strd	r2, r2, [r3, #88]	; 0x58
    5608:	4770      	bx	lr
    560a:	bf00      	nop
    560c:	200067a8 	.word	0x200067a8
    5610:	20000678 	.word	0x20000678
    5614:	40190000 	.word	0x40190000
    5618:	20000a78 	.word	0x20000a78
    561c:	20006848 	.word	0x20006848
    5620:	20006808 	.word	0x20006808

00005624 <usb_serial_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    5624:	4608      	mov	r0, r1
    5626:	f001 bf17 	b.w	7458 <usb_serial_putchar>
    562a:	bf00      	nop

0000562c <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>:
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    562c:	2a01      	cmp	r2, #1
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    562e:	b570      	push	{r4, r5, r6, lr}
		base = 10;
    5630:	bf08      	it	eq
    5632:	220a      	moveq	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    5634:	b08a      	sub	sp, #40	; 0x28
	}


	if (n == 0) {
    5636:	b391      	cbz	r1, 569e <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x72>
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
    5638:	f04f 0e21 	mov.w	lr, #33	; 0x21
    563c:	e001      	b.n	5642 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x16>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    563e:	fa5f fe86 	uxtb.w	lr, r6
    5642:	f10e 36ff 	add.w	r6, lr, #4294967295
			digit = n % base;
    5646:	fbb1 f5f2 	udiv	r5, r1, r2
    564a:	fb02 1415 	mls	r4, r2, r5, r1
    564e:	fa5f fc84 	uxtb.w	ip, r4
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5652:	2c09      	cmp	r4, #9
    5654:	f10c 0437 	add.w	r4, ip, #55	; 0x37
    5658:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    565c:	bf98      	it	ls
    565e:	fa5f f48c 	uxtbls.w	r4, ip
    5662:	f10e 0c28 	add.w	ip, lr, #40	; 0x28
    5666:	bf88      	it	hi
    5668:	b2e4      	uxtbhi	r4, r4
			if (n == 0) break;
    566a:	4291      	cmp	r1, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    566c:	44ec      	add	ip, sp
			n /= base;
    566e:	4629      	mov	r1, r5
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5670:	f80c 4c24 	strb.w	r4, [ip, #-36]
			if (n == 0) break;
    5674:	d2e3      	bcs.n	563e <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x12>
		}
	}
	if (sign) {
    5676:	b14b      	cbz	r3, 568c <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x60>
		i--;
    5678:	f10e 3eff 	add.w	lr, lr, #4294967295
		buf[i] = '-';
    567c:	222d      	movs	r2, #45	; 0x2d
		i--;
    567e:	fa5f fe8e 	uxtb.w	lr, lr
		buf[i] = '-';
    5682:	f10e 0328 	add.w	r3, lr, #40	; 0x28
    5686:	446b      	add	r3, sp
    5688:	f803 2c24 	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    568c:	6803      	ldr	r3, [r0, #0]
    568e:	a901      	add	r1, sp, #4
    5690:	f1ce 0222 	rsb	r2, lr, #34	; 0x22
    5694:	685b      	ldr	r3, [r3, #4]
    5696:	4471      	add	r1, lr
    5698:	4798      	blx	r3
}
    569a:	b00a      	add	sp, #40	; 0x28
    569c:	bd70      	pop	{r4, r5, r6, pc}
		buf[sizeof(buf) - 1] = '0';
    569e:	2230      	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    56a0:	f04f 0e21 	mov.w	lr, #33	; 0x21
		buf[sizeof(buf) - 1] = '0';
    56a4:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    56a8:	e7e5      	b.n	5676 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x4a>
    56aa:	bf00      	nop

000056ac <Print::write(unsigned char const*, unsigned int)>:
{
    56ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buffer == nullptr) return 0;
    56b0:	460c      	mov	r4, r1
    56b2:	b1d1      	cbz	r1, 56ea <Print::write(unsigned char const*, unsigned int)+0x3e>
	while (size--) count += write(*buffer++);
    56b4:	b1ea      	cbz	r2, 56f2 <Print::write(unsigned char const*, unsigned int)+0x46>
    56b6:	4680      	mov	r8, r0
    56b8:	188e      	adds	r6, r1, r2
	size_t count = 0;
    56ba:	2500      	movs	r5, #0
    56bc:	4f0e      	ldr	r7, [pc, #56]	; (56f8 <Print::write(unsigned char const*, unsigned int)+0x4c>)
    56be:	e004      	b.n	56ca <Print::write(unsigned char const*, unsigned int)+0x1e>
    56c0:	f001 feca 	bl	7458 <usb_serial_putchar>
	while (size--) count += write(*buffer++);
    56c4:	42b4      	cmp	r4, r6
    56c6:	4405      	add	r5, r0
    56c8:	d00c      	beq.n	56e4 <Print::write(unsigned char const*, unsigned int)+0x38>
    56ca:	f8d8 3000 	ldr.w	r3, [r8]
    56ce:	f814 0b01 	ldrb.w	r0, [r4], #1
    56d2:	681b      	ldr	r3, [r3, #0]
    56d4:	42bb      	cmp	r3, r7
    56d6:	d0f3      	beq.n	56c0 <Print::write(unsigned char const*, unsigned int)+0x14>
    56d8:	4601      	mov	r1, r0
    56da:	4640      	mov	r0, r8
    56dc:	4798      	blx	r3
    56de:	42b4      	cmp	r4, r6
    56e0:	4405      	add	r5, r0
    56e2:	d1f2      	bne.n	56ca <Print::write(unsigned char const*, unsigned int)+0x1e>
}
    56e4:	4628      	mov	r0, r5
    56e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    56ea:	460d      	mov	r5, r1
}
    56ec:	4628      	mov	r0, r5
    56ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    56f2:	4615      	mov	r5, r2
    56f4:	e7f6      	b.n	56e4 <Print::write(unsigned char const*, unsigned int)+0x38>
    56f6:	bf00      	nop
    56f8:	00005625 	.word	0x00005625

000056fc <Print::print(long)>:
	if (n < 0) {
    56fc:	2900      	cmp	r1, #0
    56fe:	db03      	blt.n	5708 <Print::print(long)+0xc>
	uint8_t sign=0;
    5700:	2300      	movs	r3, #0
	if (base == 0) {
    5702:	220a      	movs	r2, #10
    5704:	f7ff bf92 	b.w	562c <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
		n = -n;
    5708:	4249      	negs	r1, r1
		sign = '-';
    570a:	232d      	movs	r3, #45	; 0x2d
	if (base == 0) {
    570c:	220a      	movs	r2, #10
    570e:	f7ff bf8d 	b.w	562c <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    5712:	bf00      	nop

00005714 <Print::println()>:
{
    5714:	b500      	push	{lr}
	return write(buf, 2);
    5716:	6803      	ldr	r3, [r0, #0]
{
    5718:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    571a:	f640 2c0d 	movw	ip, #2573	; 0xa0d
	return write(buf, 2);
    571e:	2202      	movs	r2, #2
    5720:	a901      	add	r1, sp, #4
    5722:	685b      	ldr	r3, [r3, #4]
	uint8_t buf[2]={'\r', '\n'};
    5724:	f8ad c004 	strh.w	ip, [sp, #4]
	return write(buf, 2);
    5728:	4798      	blx	r3
}
    572a:	b003      	add	sp, #12
    572c:	f85d fb04 	ldr.w	pc, [sp], #4

00005730 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	if (base == 0) {
    5730:	b95a      	cbnz	r2, 574a <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1a>
		return write((uint8_t)n);
    5732:	6803      	ldr	r3, [r0, #0]
    5734:	b2c9      	uxtb	r1, r1
    5736:	4a07      	ldr	r2, [pc, #28]	; (5754 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x24>)
    5738:	681b      	ldr	r3, [r3, #0]
    573a:	4293      	cmp	r3, r2
{
    573c:	b500      	push	{lr}
    573e:	d106      	bne.n	574e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    5740:	4608      	mov	r0, r1
}
    5742:	f85d eb04 	ldr.w	lr, [sp], #4
    5746:	f001 be87 	b.w	7458 <usb_serial_putchar>
    574a:	f7ff bf6f 	b.w	562c <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    574e:	f85d eb04 	ldr.w	lr, [sp], #4
		return write((uint8_t)n);
    5752:	4718      	bx	r3
    5754:	00005625 	.word	0x00005625

00005758 <usb_serial_class::read()>:
        virtual int read() { return usb_serial_getchar(); }
    5758:	f001 be6e 	b.w	7438 <usb_serial_getchar>

0000575c <usb_serial_class::peek()>:
        virtual int peek() { return usb_serial_peekchar(); }
    575c:	f001 be06 	b.w	736c <usb_serial_peekchar>

00005760 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    5760:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
    5764:	b392      	cbz	r2, 57cc <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
    5766:	4617      	mov	r7, r2
    5768:	fab3 f283 	clz	r2, r3
    576c:	0952      	lsrs	r2, r2, #5
    576e:	b36b      	cbz	r3, 57cc <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
	length--;
	size_t index = 0;
	while (index < length) {
    5770:	f1b3 0801 	subs.w	r8, r3, #1
    5774:	d025      	beq.n	57c2 <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    5776:	eb07 0a08 	add.w	sl, r7, r8
    577a:	4683      	mov	fp, r0
    577c:	4689      	mov	r9, r1
	size_t index = 0;
    577e:	4690      	mov	r8, r2
    5780:	4c17      	ldr	r4, [pc, #92]	; (57e0 <Stream::readBytesUntil(char, char*, unsigned int)+0x80>)
    5782:	4e18      	ldr	r6, [pc, #96]	; (57e4 <Stream::readBytesUntil(char, char*, unsigned int)+0x84>)
    5784:	6825      	ldr	r5, [r4, #0]
    5786:	e00b      	b.n	57a0 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
        virtual int read() { return usb_serial_getchar(); }
    5788:	f001 fe56 	bl	7438 <usb_serial_getchar>
    if (c >= 0) return c;
    578c:	2800      	cmp	r0, #0
    578e:	da10      	bge.n	57b2 <Stream::readBytesUntil(char, char*, unsigned int)+0x52>
    yield();
    5790:	f001 fef6 	bl	7580 <yield>
    5794:	6823      	ldr	r3, [r4, #0]
  } while(millis() - startMillis < _timeout);
    5796:	f8db 2008 	ldr.w	r2, [fp, #8]
    579a:	1b5b      	subs	r3, r3, r5
    579c:	4293      	cmp	r3, r2
    579e:	d21a      	bcs.n	57d6 <Stream::readBytesUntil(char, char*, unsigned int)+0x76>
    c = read();
    57a0:	f8db 3000 	ldr.w	r3, [fp]
    57a4:	695b      	ldr	r3, [r3, #20]
    57a6:	42b3      	cmp	r3, r6
    57a8:	d0ee      	beq.n	5788 <Stream::readBytesUntil(char, char*, unsigned int)+0x28>
    57aa:	4658      	mov	r0, fp
    57ac:	4798      	blx	r3
    if (c >= 0) return c;
    57ae:	2800      	cmp	r0, #0
    57b0:	dbee      	blt.n	5790 <Stream::readBytesUntil(char, char*, unsigned int)+0x30>
		int c = timedRead();
		if (c == terminator) break;
    57b2:	4548      	cmp	r0, r9
    57b4:	d005      	beq.n	57c2 <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
		if (c < 0) {
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    57b6:	f807 0b01 	strb.w	r0, [r7], #1
	while (index < length) {
    57ba:	45ba      	cmp	sl, r7
		index++;
    57bc:	f108 0801 	add.w	r8, r8, #1
	while (index < length) {
    57c0:	d1e0      	bne.n	5784 <Stream::readBytesUntil(char, char*, unsigned int)+0x24>
	}
	*buffer = 0;
    57c2:	2300      	movs	r3, #0
	return index; // return number of characters, not including null terminator
}
    57c4:	4640      	mov	r0, r8
	*buffer = 0;
    57c6:	703b      	strb	r3, [r7, #0]
}
    57c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (length < 1) return 0;
    57cc:	f04f 0800 	mov.w	r8, #0
}
    57d0:	4640      	mov	r0, r8
    57d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	String readString(size_t max = 0 /* 0 means unlimited length */);
	String readStringUntil(char terminator, size_t max = 0 /* 0 means unlimited length */);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    57d6:	2301      	movs	r3, #1
    57d8:	f88b 300c 	strb.w	r3, [fp, #12]
    57dc:	e7f1      	b.n	57c2 <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    57de:	bf00      	nop
    57e0:	2000697c 	.word	0x2000697c
    57e4:	00005759 	.word	0x00005759

000057e8 <delay>:
	if (msec == 0) return;
    57e8:	b900      	cbnz	r0, 57ec <delay+0x4>
    57ea:	4770      	bx	lr
{
    57ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    57f0:	2101      	movs	r1, #1
    57f2:	4681      	mov	r9, r0
    57f4:	4c21      	ldr	r4, [pc, #132]	; (587c <delay+0x94>)
    57f6:	4d22      	ldr	r5, [pc, #136]	; (5880 <delay+0x98>)
    57f8:	4e22      	ldr	r6, [pc, #136]	; (5884 <delay+0x9c>)
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    57fa:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    57fe:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5800:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5802:	e844 1300 	strex	r3, r1, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    5806:	2b00      	cmp	r3, #0
    5808:	d1f7      	bne.n	57fa <delay+0x12>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    580a:	491f      	ldr	r1, [pc, #124]	; (5888 <delay+0xa0>)
    580c:	684b      	ldr	r3, [r1, #4]
	uint32_t usec = 1000*smc + frac;
    580e:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5812:	f8df a078 	ldr.w	sl, [pc, #120]	; 588c <delay+0xa4>
	uint32_t ccdelta = cyccnt - scc;
    5816:	1a1b      	subs	r3, r3, r0
    5818:	2701      	movs	r7, #1
	uint32_t usec = 1000*smc + frac;
    581a:	fb0b f802 	mul.w	r8, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    581e:	f8da 2000 	ldr.w	r2, [sl]
    5822:	fba3 3202 	umull	r3, r2, r3, r2
	uint32_t usec = 1000*smc + frac;
    5826:	455a      	cmp	r2, fp
    5828:	bf94      	ite	ls
    582a:	4490      	addls	r8, r2
    582c:	44d8      	addhi	r8, fp
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    582e:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    5832:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5834:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5836:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    583a:	2b00      	cmp	r3, #0
    583c:	d1f7      	bne.n	582e <delay+0x46>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    583e:	684b      	ldr	r3, [r1, #4]
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5840:	f8da c000 	ldr.w	ip, [sl]
	uint32_t ccdelta = cyccnt - scc;
    5844:	1a1b      	subs	r3, r3, r0
	uint32_t usec = 1000*smc + frac;
    5846:	fb0b f202 	mul.w	r2, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    584a:	fba3 3c0c 	umull	r3, ip, r3, ip
	uint32_t usec = 1000*smc + frac;
    584e:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
    5852:	bf94      	ite	ls
    5854:	4462      	addls	r2, ip
    5856:	f502 727a 	addhi.w	r2, r2, #1000	; 0x3e8
		while ((micros() - start) >= 1000) {
    585a:	eba2 0208 	sub.w	r2, r2, r8
    585e:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
    5862:	d306      	bcc.n	5872 <delay+0x8a>
			if (--msec == 0) return;
    5864:	f1b9 0901 	subs.w	r9, r9, #1
			start += 1000;
    5868:	f508 787a 	add.w	r8, r8, #1000	; 0x3e8
			if (--msec == 0) return;
    586c:	d1df      	bne.n	582e <delay+0x46>
}
    586e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		yield();
    5872:	f001 fe85 	bl	7580 <yield>
		while ((micros() - start) >= 1000) {
    5876:	4904      	ldr	r1, [pc, #16]	; (5888 <delay+0xa0>)
    5878:	e7d9      	b.n	582e <delay+0x46>
    587a:	bf00      	nop
    587c:	20006980 	.word	0x20006980
    5880:	2000697c 	.word	0x2000697c
    5884:	20006978 	.word	0x20006978
    5888:	e0001000 	.word	0xe0001000
    588c:	20006930 	.word	0x20006930

00005890 <digitalWrite>:
    5890:	2827      	cmp	r0, #39	; 0x27
    5892:	d816      	bhi.n	58c2 <digitalWrite+0x32>
	p = digital_pin_to_info_PGM + pin;
    5894:	0102      	lsls	r2, r0, #4
    5896:	4b10      	ldr	r3, [pc, #64]	; (58d8 <digitalWrite+0x48>)
    5898:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	pinmode = *(p->reg + 1);
    589c:	589b      	ldr	r3, [r3, r2]
{
    589e:	b410      	push	{r4}
	mask = p->mask;
    58a0:	68c2      	ldr	r2, [r0, #12]
	pinmode = *(p->reg + 1);
    58a2:	685c      	ldr	r4, [r3, #4]
	if (pinmode & mask) {
    58a4:	4214      	tst	r4, r2
    58a6:	d005      	beq.n	58b4 <digitalWrite+0x24>
		// pin is configured for output mode
		if (val) {
    58a8:	b961      	cbnz	r1, 58c4 <digitalWrite+0x34>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    58aa:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x22) = mask; // clear register
    58ae:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
    58b2:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    58b4:	6883      	ldr	r3, [r0, #8]
		if (val) {
    58b6:	b151      	cbz	r1, 58ce <digitalWrite+0x3e>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    58b8:	4a08      	ldr	r2, [pc, #32]	; (58dc <digitalWrite+0x4c>)
}
    58ba:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    58be:	601a      	str	r2, [r3, #0]
}
    58c0:	4770      	bx	lr
    58c2:	4770      	bx	lr
    58c4:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x21) = mask; // set register
    58c8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    58cc:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    58ce:	4a04      	ldr	r2, [pc, #16]	; (58e0 <digitalWrite+0x50>)
}
    58d0:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    58d4:	601a      	str	r2, [r3, #0]
}
    58d6:	4770      	bx	lr
    58d8:	200006bc 	.word	0x200006bc
    58dc:	0001f038 	.word	0x0001f038
    58e0:	00013038 	.word	0x00013038

000058e4 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    58e4:	2827      	cmp	r0, #39	; 0x27
    58e6:	d80b      	bhi.n	5900 <digitalRead+0x1c>
	p = digital_pin_to_info_PGM + pin;
    58e8:	4b06      	ldr	r3, [pc, #24]	; (5904 <digitalRead+0x20>)
    58ea:	0102      	lsls	r2, r0, #4
    58ec:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    58f0:	589a      	ldr	r2, [r3, r2]
    58f2:	68c3      	ldr	r3, [r0, #12]
    58f4:	6892      	ldr	r2, [r2, #8]
    58f6:	421a      	tst	r2, r3
    58f8:	bf14      	ite	ne
    58fa:	2001      	movne	r0, #1
    58fc:	2000      	moveq	r0, #0
    58fe:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return 0;
    5900:	2000      	movs	r0, #0
}
    5902:	4770      	bx	lr
    5904:	200006bc 	.word	0x200006bc

00005908 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    5908:	2827      	cmp	r0, #39	; 0x27
    590a:	d829      	bhi.n	5960 <pinMode+0x58>
	p = digital_pin_to_info_PGM + pin;
    590c:	4b16      	ldr	r3, [pc, #88]	; (5968 <pinMode+0x60>)
    590e:	0102      	lsls	r2, r0, #4
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5910:	2901      	cmp	r1, #1
	p = digital_pin_to_info_PGM + pin;
    5912:	eb03 1000 	add.w	r0, r3, r0, lsl #4
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5916:	589a      	ldr	r2, [r3, r2]
{
    5918:	b410      	push	{r4}
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    591a:	6853      	ldr	r3, [r2, #4]
    591c:	68c4      	ldr	r4, [r0, #12]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    591e:	d00e      	beq.n	593e <pinMode+0x36>
    5920:	2904      	cmp	r1, #4
    5922:	d00c      	beq.n	593e <pinMode+0x36>
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5924:	ea23 0304 	bic.w	r3, r3, r4
    5928:	6053      	str	r3, [r2, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    592a:	6883      	ldr	r3, [r0, #8]
		if (mode == INPUT) {
    592c:	b1a9      	cbz	r1, 595a <pinMode+0x52>
		} else if (mode == INPUT_PULLUP) {
    592e:	2902      	cmp	r1, #2
    5930:	d017      	beq.n	5962 <pinMode+0x5a>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    5932:	2903      	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5934:	bf0c      	ite	eq
    5936:	4a0d      	ldreq	r2, [pc, #52]	; (596c <pinMode+0x64>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    5938:	4a0d      	ldrne	r2, [pc, #52]	; (5970 <pinMode+0x68>)
    593a:	601a      	str	r2, [r3, #0]
    593c:	e007      	b.n	594e <pinMode+0x46>
		*(p->reg + 1) |= p->mask; // TODO: atomic
    593e:	4323      	orrs	r3, r4
		if (mode == OUTPUT) {
    5940:	2901      	cmp	r1, #1
		*(p->reg + 1) |= p->mask; // TODO: atomic
    5942:	6053      	str	r3, [r2, #4]
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5944:	6883      	ldr	r3, [r0, #8]
		if (mode == OUTPUT) {
    5946:	d008      	beq.n	595a <pinMode+0x52>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    5948:	f640 0238 	movw	r2, #2104	; 0x838
    594c:	601a      	str	r2, [r3, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    594e:	6843      	ldr	r3, [r0, #4]
    5950:	2215      	movs	r2, #21
}
    5952:	f85d 4b04 	ldr.w	r4, [sp], #4
	*(p->mux) = 5 | 0x10;
    5956:	601a      	str	r2, [r3, #0]
}
    5958:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7);
    595a:	2238      	movs	r2, #56	; 0x38
    595c:	601a      	str	r2, [r3, #0]
    595e:	e7f6      	b.n	594e <pinMode+0x46>
    5960:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5962:	4a04      	ldr	r2, [pc, #16]	; (5974 <pinMode+0x6c>)
    5964:	601a      	str	r2, [r3, #0]
    5966:	e7f2      	b.n	594e <pinMode+0x46>
    5968:	200006bc 	.word	0x200006bc
    596c:	00013038 	.word	0x00013038
    5970:	00010038 	.word	0x00010038
    5974:	0001f038 	.word	0x0001f038

00005978 <flash_wait>:
{
    5978:	b430      	push	{r4, r5}
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    597a:	4a12      	ldr	r2, [pc, #72]	; (59c4 <flash_wait+0x4c>)
	FLEXSPI_LUT61 = 0;
    597c:	2000      	movs	r0, #0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    597e:	4b12      	ldr	r3, [pc, #72]	; (59c8 <flash_wait+0x50>)
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5980:	2101      	movs	r1, #1
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    5982:	4d12      	ldr	r5, [pc, #72]	; (59cc <flash_wait+0x54>)
		status = *(uint8_t *)&FLEXSPI_RFDR0;
    5984:	4c12      	ldr	r4, [pc, #72]	; (59d0 <flash_wait+0x58>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5986:	f8c2 32f0 	str.w	r3, [r2, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    598a:	f8c2 02f4 	str.w	r0, [r2, #756]	; 0x2f4
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    598e:	f8c2 10b8 	str.w	r1, [r2, #184]	; 0xb8
		FLEXSPI_IPCR0 = 0;
    5992:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    5996:	f8c2 50a4 	str.w	r5, [r2, #164]	; 0xa4
		FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    599a:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
		while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) {;}
    599e:	6953      	ldr	r3, [r2, #20]
    59a0:	07db      	lsls	r3, r3, #31
    59a2:	d5fc      	bpl.n	599e <flash_wait+0x26>
		FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    59a4:	6151      	str	r1, [r2, #20]
	} while (status & 1);
    59a6:	7823      	ldrb	r3, [r4, #0]
    59a8:	07db      	lsls	r3, r3, #31
    59aa:	d4f0      	bmi.n	598e <flash_wait+0x16>
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    59ac:	6813      	ldr	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    59ae:	4905      	ldr	r1, [pc, #20]	; (59c4 <flash_wait+0x4c>)
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    59b0:	f043 0301 	orr.w	r3, r3, #1
    59b4:	6013      	str	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    59b6:	680b      	ldr	r3, [r1, #0]
    59b8:	07db      	lsls	r3, r3, #31
    59ba:	d4fc      	bmi.n	59b6 <flash_wait+0x3e>
	__enable_irq();
    59bc:	b662      	cpsie	i
}
    59be:	bc30      	pop	{r4, r5}
    59c0:	4770      	bx	lr
    59c2:	bf00      	nop
    59c4:	402a8000 	.word	0x402a8000
    59c8:	24010405 	.word	0x24010405
    59cc:	000f0001 	.word	0x000f0001
    59d0:	402a8100 	.word	0x402a8100

000059d4 <eeprom_initialize>:
{
    59d4:	b570      	push	{r4, r5, r6, lr}
    59d6:	4c0e      	ldr	r4, [pc, #56]	; (5a10 <eeprom_initialize+0x3c>)
			if (*p++ == 0xFFFF) break;
    59d8:	f64f 7eff 	movw	lr, #65535	; 0xffff
{
    59dc:	4e0d      	ldr	r6, [pc, #52]	; (5a14 <eeprom_initialize+0x40>)
    59de:	f104 051e 	add.w	r5, r4, #30
		const uint16_t *p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    59e2:	f5a6 5380 	sub.w	r3, r6, #4096	; 0x1000
		uint16_t index = 0;
    59e6:	2100      	movs	r1, #0
    59e8:	e002      	b.n	59f0 <eeprom_initialize+0x1c>
		} while (p < end);
    59ea:	42b3      	cmp	r3, r6
			index++;
    59ec:	b281      	uxth	r1, r0
		} while (p < end);
    59ee:	d204      	bcs.n	59fa <eeprom_initialize+0x26>
			if (*p++ == 0xFFFF) break;
    59f0:	881a      	ldrh	r2, [r3, #0]
			index++;
    59f2:	1c48      	adds	r0, r1, #1
			if (*p++ == 0xFFFF) break;
    59f4:	3302      	adds	r3, #2
    59f6:	4572      	cmp	r2, lr
    59f8:	d1f7      	bne.n	59ea <eeprom_initialize+0x16>
		sector_index[sector] = index;
    59fa:	f824 1f02 	strh.w	r1, [r4, #2]!
	for (sector=0; sector < FLASH_SECTORS; sector++) {
    59fe:	42ac      	cmp	r4, r5
    5a00:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
    5a04:	d1ed      	bne.n	59e2 <eeprom_initialize+0xe>
	initialized = 1;
    5a06:	4b04      	ldr	r3, [pc, #16]	; (5a18 <eeprom_initialize+0x44>)
    5a08:	2201      	movs	r2, #1
    5a0a:	701a      	strb	r2, [r3, #0]
}
    5a0c:	bd70      	pop	{r4, r5, r6, pc}
    5a0e:	bf00      	nop
    5a10:	20006932 	.word	0x20006932
    5a14:	601f1000 	.word	0x601f1000
    5a18:	20006ae5 	.word	0x20006ae5

00005a1c <eeprom_read_byte>:
	if (addr > E2END) return 0xFF;
    5a1c:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    5a20:	d22c      	bcs.n	5a7c <eeprom_read_byte+0x60>
	if (!initialized) eeprom_initialize();
    5a22:	4b17      	ldr	r3, [pc, #92]	; (5a80 <eeprom_read_byte+0x64>)
{
    5a24:	b510      	push	{r4, lr}
	if (!initialized) eeprom_initialize();
    5a26:	781b      	ldrb	r3, [r3, #0]
    5a28:	4604      	mov	r4, r0
    5a2a:	b323      	cbz	r3, 5a76 <eeprom_read_byte+0x5a>
	sector = (addr >> 2) % FLASH_SECTORS;
    5a2c:	08a0      	lsrs	r0, r4, #2
    5a2e:	4b15      	ldr	r3, [pc, #84]	; (5a84 <eeprom_read_byte+0x68>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5a30:	f004 0103 	and.w	r1, r4, #3
	end = p + sector_index[sector];
    5a34:	4c14      	ldr	r4, [pc, #80]	; (5a88 <eeprom_read_byte+0x6c>)
	sector = (addr >> 2) % FLASH_SECTORS;
    5a36:	fba3 2300 	umull	r2, r3, r3, r0
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5a3a:	4a14      	ldr	r2, [pc, #80]	; (5a8c <eeprom_read_byte+0x70>)
	sector = (addr >> 2) % FLASH_SECTORS;
    5a3c:	08db      	lsrs	r3, r3, #3
    5a3e:	ebc3 1e03 	rsb	lr, r3, r3, lsl #4
    5a42:	469c      	mov	ip, r3
    5a44:	eba0 030e 	sub.w	r3, r0, lr
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5a48:	ea41 018c 	orr.w	r1, r1, ip, lsl #2
	uint8_t data=0xFF;
    5a4c:	20ff      	movs	r0, #255	; 0xff
	end = p + sector_index[sector];
    5a4e:	f834 c013 	ldrh.w	ip, [r4, r3, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5a52:	441a      	add	r2, r3
	end = p + sector_index[sector];
    5a54:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5a58:	0313      	lsls	r3, r2, #12
	end = p + sector_index[sector];
    5a5a:	eb0c 3c02 	add.w	ip, ip, r2, lsl #12
	while (p < end) {
    5a5e:	ebbc 3f02 	cmp.w	ip, r2, lsl #12
    5a62:	d907      	bls.n	5a74 <eeprom_read_byte+0x58>
		uint32_t val = *p++;
    5a64:	881a      	ldrh	r2, [r3, #0]
    5a66:	3302      	adds	r3, #2
		if ((val & 255) == offset) data = val >> 8;
    5a68:	b2d4      	uxtb	r4, r2
    5a6a:	428c      	cmp	r4, r1
    5a6c:	bf08      	it	eq
    5a6e:	0a10      	lsreq	r0, r2, #8
	while (p < end) {
    5a70:	459c      	cmp	ip, r3
    5a72:	d8f7      	bhi.n	5a64 <eeprom_read_byte+0x48>
}
    5a74:	bd10      	pop	{r4, pc}
	if (!initialized) eeprom_initialize();
    5a76:	f7ff ffad 	bl	59d4 <eeprom_initialize>
    5a7a:	e7d7      	b.n	5a2c <eeprom_read_byte+0x10>
	if (addr > E2END) return 0xFF;
    5a7c:	20ff      	movs	r0, #255	; 0xff
}
    5a7e:	4770      	bx	lr
    5a80:	20006ae5 	.word	0x20006ae5
    5a84:	88888889 	.word	0x88888889
    5a88:	20006934 	.word	0x20006934
    5a8c:	000601f0 	.word	0x000601f0

00005a90 <eepromemu_flash_write>:
{
    5a90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5a92:	460f      	mov	r7, r1
    5a94:	4616      	mov	r6, r2
	__disable_irq();
    5a96:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5a98:	4b34      	ldr	r3, [pc, #208]	; (5b6c <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5a9a:	f240 4106 	movw	r1, #1030	; 0x406
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5a9e:	4a34      	ldr	r2, [pc, #208]	; (5b70 <eepromemu_flash_write+0xe0>)
    5aa0:	619a      	str	r2, [r3, #24]
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5aa2:	2202      	movs	r2, #2
    5aa4:	61da      	str	r2, [r3, #28]
	FLEXSPI_IPCR0 = 0;
    5aa6:	2200      	movs	r2, #0
    5aa8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5aac:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    5ab0:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    5ab4:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    5ab8:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5abc:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    5ac0:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5ac4:	2201      	movs	r2, #1
    5ac6:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    5aca:	f020 031f 	bic.w	r3, r0, #31
	uint32_t end_addr = (uint32_t)addr + size;
    5ace:	1982      	adds	r2, r0, r6
	asm volatile("": : :"memory");
	asm("dsb");
    5ad0:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    5ad4:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
    5ad8:	f8c4 3f5c 	str.w	r3, [r4, #3932]	; 0xf5c
		location += 32;
    5adc:	3320      	adds	r3, #32
	} while (location < end_addr);
    5ade:	429a      	cmp	r2, r3
    5ae0:	d8fa      	bhi.n	5ad8 <eepromemu_flash_write+0x48>
	asm("dsb");
    5ae2:	f3bf 8f4f 	dsb	sy
	asm("isb");
    5ae6:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5aea:	4d20      	ldr	r5, [pc, #128]	; (5b6c <eepromemu_flash_write+0xdc>)
    5aec:	696b      	ldr	r3, [r5, #20]
    5aee:	07da      	lsls	r2, r3, #31
    5af0:	d5fc      	bpl.n	5aec <eepromemu_flash_write+0x5c>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5af2:	2301      	movs	r3, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    5af4:	491f      	ldr	r1, [pc, #124]	; (5b74 <eepromemu_flash_write+0xe4>)
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5af6:	b2b2      	uxth	r2, r6
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    5af8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5afc:	616b      	str	r3, [r5, #20]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5afe:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    5b02:	f8c5 12f0 	str.w	r1, [r5, #752]	; 0x2f0
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    5b06:	f242 2101 	movw	r1, #8705	; 0x2201
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5b0a:	4c18      	ldr	r4, [pc, #96]	; (5b6c <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    5b0c:	f8c5 12f4 	str.w	r1, [r5, #756]	; 0x2f4
	FLEXSPI_IPTXFCR = FLEXSPI_IPTXFCR_CLRIPTXF; // clear tx fifo
    5b10:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    5b14:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5b18:	f8c5 20a4 	str.w	r2, [r5, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5b1c:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b20:	4d15      	ldr	r5, [pc, #84]	; (5b78 <eepromemu_flash_write+0xe8>)
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5b22:	e001      	b.n	5b28 <eepromemu_flash_write+0x98>
		if (n & FLEXSPI_INTR_IPTXWE) {
    5b24:	065b      	lsls	r3, r3, #25
    5b26:	d409      	bmi.n	5b3c <eepromemu_flash_write+0xac>
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5b28:	6963      	ldr	r3, [r4, #20]
    5b2a:	f013 0001 	ands.w	r0, r3, #1
    5b2e:	d0f9      	beq.n	5b24 <eepromemu_flash_write+0x94>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPTXWE;
    5b30:	2341      	movs	r3, #65	; 0x41
    5b32:	6163      	str	r3, [r4, #20]
}
    5b34:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	flash_wait();
    5b38:	f7ff bf1e 	b.w	5978 <flash_wait>
			if (wrlen > 8) wrlen = 8;
    5b3c:	2e08      	cmp	r6, #8
    5b3e:	d80a      	bhi.n	5b56 <eepromemu_flash_write+0xc6>
			if (wrlen > 0) {
    5b40:	b136      	cbz	r6, 5b50 <eepromemu_flash_write+0xc0>
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b42:	4632      	mov	r2, r6
    5b44:	4639      	mov	r1, r7
				src += wrlen;
    5b46:	4437      	add	r7, r6
				len -= wrlen;
    5b48:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b4a:	4628      	mov	r0, r5
    5b4c:	f000 f98e 	bl	5e6c <memcpy>
			FLEXSPI_INTR = FLEXSPI_INTR_IPTXWE;
    5b50:	2340      	movs	r3, #64	; 0x40
    5b52:	6163      	str	r3, [r4, #20]
    5b54:	e7e8      	b.n	5b28 <eepromemu_flash_write+0x98>
    5b56:	f1a6 0008 	sub.w	r0, r6, #8
			if (wrlen > 8) wrlen = 8;
    5b5a:	2608      	movs	r6, #8
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b5c:	4639      	mov	r1, r7
    5b5e:	4632      	mov	r2, r6
				src += wrlen;
    5b60:	4437      	add	r7, r6
				len -= wrlen;
    5b62:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b64:	4628      	mov	r0, r5
    5b66:	f000 f981 	bl	5e6c <memcpy>
				len -= wrlen;
    5b6a:	e7f1      	b.n	5b50 <eepromemu_flash_write+0xc0>
    5b6c:	402a8000 	.word	0x402a8000
    5b70:	5af05af0 	.word	0x5af05af0
    5b74:	08180432 	.word	0x08180432
    5b78:	402a8180 	.word	0x402a8180

00005b7c <eepromemu_flash_erase_sector>:
{
    5b7c:	b410      	push	{r4}
	__disable_irq();
    5b7e:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5b80:	4b28      	ldr	r3, [pc, #160]	; (5c24 <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5b82:	2102      	movs	r1, #2
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5b84:	4c28      	ldr	r4, [pc, #160]	; (5c28 <eepromemu_flash_erase_sector+0xac>)
	FLEXSPI_LUT61 = 0;
    5b86:	2200      	movs	r2, #0
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5b88:	619c      	str	r4, [r3, #24]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5b8a:	f44f 2470 	mov.w	r4, #983040	; 0xf0000
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5b8e:	61d9      	str	r1, [r3, #28]
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5b90:	f240 4106 	movw	r1, #1030	; 0x406
    5b94:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5b98:	2101      	movs	r1, #1
	FLEXSPI_LUT61 = 0;
    5b9a:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    5b9e:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    5ba2:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR0 = 0;
    5ba6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    5baa:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5bae:	f8c3 40a4 	str.w	r4, [r3, #164]	; 0xa4
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    5bb2:	4002      	ands	r2, r0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5bb4:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
	asm("dsb");
    5bb8:	f3bf 8f4f 	dsb	sy
	uint32_t end_addr = (uint32_t)addr + size;
    5bbc:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
    5bc0:	f102 0320 	add.w	r3, r2, #32
		SCB_CACHE_DCIMVAC = location;
    5bc4:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
    5bc8:	4299      	cmp	r1, r3
    5bca:	bf34      	ite	cc
    5bcc:	2101      	movcc	r1, #1
    5bce:	2180      	movcs	r1, #128	; 0x80
    5bd0:	eb02 1141 	add.w	r1, r2, r1, lsl #5
	} while (location < end_addr);
    5bd4:	428b      	cmp	r3, r1
		SCB_CACHE_DCIMVAC = location;
    5bd6:	f8cc 2f5c 	str.w	r2, [ip, #3932]	; 0xf5c
		location += 32;
    5bda:	461a      	mov	r2, r3
	} while (location < end_addr);
    5bdc:	f103 0320 	add.w	r3, r3, #32
    5be0:	d1f8      	bne.n	5bd4 <eepromemu_flash_erase_sector+0x58>
	asm("dsb");
    5be2:	f3bf 8f4f 	dsb	sy
	asm("isb");
    5be6:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5bea:	4a0e      	ldr	r2, [pc, #56]	; (5c24 <eepromemu_flash_erase_sector+0xa8>)
    5bec:	6953      	ldr	r3, [r2, #20]
    5bee:	07d9      	lsls	r1, r3, #31
    5bf0:	d5fc      	bpl.n	5bec <eepromemu_flash_erase_sector+0x70>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5bf2:	2401      	movs	r4, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    5bf4:	490d      	ldr	r1, [pc, #52]	; (5c2c <eepromemu_flash_erase_sector+0xb0>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    5bf6:	4b0e      	ldr	r3, [pc, #56]	; (5c30 <eepromemu_flash_erase_sector+0xb4>)
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5bf8:	6154      	str	r4, [r2, #20]
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    5bfa:	4003      	ands	r3, r0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    5bfc:	f8c2 12f0 	str.w	r1, [r2, #752]	; 0x2f0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5c00:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5c04:	4907      	ldr	r1, [pc, #28]	; (5c24 <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    5c06:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5c0a:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5c0e:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5c12:	694b      	ldr	r3, [r1, #20]
    5c14:	07db      	lsls	r3, r3, #31
    5c16:	d5fc      	bpl.n	5c12 <eepromemu_flash_erase_sector+0x96>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5c18:	2301      	movs	r3, #1
}
    5c1a:	f85d 4b04 	ldr.w	r4, [sp], #4
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5c1e:	614b      	str	r3, [r1, #20]
	flash_wait();
    5c20:	f7ff beaa 	b.w	5978 <flash_wait>
    5c24:	402a8000 	.word	0x402a8000
    5c28:	5af05af0 	.word	0x5af05af0
    5c2c:	08180420 	.word	0x08180420
    5c30:	00fff000 	.word	0x00fff000

00005c34 <eeprom_write_byte>:
	if (addr > E2END) return;
    5c34:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    5c38:	f080 8086 	bcs.w	5d48 <eeprom_write_byte+0x114>
	if (!initialized) eeprom_initialize();
    5c3c:	4b44      	ldr	r3, [pc, #272]	; (5d50 <eeprom_write_byte+0x11c>)
{
    5c3e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!initialized) eeprom_initialize();
    5c42:	781b      	ldrb	r3, [r3, #0]
{
    5c44:	b0c2      	sub	sp, #264	; 0x108
    5c46:	4605      	mov	r5, r0
    5c48:	4689      	mov	r9, r1
	if (!initialized) eeprom_initialize();
    5c4a:	2b00      	cmp	r3, #0
    5c4c:	d079      	beq.n	5d42 <eeprom_write_byte+0x10e>
	sector = (addr >> 2) % FLASH_SECTORS; 
    5c4e:	08ab      	lsrs	r3, r5, #2
    5c50:	4e40      	ldr	r6, [pc, #256]	; (5d54 <eeprom_write_byte+0x120>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5c52:	f005 0503 	and.w	r5, r5, #3
	end = p + sector_index[sector];
    5c56:	4f40      	ldr	r7, [pc, #256]	; (5d58 <eeprom_write_byte+0x124>)
	sector = (addr >> 2) % FLASH_SECTORS; 
    5c58:	fba6 2603 	umull	r2, r6, r6, r3
    5c5c:	08f6      	lsrs	r6, r6, #3
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5c5e:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
	sector = (addr >> 2) % FLASH_SECTORS; 
    5c62:	ebc6 1606 	rsb	r6, r6, r6, lsl #4
    5c66:	1b9e      	subs	r6, r3, r6
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5c68:	4b3c      	ldr	r3, [pc, #240]	; (5d5c <eeprom_write_byte+0x128>)
	end = p + sector_index[sector];
    5c6a:	f837 4016 	ldrh.w	r4, [r7, r6, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5c6e:	4433      	add	r3, r6
	end = p + sector_index[sector];
    5c70:	0060      	lsls	r0, r4, #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5c72:	ea4f 3803 	mov.w	r8, r3, lsl #12
	end = p + sector_index[sector];
    5c76:	eb00 3003 	add.w	r0, r0, r3, lsl #12
	while (p < end) {
    5c7a:	ebb0 3f03 	cmp.w	r0, r3, lsl #12
    5c7e:	d964      	bls.n	5d4a <eeprom_write_byte+0x116>
    5c80:	4643      	mov	r3, r8
	uint8_t olddata=0xFF;
    5c82:	f04f 0cff 	mov.w	ip, #255	; 0xff
		uint16_t val = *p++;
    5c86:	881a      	ldrh	r2, [r3, #0]
    5c88:	3302      	adds	r3, #2
		if ((val & 255) == offset) olddata = val >> 8;
    5c8a:	b2d1      	uxtb	r1, r2
    5c8c:	42a9      	cmp	r1, r5
    5c8e:	bf08      	it	eq
    5c90:	ea4f 2c12 	moveq.w	ip, r2, lsr #8
	while (p < end) {
    5c94:	4298      	cmp	r0, r3
    5c96:	d8f6      	bhi.n	5c86 <eeprom_write_byte+0x52>
	if (data == olddata) return;
    5c98:	45e1      	cmp	r9, ip
    5c9a:	d041      	beq.n	5d20 <eeprom_write_byte+0xec>
	if (sector_index[sector] < 2048) {
    5c9c:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
    5ca0:	d341      	bcc.n	5d26 <eeprom_write_byte+0xf2>
		memset(buf, 0xFF, sizeof(buf));
    5ca2:	ac02      	add	r4, sp, #8
    5ca4:	f44f 7280 	mov.w	r2, #256	; 0x100
    5ca8:	21ff      	movs	r1, #255	; 0xff
    5caa:	4620      	mov	r0, r4
    5cac:	f001 fee8 	bl	7a80 <memset>
		while (p < end) {
    5cb0:	f508 5080 	add.w	r0, r8, #4096	; 0x1000
    5cb4:	f108 0302 	add.w	r3, r8, #2
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5cb8:	4642      	mov	r2, r8
    5cba:	4298      	cmp	r0, r3
    5cbc:	bf34      	ite	cc
    5cbe:	2001      	movcc	r0, #1
    5cc0:	f44f 6000 	movcs.w	r0, #2048	; 0x800
    5cc4:	eb08 0040 	add.w	r0, r8, r0, lsl #1
			uint16_t val = *p++;
    5cc8:	4613      	mov	r3, r2
    5cca:	3202      	adds	r2, #2
    5ccc:	881b      	ldrh	r3, [r3, #0]
		while (p < end) {
    5cce:	4282      	cmp	r2, r0
			buf[val & 255] = val >> 8;
    5cd0:	b2d9      	uxtb	r1, r3
    5cd2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    5cd6:	5463      	strb	r3, [r4, r1]
		while (p < end) {
    5cd8:	d1f6      	bne.n	5cc8 <eeprom_write_byte+0x94>
		buf[offset] = data;
    5cda:	f804 9005 	strb.w	r9, [r4, r5]
		eepromemu_flash_erase_sector(p);
    5cde:	f10d 0907 	add.w	r9, sp, #7
    5ce2:	f20d 1a07 	addw	sl, sp, #263	; 0x107
		index = 0;
    5ce6:	2500      	movs	r5, #0
		eepromemu_flash_erase_sector(p);
    5ce8:	464c      	mov	r4, r9
    5cea:	4640      	mov	r0, r8
    5cec:	f7ff ff46 	bl	5b7c <eepromemu_flash_erase_sector>
			if (buf[i] != 0xFF) {
    5cf0:	f814 cf01 	ldrb.w	ip, [r4, #1]!
				eepromemu_flash_write(p + index, &newval, 2);
    5cf4:	eb08 0045 	add.w	r0, r8, r5, lsl #1
    5cf8:	2202      	movs	r2, #2
    5cfa:	f10d 0106 	add.w	r1, sp, #6
				uint16_t newval = i | (buf[i] << 8);
    5cfe:	1e63      	subs	r3, r4, #1
			if (buf[i] != 0xFF) {
    5d00:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
				uint16_t newval = i | (buf[i] << 8);
    5d04:	eba3 0309 	sub.w	r3, r3, r9
			if (buf[i] != 0xFF) {
    5d08:	d006      	beq.n	5d18 <eeprom_write_byte+0xe4>
				uint16_t newval = i | (buf[i] << 8);
    5d0a:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
				index = index + 1;
    5d0e:	3501      	adds	r5, #1
				uint16_t newval = i | (buf[i] << 8);
    5d10:	f8ad 3006 	strh.w	r3, [sp, #6]
				eepromemu_flash_write(p + index, &newval, 2);
    5d14:	f7ff febc 	bl	5a90 <eepromemu_flash_write>
		for (i=0; i < 256; i++) {
    5d18:	45a2      	cmp	sl, r4
    5d1a:	d1e9      	bne.n	5cf0 <eeprom_write_byte+0xbc>
		sector_index[sector] = index;
    5d1c:	f827 5016 	strh.w	r5, [r7, r6, lsl #1]
}
    5d20:	b042      	add	sp, #264	; 0x108
    5d22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint16_t newdata = offset | (data << 8);
    5d26:	ea45 2509 	orr.w	r5, r5, r9, lsl #8
		eepromemu_flash_write(end, &newdata, 2);
    5d2a:	a902      	add	r1, sp, #8
    5d2c:	2202      	movs	r2, #2
		sector_index[sector] = sector_index[sector] + 1;
    5d2e:	3401      	adds	r4, #1
		uint16_t newdata = offset | (data << 8);
    5d30:	f8ad 5008 	strh.w	r5, [sp, #8]
		eepromemu_flash_write(end, &newdata, 2);
    5d34:	f7ff feac 	bl	5a90 <eepromemu_flash_write>
		sector_index[sector] = sector_index[sector] + 1;
    5d38:	f827 4016 	strh.w	r4, [r7, r6, lsl #1]
}
    5d3c:	b042      	add	sp, #264	; 0x108
    5d3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!initialized) eeprom_initialize();
    5d42:	f7ff fe47 	bl	59d4 <eeprom_initialize>
    5d46:	e782      	b.n	5c4e <eeprom_write_byte+0x1a>
    5d48:	4770      	bx	lr
	uint8_t olddata=0xFF;
    5d4a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    5d4e:	e7a3      	b.n	5c98 <eeprom_write_byte+0x64>
    5d50:	20006ae5 	.word	0x20006ae5
    5d54:	88888889 	.word	0x88888889
    5d58:	20006934 	.word	0x20006934
    5d5c:	000601f0 	.word	0x000601f0

00005d60 <dummy_isr>:
static void dummy_isr() {};
    5d60:	4770      	bx	lr
    5d62:	bf00      	nop

00005d64 <attachInterrupt>:

#endif

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5d64:	2827      	cmp	r0, #39	; 0x27
    5d66:	d852      	bhi.n	5e0e <attachInterrupt+0xaa>
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
    5d68:	0100      	lsls	r0, r0, #4
{
    5d6a:	b4f0      	push	{r4, r5, r6, r7}
	volatile uint32_t *gpio = portOutputRegister(pin);
    5d6c:	4c31      	ldr	r4, [pc, #196]	; (5e34 <attachInterrupt+0xd0>)

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
    5d6e:	4d32      	ldr	r5, [pc, #200]	; (5e38 <attachInterrupt+0xd4>)
	volatile uint32_t *gpio = portOutputRegister(pin);
    5d70:	5823      	ldr	r3, [r4, r0]
	switch((uint32_t)gpio) {
    5d72:	42ab      	cmp	r3, r5
    5d74:	d050      	beq.n	5e18 <attachInterrupt+0xb4>
    5d76:	d843      	bhi.n	5e00 <attachInterrupt+0x9c>
    5d78:	f1b3 4f84 	cmp.w	r3, #1107296256	; 0x42000000
    5d7c:	d045      	beq.n	5e0a <attachInterrupt+0xa6>
    5d7e:	f5a5 4580 	sub.w	r5, r5, #16384	; 0x4000
    5d82:	42ab      	cmp	r3, r5
    5d84:	d13a      	bne.n	5dfc <attachInterrupt+0x98>
    5d86:	4d2d      	ldr	r5, [pc, #180]	; (5e3c <attachInterrupt+0xd8>)
	volatile uint32_t *mux = portConfigRegister(pin);
    5d88:	4404      	add	r4, r0
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    5d8a:	4e2d      	ldr	r6, [pc, #180]	; (5e40 <attachInterrupt+0xdc>)
    5d8c:	482d      	ldr	r0, [pc, #180]	; (5e44 <attachInterrupt+0xe0>)
    5d8e:	6867      	ldr	r7, [r4, #4]
    5d90:	f8c0 62b4 	str.w	r6, [r0, #692]	; 0x2b4
	uint32_t mask = digitalPinToBitMask(pin);
    5d94:	68e0      	ldr	r0, [r4, #12]
		default:
			return;
	}

	attachInterruptVector(IRQ_GPIO6789, &irq_gpio6789);
	NVIC_ENABLE_IRQ(IRQ_GPIO6789);
    5d96:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
    5d9a:	f04f 5600 	mov.w	r6, #536870912	; 0x20000000
    5d9e:	2a04      	cmp	r2, #4
    5da0:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110

#endif

	uint32_t icr;
	switch (mode) {
    5da4:	d82a      	bhi.n	5dfc <attachInterrupt+0x98>
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    5da6:	695c      	ldr	r4, [r3, #20]
    5da8:	ea24 0400 	bic.w	r4, r4, r0
    5dac:	615c      	str	r4, [r3, #20]
	*mux = 5;		// pin is GPIO
    5dae:	f04f 0405 	mov.w	r4, #5
    5db2:	603c      	str	r4, [r7, #0]
	gpio[GDIR_INDEX] &= ~mask;	// pin to input mode
    5db4:	685c      	ldr	r4, [r3, #4]
    5db6:	ea24 0400 	bic.w	r4, r4, r0
    5dba:	605c      	str	r4, [r3, #4]
    5dbc:	4c22      	ldr	r4, [pc, #136]	; (5e48 <attachInterrupt+0xe4>)
    5dbe:	f854 4022 	ldr.w	r4, [r4, r2, lsl #2]
	uint32_t index = __builtin_ctz(mask);
    5dc2:	fa90 f2a0 	rbit	r2, r0
    5dc6:	fab2 f282 	clz	r2, r2
	table[index] = function;
    5dca:	f845 1022 	str.w	r1, [r5, r2, lsl #2]
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    5dce:	ea6f 0100 	mvn.w	r1, r0
	if (mode == CHANGE) {
    5dd2:	d01d      	beq.n	5e10 <attachInterrupt+0xac>
		gpio[EDGE_INDEX] |= mask;
	} else {
		gpio[EDGE_INDEX] &= ~mask;
    5dd4:	69dd      	ldr	r5, [r3, #28]
		if (index < 16) {
    5dd6:	2a0f      	cmp	r2, #15
		gpio[EDGE_INDEX] &= ~mask;
    5dd8:	ea01 0105 	and.w	r1, r1, r5
    5ddc:	61d9      	str	r1, [r3, #28]
		if (index < 16) {
    5dde:	dc1d      	bgt.n	5e1c <attachInterrupt+0xb8>
			uint32_t shift = index * 2;
    5de0:	0052      	lsls	r2, r2, #1
			gpio[ICR1_INDEX] = (gpio[ICR1_INDEX] & ~(3 << shift)) | (icr << shift);
    5de2:	2503      	movs	r5, #3
    5de4:	68d9      	ldr	r1, [r3, #12]
    5de6:	4094      	lsls	r4, r2
    5de8:	fa05 f202 	lsl.w	r2, r5, r2
    5dec:	ea21 0202 	bic.w	r2, r1, r2
    5df0:	4322      	orrs	r2, r4
    5df2:	60da      	str	r2, [r3, #12]
		} else {
			uint32_t shift = (index - 16) * 2;
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
		}
	}
	gpio[ISR_INDEX] = mask;  // clear any prior pending interrupt
    5df4:	6198      	str	r0, [r3, #24]
	gpio[IMR_INDEX] |= mask; // enable interrupt
    5df6:	695a      	ldr	r2, [r3, #20]
    5df8:	4302      	orrs	r2, r0
    5dfa:	615a      	str	r2, [r3, #20]
}
    5dfc:	bcf0      	pop	{r4, r5, r6, r7}
    5dfe:	4770      	bx	lr
	switch((uint32_t)gpio) {
    5e00:	4d12      	ldr	r5, [pc, #72]	; (5e4c <attachInterrupt+0xe8>)
    5e02:	42ab      	cmp	r3, r5
    5e04:	d1fa      	bne.n	5dfc <attachInterrupt+0x98>
			table = isr_table_gpio4;
    5e06:	4d12      	ldr	r5, [pc, #72]	; (5e50 <attachInterrupt+0xec>)
    5e08:	e7be      	b.n	5d88 <attachInterrupt+0x24>
			table = isr_table_gpio1;
    5e0a:	4d12      	ldr	r5, [pc, #72]	; (5e54 <attachInterrupt+0xf0>)
    5e0c:	e7bc      	b.n	5d88 <attachInterrupt+0x24>
    5e0e:	4770      	bx	lr
		gpio[EDGE_INDEX] |= mask;
    5e10:	69da      	ldr	r2, [r3, #28]
    5e12:	4302      	orrs	r2, r0
    5e14:	61da      	str	r2, [r3, #28]
    5e16:	e7ed      	b.n	5df4 <attachInterrupt+0x90>
			table = isr_table_gpio3;
    5e18:	4d0f      	ldr	r5, [pc, #60]	; (5e58 <attachInterrupt+0xf4>)
    5e1a:	e7b5      	b.n	5d88 <attachInterrupt+0x24>
			uint32_t shift = (index - 16) * 2;
    5e1c:	3a10      	subs	r2, #16
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    5e1e:	2503      	movs	r5, #3
    5e20:	6919      	ldr	r1, [r3, #16]
			uint32_t shift = (index - 16) * 2;
    5e22:	0052      	lsls	r2, r2, #1
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    5e24:	4094      	lsls	r4, r2
    5e26:	fa05 f202 	lsl.w	r2, r5, r2
    5e2a:	ea21 0202 	bic.w	r2, r1, r2
    5e2e:	4322      	orrs	r2, r4
    5e30:	611a      	str	r2, [r3, #16]
    5e32:	e7df      	b.n	5df4 <attachInterrupt+0x90>
    5e34:	200006bc 	.word	0x200006bc
    5e38:	42008000 	.word	0x42008000
    5e3c:	20000b70 	.word	0x20000b70
    5e40:	00000021 	.word	0x00000021
    5e44:	20001000 	.word	0x20001000
    5e48:	200002d8 	.word	0x200002d8
    5e4c:	4200c000 	.word	0x4200c000
    5e50:	20000c70 	.word	0x20000c70
    5e54:	20000af0 	.word	0x20000af0
    5e58:	20000bf0 	.word	0x20000bf0

00005e5c <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    5e5c:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    5e5e:	f7fa f961 	bl	124 <setup>
	while (1) {
		loop();
    5e62:	f7fa fa01 	bl	268 <loop>
		yield();
    5e66:	f001 fb8b 	bl	7580 <yield>
	while (1) {
    5e6a:	e7fa      	b.n	5e62 <main+0x6>

00005e6c <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    5e6c:	4684      	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    5e6e:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    5e72:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    5e76:	d16d      	bne.n	5f54 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5e78:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    5e7a:	d341      	bcc.n	5f00 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    5e7c:	f851 3b04 	ldr.w	r3, [r1], #4
    5e80:	f840 3b04 	str.w	r3, [r0], #4
    5e84:	f851 3b04 	ldr.w	r3, [r1], #4
    5e88:	f840 3b04 	str.w	r3, [r0], #4
    5e8c:	f851 3b04 	ldr.w	r3, [r1], #4
    5e90:	f840 3b04 	str.w	r3, [r0], #4
    5e94:	f851 3b04 	ldr.w	r3, [r1], #4
    5e98:	f840 3b04 	str.w	r3, [r0], #4
    5e9c:	f851 3b04 	ldr.w	r3, [r1], #4
    5ea0:	f840 3b04 	str.w	r3, [r0], #4
    5ea4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ea8:	f840 3b04 	str.w	r3, [r0], #4
    5eac:	f851 3b04 	ldr.w	r3, [r1], #4
    5eb0:	f840 3b04 	str.w	r3, [r0], #4
    5eb4:	f851 3b04 	ldr.w	r3, [r1], #4
    5eb8:	f840 3b04 	str.w	r3, [r0], #4
    5ebc:	f851 3b04 	ldr.w	r3, [r1], #4
    5ec0:	f840 3b04 	str.w	r3, [r0], #4
    5ec4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ec8:	f840 3b04 	str.w	r3, [r0], #4
    5ecc:	f851 3b04 	ldr.w	r3, [r1], #4
    5ed0:	f840 3b04 	str.w	r3, [r0], #4
    5ed4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ed8:	f840 3b04 	str.w	r3, [r0], #4
    5edc:	f851 3b04 	ldr.w	r3, [r1], #4
    5ee0:	f840 3b04 	str.w	r3, [r0], #4
    5ee4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ee8:	f840 3b04 	str.w	r3, [r0], #4
    5eec:	f851 3b04 	ldr.w	r3, [r1], #4
    5ef0:	f840 3b04 	str.w	r3, [r0], #4
    5ef4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ef8:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5efc:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    5efe:	d2bd      	bcs.n	5e7c <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    5f00:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    5f02:	d311      	bcc.n	5f28 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    5f04:	f851 3b04 	ldr.w	r3, [r1], #4
    5f08:	f840 3b04 	str.w	r3, [r0], #4
    5f0c:	f851 3b04 	ldr.w	r3, [r1], #4
    5f10:	f840 3b04 	str.w	r3, [r0], #4
    5f14:	f851 3b04 	ldr.w	r3, [r1], #4
    5f18:	f840 3b04 	str.w	r3, [r0], #4
    5f1c:	f851 3b04 	ldr.w	r3, [r1], #4
    5f20:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    5f24:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    5f26:	d2ed      	bcs.n	5f04 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    5f28:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    5f2a:	d305      	bcc.n	5f38 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    5f2c:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    5f30:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    5f34:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    5f36:	d2f9      	bcs.n	5f2c <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    5f38:	3204      	adds	r2, #4
	beq	.Ldone
    5f3a:	d008      	beq.n	5f4e <memcpy+0xe2>

	lsls	r2, r2, #31
    5f3c:	07d2      	lsls	r2, r2, #31
	itt ne
    5f3e:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5f40:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    5f44:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    5f48:	d301      	bcc.n	5f4e <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    5f4a:	880b      	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    5f4c:	8003      	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    5f4e:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    5f50:	4770      	bx	lr
    5f52:	bf00      	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    5f54:	2a08      	cmp	r2, #8
	blo	.Lbyte_copy
    5f56:	d313      	bcc.n	5f80 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    5f58:	078b      	lsls	r3, r1, #30
	beq	.Ldst_aligned
    5f5a:	d08d      	beq.n	5e78 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    5f5c:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    5f60:	d08a      	beq.n	5e78 <memcpy+0xc>

	rsb	r3, #4
    5f62:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    5f66:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    5f68:	07db      	lsls	r3, r3, #31
	itt ne
    5f6a:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5f6c:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    5f70:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    5f74:	d380      	bcc.n	5e78 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    5f76:	f831 3b02 	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    5f7a:	f820 3b02 	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    5f7e:	e77b      	b.n	5e78 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    5f80:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    5f82:	d3d9      	bcc.n	5f38 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    5f84:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    5f86:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    5f8a:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    5f8e:	d2f9      	bcs.n	5f84 <memcpy+0x118>

	ldrb	r3, [r1]
    5f90:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    5f92:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    5f94:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    5f96:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    5f98:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    5f9a:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    5f9c:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    5f9e:	4770      	bx	lr

00005fa0 <ultoa>:


char * ultoa(unsigned long val, char *buf, int radix)
{
	unsigned digit;
	int i=0, j;
    5fa0:	f101 3cff 	add.w	ip, r1, #4294967295
{
    5fa4:	b570      	push	{r4, r5, r6, lr}
	char t;

	while (1) {
		digit = val % radix;
    5fa6:	4666      	mov	r6, ip
	int i=0, j;
    5fa8:	2400      	movs	r4, #0
    5faa:	e000      	b.n	5fae <ultoa+0xe>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    5fac:	3401      	adds	r4, #1
		digit = val % radix;
    5fae:	fbb0 f5f2 	udiv	r5, r0, r2
    5fb2:	fb02 0315 	mls	r3, r2, r5, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5fb6:	2b09      	cmp	r3, #9
    5fb8:	f103 0e37 	add.w	lr, r3, #55	; 0x37
    5fbc:	f103 0330 	add.w	r3, r3, #48	; 0x30
    5fc0:	fa5f fe8e 	uxtb.w	lr, lr
    5fc4:	bf98      	it	ls
    5fc6:	fa5f fe83 	uxtbls.w	lr, r3
		if (val == 0) break;
    5fca:	4290      	cmp	r0, r2
		val /= radix;
    5fcc:	4628      	mov	r0, r5
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5fce:	f806 ef01 	strb.w	lr, [r6, #1]!
		if (val == 0) break;
    5fd2:	d2eb      	bcs.n	5fac <ultoa+0xc>
	}
	buf[i + 1] = 0;
    5fd4:	1c63      	adds	r3, r4, #1
    5fd6:	2200      	movs	r2, #0
    5fd8:	18c8      	adds	r0, r1, r3
    5fda:	54ca      	strb	r2, [r1, r3]
	for (j=0; j < i; j++, i--) {
    5fdc:	b17c      	cbz	r4, 5ffe <ultoa+0x5e>
		t = buf[j];
    5fde:	4662      	mov	r2, ip
    5fe0:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
		buf[j] = buf[i];
    5fe4:	f810 6d01 	ldrb.w	r6, [r0, #-1]!
	for (j=0; j < i; j++, i--) {
    5fe8:	eba1 030c 	sub.w	r3, r1, ip
    5fec:	3202      	adds	r2, #2
		buf[j] = buf[i];
    5fee:	f88c 6000 	strb.w	r6, [ip]
	for (j=0; j < i; j++, i--) {
    5ff2:	3b01      	subs	r3, #1
    5ff4:	1a52      	subs	r2, r2, r1
		buf[i] = t;
    5ff6:	7005      	strb	r5, [r0, #0]
	for (j=0; j < i; j++, i--) {
    5ff8:	4423      	add	r3, r4
    5ffa:	429a      	cmp	r2, r3
    5ffc:	dbef      	blt.n	5fde <ultoa+0x3e>
	}
	return buf;
}
    5ffe:	4608      	mov	r0, r1
    6000:	bd70      	pop	{r4, r5, r6, pc}
    6002:	bf00      	nop

00006004 <flexpwmWrite>:

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    6004:	f04f 0c01 	mov.w	ip, #1
    6008:	fa0c fc01 	lsl.w	ip, ip, r1
	uint32_t modulo = p->SM[submodule].VAL1;
    600c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6010:	eb00 1141 	add.w	r1, r0, r1, lsl #5
{
    6014:	b570      	push	{r4, r5, r6, lr}
	uint32_t modulo = p->SM[submodule].VAL1;
    6016:	f8b1 e00e 	ldrh.w	lr, [r1, #14]
	uint16_t mask = 1 << submodule;
    601a:	fa1f f58c 	uxth.w	r5, ip
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    601e:	4c25      	ldr	r4, [pc, #148]	; (60b4 <flexpwmWrite+0xb0>)
	uint32_t modulo = p->SM[submodule].VAL1;
    6020:	fa1f fe8e 	uxth.w	lr, lr
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6024:	7824      	ldrb	r4, [r4, #0]
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    6026:	012e      	lsls	r6, r5, #4
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6028:	fb0e 3303 	mla	r3, lr, r3, r3
    602c:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    6030:	40e3      	lsrs	r3, r4
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    6032:	f8b0 4188 	ldrh.w	r4, [r0, #392]	; 0x188
    6036:	4573      	cmp	r3, lr
    6038:	b2a4      	uxth	r4, r4
    603a:	bf28      	it	cs
    603c:	4673      	movcs	r3, lr
    603e:	4334      	orrs	r4, r6
	switch (channel) {
    6040:	2a01      	cmp	r2, #1
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    6042:	f8a0 4188 	strh.w	r4, [r0, #392]	; 0x188
	switch (channel) {
    6046:	d00d      	beq.n	6064 <flexpwmWrite+0x60>
    6048:	2a02      	cmp	r2, #2
    604a:	d028      	beq.n	609e <flexpwmWrite+0x9a>
    604c:	b1c2      	cbz	r2, 6080 <flexpwmWrite+0x7c>
    604e:	f00c 020f 	and.w	r2, ip, #15
	  case 2: // B
		p->SM[submodule].VAL5 = cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
		//printf(" write channel B\n");
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    6052:	f8b0 c188 	ldrh.w	ip, [r0, #392]	; 0x188
    6056:	fa1f fc8c 	uxth.w	ip, ip
    605a:	ea4c 0c02 	orr.w	ip, ip, r2
    605e:	f8a0 c188 	strh.w	ip, [r0, #392]	; 0x188
}
    6062:	bd70      	pop	{r4, r5, r6, pc}
		p->SM[submodule].VAL3 = cval;
    6064:	b29b      	uxth	r3, r3
    6066:	f00c 020f 	and.w	r2, ip, #15
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    606a:	022d      	lsls	r5, r5, #8
		p->SM[submodule].VAL3 = cval;
    606c:	82cb      	strh	r3, [r1, #22]
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    606e:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    6072:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
    6076:	b29b      	uxth	r3, r3
    6078:	432b      	orrs	r3, r5
    607a:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    607e:	e7e8      	b.n	6052 <flexpwmWrite+0x4e>
		p->SM[submodule].VAL0 = modulo - cval;
    6080:	ebae 0e03 	sub.w	lr, lr, r3
    6084:	f00c 020f 	and.w	r2, ip, #15
    6088:	fa1f fe8e 	uxth.w	lr, lr
    608c:	f8a1 e00a 	strh.w	lr, [r1, #10]
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
    6090:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    6094:	b29b      	uxth	r3, r3
    6096:	4313      	orrs	r3, r2
    6098:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    609c:	e7d9      	b.n	6052 <flexpwmWrite+0x4e>
		p->SM[submodule].VAL5 = cval;
    609e:	b29b      	uxth	r3, r3
    60a0:	f00c 020f 	and.w	r2, ip, #15
    60a4:	83cb      	strh	r3, [r1, #30]
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
    60a6:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    60aa:	b29b      	uxth	r3, r3
    60ac:	431e      	orrs	r6, r3
    60ae:	f8a0 6180 	strh.w	r6, [r0, #384]	; 0x180
    60b2:	e7ce      	b.n	6052 <flexpwmWrite+0x4e>
    60b4:	20000d46 	.word	0x20000d46

000060b8 <analogWrite>:

void analogWrite(uint8_t pin, int val)
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
    60b8:	2827      	cmp	r0, #39	; 0x27
    60ba:	d84b      	bhi.n	6154 <analogWrite+0x9c>
{
    60bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    60be:	4d2a      	ldr	r5, [pc, #168]	; (6168 <analogWrite+0xb0>)
    60c0:	4604      	mov	r4, r0
	if (info->type == 1) {
    60c2:	f815 2020 	ldrb.w	r2, [r5, r0, lsl #2]
	info = pwm_pin_info + pin;
    60c6:	eb05 0580 	add.w	r5, r5, r0, lsl #2
	if (info->type == 1) {
    60ca:	2a01      	cmp	r2, #1
    60cc:	d02d      	beq.n	612a <analogWrite+0x72>
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
    60ce:	2a02      	cmp	r2, #2
    60d0:	d13f      	bne.n	6152 <analogWrite+0x9a>
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    60d2:	786b      	ldrb	r3, [r5, #1]
    60d4:	f3c3 1001 	ubfx	r0, r3, #4, #2
    60d8:	2803      	cmp	r0, #3
    60da:	d03e      	beq.n	615a <analogWrite+0xa2>
    60dc:	4a23      	ldr	r2, [pc, #140]	; (616c <analogWrite+0xb4>)
    60de:	eb02 3280 	add.w	r2, r2, r0, lsl #14
		  case 0: qtimer = &IMXRT_TMR1; break;
		  case 1: qtimer = &IMXRT_TMR2; break;
		  case 2: qtimer = &IMXRT_TMR3; break;
		  default: qtimer = &IMXRT_TMR4;
		}
		quadtimerWrite(qtimer, info->module & 0x03, val);
    60e2:	f003 0c03 	and.w	ip, r3, #3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    60e6:	4822      	ldr	r0, [pc, #136]	; (6170 <analogWrite+0xb8>)
    60e8:	b289      	uxth	r1, r1
    60ea:	4663      	mov	r3, ip
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    60ec:	eb02 1c4c 	add.w	ip, r2, ip, lsl #5
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    60f0:	7806      	ldrb	r6, [r0, #0]
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    60f2:	f8bc e006 	ldrh.w	lr, [ip, #6]
    60f6:	0158      	lsls	r0, r3, #5
    60f8:	f8bc 3010 	ldrh.w	r3, [ip, #16]
    60fc:	fa1f fe8e 	uxth.w	lr, lr
    6100:	f1ce 1e01 	rsb	lr, lr, #65537	; 0x10001
    6104:	fa1e f383 	uxtah	r3, lr, r3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    6108:	f103 3eff 	add.w	lr, r3, #4294967295
    610c:	fb0e f101 	mul.w	r1, lr, r1
    6110:	40f1      	lsrs	r1, r6
	if (high >= modulo - 1) high = modulo - 2;
    6112:	458e      	cmp	lr, r1
    6114:	d923      	bls.n	615e <analogWrite+0xa6>
	uint32_t low = modulo - high; // low must 2 or higher
    6116:	1a5b      	subs	r3, r3, r1
	p->CH[submodule].LOAD = 65537 - low;
    6118:	f1c3 0301 	rsb	r3, r3, #1
    611c:	b29b      	uxth	r3, r3
	p->CH[submodule].CMPLD1 = high;
    611e:	b289      	uxth	r1, r1
    6120:	4402      	add	r2, r0
	p->CH[submodule].LOAD = 65537 - low;
    6122:	f8ac 3006 	strh.w	r3, [ip, #6]
	p->CH[submodule].CMPLD1 = high;
    6126:	8211      	strh	r1, [r2, #16]
}
    6128:	e00d      	b.n	6146 <analogWrite+0x8e>
		switch ((info->module >> 4) & 3) {
    612a:	786a      	ldrb	r2, [r5, #1]
    612c:	f3c2 1301 	ubfx	r3, r2, #4, #2
    6130:	2b03      	cmp	r3, #3
    6132:	d010      	beq.n	6156 <analogWrite+0x9e>
    6134:	480f      	ldr	r0, [pc, #60]	; (6174 <analogWrite+0xbc>)
    6136:	eb00 3083 	add.w	r0, r0, r3, lsl #14
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
    613a:	b28b      	uxth	r3, r1
    613c:	f002 0103 	and.w	r1, r2, #3
    6140:	78aa      	ldrb	r2, [r5, #2]
    6142:	f7ff ff5f 	bl	6004 <flexpwmWrite>
	} else {
		return;
	}
	*(portConfigRegister(pin)) = info->muxval;
    6146:	4b0c      	ldr	r3, [pc, #48]	; (6178 <analogWrite+0xc0>)
    6148:	78ea      	ldrb	r2, [r5, #3]
    614a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    614e:	685b      	ldr	r3, [r3, #4]
    6150:	601a      	str	r2, [r3, #0]
	// TODO: pad config register
}
    6152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6154:	4770      	bx	lr
		switch ((info->module >> 4) & 3) {
    6156:	4809      	ldr	r0, [pc, #36]	; (617c <analogWrite+0xc4>)
    6158:	e7ef      	b.n	613a <analogWrite+0x82>
		switch ((info->module >> 4) & 3) {
    615a:	4a09      	ldr	r2, [pc, #36]	; (6180 <analogWrite+0xc8>)
    615c:	e7c1      	b.n	60e2 <analogWrite+0x2a>
	if (high >= modulo - 1) high = modulo - 2;
    615e:	1e99      	subs	r1, r3, #2
    6160:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6164:	e7db      	b.n	611e <analogWrite+0x66>
    6166:	bf00      	nop
    6168:	2000093c 	.word	0x2000093c
    616c:	401dc000 	.word	0x401dc000
    6170:	20000d46 	.word	0x20000d46
    6174:	403dc000 	.word	0x403dc000
    6178:	200006bc 	.word	0x200006bc
    617c:	403e8000 	.word	0x403e8000
    6180:	401e8000 	.word	0x401e8000

00006184 <flexpwm_init>:
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    6184:	2300      	movs	r3, #0
	p->FSTS0 = 0x000F; // clear fault status
    6186:	220f      	movs	r2, #15
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    6188:	f248 2cb8 	movw	ip, #33464	; 0x82b8
	for (i=0; i < 4; i++) {
    618c:	4619      	mov	r1, r3
{
    618e:	b510      	push	{r4, lr}
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    6190:	f44f 4470 	mov.w	r4, #61440	; 0xf000
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    6194:	f44f 6e80 	mov.w	lr, #1024	; 0x400
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    6198:	f8a0 418c 	strh.w	r4, [r0, #396]	; 0x18c
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    619c:	f44f 4460 	mov.w	r4, #57344	; 0xe000
	p->FSTS0 = 0x000F; // clear fault status
    61a0:	f8a0 218e 	strh.w	r2, [r0, #398]	; 0x18e
		p->SM[i].OCTRL = 0;
    61a4:	460a      	mov	r2, r1
	p->FFILT0 = 0;
    61a6:	f8a0 3190 	strh.w	r3, [r0, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    61aa:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    61ae:	b29b      	uxth	r3, r3
    61b0:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    61b4:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    61b8:	eb01 0341 	add.w	r3, r1, r1, lsl #1
	for (i=0; i < 4; i++) {
    61bc:	3101      	adds	r1, #1
    61be:	eb00 1343 	add.w	r3, r0, r3, lsl #5
    61c2:	2904      	cmp	r1, #4
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    61c4:	809c      	strh	r4, [r3, #4]
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    61c6:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    61ca:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    61cc:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    61ce:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    61d0:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    61d2:	f8a3 c00e 	strh.w	ip, [r3, #14]
		p->SM[i].VAL2 = 0;
    61d6:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    61d8:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    61da:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    61dc:	83da      	strh	r2, [r3, #30]
	for (i=0; i < 4; i++) {
    61de:	d1eb      	bne.n	61b8 <flexpwm_init+0x34>
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    61e0:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    61e4:	b29b      	uxth	r3, r3
    61e6:	f043 030f 	orr.w	r3, r3, #15
    61ea:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    61ee:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    61f2:	b29b      	uxth	r3, r3
    61f4:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    61f8:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
}
    61fc:	bd10      	pop	{r4, pc}
    61fe:	bf00      	nop

00006200 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6200:	4b37      	ldr	r3, [pc, #220]	; (62e0 <pwm_init+0xe0>)
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6202:	4a38      	ldr	r2, [pc, #224]	; (62e4 <pwm_init+0xe4>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6204:	6f99      	ldr	r1, [r3, #120]	; 0x78
		CCM_CCGR6_QTIMER3(CCM_CCGR_ON) | CCM_CCGR6_QTIMER4(CCM_CCGR_ON);
	flexpwm_init(&IMXRT_FLEXPWM1);
    6206:	4838      	ldr	r0, [pc, #224]	; (62e8 <pwm_init+0xe8>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6208:	f441 017f 	orr.w	r1, r1, #16711680	; 0xff0000
{
    620c:	b570      	push	{r4, r5, r6, lr}
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    620e:	6799      	str	r1, [r3, #120]	; 0x78
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6210:	f241 0601 	movw	r6, #4097	; 0x1001
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6214:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6218:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    621c:	f243 0426 	movw	r4, #12326	; 0x3026
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6220:	430a      	orrs	r2, r1
    6222:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	flexpwm_init(&IMXRT_FLEXPWM1);
    6226:	f7ff ffad 	bl	6184 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM2);
    622a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    622e:	f7ff ffa9 	bl	6184 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM3);
    6232:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    6236:	f7ff ffa5 	bl	6184 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM4);
    623a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    623e:	f7ff ffa1 	bl	6184 <flexpwm_init>
	for (i=0; i < 4; i++) {
    6242:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    6244:	f5a0 1003 	sub.w	r0, r0, #2146304	; 0x20c000
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6248:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CTRL = 0; // stop timer
    624c:	4611      	mov	r1, r2
    624e:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    6252:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    6256:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6258:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    625a:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    625c:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    625e:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6262:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6264:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    6266:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    626a:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    626c:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    626e:	d1ee      	bne.n	624e <pwm_init+0x4e>
    6270:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    6272:	481e      	ldr	r0, [pc, #120]	; (62ec <pwm_init+0xec>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6274:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6278:	f241 0601 	movw	r6, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    627c:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    627e:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6282:	f243 0426 	movw	r4, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    6286:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    628a:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    628e:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6290:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    6292:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    6294:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6296:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    629a:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    629c:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    629e:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    62a2:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    62a4:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    62a6:	d1ee      	bne.n	6286 <pwm_init+0x86>
    62a8:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    62aa:	4811      	ldr	r0, [pc, #68]	; (62f0 <pwm_init+0xf0>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    62ac:	260f      	movs	r6, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    62ae:	f241 0501 	movw	r5, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    62b2:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    62b4:	f645 54c0 	movw	r4, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    62b8:	f243 0e26 	movw	lr, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    62bc:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    62c0:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    62c4:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    62c6:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    62c8:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    62ca:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    62cc:	81de      	strh	r6, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    62ce:	829d      	strh	r5, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    62d0:	80dc      	strh	r4, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    62d2:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    62d6:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    62d8:	f8a3 e00c 	strh.w	lr, [r3, #12]
	for (i=0; i < 4; i++) {
    62dc:	d1ee      	bne.n	62bc <pwm_init+0xbc>
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    62de:	bd70      	pop	{r4, r5, r6, pc}
    62e0:	400fc000 	.word	0x400fc000
    62e4:	fc030000 	.word	0xfc030000
    62e8:	403dc000 	.word	0x403dc000
    62ec:	401e0000 	.word	0x401e0000
    62f0:	401e4000 	.word	0x401e4000

000062f4 <serialEvent2()>:

#include <Arduino.h>
#include "HardwareSerial.h"
void serialEvent2() __attribute__((weak));
void serialEvent2() {}		// No use calling this so disable if called...
    62f4:	4770      	bx	lr
    62f6:	bf00      	nop

000062f8 <unused_interrupt_vector>:
	__disable_irq();
    62f8:	b672      	cpsid	i
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    62fa:	f3ef 8305 	mrs	r3, IPSR
	info->ipsr = ipsr;
    62fe:	4c4f      	ldr	r4, [pc, #316]	; (643c <unused_interrupt_vector+0x144>)
    6300:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    6304:	f3ef 8208 	mrs	r2, MSP
	info->cfsr = SCB_CFSR;
    6308:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	p = (uint32_t *)info;
    630c:	4e4c      	ldr	r6, [pc, #304]	; (6440 <unused_interrupt_vector+0x148>)
	while (p < end) {
    630e:	4d4d      	ldr	r5, [pc, #308]	; (6444 <unused_interrupt_vector+0x14c>)
	info->cfsr = SCB_CFSR;
    6310:	f8d3 0d28 	ldr.w	r0, [r3, #3368]	; 0xd28
	info->hfsr = SCB_HFSR;
    6314:	f8d3 1d2c 	ldr.w	r1, [r3, #3372]	; 0xd2c
    6318:	e9c4 0122 	strd	r0, r1, [r4, #136]	; 0x88
	info->mmfar = SCB_MMFAR;
    631c:	f8d3 1d34 	ldr.w	r1, [r3, #3380]	; 0xd34
	info->bfar = SCB_BFAR;
    6320:	f8d3 3d38 	ldr.w	r3, [r3, #3384]	; 0xd38
    6324:	e9c4 1324 	strd	r1, r3, [r4, #144]	; 0x90
	info->ret = stack[6];
    6328:	6993      	ldr	r3, [r2, #24]
    632a:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	info->xpsr = stack[7];
    632e:	69d3      	ldr	r3, [r2, #28]
    6330:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	info->temp = tempmonGetTemp();
    6334:	f000 f8a2 	bl	647c <tempmonGetTemp>
    6338:	ed84 0a28 	vstr	s0, [r4, #160]	; 0xa0
	info->time = rtc_get();
    633c:	f001 fb10 	bl	7960 <rtc_get>
	info->len = sizeof(*info) / 4;
    6340:	210b      	movs	r1, #11
	crc = 0xFFFFFFFF;
    6342:	f04f 32ff 	mov.w	r2, #4294967295
	info->time = rtc_get();
    6346:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
	info->len = sizeof(*info) / 4;
    634a:	460b      	mov	r3, r1
    634c:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    6350:	493d      	ldr	r1, [pc, #244]	; (6448 <unused_interrupt_vector+0x150>)
		crc ^= *p++;
    6352:	1d30      	adds	r0, r6, #4
    6354:	405a      	eors	r2, r3
    6356:	2420      	movs	r4, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    6358:	f002 0301 	and.w	r3, r2, #1
    635c:	3c01      	subs	r4, #1
    635e:	fb01 f303 	mul.w	r3, r1, r3
    6362:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    6366:	d1f7      	bne.n	6358 <unused_interrupt_vector+0x60>
	while (p < end) {
    6368:	42a8      	cmp	r0, r5
    636a:	d002      	beq.n	6372 <unused_interrupt_vector+0x7a>
		crc ^= *p++;
    636c:	6873      	ldr	r3, [r6, #4]
    636e:	4606      	mov	r6, r0
    6370:	e7ef      	b.n	6352 <unused_interrupt_vector+0x5a>
	info->crc = crc;
    6372:	4b32      	ldr	r3, [pc, #200]	; (643c <unused_interrupt_vector+0x144>)
    6374:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    6378:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    637c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6380:	492f      	ldr	r1, [pc, #188]	; (6440 <unused_interrupt_vector+0x148>)
    6382:	4a32      	ldr	r2, [pc, #200]	; (644c <unused_interrupt_vector+0x154>)
    6384:	f8c3 1f70 	str.w	r1, [r3, #3952]	; 0xf70
    6388:	f8c3 2f70 	str.w	r2, [r3, #3952]	; 0xf70
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    638c:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6390:	f3bf 8f6f 	isb	sy
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    6394:	4a2e      	ldr	r2, [pc, #184]	; (6450 <unused_interrupt_vector+0x158>)
	PIT_MCR = PIT_MCR_MDIS;
    6396:	2502      	movs	r5, #2
    6398:	482e      	ldr	r0, [pc, #184]	; (6454 <unused_interrupt_vector+0x15c>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    639a:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    639c:	492e      	ldr	r1, [pc, #184]	; (6458 <unused_interrupt_vector+0x160>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    639e:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
    63a2:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    63a4:	6005      	str	r5, [r0, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    63a6:	69d3      	ldr	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    63a8:	482c      	ldr	r0, [pc, #176]	; (645c <unused_interrupt_vector+0x164>)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    63aa:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    63ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    63b2:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    63b4:	680b      	ldr	r3, [r1, #0]
    63b6:	4283      	cmp	r3, r0
    63b8:	d83d      	bhi.n	6436 <unused_interrupt_vector+0x13e>
	PIT_MCR = 0;
    63ba:	4d26      	ldr	r5, [pc, #152]	; (6454 <unused_interrupt_vector+0x15c>)
    63bc:	2100      	movs	r1, #0
	NVIC_ICER0 = 0xFFFFFFFF;
    63be:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    63c2:	f04f 32ff 	mov.w	r2, #4294967295
	PIT_MCR = 0;
    63c6:	6029      	str	r1, [r5, #0]
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    63c8:	2601      	movs	r6, #1
	PIT_TCTRL0 = 0;
    63ca:	f8c5 1108 	str.w	r1, [r5, #264]	; 0x108
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    63ce:	4924      	ldr	r1, [pc, #144]	; (6460 <unused_interrupt_vector+0x168>)
    63d0:	f8c5 1100 	str.w	r1, [r5, #256]	; 0x100
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    63d4:	f8c5 6108 	str.w	r6, [r5, #264]	; 0x108
	NVIC_ICER0 = 0xFFFFFFFF;
    63d8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	NVIC_ICER1 = 0xFFFFFFFF;
    63dc:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
	NVIC_ICER2 = 0xFFFFFFFF;
    63e0:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
	NVIC_ICER3 = 0xFFFFFFFF;
    63e4:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	NVIC_ICER4 = 0xFFFFFFFF;
    63e8:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
	count = 0;
    63ec:	e001      	b.n	63f2 <unused_interrupt_vector+0xfa>
		usb_isr();
    63ee:	f000 f937 	bl	6660 <usb_isr>
		if (PIT_TFLG0) {
    63f2:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    63f6:	2b00      	cmp	r3, #0
    63f8:	d0f9      	beq.n	63ee <unused_interrupt_vector+0xf6>
			if (++count >= 80) break;  // reboot after 8 seconds
    63fa:	3401      	adds	r4, #1
			PIT_TFLG0 = 1;
    63fc:	f8c5 610c 	str.w	r6, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    6400:	2c4f      	cmp	r4, #79	; 0x4f
    6402:	d9f4      	bls.n	63ee <unused_interrupt_vector+0xf6>
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6404:	4b17      	ldr	r3, [pc, #92]	; (6464 <unused_interrupt_vector+0x16c>)
	USB1_USBCMD = USB_USBCMD_RST;
    6406:	2002      	movs	r0, #2
    6408:	4917      	ldr	r1, [pc, #92]	; (6468 <unused_interrupt_vector+0x170>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    640a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	USB1_USBCMD = USB_USBCMD_RST;
    640e:	f8c1 0140 	str.w	r0, [r1, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6412:	635a      	str	r2, [r3, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6414:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    6418:	b93b      	cbnz	r3, 642a <unused_interrupt_vector+0x132>
	SRC_GPR5 = 0x0BAD00F1;
    641a:	4814      	ldr	r0, [pc, #80]	; (646c <unused_interrupt_vector+0x174>)
    641c:	4914      	ldr	r1, [pc, #80]	; (6470 <unused_interrupt_vector+0x178>)
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    641e:	4a0d      	ldr	r2, [pc, #52]	; (6454 <unused_interrupt_vector+0x15c>)
	SRC_GPR5 = 0x0BAD00F1;
    6420:	6301      	str	r1, [r0, #48]	; 0x30
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6422:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    6426:	2b00      	cmp	r3, #0
    6428:	d0fa      	beq.n	6420 <unused_interrupt_vector+0x128>
	SCB_AIRCR = 0x05FA0004;
    642a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    642e:	4a11      	ldr	r2, [pc, #68]	; (6474 <unused_interrupt_vector+0x17c>)
    6430:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c
	while (1) ;
    6434:	e7fe      	b.n	6434 <unused_interrupt_vector+0x13c>
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    6436:	f001 f91b 	bl	7670 <set_arm_clock>
    643a:	e7be      	b.n	63ba <unused_interrupt_vector+0xc2>
    643c:	2027ff00 	.word	0x2027ff00
    6440:	2027ff80 	.word	0x2027ff80
    6444:	2027ffa8 	.word	0x2027ffa8
    6448:	edb88320 	.word	0xedb88320
    644c:	2027ffa0 	.word	0x2027ffa0
    6450:	400fc000 	.word	0x400fc000
    6454:	40084000 	.word	0x40084000
    6458:	20000a64 	.word	0x20000a64
    645c:	0bcd3d80 	.word	0x0bcd3d80
    6460:	00249f00 	.word	0x00249f00
    6464:	400d9000 	.word	0x400d9000
    6468:	402e0000 	.word	0x402e0000
    646c:	400f8000 	.word	0x400f8000
    6470:	0bad00f1 	.word	0x0bad00f1
    6474:	05fa0004 	.word	0x05fa0004

00006478 <Panic_Temp_isr>:
  unused_interrupt_vector();
    6478:	f7ff bf3e 	b.w	62f8 <unused_interrupt_vector>

0000647c <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    647c:	4a12      	ldr	r2, [pc, #72]	; (64c8 <tempmonGetTemp+0x4c>)
    647e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    6482:	075b      	lsls	r3, r3, #29
    6484:	d5fb      	bpl.n	647e <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6486:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    648a:	4810      	ldr	r0, [pc, #64]	; (64cc <tempmonGetTemp+0x50>)
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    648c:	f3c3 230b 	ubfx	r3, r3, #8, #12
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6490:	490f      	ldr	r1, [pc, #60]	; (64d0 <tempmonGetTemp+0x54>)
    6492:	ed90 7a00 	vldr	s14, [r0]
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6496:	ee07 3a90 	vmov	s15, r3
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    649a:	ed91 6a00 	vldr	s12, [r1]
    649e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    64a2:	4a0c      	ldr	r2, [pc, #48]	; (64d4 <tempmonGetTemp+0x58>)
    64a4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    64a8:	4b0b      	ldr	r3, [pc, #44]	; (64d8 <tempmonGetTemp+0x5c>)
    64aa:	edd2 6a00 	vldr	s13, [r2]
    64ae:	ee77 7ac7 	vsub.f32	s15, s15, s14
    64b2:	ed93 7a00 	vldr	s14, [r3]
    64b6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    64ba:	ee67 7a86 	vmul.f32	s15, s15, s12
    64be:	ee87 0aa6 	vdiv.f32	s0, s15, s13

    return tmeas;
}
    64c2:	ee37 0a40 	vsub.f32	s0, s14, s0
    64c6:	4770      	bx	lr
    64c8:	400d8100 	.word	0x400d8100
    64cc:	20006920 	.word	0x20006920
    64d0:	20006928 	.word	0x20006928
    64d4:	2000692c 	.word	0x2000692c
    64d8:	20006924 	.word	0x20006924

000064dc <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    64dc:	6b83      	ldr	r3, [r0, #56]	; 0x38
{
    64de:	b4f0      	push	{r4, r5, r6, r7}
	if (endpoint->callback_function) {
    64e0:	b11b      	cbz	r3, 64ea <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    64e2:	6853      	ldr	r3, [r2, #4]
    64e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    64e8:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    64ea:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    64ec:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    64ee:	b33c      	cbz	r4, 6540 <schedule_transfer+0x64>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    64f0:	4b1a      	ldr	r3, [pc, #104]	; (655c <schedule_transfer+0x80>)
		last->next = (uint32_t)transfer;
    64f2:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    64f4:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    64f8:	420c      	tst	r4, r1
    64fa:	d11d      	bne.n	6538 <schedule_transfer+0x5c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    64fc:	4e18      	ldr	r6, [pc, #96]	; (6560 <schedule_transfer+0x84>)
    64fe:	6877      	ldr	r7, [r6, #4]
    6500:	e004      	b.n	650c <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    6502:	6874      	ldr	r4, [r6, #4]
    6504:	1be4      	subs	r4, r4, r7
    6506:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    650a:	d20b      	bcs.n	6524 <schedule_transfer+0x48>
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    650c:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    6510:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    6514:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    6518:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    651c:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    6520:	0464      	lsls	r4, r4, #17
    6522:	d5ee      	bpl.n	6502 <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    6524:	400d      	ands	r5, r1
    6526:	d107      	bne.n	6538 <schedule_transfer+0x5c>
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    6528:	4c0c      	ldr	r4, [pc, #48]	; (655c <schedule_transfer+0x80>)
		endpoint->status = 0;
    652a:	e9c0 2502 	strd	r2, r5, [r0, #8]
		USB1_ENDPTPRIME |= epmask;
    652e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6532:	430b      	orrs	r3, r1
    6534:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    6538:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    653a:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    653c:	bcf0      	pop	{r4, r5, r6, r7}
    653e:	4770      	bx	lr
	USB1_ENDPTPRIME |= epmask;
    6540:	4d06      	ldr	r5, [pc, #24]	; (655c <schedule_transfer+0x80>)
	endpoint->status = 0;
    6542:	e9c0 2402 	strd	r2, r4, [r0, #8]
	USB1_ENDPTPRIME |= epmask;
    6546:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    654a:	430b      	orrs	r3, r1
    654c:	f8c5 31b0 	str.w	r3, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    6550:	6302      	str	r2, [r0, #48]	; 0x30
	endpoint->last_transfer = transfer;
    6552:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    6554:	b662      	cpsie	i
}
    6556:	bcf0      	pop	{r4, r5, r6, r7}
    6558:	4770      	bx	lr
    655a:	bf00      	nop
    655c:	402e0000 	.word	0x402e0000
    6560:	e0001000 	.word	0xe0001000

00006564 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    6564:	b570      	push	{r4, r5, r6, lr}
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    6566:	6b05      	ldr	r5, [r0, #48]	; 0x30
	if (first == NULL) return;
    6568:	b19d      	cbz	r5, 6592 <run_callbacks+0x2e>
    656a:	4606      	mov	r6, r0
    656c:	462a      	mov	r2, r5

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
    656e:	2400      	movs	r4, #0
    6570:	e003      	b.n	657a <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    6572:	6812      	ldr	r2, [r2, #0]
		count++;
    6574:	3401      	adds	r4, #1
		if ((uint32_t)t == 1) {
    6576:	2a01      	cmp	r2, #1
    6578:	d00c      	beq.n	6594 <run_callbacks+0x30>
		if (t->status & (1<<7)) {
    657a:	6853      	ldr	r3, [r2, #4]
    657c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    6580:	d0f7      	beq.n	6572 <run_callbacks+0xe>
			ep->first_transfer = t;
    6582:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    6584:	b12c      	cbz	r4, 6592 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
    6586:	4628      	mov	r0, r5
		ep->callback_function(first);
    6588:	6bb3      	ldr	r3, [r6, #56]	; 0x38
		transfer_t *next = (transfer_t *)first->next;
    658a:	682d      	ldr	r5, [r5, #0]
		ep->callback_function(first);
    658c:	4798      	blx	r3
	while (count) {
    658e:	3c01      	subs	r4, #1
    6590:	d1f9      	bne.n	6586 <run_callbacks+0x22>
		first = next;
		count--;
	}
}
    6592:	bd70      	pop	{r4, r5, r6, pc}
			ep->last_transfer = NULL;
    6594:	e9c6 330c 	strd	r3, r3, [r6, #48]	; 0x30
			break;
    6598:	e7f4      	b.n	6584 <run_callbacks+0x20>
    659a:	bf00      	nop

0000659c <endpoint0_transmit.constprop.0>:
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    659c:	b430      	push	{r4, r5}
	if (len > 0) {
    659e:	b9d9      	cbnz	r1, 65d8 <endpoint0_transmit.constprop.0+0x3c>
    65a0:	4c1f      	ldr	r4, [pc, #124]	; (6620 <endpoint0_transmit.constprop.0+0x84>)
	endpoint0_transfer_ack.next = 1;
    65a2:	4b20      	ldr	r3, [pc, #128]	; (6624 <endpoint0_transmit.constprop.0+0x88>)
	endpoint0_transfer_ack.pointer0 = 0;
    65a4:	2100      	movs	r1, #0
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    65a6:	4a20      	ldr	r2, [pc, #128]	; (6628 <endpoint0_transmit.constprop.0+0x8c>)
	endpoint0_transfer_ack.next = 1;
    65a8:	2501      	movs	r5, #1
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    65aa:	f04f 1001 	mov.w	r0, #65537	; 0x10001
	endpoint0_transfer_ack.pointer0 = 0;
    65ae:	6099      	str	r1, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    65b0:	601d      	str	r5, [r3, #0]
	endpoint_queue_head[0].status = 0;
    65b2:	e9c4 3102 	strd	r3, r1, [r4, #8]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    65b6:	2480      	movs	r4, #128	; 0x80
    65b8:	605c      	str	r4, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    65ba:	f8c2 01bc 	str.w	r0, [r2, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    65be:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    65c2:	481a      	ldr	r0, [pc, #104]	; (662c <endpoint0_transmit.constprop.0+0x90>)
	USB1_ENDPTPRIME |= (1<<0);
    65c4:	432b      	orrs	r3, r5
    65c6:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    65ca:	6001      	str	r1, [r0, #0]
	while (USB1_ENDPTPRIME) ;
    65cc:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    65d0:	2b00      	cmp	r3, #0
    65d2:	d1fb      	bne.n	65cc <endpoint0_transmit.constprop.0+0x30>
}
    65d4:	bc30      	pop	{r4, r5}
    65d6:	4770      	bx	lr
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    65d8:	0409      	lsls	r1, r1, #16
		endpoint0_transfer_data.next = 1;
    65da:	4b15      	ldr	r3, [pc, #84]	; (6630 <endpoint0_transmit.constprop.0+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    65dc:	4c10      	ldr	r4, [pc, #64]	; (6620 <endpoint0_transmit.constprop.0+0x84>)
		endpoint0_transfer_data.next = 1;
    65de:	2501      	movs	r5, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    65e0:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    65e4:	6098      	str	r0, [r3, #8]
		USB1_ENDPTPRIME |= (1<<16);
    65e6:	4a10      	ldr	r2, [pc, #64]	; (6628 <endpoint0_transmit.constprop.0+0x8c>)
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    65e8:	6059      	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    65ea:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
		endpoint0_transfer_data.next = 1;
    65ee:	601d      	str	r5, [r3, #0]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    65f0:	60d9      	str	r1, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    65f2:	f500 5100 	add.w	r1, r0, #8192	; 0x2000
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    65f6:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.pointer2 = addr + 8192;
    65f8:	6119      	str	r1, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    65fa:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    65fe:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6602:	6159      	str	r1, [r3, #20]
		endpoint_queue_head[1].status = 0;
    6604:	2100      	movs	r1, #0
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6606:	6198      	str	r0, [r3, #24]
		endpoint_queue_head[1].status = 0;
    6608:	64e1      	str	r1, [r4, #76]	; 0x4c
		USB1_ENDPTPRIME |= (1<<16);
    660a:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    660e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6612:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    6616:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    661a:	2b00      	cmp	r3, #0
    661c:	d1fb      	bne.n	6616 <endpoint0_transmit.constprop.0+0x7a>
    661e:	e7c0      	b.n	65a2 <endpoint0_transmit.constprop.0+0x6>
    6620:	20000000 	.word	0x20000000
    6624:	200012c0 	.word	0x200012c0
    6628:	402e0000 	.word	0x402e0000
    662c:	200068b8 	.word	0x200068b8
    6630:	200012e0 	.word	0x200012e0

00006634 <usb_stop_sof_interrupts>:
	sof_usage &= ~(1 << interface);
    6634:	4908      	ldr	r1, [pc, #32]	; (6658 <usb_stop_sof_interrupts+0x24>)
    6636:	2201      	movs	r2, #1
    6638:	780b      	ldrb	r3, [r1, #0]
    663a:	fa02 f000 	lsl.w	r0, r2, r0
    663e:	ea23 0000 	bic.w	r0, r3, r0
    6642:	7008      	strb	r0, [r1, #0]
	if (sof_usage == 0) {
    6644:	b930      	cbnz	r0, 6654 <usb_stop_sof_interrupts+0x20>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    6646:	4a05      	ldr	r2, [pc, #20]	; (665c <usb_stop_sof_interrupts+0x28>)
    6648:	f8d2 3148 	ldr.w	r3, [r2, #328]	; 0x148
    664c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    6650:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
}
    6654:	4770      	bx	lr
    6656:	bf00      	nop
    6658:	20006aeb 	.word	0x20006aeb
    665c:	402e0000 	.word	0x402e0000

00006660 <usb_isr>:
{
    6660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t status = USB1_USBSTS;
    6664:	4c97      	ldr	r4, [pc, #604]	; (68c4 <usb_isr+0x264>)
{
    6666:	b083      	sub	sp, #12
	uint32_t status = USB1_USBSTS;
    6668:	f8d4 7144 	ldr.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    666c:	07fb      	lsls	r3, r7, #31
	USB1_USBSTS = status;
    666e:	f8c4 7144 	str.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    6672:	d553      	bpl.n	671c <usb_isr+0xbc>
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    6674:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6678:	2a00      	cmp	r2, #0
    667a:	d04a      	beq.n	6712 <usb_isr+0xb2>
    667c:	4e92      	ldr	r6, [pc, #584]	; (68c8 <usb_isr+0x268>)
    667e:	f8df a260 	ldr.w	sl, [pc, #608]	; 68e0 <usb_isr+0x280>
		uint32_t addr = (uint32_t)data;
    6682:	f8df 9274 	ldr.w	r9, [pc, #628]	; 68f8 <usb_isr+0x298>
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    6686:	f8df b274 	ldr.w	fp, [pc, #628]	; 68fc <usb_isr+0x29c>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    668a:	f8df 8274 	ldr.w	r8, [pc, #628]	; 6900 <usb_isr+0x2a0>
			USB1_ENDPTSETUPSTAT = setupstatus;
    668e:	f8c4 21ac 	str.w	r2, [r4, #428]	; 0x1ac
				s.word2 = endpoint_queue_head[0].setup1;
    6692:	e9d6 200a 	ldrd	r2, r0, [r6, #40]	; 0x28
				USB1_USBCMD |= USB_USBCMD_SUTW;
    6696:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    669a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    669e:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    66a2:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    66a6:	049d      	lsls	r5, r3, #18
    66a8:	d5f5      	bpl.n	6696 <usb_isr+0x36>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    66aa:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    66ae:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    66b2:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    66b6:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    66ba:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    66be:	f8d4 51b4 	ldr.w	r5, [r4, #436]	; 0x1b4
    66c2:	f015 1501 	ands.w	r5, r5, #65537	; 0x10001
    66c6:	d1fa      	bne.n	66be <usb_isr+0x5e>
			endpoint0_notify_mask = 0;
    66c8:	b293      	uxth	r3, r2
	setup.bothwords = setupdata;
    66ca:	4684      	mov	ip, r0
			endpoint0_notify_mask = 0;
    66cc:	f8ca 5000 	str.w	r5, [sl]
	switch (setup.wRequestAndType) {
    66d0:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    66d4:	f000 81cf 	beq.w	6a76 <usb_isr+0x416>
    66d8:	f200 80db 	bhi.w	6892 <usb_isr+0x232>
    66dc:	f240 3102 	movw	r1, #770	; 0x302
    66e0:	428b      	cmp	r3, r1
    66e2:	f000 81e7 	beq.w	6ab4 <usb_isr+0x454>
    66e6:	f200 809a 	bhi.w	681e <usb_isr+0x1be>
    66ea:	2b82      	cmp	r3, #130	; 0x82
    66ec:	f000 81cb 	beq.w	6a86 <usb_isr+0x426>
    66f0:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    66f4:	f040 808a 	bne.w	680c <usb_isr+0x1ac>
		if (endpoint > 7) break;
    66f8:	f010 0f78 	tst.w	r0, #120	; 0x78
    66fc:	b283      	uxth	r3, r0
    66fe:	f000 8203 	beq.w	6b08 <usb_isr+0x4a8>
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    6702:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6706:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    670a:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    670e:	2a00      	cmp	r2, #0
    6710:	d1bd      	bne.n	668e <usb_isr+0x2e>
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    6712:	4a6c      	ldr	r2, [pc, #432]	; (68c4 <usb_isr+0x264>)
    6714:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    6718:	2b00      	cmp	r3, #0
    671a:	d142      	bne.n	67a2 <usb_isr+0x142>
	if (status & USB_USBSTS_URI) { // page 3164
    671c:	067e      	lsls	r6, r7, #25
    671e:	d516      	bpl.n	674e <usb_isr+0xee>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    6720:	4b68      	ldr	r3, [pc, #416]	; (68c4 <usb_isr+0x264>)
    6722:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
    6726:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    672a:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    672e:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    6732:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    6736:	2c00      	cmp	r4, #0
    6738:	d1fb      	bne.n	6732 <usb_isr+0xd2>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    673a:	f04f 32ff 	mov.w	r2, #4294967295
    673e:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    6742:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
		usb_serial_reset();
    6746:	f000 fd29 	bl	719c <usb_serial_reset>
		endpointN_notify_mask = 0;
    674a:	4b60      	ldr	r3, [pc, #384]	; (68cc <usb_isr+0x26c>)
    674c:	601c      	str	r4, [r3, #0]
	if (status & USB_USBSTS_TI0) {
    674e:	01fc      	lsls	r4, r7, #7
    6750:	d503      	bpl.n	675a <usb_isr+0xfa>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    6752:	4b5f      	ldr	r3, [pc, #380]	; (68d0 <usb_isr+0x270>)
    6754:	681b      	ldr	r3, [r3, #0]
    6756:	b103      	cbz	r3, 675a <usb_isr+0xfa>
    6758:	4798      	blx	r3
	if (status & USB_USBSTS_TI1) {
    675a:	01b8      	lsls	r0, r7, #6
    675c:	d503      	bpl.n	6766 <usb_isr+0x106>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    675e:	4b5d      	ldr	r3, [pc, #372]	; (68d4 <usb_isr+0x274>)
    6760:	681b      	ldr	r3, [r3, #0]
    6762:	b103      	cbz	r3, 6766 <usb_isr+0x106>
    6764:	4798      	blx	r3
	if (status & USB_USBSTS_PCI) {
    6766:	0779      	lsls	r1, r7, #29
    6768:	d508      	bpl.n	677c <usb_isr+0x11c>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    676a:	4b56      	ldr	r3, [pc, #344]	; (68c4 <usb_isr+0x264>)
    676c:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    6770:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    6774:	d047      	beq.n	6806 <usb_isr+0x1a6>
			usb_high_speed = 1;
    6776:	4b58      	ldr	r3, [pc, #352]	; (68d8 <usb_isr+0x278>)
    6778:	2201      	movs	r2, #1
    677a:	701a      	strb	r2, [r3, #0]
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    677c:	4b51      	ldr	r3, [pc, #324]	; (68c4 <usb_isr+0x264>)
    677e:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
    6782:	061a      	lsls	r2, r3, #24
    6784:	d50a      	bpl.n	679c <usb_isr+0x13c>
    6786:	063b      	lsls	r3, r7, #24
    6788:	d508      	bpl.n	679c <usb_isr+0x13c>
		if (usb_reboot_timer) {
    678a:	4a54      	ldr	r2, [pc, #336]	; (68dc <usb_isr+0x27c>)
    678c:	7813      	ldrb	r3, [r2, #0]
    678e:	b12b      	cbz	r3, 679c <usb_isr+0x13c>
			if (--usb_reboot_timer == 0) {
    6790:	3b01      	subs	r3, #1
    6792:	b2db      	uxtb	r3, r3
    6794:	7013      	strb	r3, [r2, #0]
    6796:	2b00      	cmp	r3, #0
    6798:	f000 8272 	beq.w	6c80 <usb_isr+0x620>
}
    679c:	b003      	add	sp, #12
    679e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (completestatus & endpoint0_notify_mask) {
    67a2:	494f      	ldr	r1, [pc, #316]	; (68e0 <usb_isr+0x280>)
			USB1_ENDPTCOMPLETE = completestatus;
    67a4:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			if (completestatus & endpoint0_notify_mask) {
    67a8:	6808      	ldr	r0, [r1, #0]
    67aa:	4203      	tst	r3, r0
    67ac:	f040 81d1 	bne.w	6b52 <usb_isr+0x4f2>
			completestatus &= endpointN_notify_mask;
    67b0:	4a46      	ldr	r2, [pc, #280]	; (68cc <usb_isr+0x26c>)
    67b2:	6814      	ldr	r4, [r2, #0]
			if (completestatus) {
    67b4:	401c      	ands	r4, r3
    67b6:	d0b1      	beq.n	671c <usb_isr+0xbc>
				while (tx) {
    67b8:	ea5f 4814 	movs.w	r8, r4, lsr #16
    67bc:	d010      	beq.n	67e0 <usb_isr+0x180>
    67be:	4e42      	ldr	r6, [pc, #264]	; (68c8 <usb_isr+0x268>)
					tx &= ~(1<<p);
    67c0:	f04f 0901 	mov.w	r9, #1
					int p=__builtin_ctz(tx);
    67c4:	fa98 f5a8 	rbit	r5, r8
    67c8:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    67cc:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					tx &= ~(1<<p);
    67d0:	fa09 f505 	lsl.w	r5, r9, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    67d4:	3040      	adds	r0, #64	; 0x40
    67d6:	f7ff fec5 	bl	6564 <run_callbacks>
				while (tx) {
    67da:	ea38 0805 	bics.w	r8, r8, r5
    67de:	d1f1      	bne.n	67c4 <usb_isr+0x164>
				uint32_t rx = completestatus & 0xffff;
    67e0:	b2a4      	uxth	r4, r4
				while(rx) {
    67e2:	2c00      	cmp	r4, #0
    67e4:	d09a      	beq.n	671c <usb_isr+0xbc>
    67e6:	4e38      	ldr	r6, [pc, #224]	; (68c8 <usb_isr+0x268>)
					rx &= ~(1<<p);
    67e8:	f04f 0801 	mov.w	r8, #1
					int p=__builtin_ctz(rx);
    67ec:	fa94 f5a4 	rbit	r5, r4
    67f0:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2);
    67f4:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					rx &= ~(1<<p);
    67f8:	fa08 f505 	lsl.w	r5, r8, r5
					run_callbacks(endpoint_queue_head + p * 2);
    67fc:	f7ff feb2 	bl	6564 <run_callbacks>
				while(rx) {
    6800:	43ac      	bics	r4, r5
    6802:	d1f3      	bne.n	67ec <usb_isr+0x18c>
    6804:	e78a      	b.n	671c <usb_isr+0xbc>
			usb_high_speed = 0;
    6806:	4a34      	ldr	r2, [pc, #208]	; (68d8 <usb_isr+0x278>)
    6808:	7013      	strb	r3, [r2, #0]
    680a:	e7b7      	b.n	677c <usb_isr+0x11c>
	switch (setup.wRequestAndType) {
    680c:	2b80      	cmp	r3, #128	; 0x80
    680e:	f47f af78 	bne.w	6702 <usb_isr+0xa2>
		reply_buffer[0] = 0;
    6812:	4834      	ldr	r0, [pc, #208]	; (68e4 <usb_isr+0x284>)
		endpoint0_transmit(reply_buffer, 2, 0);
    6814:	2102      	movs	r1, #2
		reply_buffer[0] = 0;
    6816:	8005      	strh	r5, [r0, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6818:	f7ff fec0 	bl	659c <endpoint0_transmit.constprop.0>
		return;
    681c:	e775      	b.n	670a <usb_isr+0xaa>
	switch (setup.wRequestAndType) {
    681e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    6822:	f000 810b 	beq.w	6a3c <usb_isr+0x3dc>
    6826:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    682a:	2b01      	cmp	r3, #1
    682c:	f63f af69 	bhi.w	6702 <usb_isr+0xa2>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6830:	4b2d      	ldr	r3, [pc, #180]	; (68e8 <usb_isr+0x288>)
    6832:	685d      	ldr	r5, [r3, #4]
    6834:	2d00      	cmp	r5, #0
    6836:	f43f af64 	beq.w	6702 <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    683a:	fa1f fc8c 	uxth.w	ip, ip
    683e:	ea4f 4e12 	mov.w	lr, r2, lsr #16
    6842:	e004      	b.n	684e <usb_isr+0x1ee>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6844:	691d      	ldr	r5, [r3, #16]
    6846:	330c      	adds	r3, #12
    6848:	2d00      	cmp	r5, #0
    684a:	f43f af5a 	beq.w	6702 <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    684e:	881a      	ldrh	r2, [r3, #0]
    6850:	4572      	cmp	r2, lr
    6852:	d1f7      	bne.n	6844 <usb_isr+0x1e4>
    6854:	885a      	ldrh	r2, [r3, #2]
    6856:	4562      	cmp	r2, ip
    6858:	d1f4      	bne.n	6844 <usb_isr+0x1e4>
				if ((setup.wValue >> 8) == 3) {
    685a:	ea4f 221e 	mov.w	r2, lr, lsr #8
    685e:	2a03      	cmp	r2, #3
    6860:	f000 81a5 	beq.w	6bae <usb_isr+0x54e>
					datalen = list->length;
    6864:	891a      	ldrh	r2, [r3, #8]
				if (datalen > setup.wLength) datalen = setup.wLength;
    6866:	0c00      	lsrs	r0, r0, #16
    6868:	4282      	cmp	r2, r0
    686a:	bf28      	it	cs
    686c:	4602      	movcs	r2, r0
				if (setup.wValue == 0x200) {
    686e:	f5be 7f00 	cmp.w	lr, #512	; 0x200
    6872:	f040 81a1 	bne.w	6bb8 <usb_isr+0x558>
					if (usb_high_speed) src = usb_config_descriptor_480;
    6876:	4b18      	ldr	r3, [pc, #96]	; (68d8 <usb_isr+0x278>)
    6878:	491c      	ldr	r1, [pc, #112]	; (68ec <usb_isr+0x28c>)
    687a:	7818      	ldrb	r0, [r3, #0]
    687c:	4b1c      	ldr	r3, [pc, #112]	; (68f0 <usb_isr+0x290>)
					memcpy(usb_descriptor_buffer, src, datalen);
    687e:	9201      	str	r2, [sp, #4]
    6880:	2800      	cmp	r0, #0
    6882:	bf18      	it	ne
    6884:	4619      	movne	r1, r3
    6886:	481b      	ldr	r0, [pc, #108]	; (68f4 <usb_isr+0x294>)
    6888:	f7ff faf0 	bl	5e6c <memcpy>
    688c:	4d19      	ldr	r5, [pc, #100]	; (68f4 <usb_isr+0x294>)
    688e:	9a01      	ldr	r2, [sp, #4]
    6890:	e1e1      	b.n	6c56 <usb_isr+0x5f6>
	switch (setup.wRequestAndType) {
    6892:	f242 2121 	movw	r1, #8737	; 0x2221
    6896:	428b      	cmp	r3, r1
    6898:	d07c      	beq.n	6994 <usb_isr+0x334>
    689a:	d933      	bls.n	6904 <usb_isr+0x2a4>
    689c:	f242 3121 	movw	r1, #8993	; 0x2321
    68a0:	428b      	cmp	r3, r1
    68a2:	f000 8081 	beq.w	69a8 <usb_isr+0x348>
    68a6:	f64f 01c0 	movw	r1, #63680	; 0xf8c0
    68aa:	428b      	cmp	r3, r1
    68ac:	f47f af29 	bne.w	6702 <usb_isr+0xa2>
		if ((setup.wIndex & 0xFF00) != 0) break; // 1=Genre, 4=Compat ID, 5=Properties
    68b0:	f410 4f7f 	tst.w	r0, #65280	; 0xff00
    68b4:	b283      	uxth	r3, r0
    68b6:	f47f af24 	bne.w	6702 <usb_isr+0xa2>
		setup.wIndex |= 0xEE00; // alter wIndex and treat as normal USB descriptor
    68ba:	f443 436e 	orr.w	r3, r3, #60928	; 0xee00
    68be:	f363 0c0f 	bfi	ip, r3, #0, #16
    68c2:	e7b5      	b.n	6830 <usb_isr+0x1d0>
    68c4:	402e0000 	.word	0x402e0000
    68c8:	20000000 	.word	0x20000000
    68cc:	200068bc 	.word	0x200068bc
    68d0:	20006ad0 	.word	0x20006ad0
    68d4:	20006ad4 	.word	0x20006ad4
    68d8:	20006af1 	.word	0x20006af1
    68dc:	20006af2 	.word	0x20006af2
    68e0:	200068b8 	.word	0x200068b8
    68e4:	200068e8 	.word	0x200068e8
    68e8:	200009dc 	.word	0x200009dc
    68ec:	60001b14 	.word	0x60001b14
    68f0:	60001b78 	.word	0x60001b78
    68f4:	20200000 	.word	0x20200000
    68f8:	200068b0 	.word	0x200068b0
    68fc:	b8c6cf5d 	.word	0xb8c6cf5d
    6900:	402e01c0 	.word	0x402e01c0
	switch (setup.wRequestAndType) {
    6904:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    6908:	d066      	beq.n	69d8 <usb_isr+0x378>
    690a:	f242 0121 	movw	r1, #8225	; 0x2021
    690e:	428b      	cmp	r3, r1
    6910:	f47f aef7 	bne.w	6702 <usb_isr+0xa2>
		if (setup.wLength != 7) break;
    6914:	0c03      	lsrs	r3, r0, #16
    6916:	2b07      	cmp	r3, #7
    6918:	f47f aef3 	bne.w	6702 <usb_isr+0xa2>
		endpoint0_transfer_data.next = 1;
    691c:	4bb2      	ldr	r3, [pc, #712]	; (6be8 <usb_isr+0x588>)
		endpoint0_transfer_data.pointer1 = addr + 4096;
    691e:	49b3      	ldr	r1, [pc, #716]	; (6bec <usb_isr+0x58c>)
		endpoint_queue_head[0].status = 0;
    6920:	60f5      	str	r5, [r6, #12]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6922:	60d9      	str	r1, [r3, #12]
		endpoint0_setupdata.bothwords = setupdata;
    6924:	49b2      	ldr	r1, [pc, #712]	; (6bf0 <usb_isr+0x590>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    6926:	60b3      	str	r3, [r6, #8]
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    6928:	f8c3 9008 	str.w	r9, [r3, #8]
		endpoint0_setupdata.bothwords = setupdata;
    692c:	e9c1 2000 	strd	r2, r0, [r1]
		endpoint0_transfer_data.next = 1;
    6930:	2201      	movs	r2, #1
    6932:	601a      	str	r2, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6934:	4aaf      	ldr	r2, [pc, #700]	; (6bf4 <usb_isr+0x594>)
    6936:	605a      	str	r2, [r3, #4]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6938:	4aaf      	ldr	r2, [pc, #700]	; (6bf8 <usb_isr+0x598>)
    693a:	611a      	str	r2, [r3, #16]
		USB1_ENDPTPRIME |= (1<<0);
    693c:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
    6940:	f041 0101 	orr.w	r1, r1, #1
    6944:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6948:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    694c:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6950:	6159      	str	r1, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6952:	619a      	str	r2, [r3, #24]
		while (USB1_ENDPTPRIME) ;
    6954:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6958:	2b00      	cmp	r3, #0
    695a:	d1fb      	bne.n	6954 <usb_isr+0x2f4>
	endpoint0_transfer_ack.next = 1;
    695c:	4aa7      	ldr	r2, [pc, #668]	; (6bfc <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    695e:	64f3      	str	r3, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6960:	6093      	str	r3, [r2, #8]
	endpoint0_transfer_ack.next = 1;
    6962:	2301      	movs	r3, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6964:	64b2      	str	r2, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6966:	6013      	str	r3, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6968:	f248 0380 	movw	r3, #32896	; 0x8080
    696c:	6053      	str	r3, [r2, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    696e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6972:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6976:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    697a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    697e:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    6982:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    6986:	f8ca 3000 	str.w	r3, [sl]
	while (USB1_ENDPTPRIME) ;
    698a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    698e:	2b00      	cmp	r3, #0
    6990:	d1fb      	bne.n	698a <usb_isr+0x32a>
    6992:	e6ba      	b.n	670a <usb_isr+0xaa>
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
    6994:	b280      	uxth	r0, r0
    6996:	b938      	cbnz	r0, 69a8 <usb_isr+0x348>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6998:	4b99      	ldr	r3, [pc, #612]	; (6c00 <usb_isr+0x5a0>)
			usb_cdc_line_rtsdtr = setup.wValue;
    699a:	f3c2 4207 	ubfx	r2, r2, #16, #8
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    699e:	6819      	ldr	r1, [r3, #0]
    69a0:	4b98      	ldr	r3, [pc, #608]	; (6c04 <usb_isr+0x5a4>)
    69a2:	6019      	str	r1, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    69a4:	4b98      	ldr	r3, [pc, #608]	; (6c08 <usb_isr+0x5a8>)
    69a6:	701a      	strb	r2, [r3, #0]
	endpoint0_transfer_ack.next = 1;
    69a8:	4b94      	ldr	r3, [pc, #592]	; (6bfc <usb_isr+0x59c>)
	endpoint0_transfer_ack.pointer0 = 0;
    69aa:	2200      	movs	r2, #0
    69ac:	609a      	str	r2, [r3, #8]
	endpoint_queue_head[1].status = 0;
    69ae:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    69b0:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    69b2:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    69b4:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    69b6:	2280      	movs	r2, #128	; 0x80
    69b8:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    69ba:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    69be:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    69c2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    69c6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    69ca:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    69ce:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    69d2:	2b00      	cmp	r3, #0
    69d4:	d1fb      	bne.n	69ce <usb_isr+0x36e>
    69d6:	e698      	b.n	670a <usb_isr+0xaa>
		usb_configuration = setup.wValue;
    69d8:	f3c2 4207 	ubfx	r2, r2, #16, #8
    69dc:	4b8b      	ldr	r3, [pc, #556]	; (6c0c <usb_isr+0x5ac>)
    69de:	701a      	strb	r2, [r3, #0]
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    69e0:	4b8b      	ldr	r3, [pc, #556]	; (6c10 <usb_isr+0x5b0>)
    69e2:	f8c4 31c8 	str.w	r3, [r4, #456]	; 0x1c8
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    69e6:	4b8b      	ldr	r3, [pc, #556]	; (6c14 <usb_isr+0x5b4>)
    69e8:	f8c4 31cc 	str.w	r3, [r4, #460]	; 0x1cc
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    69ec:	4b8a      	ldr	r3, [pc, #552]	; (6c18 <usb_isr+0x5b8>)
    69ee:	f8c4 31d0 	str.w	r3, [r4, #464]	; 0x1d0
		usb_serial_configure();
    69f2:	f000 fbd5 	bl	71a0 <usb_serial_configure>
		memset(endpoint_queue_head + 2, 0, sizeof(endpoint_t) * 2);
    69f6:	2280      	movs	r2, #128	; 0x80
    69f8:	4629      	mov	r1, r5
    69fa:	4888      	ldr	r0, [pc, #544]	; (6c1c <usb_isr+0x5bc>)
    69fc:	f001 f840 	bl	7a80 <memset>
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    6a00:	4b87      	ldr	r3, [pc, #540]	; (6c20 <usb_isr+0x5c0>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a02:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    6a04:	f8c6 b0a0 	str.w	fp, [r6, #160]	; 0xa0
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    6a08:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
	endpoint0_transfer_ack.next = 1;
    6a0c:	4b7b      	ldr	r3, [pc, #492]	; (6bfc <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6a0e:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a10:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.next = 1;
    6a12:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6a14:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.pointer0 = 0;
    6a16:	609d      	str	r5, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6a18:	601a      	str	r2, [r3, #0]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a1a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6a1e:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6a22:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a26:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6a2a:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    6a2e:	f8ca 5000 	str.w	r5, [sl]
	while (USB1_ENDPTPRIME) ;
    6a32:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a36:	2b00      	cmp	r3, #0
    6a38:	d1fb      	bne.n	6a32 <usb_isr+0x3d2>
    6a3a:	e666      	b.n	670a <usb_isr+0xaa>
	endpoint0_transfer_ack.next = 1;
    6a3c:	4b6f      	ldr	r3, [pc, #444]	; (6bfc <usb_isr+0x59c>)
    6a3e:	2101      	movs	r1, #1
	endpoint_queue_head[1].status = 0;
    6a40:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    6a42:	6019      	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a44:	2180      	movs	r1, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
    6a46:	609d      	str	r5, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6a48:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a4a:	6059      	str	r1, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a4c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6a50:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6a54:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a58:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6a5c:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6a60:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a64:	2b00      	cmp	r3, #0
    6a66:	d1fb      	bne.n	6a60 <usb_isr+0x400>
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    6a68:	0c13      	lsrs	r3, r2, #16
    6a6a:	065b      	lsls	r3, r3, #25
    6a6c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    6a70:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
		return;
    6a74:	e649      	b.n	670a <usb_isr+0xaa>
		reply_buffer[0] = usb_configuration;
    6a76:	4b65      	ldr	r3, [pc, #404]	; (6c0c <usb_isr+0x5ac>)
		endpoint0_transmit(reply_buffer, 1, 0);
    6a78:	2101      	movs	r1, #1
		reply_buffer[0] = usb_configuration;
    6a7a:	486a      	ldr	r0, [pc, #424]	; (6c24 <usb_isr+0x5c4>)
    6a7c:	781b      	ldrb	r3, [r3, #0]
    6a7e:	7003      	strb	r3, [r0, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    6a80:	f7ff fd8c 	bl	659c <endpoint0_transmit.constprop.0>
		return;
    6a84:	e641      	b.n	670a <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    6a86:	b283      	uxth	r3, r0
		if (endpoint > 7) break;
    6a88:	f010 0078 	ands.w	r0, r0, #120	; 0x78
    6a8c:	f47f ae39 	bne.w	6702 <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    6a90:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    6a94:	f858 1022 	ldr.w	r1, [r8, r2, lsl #2]
		reply_buffer[0] = 0;
    6a98:	4a62      	ldr	r2, [pc, #392]	; (6c24 <usb_isr+0x5c4>)
    6a9a:	8010      	strh	r0, [r2, #0]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    6a9c:	0618      	lsls	r0, r3, #24
    6a9e:	f100 809e 	bmi.w	6bde <usb_isr+0x57e>
    6aa2:	07cb      	lsls	r3, r1, #31
    6aa4:	d501      	bpl.n	6aaa <usb_isr+0x44a>
			reply_buffer[0] = 1;
    6aa6:	2301      	movs	r3, #1
    6aa8:	7013      	strb	r3, [r2, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6aaa:	2102      	movs	r1, #2
    6aac:	485d      	ldr	r0, [pc, #372]	; (6c24 <usb_isr+0x5c4>)
    6aae:	f7ff fd75 	bl	659c <endpoint0_transmit.constprop.0>
		return;
    6ab2:	e62a      	b.n	670a <usb_isr+0xaa>
		if (endpoint > 7) break;
    6ab4:	f010 0f78 	tst.w	r0, #120	; 0x78
    6ab8:	b283      	uxth	r3, r0
    6aba:	f47f ae22 	bne.w	6702 <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    6abe:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    6ac2:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    6ac6:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    6aca:	bf14      	ite	ne
    6acc:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    6ad0:	f043 0301 	orreq.w	r3, r3, #1
    6ad4:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    6ad8:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    6ada:	4b48      	ldr	r3, [pc, #288]	; (6bfc <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6adc:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6ade:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6ae0:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6ae2:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6ae4:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6ae6:	2280      	movs	r2, #128	; 0x80
    6ae8:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6aea:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6aee:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6af2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6af6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6afa:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6afe:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b02:	2b00      	cmp	r3, #0
    6b04:	d1fb      	bne.n	6afe <usb_isr+0x49e>
    6b06:	e600      	b.n	670a <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    6b08:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    6b0c:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    6b10:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    6b14:	bf14      	ite	ne
    6b16:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    6b1a:	f023 0301 	biceq.w	r3, r3, #1
    6b1e:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    6b22:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    6b24:	4b35      	ldr	r3, [pc, #212]	; (6bfc <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6b26:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6b28:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6b2a:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6b2c:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6b2e:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6b30:	2280      	movs	r2, #128	; 0x80
    6b32:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6b34:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6b38:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6b3c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b40:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6b44:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6b48:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b4c:	2b00      	cmp	r3, #0
    6b4e:	d1fb      	bne.n	6b48 <usb_isr+0x4e8>
    6b50:	e5db      	b.n	670a <usb_isr+0xaa>
				endpoint0_notify_mask = 0;
    6b52:	2000      	movs	r0, #0
    6b54:	6008      	str	r0, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    6b56:	4926      	ldr	r1, [pc, #152]	; (6bf0 <usb_isr+0x590>)
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    6b58:	880c      	ldrh	r4, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    6b5a:	6848      	ldr	r0, [r1, #4]
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    6b5c:	f242 0121 	movw	r1, #8225	; 0x2021
    6b60:	428c      	cmp	r4, r1
    6b62:	f47f ae25 	bne.w	67b0 <usb_isr+0x150>
    6b66:	b280      	uxth	r0, r0
    6b68:	2800      	cmp	r0, #0
    6b6a:	f47f ae21 	bne.w	67b0 <usb_isr+0x150>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    6b6e:	492e      	ldr	r1, [pc, #184]	; (6c28 <usb_isr+0x5c8>)
    6b70:	4c2e      	ldr	r4, [pc, #184]	; (6c2c <usb_isr+0x5cc>)
    6b72:	c903      	ldmia	r1, {r0, r1}
    6b74:	80a1      	strh	r1, [r4, #4]
		if (usb_cdc_line_coding[0] == 134) {
    6b76:	2886      	cmp	r0, #134	; 0x86
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    6b78:	ea4f 4111 	mov.w	r1, r1, lsr #16
    6b7c:	6020      	str	r0, [r4, #0]
    6b7e:	71a1      	strb	r1, [r4, #6]
		if (usb_cdc_line_coding[0] == 134) {
    6b80:	f47f ae16 	bne.w	67b0 <usb_isr+0x150>
	__disable_irq();
    6b84:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    6b86:	482a      	ldr	r0, [pc, #168]	; (6c30 <usb_isr+0x5d0>)
    6b88:	7801      	ldrb	r1, [r0, #0]
    6b8a:	f041 0108 	orr.w	r1, r1, #8
    6b8e:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    6b90:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    6b94:	060d      	lsls	r5, r1, #24
    6b96:	d405      	bmi.n	6ba4 <usb_isr+0x544>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    6b98:	2080      	movs	r0, #128	; 0x80
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    6b9a:	4301      	orrs	r1, r0
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    6b9c:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    6ba0:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	__enable_irq();
    6ba4:	b662      	cpsie	i
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    6ba6:	4a23      	ldr	r2, [pc, #140]	; (6c34 <usb_isr+0x5d4>)
    6ba8:	2150      	movs	r1, #80	; 0x50
    6baa:	7011      	strb	r1, [r2, #0]
    6bac:	e600      	b.n	67b0 <usb_isr+0x150>
				if (datalen > setup.wLength) datalen = setup.wLength;
    6bae:	0c00      	lsrs	r0, r0, #16
					datalen = *(list->addr);
    6bb0:	782a      	ldrb	r2, [r5, #0]
    6bb2:	4282      	cmp	r2, r0
    6bb4:	bf28      	it	cs
    6bb6:	4602      	movcs	r2, r0
				} else if (setup.wValue == 0x700) {
    6bb8:	f5be 6fe0 	cmp.w	lr, #1792	; 0x700
    6bbc:	d144      	bne.n	6c48 <usb_isr+0x5e8>
					if (usb_high_speed) src = usb_config_descriptor_12;
    6bbe:	4b1e      	ldr	r3, [pc, #120]	; (6c38 <usb_isr+0x5d8>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6bc0:	4d1e      	ldr	r5, [pc, #120]	; (6c3c <usb_isr+0x5dc>)
					if (usb_high_speed) src = usb_config_descriptor_12;
    6bc2:	7818      	ldrb	r0, [r3, #0]
    6bc4:	491e      	ldr	r1, [pc, #120]	; (6c40 <usb_isr+0x5e0>)
    6bc6:	4b1f      	ldr	r3, [pc, #124]	; (6c44 <usb_isr+0x5e4>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6bc8:	9201      	str	r2, [sp, #4]
    6bca:	2800      	cmp	r0, #0
    6bcc:	bf18      	it	ne
    6bce:	4619      	movne	r1, r3
    6bd0:	4628      	mov	r0, r5
    6bd2:	f7ff f94b 	bl	5e6c <memcpy>
					usb_descriptor_buffer[1] = 7;
    6bd6:	2307      	movs	r3, #7
    6bd8:	706b      	strb	r3, [r5, #1]
    6bda:	9a01      	ldr	r2, [sp, #4]
    6bdc:	e03b      	b.n	6c56 <usb_isr+0x5f6>
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    6bde:	03c9      	lsls	r1, r1, #15
    6be0:	f53f af61 	bmi.w	6aa6 <usb_isr+0x446>
    6be4:	e761      	b.n	6aaa <usb_isr+0x44a>
    6be6:	bf00      	nop
    6be8:	200012e0 	.word	0x200012e0
    6bec:	200078b0 	.word	0x200078b0
    6bf0:	20001480 	.word	0x20001480
    6bf4:	00070080 	.word	0x00070080
    6bf8:	200088b0 	.word	0x200088b0
    6bfc:	200012c0 	.word	0x200012c0
    6c00:	2000697c 	.word	0x2000697c
    6c04:	20006acc 	.word	0x20006acc
    6c08:	20006aef 	.word	0x20006aef
    6c0c:	20006af0 	.word	0x20006af0
    6c10:	00cc0002 	.word	0x00cc0002
    6c14:	000200c8 	.word	0x000200c8
    6c18:	00c80002 	.word	0x00c80002
    6c1c:	20000080 	.word	0x20000080
    6c20:	74d59319 	.word	0x74d59319
    6c24:	200068e8 	.word	0x200068e8
    6c28:	200068b0 	.word	0x200068b0
    6c2c:	20006ac4 	.word	0x20006ac4
    6c30:	20006aeb 	.word	0x20006aeb
    6c34:	20006af2 	.word	0x20006af2
    6c38:	20006af1 	.word	0x20006af1
    6c3c:	20200000 	.word	0x20200000
    6c40:	60001b78 	.word	0x60001b78
    6c44:	60001b14 	.word	0x60001b14
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    6c48:	4629      	mov	r1, r5
    6c4a:	4d10      	ldr	r5, [pc, #64]	; (6c8c <usb_isr+0x62c>)
    6c4c:	9201      	str	r2, [sp, #4]
    6c4e:	4628      	mov	r0, r5
    6c50:	f7ff f90c 	bl	5e6c <memcpy>
    6c54:	9a01      	ldr	r2, [sp, #4]
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    6c56:	f025 031f 	bic.w	r3, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    6c5a:	4415      	add	r5, r2
	asm("dsb");
    6c5c:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    6c60:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    6c64:	f8c1 3f70 	str.w	r3, [r1, #3952]	; 0xf70
		location += 32;
    6c68:	3320      	adds	r3, #32
	} while (location < end_addr);
    6c6a:	429d      	cmp	r5, r3
    6c6c:	d8fa      	bhi.n	6c64 <usb_isr+0x604>
	asm("dsb");
    6c6e:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6c72:	f3bf 8f6f 	isb	sy
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    6c76:	4805      	ldr	r0, [pc, #20]	; (6c8c <usb_isr+0x62c>)
    6c78:	4611      	mov	r1, r2
    6c7a:	f7ff fc8f 	bl	659c <endpoint0_transmit.constprop.0>
				return;
    6c7e:	e544      	b.n	670a <usb_isr+0xaa>
				usb_stop_sof_interrupts(NUM_INTERFACE);
    6c80:	2003      	movs	r0, #3
    6c82:	f7ff fcd7 	bl	6634 <usb_stop_sof_interrupts>
				_reboot_Teensyduino_();
    6c86:	f000 ff77 	bl	7b78 <___reboot_Teensyduino__veneer>
    6c8a:	bf00      	nop
    6c8c:	20200000 	.word	0x20200000

00006c90 <usb_config_rx>:
{
    6c90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6c94:	461f      	mov	r7, r3
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    6c96:	1e83      	subs	r3, r0, #2
    6c98:	2b02      	cmp	r3, #2
    6c9a:	d901      	bls.n	6ca0 <usb_config_rx+0x10>
}
    6c9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    6ca0:	f8df 904c 	ldr.w	r9, [pc, #76]	; 6cf0 <usb_config_rx+0x60>
    6ca4:	4615      	mov	r5, r2
    6ca6:	460c      	mov	r4, r1
	memset(qh, 0, sizeof(endpoint_t));
    6ca8:	223c      	movs	r2, #60	; 0x3c
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    6caa:	eb09 18c0 	add.w	r8, r9, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    6cae:	4606      	mov	r6, r0
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    6cb0:	ea4f 1ac0 	mov.w	sl, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    6cb4:	2100      	movs	r1, #0
    6cb6:	f108 0004 	add.w	r0, r8, #4
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6cba:	0424      	lsls	r4, r4, #16
	memset(qh, 0, sizeof(endpoint_t));
    6cbc:	f000 fee0 	bl	7a80 <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6cc0:	fab5 f285 	clz	r2, r5
	qh->next = 1; // Terminate bit = 1
    6cc4:	2301      	movs	r3, #1
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6cc6:	0952      	lsrs	r2, r2, #5
    6cc8:	ea44 7442 	orr.w	r4, r4, r2, lsl #29
	qh->config = config;
    6ccc:	f849 400a 	str.w	r4, [r9, sl]
	qh->callback_function = callback;
    6cd0:	f8c8 7038 	str.w	r7, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    6cd4:	f8c8 3008 	str.w	r3, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << ep);
    6cd8:	2f00      	cmp	r7, #0
    6cda:	d0df      	beq.n	6c9c <usb_config_rx+0xc>
    6cdc:	4a03      	ldr	r2, [pc, #12]	; (6cec <usb_config_rx+0x5c>)
    6cde:	40b3      	lsls	r3, r6
    6ce0:	6811      	ldr	r1, [r2, #0]
    6ce2:	430b      	orrs	r3, r1
    6ce4:	6013      	str	r3, [r2, #0]
}
    6ce6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6cea:	bf00      	nop
    6cec:	200068bc 	.word	0x200068bc
    6cf0:	20000000 	.word	0x20000000

00006cf4 <usb_config_tx>:
{
    6cf4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6cf8:	460d      	mov	r5, r1
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    6cfa:	1e81      	subs	r1, r0, #2
    6cfc:	2902      	cmp	r1, #2
    6cfe:	d901      	bls.n	6d04 <usb_config_tx+0x10>
}
    6d00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    6d04:	01c7      	lsls	r7, r0, #7
    6d06:	f8df 904c 	ldr.w	r9, [pc, #76]	; 6d54 <usb_config_tx+0x60>
    6d0a:	4692      	mov	sl, r2
    6d0c:	4604      	mov	r4, r0
    6d0e:	3740      	adds	r7, #64	; 0x40
	memset(qh, 0, sizeof(endpoint_t));
    6d10:	223c      	movs	r2, #60	; 0x3c
    6d12:	2100      	movs	r1, #0
    6d14:	461e      	mov	r6, r3
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    6d16:	eb09 0807 	add.w	r8, r9, r7
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6d1a:	042d      	lsls	r5, r5, #16
	memset(qh, 0, sizeof(endpoint_t));
    6d1c:	f108 0004 	add.w	r0, r8, #4
    6d20:	f000 feae 	bl	7a80 <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6d24:	faba f28a 	clz	r2, sl
    6d28:	0952      	lsrs	r2, r2, #5
    6d2a:	ea45 7242 	orr.w	r2, r5, r2, lsl #29
	qh->config = config;
    6d2e:	f849 2007 	str.w	r2, [r9, r7]
	qh->next = 1; // Terminate bit = 1
    6d32:	2201      	movs	r2, #1
	qh->callback_function = callback;
    6d34:	f8c8 6038 	str.w	r6, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    6d38:	f8c8 2008 	str.w	r2, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    6d3c:	2e00      	cmp	r6, #0
    6d3e:	d0df      	beq.n	6d00 <usb_config_tx+0xc>
    6d40:	4b03      	ldr	r3, [pc, #12]	; (6d50 <usb_config_tx+0x5c>)
    6d42:	3410      	adds	r4, #16
    6d44:	6819      	ldr	r1, [r3, #0]
    6d46:	40a2      	lsls	r2, r4
    6d48:	430a      	orrs	r2, r1
    6d4a:	601a      	str	r2, [r3, #0]
}
    6d4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6d50:	200068bc 	.word	0x200068bc
    6d54:	20000000 	.word	0x20000000

00006d58 <usb_prepare_transfer>:
	transfer->status = (len << 16) | (1<<7);
    6d58:	0412      	lsls	r2, r2, #16
	transfer->pointer0 = addr;
    6d5a:	6081      	str	r1, [r0, #8]
	transfer->callback_param = param;
    6d5c:	61c3      	str	r3, [r0, #28]
	transfer->pointer3 = addr + 12288;
    6d5e:	f501 5340 	add.w	r3, r1, #12288	; 0x3000
	transfer->status = (len << 16) | (1<<7);
    6d62:	f042 0280 	orr.w	r2, r2, #128	; 0x80
{
    6d66:	b410      	push	{r4}
	transfer->next = 1;
    6d68:	2401      	movs	r4, #1
	transfer->status = (len << 16) | (1<<7);
    6d6a:	6042      	str	r2, [r0, #4]
	transfer->pointer2 = addr + 8192;
    6d6c:	f501 5200 	add.w	r2, r1, #8192	; 0x2000
	transfer->next = 1;
    6d70:	6004      	str	r4, [r0, #0]
	transfer->pointer1 = addr + 4096;
    6d72:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
	transfer->pointer4 = addr + 16384;
    6d76:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
	transfer->pointer1 = addr + 4096;
    6d7a:	60c4      	str	r4, [r0, #12]
	transfer->pointer4 = addr + 16384;
    6d7c:	6181      	str	r1, [r0, #24]
}
    6d7e:	f85d 4b04 	ldr.w	r4, [sp], #4
	transfer->pointer3 = addr + 12288;
    6d82:	e9c0 2304 	strd	r2, r3, [r0, #16]
}
    6d86:	4770      	bx	lr

00006d88 <usb_transmit>:

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6d88:	1e83      	subs	r3, r0, #2
{
    6d8a:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6d8c:	2b02      	cmp	r3, #2
    6d8e:	d900      	bls.n	6d92 <usb_transmit+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}
    6d90:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    6d92:	4b06      	ldr	r3, [pc, #24]	; (6dac <usb_transmit+0x24>)
	uint32_t mask = 1 << (endpoint_number + 16);
    6d94:	f100 0110 	add.w	r1, r0, #16
    6d98:	f04f 0c01 	mov.w	ip, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    6d9c:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
	schedule_transfer(endpoint, mask, transfer);
    6da0:	fa0c f101 	lsl.w	r1, ip, r1
    6da4:	3040      	adds	r0, #64	; 0x40
    6da6:	f7ff bb99 	b.w	64dc <schedule_transfer>
    6daa:	bf00      	nop
    6dac:	20000000 	.word	0x20000000

00006db0 <usb_receive>:

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6db0:	1e83      	subs	r3, r0, #2
{
    6db2:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6db4:	2b02      	cmp	r3, #2
    6db6:	d900      	bls.n	6dba <usb_receive+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
}
    6db8:	4770      	bx	lr
	uint32_t mask = 1 << endpoint_number;
    6dba:	2101      	movs	r1, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
    6dbc:	4b02      	ldr	r3, [pc, #8]	; (6dc8 <usb_receive+0x18>)
	schedule_transfer(endpoint, mask, transfer);
    6dbe:	4081      	lsls	r1, r0
    6dc0:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    6dc4:	f7ff bb8a 	b.w	64dc <schedule_transfer>
    6dc8:	20000000 	.word	0x20000000

00006dcc <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    6dcc:	6840      	ldr	r0, [r0, #4]
#endif
}
    6dce:	4770      	bx	lr

00006dd0 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    6dd0:	4a12      	ldr	r2, [pc, #72]	; (6e1c <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    6dd2:	4b13      	ldr	r3, [pc, #76]	; (6e20 <usb_init_serialnumber+0x50>)
	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    6dd4:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    6dd8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	if (num < 10000000) num = num * 10;
    6ddc:	4298      	cmp	r0, r3
{
    6dde:	b510      	push	{r4, lr}
    6de0:	b084      	sub	sp, #16
	if (num < 10000000) num = num * 10;
    6de2:	d202      	bcs.n	6dea <usb_init_serialnumber+0x1a>
    6de4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    6de8:	0040      	lsls	r0, r0, #1
	ultoa(num, buf, 10);
    6dea:	4c0e      	ldr	r4, [pc, #56]	; (6e24 <usb_init_serialnumber+0x54>)
    6dec:	a901      	add	r1, sp, #4
    6dee:	220a      	movs	r2, #10
    6df0:	f7ff f8d6 	bl	5fa0 <ultoa>
	for (i=0; i<10; i++) {
    6df4:	a901      	add	r1, sp, #4
    6df6:	2300      	movs	r3, #0
    6df8:	4620      	mov	r0, r4
		char c = buf[i];
    6dfa:	f811 2b01 	ldrb.w	r2, [r1], #1
	for (i=0; i<10; i++) {
    6dfe:	3301      	adds	r3, #1
		if (!c) break;
    6e00:	b13a      	cbz	r2, 6e12 <usb_init_serialnumber+0x42>
	for (i=0; i<10; i++) {
    6e02:	2b0a      	cmp	r3, #10
		usb_string_serial_number_default.wString[i] = c;
    6e04:	f820 2f02 	strh.w	r2, [r0, #2]!
	for (i=0; i<10; i++) {
    6e08:	d1f7      	bne.n	6dfa <usb_init_serialnumber+0x2a>
    6e0a:	2316      	movs	r3, #22
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    6e0c:	7023      	strb	r3, [r4, #0]
}
    6e0e:	b004      	add	sp, #16
    6e10:	bd10      	pop	{r4, pc}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    6e12:	005b      	lsls	r3, r3, #1
    6e14:	b2db      	uxtb	r3, r3
    6e16:	7023      	strb	r3, [r4, #0]
}
    6e18:	b004      	add	sp, #16
    6e1a:	bd10      	pop	{r4, pc}
    6e1c:	401f4400 	.word	0x401f4400
    6e20:	00989680 	.word	0x00989680
    6e24:	20000d30 	.word	0x20000d30

00006e28 <usb_serial_class::clear()>:
        virtual void clear(void) { usb_serial_flush_input(); }
    6e28:	f000 bace 	b.w	73c8 <usb_serial_flush_input>

00006e2c <usb_serial_class::available()>:
        virtual int available() { return usb_serial_available(); }
    6e2c:	f000 bac0 	b.w	73b0 <usb_serial_available>

00006e30 <usb_serial_class::flush()>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6e30:	f000 bb5c 	b.w	74ec <usb_serial_flush_output>

00006e34 <usb_serial_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    6e34:	f000 bb32 	b.w	749c <usb_serial_write_buffer_free>

00006e38 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    6e38:	4608      	mov	r0, r1
    6e3a:	4611      	mov	r1, r2
    6e3c:	f000 bb22 	b.w	7484 <usb_serial_write>

00006e40 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    6e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    6e42:	4c14      	ldr	r4, [pc, #80]	; (6e94 <rx_queue_transfer+0x54>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    6e44:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    6e48:	4e13      	ldr	r6, [pc, #76]	; (6e98 <rx_queue_transfer+0x58>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    6e4a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    6e4e:	eb04 2440 	add.w	r4, r4, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    6e52:	4f12      	ldr	r7, [pc, #72]	; (6e9c <rx_queue_transfer+0x5c>)
    6e54:	eb06 1640 	add.w	r6, r6, r0, lsl #5
{
    6e58:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
    6e5a:	f8c5 218c 	str.w	r2, [r5, #396]	; 0x18c
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    6e5e:	4621      	mov	r1, r4
    6e60:	883a      	ldrh	r2, [r7, #0]
    6e62:	4630      	mov	r0, r6
    6e64:	f7ff ff78 	bl	6d58 <usb_prepare_transfer>
	arm_dcache_delete(buffer, rx_packet_size);
    6e68:	883b      	ldrh	r3, [r7, #0]
	uint32_t end_addr = (uint32_t)addr + size;
    6e6a:	4423      	add	r3, r4
	asm("dsb");
    6e6c:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCIMVAC = location;
    6e70:	f8c5 4f5c 	str.w	r4, [r5, #3932]	; 0xf5c
		location += 32;
    6e74:	3420      	adds	r4, #32
	} while (location < end_addr);
    6e76:	42a3      	cmp	r3, r4
    6e78:	d8fa      	bhi.n	6e70 <rx_queue_transfer+0x30>
	asm("dsb");
    6e7a:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6e7e:	f3bf 8f6f 	isb	sy
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    6e82:	2003      	movs	r0, #3
    6e84:	4631      	mov	r1, r6
    6e86:	f7ff ff93 	bl	6db0 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    6e8a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    6e8e:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
}
    6e92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6e94:	20200080 	.word	0x20200080
    6e98:	20001300 	.word	0x20001300
    6e9c:	20006ad8 	.word	0x20006ad8

00006ea0 <rx_event>:

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    6ea0:	4b24      	ldr	r3, [pc, #144]	; (6f34 <rx_event+0x94>)
{
    6ea2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    6ea6:	881c      	ldrh	r4, [r3, #0]
    6ea8:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    6eaa:	69c5      	ldr	r5, [r0, #28]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    6eac:	f3c3 430e 	ubfx	r3, r3, #16, #15
    6eb0:	1ae4      	subs	r4, r4, r3
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    6eb2:	2c00      	cmp	r4, #0
    6eb4:	dd24      	ble.n	6f00 <rx_event+0x60>
		// received a packet with data
		uint32_t head = rx_head;
    6eb6:	4920      	ldr	r1, [pc, #128]	; (6f38 <rx_event+0x98>)
		if (head != rx_tail) {
    6eb8:	4820      	ldr	r0, [pc, #128]	; (6f3c <rx_event+0x9c>)
		uint32_t head = rx_head;
    6eba:	780a      	ldrb	r2, [r1, #0]
		if (head != rx_tail) {
    6ebc:	7800      	ldrb	r0, [r0, #0]
		uint32_t head = rx_head;
    6ebe:	b2d3      	uxtb	r3, r2
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
    6ec0:	4e1f      	ldr	r6, [pc, #124]	; (6f40 <rx_event+0xa0>)
		if (head != rx_tail) {
    6ec2:	4282      	cmp	r2, r0
			uint32_t ii = rx_list[head];
    6ec4:	481f      	ldr	r0, [pc, #124]	; (6f44 <rx_event+0xa4>)
		if (head != rx_tail) {
    6ec6:	d007      	beq.n	6ed8 <rx_event+0x38>
			uint32_t ii = rx_list[head];
    6ec8:	f810 8003 	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    6ecc:	f836 7018 	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    6ed0:	f5c7 7200 	rsb	r2, r7, #512	; 0x200
    6ed4:	4294      	cmp	r4, r2
    6ed6:	d918      	bls.n	6f0a <rx_event+0x6a>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    6ed8:	3301      	adds	r3, #1
		rx_index[i] = 0;
    6eda:	2200      	movs	r2, #0
		rx_count[i] = len;
    6edc:	f826 4015 	strh.w	r4, [r6, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
    6ee0:	2b08      	cmp	r3, #8
		rx_index[i] = 0;
    6ee2:	4e19      	ldr	r6, [pc, #100]	; (6f48 <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    6ee4:	bf88      	it	hi
    6ee6:	4613      	movhi	r3, r2
		rx_index[i] = 0;
    6ee8:	f826 2015 	strh.w	r2, [r6, r5, lsl #1]
		rx_list[head] = i;
		rx_head = head;
    6eec:	bf98      	it	ls
    6eee:	b2da      	uxtbls	r2, r3
		rx_list[head] = i;
    6ef0:	54c5      	strb	r5, [r0, r3]
		rx_available += len;
    6ef2:	4b16      	ldr	r3, [pc, #88]	; (6f4c <rx_event+0xac>)
		rx_head = head;
    6ef4:	700a      	strb	r2, [r1, #0]
		rx_available += len;
    6ef6:	681a      	ldr	r2, [r3, #0]
    6ef8:	4414      	add	r4, r2
    6efa:	601c      	str	r4, [r3, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    6efc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx_queue_transfer(i);
    6f00:	4628      	mov	r0, r5
}
    6f02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_queue_transfer(i);
    6f06:	f7ff bf9b 	b.w	6e40 <rx_queue_transfer>
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    6f0a:	eb07 2048 	add.w	r0, r7, r8, lsl #9
    6f0e:	4910      	ldr	r1, [pc, #64]	; (6f50 <rx_event+0xb0>)
    6f10:	4622      	mov	r2, r4
				rx_count[ii] = count + len;
    6f12:	4427      	add	r7, r4
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    6f14:	4408      	add	r0, r1
    6f16:	eb01 2145 	add.w	r1, r1, r5, lsl #9
    6f1a:	f7fe ffa7 	bl	5e6c <memcpy>
				rx_available += len;
    6f1e:	4a0b      	ldr	r2, [pc, #44]	; (6f4c <rx_event+0xac>)
				rx_queue_transfer(i);
    6f20:	4628      	mov	r0, r5
				rx_count[ii] = count + len;
    6f22:	f826 7018 	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    6f26:	6813      	ldr	r3, [r2, #0]
    6f28:	4423      	add	r3, r4
}
    6f2a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				rx_available += len;
    6f2e:	6013      	str	r3, [r2, #0]
				rx_queue_transfer(i);
    6f30:	f7ff bf86 	b.w	6e40 <rx_queue_transfer>
    6f34:	20006ad8 	.word	0x20006ad8
    6f38:	20006ae9 	.word	0x20006ae9
    6f3c:	20006aea 	.word	0x20006aea
    6f40:	200068f4 	.word	0x200068f4
    6f44:	20006914 	.word	0x20006914
    6f48:	20006904 	.word	0x20006904
    6f4c:	200068f0 	.word	0x200068f0
    6f50:	20200080 	.word	0x20200080

00006f54 <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    6f54:	4b1d      	ldr	r3, [pc, #116]	; (6fcc <usb_serial_flush_callback+0x78>)
    6f56:	781a      	ldrb	r2, [r3, #0]
    6f58:	2a00      	cmp	r2, #0
    6f5a:	d136      	bne.n	6fca <usb_serial_flush_callback+0x76>
	if (!usb_configuration) return;
    6f5c:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    6f60:	4a1b      	ldr	r2, [pc, #108]	; (6fd0 <usb_serial_flush_callback+0x7c>)
    6f62:	7812      	ldrb	r2, [r2, #0]
    6f64:	b38a      	cbz	r2, 6fca <usb_serial_flush_callback+0x76>
{
    6f66:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_available == 0) return;
    6f6a:	4d1a      	ldr	r5, [pc, #104]	; (6fd4 <usb_serial_flush_callback+0x80>)
    6f6c:	882a      	ldrh	r2, [r5, #0]
    6f6e:	b352      	cbz	r2, 6fc6 <usb_serial_flush_callback+0x72>
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    6f70:	4e19      	ldr	r6, [pc, #100]	; (6fd8 <usb_serial_flush_callback+0x84>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    6f72:	f5c2 6800 	rsb	r8, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    6f76:	4f19      	ldr	r7, [pc, #100]	; (6fdc <usb_serial_flush_callback+0x88>)
    6f78:	7832      	ldrb	r2, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    6f7a:	4c19      	ldr	r4, [pc, #100]	; (6fe0 <usb_serial_flush_callback+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    6f7c:	eb07 1742 	add.w	r7, r7, r2, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    6f80:	eb04 24c2 	add.w	r4, r4, r2, lsl #11
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    6f84:	4642      	mov	r2, r8
    6f86:	4638      	mov	r0, r7
    6f88:	4621      	mov	r1, r4
    6f8a:	f7ff fee5 	bl	6d58 <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    6f8e:	eb04 0208 	add.w	r2, r4, r8
	asm("dsb");
    6f92:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    6f96:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6f9a:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    6f9e:	3420      	adds	r4, #32
	} while (location < end_addr);
    6fa0:	42a2      	cmp	r2, r4
    6fa2:	d8fa      	bhi.n	6f9a <usb_serial_flush_callback+0x46>
	asm("dsb");
    6fa4:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6fa8:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    6fac:	2004      	movs	r0, #4
    6fae:	4639      	mov	r1, r7
    6fb0:	f7ff feea 	bl	6d88 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    6fb4:	7833      	ldrb	r3, [r6, #0]
    6fb6:	3301      	adds	r3, #1
    6fb8:	b2db      	uxtb	r3, r3
    6fba:	2b03      	cmp	r3, #3
    6fbc:	bf88      	it	hi
    6fbe:	2300      	movhi	r3, #0
    6fc0:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    6fc2:	2300      	movs	r3, #0
    6fc4:	802b      	strh	r3, [r5, #0]
}
    6fc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6fca:	4770      	bx	lr
    6fcc:	20006aee 	.word	0x20006aee
    6fd0:	20006af0 	.word	0x20006af0
    6fd4:	20006ada 	.word	0x20006ada
    6fd8:	20006aed 	.word	0x20006aed
    6fdc:	20001400 	.word	0x20001400
    6fe0:	20201080 	.word	0x20201080

00006fe4 <usb_serial_write.part.0>:
int usb_serial_write(const void *buffer, uint32_t size)
    6fe4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6fe8:	b085      	sub	sp, #20
	while (size > 0) {
    6fea:	e9cd 1001 	strd	r1, r0, [sp, #4]
    6fee:	2900      	cmp	r1, #0
    6ff0:	f000 80bf 	beq.w	7172 <usb_serial_write.part.0+0x18e>
	uint32_t sent=0;
    6ff4:	2300      	movs	r3, #0
    6ff6:	4c60      	ldr	r4, [pc, #384]	; (7178 <usb_serial_write.part.0+0x194>)
    6ff8:	f8df 8198 	ldr.w	r8, [pc, #408]	; 7194 <usb_serial_write.part.0+0x1b0>
    6ffc:	f8df a198 	ldr.w	sl, [pc, #408]	; 7198 <usb_serial_write.part.0+0x1b4>
				wait_begin_at = systick_millis_count;
    7000:	4f5e      	ldr	r7, [pc, #376]	; (717c <usb_serial_write.part.0+0x198>)
	uint32_t sent=0;
    7002:	9300      	str	r3, [sp, #0]
		tx_noautoflush = 1;
    7004:	2301      	movs	r3, #1
		transfer_t *xfer = tx_transfer + tx_head;
    7006:	4a5e      	ldr	r2, [pc, #376]	; (7180 <usb_serial_write.part.0+0x19c>)
		tx_noautoflush = 1;
    7008:	7023      	strb	r3, [r4, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    700a:	4b5e      	ldr	r3, [pc, #376]	; (7184 <usb_serial_write.part.0+0x1a0>)
    700c:	7819      	ldrb	r1, [r3, #0]
		while (!tx_available) {
    700e:	f8b8 3000 	ldrh.w	r3, [r8]
		transfer_t *xfer = tx_transfer + tx_head;
    7012:	eb02 1941 	add.w	r9, r2, r1, lsl #5
		while (!tx_available) {
    7016:	2b00      	cmp	r3, #0
    7018:	f040 80a7 	bne.w	716a <usb_serial_write.part.0+0x186>
		uint32_t wait_begin_at=0;
    701c:	461e      	mov	r6, r3
		int waiting=0;
    701e:	461d      	mov	r5, r3
			tx_noautoflush = 0;
    7020:	469b      	mov	fp, r3
			uint32_t status = usb_transfer_status(xfer);
    7022:	4648      	mov	r0, r9
    7024:	f7ff fed2 	bl	6dcc <usb_transfer_status>
			if (!(status & 0x80)) {
    7028:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    702c:	f000 808c 	beq.w	7148 <usb_serial_write.part.0+0x164>
			asm("dsb" ::: "memory");
    7030:	f3bf 8f4f 	dsb	sy
			if (transmit_previous_timeout) return sent;
    7034:	f89a 3000 	ldrb.w	r3, [sl]
			tx_noautoflush = 0;
    7038:	f884 b000 	strb.w	fp, [r4]
			if (!waiting) {
    703c:	b905      	cbnz	r5, 7040 <usb_serial_write.part.0+0x5c>
				wait_begin_at = systick_millis_count;
    703e:	683e      	ldr	r6, [r7, #0]
			if (transmit_previous_timeout) return sent;
    7040:	2b00      	cmp	r3, #0
    7042:	d17d      	bne.n	7140 <usb_serial_write.part.0+0x15c>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    7044:	683b      	ldr	r3, [r7, #0]
    7046:	1b9b      	subs	r3, r3, r6
    7048:	2b78      	cmp	r3, #120	; 0x78
    704a:	f200 8087 	bhi.w	715c <usb_serial_write.part.0+0x178>
			if (!usb_configuration) return sent;
    704e:	4b4e      	ldr	r3, [pc, #312]	; (7188 <usb_serial_write.part.0+0x1a4>)
    7050:	781b      	ldrb	r3, [r3, #0]
    7052:	2b00      	cmp	r3, #0
    7054:	d074      	beq.n	7140 <usb_serial_write.part.0+0x15c>
			yield();
    7056:	f000 fa93 	bl	7580 <yield>
			tx_noautoflush = 1;
    705a:	2201      	movs	r2, #1
		while (!tx_available) {
    705c:	f8b8 3000 	ldrh.w	r3, [r8]
    7060:	4615      	mov	r5, r2
			tx_noautoflush = 1;
    7062:	7022      	strb	r2, [r4, #0]
		while (!tx_available) {
    7064:	2b00      	cmp	r3, #0
    7066:	d0dc      	beq.n	7022 <usb_serial_write.part.0+0x3e>
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7068:	4a46      	ldr	r2, [pc, #280]	; (7184 <usb_serial_write.part.0+0x1a0>)
    706a:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    706e:	7811      	ldrb	r1, [r2, #0]
    7070:	461a      	mov	r2, r3
    7072:	eb00 20c1 	add.w	r0, r0, r1, lsl #11
    7076:	4d45      	ldr	r5, [pc, #276]	; (718c <usb_serial_write.part.0+0x1a8>)
    7078:	02c9      	lsls	r1, r1, #11
    707a:	4428      	add	r0, r5
		if (size >= tx_available) {
    707c:	9d01      	ldr	r5, [sp, #4]
    707e:	4295      	cmp	r5, r2
    7080:	d217      	bcs.n	70b2 <usb_serial_write.part.0+0xce>
			memcpy(txdata, data, size);
    7082:	9303      	str	r3, [sp, #12]
    7084:	e9dd 5101 	ldrd	r5, r1, [sp, #4]
    7088:	462a      	mov	r2, r5
    708a:	f7fe feef 	bl	5e6c <memcpy>
			tx_available -= size;
    708e:	9b03      	ldr	r3, [sp, #12]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    7090:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
			tx_available -= size;
    7094:	1b5b      	subs	r3, r3, r5
    7096:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    709a:	4b3d      	ldr	r3, [pc, #244]	; (7190 <usb_serial_write.part.0+0x1ac>)
    709c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		asm("dsb" ::: "memory");
    70a0:	f3bf 8f4f 	dsb	sy
			sent += size;
    70a4:	9800      	ldr	r0, [sp, #0]
		tx_noautoflush = 0;
    70a6:	2300      	movs	r3, #0
			sent += size;
    70a8:	4428      	add	r0, r5
		tx_noautoflush = 0;
    70aa:	7023      	strb	r3, [r4, #0]
}
    70ac:	b005      	add	sp, #20
    70ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    70b2:	4b36      	ldr	r3, [pc, #216]	; (718c <usb_serial_write.part.0+0x1a8>)
    70b4:	18cd      	adds	r5, r1, r3
			memcpy(txdata, data, tx_available);
    70b6:	9902      	ldr	r1, [sp, #8]
    70b8:	f7fe fed8 	bl	5e6c <memcpy>
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    70bc:	2300      	movs	r3, #0
    70be:	f44f 6200 	mov.w	r2, #2048	; 0x800
    70c2:	4629      	mov	r1, r5
    70c4:	4648      	mov	r0, r9
    70c6:	f7ff fe47 	bl	6d58 <usb_prepare_transfer>
	asm("dsb");
    70ca:	f3bf 8f4f 	dsb	sy
    70ce:	f105 0220 	add.w	r2, r5, #32
	uint32_t end_addr = (uint32_t)addr + size;
    70d2:	f505 6300 	add.w	r3, r5, #2048	; 0x800
    70d6:	4293      	cmp	r3, r2
    70d8:	bf34      	ite	cc
    70da:	2301      	movcc	r3, #1
    70dc:	2340      	movcs	r3, #64	; 0x40
		SCB_CACHE_DCCIMVAC = location;
    70de:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    70e2:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    70e6:	f8c2 5f70 	str.w	r5, [r2, #3952]	; 0xf70
		location += 32;
    70ea:	3520      	adds	r5, #32
	} while (location < end_addr);
    70ec:	42ab      	cmp	r3, r5
    70ee:	d1fa      	bne.n	70e6 <usb_serial_write.part.0+0x102>
	asm("dsb");
    70f0:	f3bf 8f4f 	dsb	sy
	asm("isb");
    70f4:	f3bf 8f6f 	isb	sy
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    70f8:	2004      	movs	r0, #4
    70fa:	4649      	mov	r1, r9
    70fc:	f7ff fe44 	bl	6d88 <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    7100:	4a20      	ldr	r2, [pc, #128]	; (7184 <usb_serial_write.part.0+0x1a0>)
    7102:	7813      	ldrb	r3, [r2, #0]
    7104:	3301      	adds	r3, #1
    7106:	b2db      	uxtb	r3, r3
    7108:	2b03      	cmp	r3, #3
    710a:	bf84      	itt	hi
    710c:	2300      	movhi	r3, #0
    710e:	4a1d      	ldrhi	r2, [pc, #116]	; (7184 <usb_serial_write.part.0+0x1a0>)
    7110:	7013      	strb	r3, [r2, #0]
			size -= tx_available;
    7112:	f8b8 3000 	ldrh.w	r3, [r8]
    7116:	9a01      	ldr	r2, [sp, #4]
    7118:	1ad1      	subs	r1, r2, r3
			sent += tx_available;
    711a:	9a00      	ldr	r2, [sp, #0]
    711c:	441a      	add	r2, r3
			size -= tx_available;
    711e:	9101      	str	r1, [sp, #4]
			sent += tx_available;
    7120:	9200      	str	r2, [sp, #0]
			data += tx_available;
    7122:	9a02      	ldr	r2, [sp, #8]
    7124:	441a      	add	r2, r3
			tx_available = 0;
    7126:	2300      	movs	r3, #0
			data += tx_available;
    7128:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = 0;
    712a:	4a19      	ldr	r2, [pc, #100]	; (7190 <usb_serial_write.part.0+0x1ac>)
			tx_available = 0;
    712c:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = 0;
    7130:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
		asm("dsb" ::: "memory");
    7134:	f3bf 8f4f 	dsb	sy
		tx_noautoflush = 0;
    7138:	7023      	strb	r3, [r4, #0]
	while (size > 0) {
    713a:	2900      	cmp	r1, #0
    713c:	f47f af62 	bne.w	7004 <usb_serial_write.part.0+0x20>
	return sent;
    7140:	9800      	ldr	r0, [sp, #0]
}
    7142:	b005      	add	sp, #20
    7144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tx_available = TX_SIZE;
    7148:	f44f 6200 	mov.w	r2, #2048	; 0x800
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    714c:	4b0d      	ldr	r3, [pc, #52]	; (7184 <usb_serial_write.part.0+0x1a0>)
				transmit_previous_timeout = 0;
    714e:	f88a 0000 	strb.w	r0, [sl]
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7152:	7819      	ldrb	r1, [r3, #0]
				break;
    7154:	4613      	mov	r3, r2
				tx_available = TX_SIZE;
    7156:	f8a8 2000 	strh.w	r2, [r8]
				break;
    715a:	e78a      	b.n	7072 <usb_serial_write.part.0+0x8e>
				transmit_previous_timeout = 1;
    715c:	2301      	movs	r3, #1
				return sent;
    715e:	9800      	ldr	r0, [sp, #0]
				transmit_previous_timeout = 1;
    7160:	f88a 3000 	strb.w	r3, [sl]
}
    7164:	b005      	add	sp, #20
    7166:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    716a:	461a      	mov	r2, r3
    716c:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    7170:	e77f      	b.n	7072 <usb_serial_write.part.0+0x8e>
	while (size > 0) {
    7172:	9801      	ldr	r0, [sp, #4]
	return sent;
    7174:	e7e5      	b.n	7142 <usb_serial_write.part.0+0x15e>
    7176:	bf00      	nop
    7178:	20006aee 	.word	0x20006aee
    717c:	2000697c 	.word	0x2000697c
    7180:	20001400 	.word	0x20001400
    7184:	20006aed 	.word	0x20006aed
    7188:	20006af0 	.word	0x20006af0
    718c:	20201080 	.word	0x20201080
    7190:	402e0000 	.word	0x402e0000
    7194:	20006ada 	.word	0x20006ada
    7198:	20006aec 	.word	0x20006aec

0000719c <usb_serial_reset>:
}
    719c:	4770      	bx	lr
    719e:	bf00      	nop

000071a0 <usb_serial_configure>:
	if (usb_high_speed) {
    71a0:	4b2a      	ldr	r3, [pc, #168]	; (724c <usb_serial_configure+0xac>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
    71a2:	2100      	movs	r1, #0
    71a4:	2280      	movs	r2, #128	; 0x80
    71a6:	482a      	ldr	r0, [pc, #168]	; (7250 <usb_serial_configure+0xb0>)
{
    71a8:	b570      	push	{r4, r5, r6, lr}
	if (usb_high_speed) {
    71aa:	781b      	ldrb	r3, [r3, #0]
	tx_head = 0;
    71ac:	2400      	movs	r4, #0
		tx_packet_size = CDC_TX_SIZE_480;
    71ae:	4d29      	ldr	r5, [pc, #164]	; (7254 <usb_serial_configure+0xb4>)
	if (usb_high_speed) {
    71b0:	428b      	cmp	r3, r1
		rx_packet_size = CDC_RX_SIZE_480;
    71b2:	4e29      	ldr	r6, [pc, #164]	; (7258 <usb_serial_configure+0xb8>)
	if (usb_high_speed) {
    71b4:	bf0c      	ite	eq
    71b6:	2340      	moveq	r3, #64	; 0x40
    71b8:	f44f 7300 	movne.w	r3, #512	; 0x200
		tx_packet_size = CDC_TX_SIZE_480;
    71bc:	802b      	strh	r3, [r5, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    71be:	8033      	strh	r3, [r6, #0]
	memset(tx_transfer, 0, sizeof(tx_transfer));
    71c0:	f000 fc5e 	bl	7a80 <memset>
	tx_head = 0;
    71c4:	4a25      	ldr	r2, [pc, #148]	; (725c <usb_serial_configure+0xbc>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    71c6:	4621      	mov	r1, r4
	tx_available = 0;
    71c8:	4b25      	ldr	r3, [pc, #148]	; (7260 <usb_serial_configure+0xc0>)
	tx_head = 0;
    71ca:	7014      	strb	r4, [r2, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    71cc:	f44f 7280 	mov.w	r2, #256	; 0x100
    71d0:	4824      	ldr	r0, [pc, #144]	; (7264 <usb_serial_configure+0xc4>)
	tx_available = 0;
    71d2:	801c      	strh	r4, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    71d4:	f000 fc54 	bl	7a80 <memset>
	memset(rx_count, 0, sizeof(rx_count));
    71d8:	4a23      	ldr	r2, [pc, #140]	; (7268 <usb_serial_configure+0xc8>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    71da:	2110      	movs	r1, #16
	memset(rx_index, 0, sizeof(rx_index));
    71dc:	4b23      	ldr	r3, [pc, #140]	; (726c <usb_serial_configure+0xcc>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    71de:	2002      	movs	r0, #2
	memset(rx_count, 0, sizeof(rx_count));
    71e0:	e9c2 4400 	strd	r4, r4, [r2]
    71e4:	e9c2 4402 	strd	r4, r4, [r2, #8]
	rx_head = 0;
    71e8:	4a21      	ldr	r2, [pc, #132]	; (7270 <usb_serial_configure+0xd0>)
	memset(rx_index, 0, sizeof(rx_index));
    71ea:	e9c3 4400 	strd	r4, r4, [r3]
	rx_head = 0;
    71ee:	7014      	strb	r4, [r2, #0]
	rx_available = 0;
    71f0:	4a20      	ldr	r2, [pc, #128]	; (7274 <usb_serial_configure+0xd4>)
	memset(rx_index, 0, sizeof(rx_index));
    71f2:	e9c3 4402 	strd	r4, r4, [r3, #8]
	rx_tail = 0;
    71f6:	4b20      	ldr	r3, [pc, #128]	; (7278 <usb_serial_configure+0xd8>)
    71f8:	701c      	strb	r4, [r3, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    71fa:	4623      	mov	r3, r4
	rx_available = 0;
    71fc:	6014      	str	r4, [r2, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    71fe:	4622      	mov	r2, r4
    7200:	f7ff fd78 	bl	6cf4 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    7204:	4622      	mov	r2, r4
    7206:	8831      	ldrh	r1, [r6, #0]
    7208:	2003      	movs	r0, #3
    720a:	4b1c      	ldr	r3, [pc, #112]	; (727c <usb_serial_configure+0xdc>)
    720c:	f7ff fd40 	bl	6c90 <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    7210:	4623      	mov	r3, r4
    7212:	2201      	movs	r2, #1
    7214:	8829      	ldrh	r1, [r5, #0]
    7216:	2004      	movs	r0, #4
    7218:	f7ff fd6c 	bl	6cf4 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    721c:	4620      	mov	r0, r4
    721e:	3401      	adds	r4, #1
    7220:	f7ff fe0e 	bl	6e40 <rx_queue_transfer>
    7224:	2c08      	cmp	r4, #8
    7226:	d1f9      	bne.n	721c <usb_serial_configure+0x7c>
	USB1_GPTIMER0CTRL = 0;
    7228:	4b15      	ldr	r3, [pc, #84]	; (7280 <usb_serial_configure+0xe0>)
	USB1_GPTIMER0LD = microseconds - 1;
    722a:	224a      	movs	r2, #74	; 0x4a
	usb_timer0_callback = callback;
    722c:	4815      	ldr	r0, [pc, #84]	; (7284 <usb_serial_configure+0xe4>)
	USB1_GPTIMER0CTRL = 0;
    722e:	2100      	movs	r1, #0
	usb_timer0_callback = callback;
    7230:	4c15      	ldr	r4, [pc, #84]	; (7288 <usb_serial_configure+0xe8>)
    7232:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    7234:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    7238:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    723c:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    7240:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    7244:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
}
    7248:	bd70      	pop	{r4, r5, r6, pc}
    724a:	bf00      	nop
    724c:	20006af1 	.word	0x20006af1
    7250:	20001400 	.word	0x20001400
    7254:	20006adc 	.word	0x20006adc
    7258:	20006ad8 	.word	0x20006ad8
    725c:	20006aed 	.word	0x20006aed
    7260:	20006ada 	.word	0x20006ada
    7264:	20001300 	.word	0x20001300
    7268:	200068f4 	.word	0x200068f4
    726c:	20006904 	.word	0x20006904
    7270:	20006ae9 	.word	0x20006ae9
    7274:	200068f0 	.word	0x200068f0
    7278:	20006aea 	.word	0x20006aea
    727c:	00006ea1 	.word	0x00006ea1
    7280:	402e0000 	.word	0x402e0000
    7284:	20006ad0 	.word	0x20006ad0
    7288:	00006f55 	.word	0x00006f55

0000728c <usb_serial_read>:
{
    728c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
    7290:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7294:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	uint32_t tail = rx_tail;
    7298:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 7364 <usb_serial_read+0xd8>
{
    729c:	b083      	sub	sp, #12
	NVIC_DISABLE_IRQ(IRQ_USB1);
    729e:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	while (count < size && tail != rx_head) {
    72a2:	468b      	mov	fp, r1
	uint32_t tail = rx_tail;
    72a4:	f89a 4000 	ldrb.w	r4, [sl]
	while (count < size && tail != rx_head) {
    72a8:	2900      	cmp	r1, #0
    72aa:	d04f      	beq.n	734c <usb_serial_read+0xc0>
    72ac:	4680      	mov	r8, r0
    72ae:	b2e4      	uxtb	r4, r4
	uint32_t count=0;
    72b0:	2700      	movs	r7, #0
		uint32_t avail = rx_count[i] - rx_index[i];
    72b2:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 7368 <usb_serial_read+0xdc>
	while (count < size && tail != rx_head) {
    72b6:	4b26      	ldr	r3, [pc, #152]	; (7350 <usb_serial_read+0xc4>)
		uint32_t len = size - count;
    72b8:	ebab 0207 	sub.w	r2, fp, r7
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    72bc:	4925      	ldr	r1, [pc, #148]	; (7354 <usb_serial_read+0xc8>)
	while (count < size && tail != rx_head) {
    72be:	781b      	ldrb	r3, [r3, #0]
    72c0:	42a3      	cmp	r3, r4
		if (++tail > RX_NUM) tail = 0;
    72c2:	f104 0401 	add.w	r4, r4, #1
	while (count < size && tail != rx_head) {
    72c6:	d03f      	beq.n	7348 <usb_serial_read+0xbc>
		if (++tail > RX_NUM) tail = 0;
    72c8:	2c09      	cmp	r4, #9
		uint32_t i = rx_list[tail];
    72ca:	4b23      	ldr	r3, [pc, #140]	; (7358 <usb_serial_read+0xcc>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    72cc:	4640      	mov	r0, r8
		if (++tail > RX_NUM) tail = 0;
    72ce:	bf28      	it	cs
    72d0:	2400      	movcs	r4, #0
		uint32_t i = rx_list[tail];
    72d2:	5d1e      	ldrb	r6, [r3, r4]
		uint32_t avail = rx_count[i] - rx_index[i];
    72d4:	f839 c016 	ldrh.w	ip, [r9, r6, lsl #1]
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    72d8:	eb0c 2346 	add.w	r3, ip, r6, lsl #9
    72dc:	4419      	add	r1, r3
		uint32_t avail = rx_count[i] - rx_index[i];
    72de:	4b1f      	ldr	r3, [pc, #124]	; (735c <usb_serial_read+0xd0>)
    72e0:	f833 5016 	ldrh.w	r5, [r3, r6, lsl #1]
    72e4:	eba5 050c 	sub.w	r5, r5, ip
		if (avail > len) {
    72e8:	42aa      	cmp	r2, r5
    72ea:	d21c      	bcs.n	7326 <usb_serial_read+0x9a>
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    72ec:	eb0c 2c46 	add.w	ip, ip, r6, lsl #9
    72f0:	4918      	ldr	r1, [pc, #96]	; (7354 <usb_serial_read+0xc8>)
			rx_available -= len;
    72f2:	4c1b      	ldr	r4, [pc, #108]	; (7360 <usb_serial_read+0xd4>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    72f4:	4461      	add	r1, ip
    72f6:	9201      	str	r2, [sp, #4]
    72f8:	f7fe fdb8 	bl	5e6c <memcpy>
			rx_available -= len;
    72fc:	6821      	ldr	r1, [r4, #0]
			rx_index[i] += len;
    72fe:	f839 5016 	ldrh.w	r5, [r9, r6, lsl #1]
	return count;
    7302:	4658      	mov	r0, fp
			rx_index[i] += len;
    7304:	9a01      	ldr	r2, [sp, #4]
			rx_available -= len;
    7306:	eba1 010b 	sub.w	r1, r1, fp
			rx_index[i] += len;
    730a:	442a      	add	r2, r5
			rx_available -= len;
    730c:	4439      	add	r1, r7
			rx_index[i] += len;
    730e:	f829 2016 	strh.w	r2, [r9, r6, lsl #1]
			rx_available -= len;
    7312:	6021      	str	r1, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
    7314:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7318:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    731c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
}
    7320:	b003      	add	sp, #12
    7322:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    7326:	462a      	mov	r2, r5
			count += avail;
    7328:	442f      	add	r7, r5
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    732a:	f7fe fd9f 	bl	5e6c <memcpy>
			rx_available -= avail;
    732e:	490c      	ldr	r1, [pc, #48]	; (7360 <usb_serial_read+0xd4>)
			rx_tail = tail;
    7330:	b2e3      	uxtb	r3, r4
			rx_queue_transfer(i);
    7332:	4630      	mov	r0, r6
			rx_available -= avail;
    7334:	680a      	ldr	r2, [r1, #0]
			p += avail;
    7336:	44a8      	add	r8, r5
			rx_available -= avail;
    7338:	1b52      	subs	r2, r2, r5
    733a:	600a      	str	r2, [r1, #0]
			rx_tail = tail;
    733c:	f88a 3000 	strb.w	r3, [sl]
			rx_queue_transfer(i);
    7340:	f7ff fd7e 	bl	6e40 <rx_queue_transfer>
	while (count < size && tail != rx_head) {
    7344:	45bb      	cmp	fp, r7
    7346:	d8b6      	bhi.n	72b6 <usb_serial_read+0x2a>
	return count;
    7348:	4638      	mov	r0, r7
    734a:	e7e3      	b.n	7314 <usb_serial_read+0x88>
	while (count < size && tail != rx_head) {
    734c:	4608      	mov	r0, r1
    734e:	e7e1      	b.n	7314 <usb_serial_read+0x88>
    7350:	20006ae9 	.word	0x20006ae9
    7354:	20200080 	.word	0x20200080
    7358:	20006914 	.word	0x20006914
    735c:	200068f4 	.word	0x200068f4
    7360:	200068f0 	.word	0x200068f0
    7364:	20006aea 	.word	0x20006aea
    7368:	20006904 	.word	0x20006904

0000736c <usb_serial_peekchar>:
	if (tail == rx_head) return -1;
    736c:	4b0b      	ldr	r3, [pc, #44]	; (739c <usb_serial_peekchar+0x30>)
	uint32_t tail = rx_tail;
    736e:	4a0c      	ldr	r2, [pc, #48]	; (73a0 <usb_serial_peekchar+0x34>)
    7370:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) return -1;
    7372:	7819      	ldrb	r1, [r3, #0]
	uint32_t tail = rx_tail;
    7374:	b2d3      	uxtb	r3, r2
	if (tail == rx_head) return -1;
    7376:	428a      	cmp	r2, r1
    7378:	d00d      	beq.n	7396 <usb_serial_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    737a:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    737c:	4809      	ldr	r0, [pc, #36]	; (73a4 <usb_serial_peekchar+0x38>)
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    737e:	4a0a      	ldr	r2, [pc, #40]	; (73a8 <usb_serial_peekchar+0x3c>)
	if (++tail > RX_NUM) tail = 0;
    7380:	2b09      	cmp	r3, #9
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7382:	490a      	ldr	r1, [pc, #40]	; (73ac <usb_serial_peekchar+0x40>)
	if (++tail > RX_NUM) tail = 0;
    7384:	bf28      	it	cs
    7386:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    7388:	5cc3      	ldrb	r3, [r0, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    738a:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
    738e:	eb02 2343 	add.w	r3, r2, r3, lsl #9
    7392:	5c58      	ldrb	r0, [r3, r1]
    7394:	4770      	bx	lr
	if (tail == rx_head) return -1;
    7396:	f04f 30ff 	mov.w	r0, #4294967295
}
    739a:	4770      	bx	lr
    739c:	20006ae9 	.word	0x20006ae9
    73a0:	20006aea 	.word	0x20006aea
    73a4:	20006914 	.word	0x20006914
    73a8:	20200080 	.word	0x20200080
    73ac:	20006904 	.word	0x20006904

000073b0 <usb_serial_available>:
	uint32_t n = rx_available;
    73b0:	4b04      	ldr	r3, [pc, #16]	; (73c4 <usb_serial_available+0x14>)
{
    73b2:	b510      	push	{r4, lr}
	uint32_t n = rx_available;
    73b4:	681c      	ldr	r4, [r3, #0]
	if (n == 0) yield();
    73b6:	b10c      	cbz	r4, 73bc <usb_serial_available+0xc>
}
    73b8:	4620      	mov	r0, r4
    73ba:	bd10      	pop	{r4, pc}
	if (n == 0) yield();
    73bc:	f000 f8e0 	bl	7580 <yield>
}
    73c0:	4620      	mov	r0, r4
    73c2:	bd10      	pop	{r4, pc}
    73c4:	200068f0 	.word	0x200068f0

000073c8 <usb_serial_flush_input>:
{
    73c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t tail = rx_tail;
    73cc:	4e14      	ldr	r6, [pc, #80]	; (7420 <usb_serial_flush_input+0x58>)
	while (tail != rx_head) {
    73ce:	4d15      	ldr	r5, [pc, #84]	; (7424 <usb_serial_flush_input+0x5c>)
	uint32_t tail = rx_tail;
    73d0:	7833      	ldrb	r3, [r6, #0]
	while (tail != rx_head) {
    73d2:	782a      	ldrb	r2, [r5, #0]
    73d4:	4293      	cmp	r3, r2
    73d6:	d021      	beq.n	741c <usb_serial_flush_input+0x54>
    73d8:	b2dc      	uxtb	r4, r3
    73da:	f8df 9050 	ldr.w	r9, [pc, #80]	; 742c <usb_serial_flush_input+0x64>
    73de:	f8df b050 	ldr.w	fp, [pc, #80]	; 7430 <usb_serial_flush_input+0x68>
    73e2:	f8df 8050 	ldr.w	r8, [pc, #80]	; 7434 <usb_serial_flush_input+0x6c>
    73e6:	4f10      	ldr	r7, [pc, #64]	; (7428 <usb_serial_flush_input+0x60>)
		if (++tail > RX_NUM) tail = 0;
    73e8:	3401      	adds	r4, #1
    73ea:	2c08      	cmp	r4, #8
		rx_tail = tail;
    73ec:	fa5f fa84 	uxtb.w	sl, r4
		if (++tail > RX_NUM) tail = 0;
    73f0:	d901      	bls.n	73f6 <usb_serial_flush_input+0x2e>
    73f2:	2400      	movs	r4, #0
    73f4:	46a2      	mov	sl, r4
		uint32_t i = rx_list[tail];
    73f6:	f819 0004 	ldrb.w	r0, [r9, r4]
		rx_available -= rx_count[i] - rx_index[i];
    73fa:	f8db 3000 	ldr.w	r3, [fp]
    73fe:	f838 2010 	ldrh.w	r2, [r8, r0, lsl #1]
    7402:	f837 1010 	ldrh.w	r1, [r7, r0, lsl #1]
    7406:	1a52      	subs	r2, r2, r1
    7408:	1a9b      	subs	r3, r3, r2
    740a:	f8cb 3000 	str.w	r3, [fp]
		rx_queue_transfer(i);
    740e:	f7ff fd17 	bl	6e40 <rx_queue_transfer>
		rx_tail = tail;
    7412:	f886 a000 	strb.w	sl, [r6]
	while (tail != rx_head) {
    7416:	782b      	ldrb	r3, [r5, #0]
    7418:	42a3      	cmp	r3, r4
    741a:	d1e5      	bne.n	73e8 <usb_serial_flush_input+0x20>
}
    741c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7420:	20006aea 	.word	0x20006aea
    7424:	20006ae9 	.word	0x20006ae9
    7428:	20006904 	.word	0x20006904
    742c:	20006914 	.word	0x20006914
    7430:	200068f0 	.word	0x200068f0
    7434:	200068f4 	.word	0x200068f4

00007438 <usb_serial_getchar>:
{
    7438:	b500      	push	{lr}
    743a:	b083      	sub	sp, #12
	if (usb_serial_read(&c, 1)) return c;
    743c:	2101      	movs	r1, #1
    743e:	f10d 0007 	add.w	r0, sp, #7
    7442:	f7ff ff23 	bl	728c <usb_serial_read>
    7446:	b120      	cbz	r0, 7452 <usb_serial_getchar+0x1a>
    7448:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
    744c:	b003      	add	sp, #12
    744e:	f85d fb04 	ldr.w	pc, [sp], #4
	return -1;
    7452:	f04f 30ff 	mov.w	r0, #4294967295
    7456:	e7f9      	b.n	744c <usb_serial_getchar+0x14>

00007458 <usb_serial_putchar>:
	if (!usb_configuration) return 0;
    7458:	4b09      	ldr	r3, [pc, #36]	; (7480 <usb_serial_putchar+0x28>)
{
    745a:	b500      	push	{lr}
    745c:	b083      	sub	sp, #12
	if (!usb_configuration) return 0;
    745e:	781b      	ldrb	r3, [r3, #0]
{
    7460:	f88d 0007 	strb.w	r0, [sp, #7]
	if (!usb_configuration) return 0;
    7464:	b13b      	cbz	r3, 7476 <usb_serial_putchar+0x1e>
    7466:	2101      	movs	r1, #1
    7468:	f10d 0007 	add.w	r0, sp, #7
    746c:	f7ff fdba 	bl	6fe4 <usb_serial_write.part.0>
}
    7470:	b003      	add	sp, #12
    7472:	f85d fb04 	ldr.w	pc, [sp], #4
    7476:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    747a:	b003      	add	sp, #12
    747c:	f85d fb04 	ldr.w	pc, [sp], #4
    7480:	20006af0 	.word	0x20006af0

00007484 <usb_serial_write>:
	if (!usb_configuration) return 0;
    7484:	4b04      	ldr	r3, [pc, #16]	; (7498 <usb_serial_write+0x14>)
    7486:	781b      	ldrb	r3, [r3, #0]
    7488:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    748c:	b10b      	cbz	r3, 7492 <usb_serial_write+0xe>
    748e:	f7ff bda9 	b.w	6fe4 <usb_serial_write.part.0>
}
    7492:	4610      	mov	r0, r2
    7494:	4770      	bx	lr
    7496:	bf00      	nop
    7498:	20006af0 	.word	0x20006af0

0000749c <usb_serial_write_buffer_free>:
{
    749c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (uint32_t i=0; i < TX_NUM; i++) {
    74a0:	2400      	movs	r4, #0
	tx_noautoflush = 1;
    74a2:	f8df 8044 	ldr.w	r8, [pc, #68]	; 74e8 <usb_serial_write_buffer_free+0x4c>
    74a6:	2301      	movs	r3, #1
    74a8:	4d0d      	ldr	r5, [pc, #52]	; (74e0 <usb_serial_write_buffer_free+0x44>)
	uint32_t sum = 0;
    74aa:	4627      	mov	r7, r4
    74ac:	4e0d      	ldr	r6, [pc, #52]	; (74e4 <usb_serial_write_buffer_free+0x48>)
	tx_noautoflush = 1;
    74ae:	f888 3000 	strb.w	r3, [r8]
		if (i == tx_head) continue;
    74b2:	7833      	ldrb	r3, [r6, #0]
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    74b4:	4628      	mov	r0, r5
	for (uint32_t i=0; i < TX_NUM; i++) {
    74b6:	3520      	adds	r5, #32
		if (i == tx_head) continue;
    74b8:	42a3      	cmp	r3, r4
	for (uint32_t i=0; i < TX_NUM; i++) {
    74ba:	f104 0401 	add.w	r4, r4, #1
		if (i == tx_head) continue;
    74be:	d005      	beq.n	74cc <usb_serial_write_buffer_free+0x30>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    74c0:	f7ff fc84 	bl	6dcc <usb_transfer_status>
    74c4:	0603      	lsls	r3, r0, #24
    74c6:	bf58      	it	pl
    74c8:	f507 6700 	addpl.w	r7, r7, #2048	; 0x800
	for (uint32_t i=0; i < TX_NUM; i++) {
    74cc:	2c04      	cmp	r4, #4
    74ce:	d1f0      	bne.n	74b2 <usb_serial_write_buffer_free+0x16>
	asm("dsb" ::: "memory");
    74d0:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    74d4:	2300      	movs	r3, #0
}
    74d6:	4638      	mov	r0, r7
	tx_noautoflush = 0;
    74d8:	f888 3000 	strb.w	r3, [r8]
}
    74dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    74e0:	20001400 	.word	0x20001400
    74e4:	20006aed 	.word	0x20006aed
    74e8:	20006aee 	.word	0x20006aee

000074ec <usb_serial_flush_output>:
{
    74ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!usb_configuration) return;
    74f0:	4b1d      	ldr	r3, [pc, #116]	; (7568 <usb_serial_flush_output+0x7c>)
    74f2:	781b      	ldrb	r3, [r3, #0]
    74f4:	b113      	cbz	r3, 74fc <usb_serial_flush_output+0x10>
	if (tx_available == 0) return;
    74f6:	4d1d      	ldr	r5, [pc, #116]	; (756c <usb_serial_flush_output+0x80>)
    74f8:	882a      	ldrh	r2, [r5, #0]
    74fa:	b90a      	cbnz	r2, 7500 <usb_serial_flush_output+0x14>
}
    74fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	transfer_t *xfer = tx_transfer + tx_head;
    7500:	4e1b      	ldr	r6, [pc, #108]	; (7570 <usb_serial_flush_output+0x84>)
	uint32_t txnum = TX_SIZE - tx_available;
    7502:	f5c2 6900 	rsb	r9, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    7506:	491b      	ldr	r1, [pc, #108]	; (7574 <usb_serial_flush_output+0x88>)
    7508:	7833      	ldrb	r3, [r6, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    750a:	464a      	mov	r2, r9
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    750c:	4c1a      	ldr	r4, [pc, #104]	; (7578 <usb_serial_flush_output+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    750e:	eb01 1843 	add.w	r8, r1, r3, lsl #5
	tx_noautoflush = 1;
    7512:	4f1a      	ldr	r7, [pc, #104]	; (757c <usb_serial_flush_output+0x90>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    7514:	eb04 24c3 	add.w	r4, r4, r3, lsl #11
	tx_noautoflush = 1;
    7518:	2301      	movs	r3, #1
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    751a:	4640      	mov	r0, r8
	tx_noautoflush = 1;
    751c:	703b      	strb	r3, [r7, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    751e:	4621      	mov	r1, r4
    7520:	2300      	movs	r3, #0
    7522:	f7ff fc19 	bl	6d58 <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    7526:	eb04 0209 	add.w	r2, r4, r9
	asm("dsb");
    752a:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    752e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7532:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    7536:	3420      	adds	r4, #32
	} while (location < end_addr);
    7538:	42a2      	cmp	r2, r4
    753a:	d8fa      	bhi.n	7532 <usb_serial_flush_output+0x46>
	asm("dsb");
    753c:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7540:	f3bf 8f6f 	isb	sy
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    7544:	2004      	movs	r0, #4
    7546:	4641      	mov	r1, r8
    7548:	f7ff fc1e 	bl	6d88 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    754c:	7833      	ldrb	r3, [r6, #0]
    754e:	3301      	adds	r3, #1
    7550:	b2db      	uxtb	r3, r3
    7552:	2b03      	cmp	r3, #3
    7554:	bf88      	it	hi
    7556:	2300      	movhi	r3, #0
    7558:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    755a:	2300      	movs	r3, #0
    755c:	802b      	strh	r3, [r5, #0]
	asm("dsb" ::: "memory");
    755e:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    7562:	703b      	strb	r3, [r7, #0]
}
    7564:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7568:	20006af0 	.word	0x20006af0
    756c:	20006ada 	.word	0x20006ada
    7570:	20006aed 	.word	0x20006aed
    7574:	20001400 	.word	0x20001400
    7578:	20201080 	.word	0x20201080
    757c:	20006aee 	.word	0x20006aee

00007580 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    7580:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    7584:	4e32      	ldr	r6, [pc, #200]	; (7650 <yield+0xd0>)
    7586:	7833      	ldrb	r3, [r6, #0]
    7588:	b163      	cbz	r3, 75a4 <yield+0x24>
	if (running) return; // TODO: does this need to be atomic?
    758a:	4f32      	ldr	r7, [pc, #200]	; (7654 <yield+0xd4>)
    758c:	783a      	ldrb	r2, [r7, #0]
    758e:	b94a      	cbnz	r2, 75a4 <yield+0x24>
	running = 1;
    7590:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    7592:	07d9      	lsls	r1, r3, #31
	running = 1;
    7594:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    7596:	d444      	bmi.n	7622 <yield+0xa2>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    7598:	079a      	lsls	r2, r3, #30
    759a:	d426      	bmi.n	75ea <yield+0x6a>

	running = 0;
    759c:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    759e:	075b      	lsls	r3, r3, #29
	running = 0;
    75a0:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    75a2:	d401      	bmi.n	75a8 <yield+0x28>
	
};
    75a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (!firstYield) return;  
    75a8:	4b2b      	ldr	r3, [pc, #172]	; (7658 <yield+0xd8>)
    75aa:	681a      	ldr	r2, [r3, #0]
    75ac:	2a00      	cmp	r2, #0
    75ae:	d0f9      	beq.n	75a4 <yield+0x24>
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    75b0:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    75b4:	2a00      	cmp	r2, #0
    75b6:	d1f5      	bne.n	75a4 <yield+0x24>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    75b8:	f3ef 8510 	mrs	r5, PRIMASK
		__disable_irq();
    75bc:	b672      	cpsid	i
		EventResponder *first = firstYield;
    75be:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    75c0:	2800      	cmp	r0, #0
    75c2:	d03b      	beq.n	763c <yield+0xbc>
		if (runningFromYield) {
    75c4:	4c25      	ldr	r4, [pc, #148]	; (765c <yield+0xdc>)
    75c6:	7821      	ldrb	r1, [r4, #0]
    75c8:	2900      	cmp	r1, #0
    75ca:	d137      	bne.n	763c <yield+0xbc>
		runningFromYield = true;
    75cc:	2201      	movs	r2, #1
    75ce:	7022      	strb	r2, [r4, #0]
		firstYield = first->_next;
    75d0:	6942      	ldr	r2, [r0, #20]
    75d2:	601a      	str	r2, [r3, #0]
		if (firstYield) {
    75d4:	2a00      	cmp	r2, #0
    75d6:	d038      	beq.n	764a <yield+0xca>
			firstYield->_prev = nullptr;
    75d8:	6191      	str	r1, [r2, #24]
		if (doit) __enable_irq();
    75da:	b905      	cbnz	r5, 75de <yield+0x5e>
    75dc:	b662      	cpsie	i
		first->_triggered = false;
    75de:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    75e0:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
    75e2:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    75e4:	4798      	blx	r3
		runningFromYield = false;
    75e6:	7025      	strb	r5, [r4, #0]
    75e8:	e7dc      	b.n	75a4 <yield+0x24>
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    75ea:	f8df 807c 	ldr.w	r8, [pc, #124]	; 7668 <yield+0xe8>
    75ee:	f898 2000 	ldrb.w	r2, [r8]
    75f2:	2a00      	cmp	r2, #0
    75f4:	d0d2      	beq.n	759c <yield+0x1c>
    75f6:	2500      	movs	r5, #0
    75f8:	f8df 9070 	ldr.w	r9, [pc, #112]	; 766c <yield+0xec>
    75fc:	462b      	mov	r3, r5
			s_serials_with_serial_events[i]->doYieldCode();
    75fe:	f859 4023 	ldr.w	r4, [r9, r3, lsl #2]
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7602:	3501      	adds	r5, #1
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    7604:	6823      	ldr	r3, [r4, #0]
    7606:	4620      	mov	r0, r4
    7608:	691b      	ldr	r3, [r3, #16]
    760a:	4798      	blx	r3
    760c:	b110      	cbz	r0, 7614 <yield+0x94>
    760e:	6963      	ldr	r3, [r4, #20]
    7610:	689b      	ldr	r3, [r3, #8]
    7612:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7614:	f898 2000 	ldrb.w	r2, [r8]
    7618:	b2eb      	uxtb	r3, r5
    761a:	429a      	cmp	r2, r3
    761c:	d8ef      	bhi.n	75fe <yield+0x7e>
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    761e:	7833      	ldrb	r3, [r6, #0]
    7620:	e7bc      	b.n	759c <yield+0x1c>
        virtual int available() { return usb_serial_available(); }
    7622:	f7ff fec5 	bl	73b0 <usb_serial_available>
		if (Serial.available()) serialEvent();
    7626:	b968      	cbnz	r0, 7644 <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    7628:	4b0d      	ldr	r3, [pc, #52]	; (7660 <yield+0xe0>)
    762a:	781b      	ldrb	r3, [r3, #0]
    762c:	b90b      	cbnz	r3, 7632 <yield+0xb2>
    762e:	7833      	ldrb	r3, [r6, #0]
    7630:	e7b2      	b.n	7598 <yield+0x18>
    7632:	7833      	ldrb	r3, [r6, #0]
    7634:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    7638:	7033      	strb	r3, [r6, #0]
    763a:	e7ad      	b.n	7598 <yield+0x18>
		if (doit) __enable_irq();
    763c:	2d00      	cmp	r5, #0
    763e:	d1b1      	bne.n	75a4 <yield+0x24>
    7640:	b662      	cpsie	i
    7642:	e7af      	b.n	75a4 <yield+0x24>
		if (Serial.available()) serialEvent();
    7644:	f000 f99e 	bl	7984 <serialEvent()>
    7648:	e7ee      	b.n	7628 <yield+0xa8>
			lastYield = nullptr;
    764a:	4b06      	ldr	r3, [pc, #24]	; (7664 <yield+0xe4>)
    764c:	601a      	str	r2, [r3, #0]
    764e:	e7c4      	b.n	75da <yield+0x5a>
    7650:	20000d47 	.word	0x20000d47
    7654:	20006ae0 	.word	0x20006ae0
    7658:	20006878 	.word	0x20006878
    765c:	20006ade 	.word	0x20006ade
    7660:	60001ade 	.word	0x60001ade
    7664:	20006884 	.word	0x20006884
    7668:	20006adf 	.word	0x20006adf
    766c:	20006888 	.word	0x20006888

00007670 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    7670:	49a2      	ldr	r1, [pc, #648]	; (78fc <set_arm_clock+0x28c>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    7672:	4ba3      	ldr	r3, [pc, #652]	; (7900 <set_arm_clock+0x290>)
	if (frequency > 528000000) {
    7674:	4288      	cmp	r0, r1
{
    7676:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t dcdc = DCDC_REG3;
    767a:	4ca2      	ldr	r4, [pc, #648]	; (7904 <set_arm_clock+0x294>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    767c:	695e      	ldr	r6, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    767e:	699a      	ldr	r2, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    7680:	f8d4 800c 	ldr.w	r8, [r4, #12]
	if (frequency > 528000000) {
    7684:	d91b      	bls.n	76be <set_arm_clock+0x4e>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    7686:	4ba0      	ldr	r3, [pc, #640]	; (7908 <set_arm_clock+0x298>)
    7688:	4298      	cmp	r0, r3
    768a:	f240 8102 	bls.w	7892 <set_arm_clock+0x222>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    768e:	1ac3      	subs	r3, r0, r3
    7690:	499e      	ldr	r1, [pc, #632]	; (790c <set_arm_clock+0x29c>)
    7692:	0a1b      	lsrs	r3, r3, #8
    7694:	fba1 1303 	umull	r1, r3, r1, r3
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    7698:	f240 6127 	movw	r1, #1575	; 0x627
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    769c:	09db      	lsrs	r3, r3, #7
    769e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    76a2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    76a6:	f203 43e2 	addw	r3, r3, #1250	; 0x4e2
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76aa:	428b      	cmp	r3, r1
    76ac:	bf28      	it	cs
    76ae:	460b      	movcs	r3, r1
    76b0:	f5a3 7748 	sub.w	r7, r3, #800	; 0x320
    76b4:	4b96      	ldr	r3, [pc, #600]	; (7910 <set_arm_clock+0x2a0>)
    76b6:	fba3 3707 	umull	r3, r7, r3, r7
    76ba:	08ff      	lsrs	r7, r7, #3
    76bc:	e004      	b.n	76c8 <set_arm_clock+0x58>
	} else if (frequency <= 24000000) {
    76be:	4f95      	ldr	r7, [pc, #596]	; (7914 <set_arm_clock+0x2a4>)
    76c0:	42b8      	cmp	r0, r7
    76c2:	bf8c      	ite	hi
    76c4:	270e      	movhi	r7, #14
    76c6:	2706      	movls	r7, #6
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    76c8:	498d      	ldr	r1, [pc, #564]	; (7900 <set_arm_clock+0x290>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76ca:	f008 091f 	and.w	r9, r8, #31
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    76ce:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76d2:	45b9      	cmp	r9, r7
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    76d4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    76d8:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76dc:	d20c      	bcs.n	76f8 <set_arm_clock+0x88>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    76de:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    76e2:	f5a1 21f8 	sub.w	r1, r1, #507904	; 0x7c000
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    76e6:	ea48 0807 	orr.w	r8, r8, r7
		DCDC_REG3 = dcdc;
    76ea:	f8c1 800c 	str.w	r8, [r1, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    76ee:	680b      	ldr	r3, [r1, #0]
    76f0:	2b00      	cmp	r3, #0
    76f2:	dafc      	bge.n	76ee <set_arm_clock+0x7e>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    76f4:	f008 091f 	and.w	r9, r8, #31
	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    76f8:	f016 7300 	ands.w	r3, r6, #33554432	; 0x2000000
    76fc:	d124      	bne.n	7748 <set_arm_clock+0xd8>
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    76fe:	4986      	ldr	r1, [pc, #536]	; (7918 <set_arm_clock+0x2a8>)
    7700:	690c      	ldr	r4, [r1, #16]
    7702:	4986      	ldr	r1, [pc, #536]	; (791c <set_arm_clock+0x2ac>)
    7704:	43a1      	bics	r1, r4
    7706:	f000 80ea 	beq.w	78de <set_arm_clock+0x26e>
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    770a:	f482 5180 	eor.w	r1, r2, #4096	; 0x1000
    770e:	4634      	mov	r4, r6
    7710:	f44f 5580 	mov.w	r5, #4096	; 0x1000
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    7714:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    7718:	d004      	beq.n	7724 <set_arm_clock+0xb4>
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    771a:	f026 5660 	bic.w	r6, r6, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    771e:	431e      	orrs	r6, r3
			CCM_CBCDR = cbcdr;
    7720:	4b77      	ldr	r3, [pc, #476]	; (7900 <set_arm_clock+0x290>)
    7722:	615e      	str	r6, [r3, #20]
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    7724:	f411 5f40 	tst.w	r1, #12288	; 0x3000
    7728:	d007      	beq.n	773a <set_arm_clock+0xca>
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    772a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
			CCM_CBCMR = cbcmr;
    772e:	4974      	ldr	r1, [pc, #464]	; (7900 <set_arm_clock+0x290>)
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    7730:	432a      	orrs	r2, r5
			CCM_CBCMR = cbcmr;
    7732:	618a      	str	r2, [r1, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    7734:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    7736:	071a      	lsls	r2, r3, #28
    7738:	d4fc      	bmi.n	7734 <set_arm_clock+0xc4>
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    773a:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    773e:	4a70      	ldr	r2, [pc, #448]	; (7900 <set_arm_clock+0x290>)
    7740:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    7742:	6c93      	ldr	r3, [r2, #72]	; 0x48
    7744:	069b      	lsls	r3, r3, #26
    7746:	d4fc      	bmi.n	7742 <set_arm_clock+0xd2>
	while (frequency * div_arm * div_ahb < 648000000) {
    7748:	4c75      	ldr	r4, [pc, #468]	; (7920 <set_arm_clock+0x2b0>)
    774a:	42a0      	cmp	r0, r4
    774c:	f200 80ce 	bhi.w	78ec <set_arm_clock+0x27c>
	uint32_t div_ahb = 1;
    7750:	f04f 0c01 	mov.w	ip, #1
    7754:	4601      	mov	r1, r0
	uint32_t div_arm = 1;
    7756:	4663      	mov	r3, ip
	while (frequency * div_arm * div_ahb < 648000000) {
    7758:	fb03 1201 	mla	r2, r3, r1, r1
			div_arm = div_arm + 1;
    775c:	f103 0e01 	add.w	lr, r3, #1
				div_ahb = div_ahb + 1;
    7760:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    7764:	42a2      	cmp	r2, r4
    7766:	d818      	bhi.n	779a <set_arm_clock+0x12a>
		if (div_arm < 8) {
    7768:	f1be 0f08 	cmp.w	lr, #8
				div_arm = 1;
    776c:	f04f 0301 	mov.w	r3, #1
		if (div_arm < 8) {
    7770:	f040 808d 	bne.w	788e <set_arm_clock+0x21e>
			if (div_ahb < 5) {
    7774:	f1bc 0f04 	cmp.w	ip, #4
    7778:	f200 8091 	bhi.w	789e <set_arm_clock+0x22e>
	while (frequency * div_arm * div_ahb < 648000000) {
    777c:	180a      	adds	r2, r1, r0
    777e:	42a2      	cmp	r2, r4
    7780:	f200 80a4 	bhi.w	78cc <set_arm_clock+0x25c>
    7784:	fb05 f100 	mul.w	r1, r5, r0
				div_ahb = div_ahb + 1;
    7788:	46ac      	mov	ip, r5
			div_arm = div_arm + 1;
    778a:	f103 0e01 	add.w	lr, r3, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    778e:	fb03 1201 	mla	r2, r3, r1, r1
				div_ahb = div_ahb + 1;
    7792:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    7796:	42a2      	cmp	r2, r4
    7798:	d9e6      	bls.n	7768 <set_arm_clock+0xf8>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    779a:	f10c 31ff 	add.w	r1, ip, #4294967295
    779e:	028c      	lsls	r4, r1, #10
    77a0:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    77a4:	485f      	ldr	r0, [pc, #380]	; (7924 <set_arm_clock+0x2b4>)
    77a6:	4410      	add	r0, r2
	if (mult > 108) mult = 108;
    77a8:	4a5f      	ldr	r2, [pc, #380]	; (7928 <set_arm_clock+0x2b8>)
    77aa:	4290      	cmp	r0, r2
    77ac:	d97f      	bls.n	78ae <set_arm_clock+0x23e>
    77ae:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 7954 <set_arm_clock+0x2e4>
    77b2:	226c      	movs	r2, #108	; 0x6c
    77b4:	485d      	ldr	r0, [pc, #372]	; (792c <set_arm_clock+0x2bc>)
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    77b6:	4d58      	ldr	r5, [pc, #352]	; (7918 <set_arm_clock+0x2a8>)
	frequency = mult * 12000000 / div_arm / div_ahb;
    77b8:	fbb0 f0fe 	udiv	r0, r0, lr
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    77bc:	f8d5 e000 	ldr.w	lr, [r5]
	frequency = mult * 12000000 / div_arm / div_ahb;
    77c0:	fbb0 f0fc 	udiv	r0, r0, ip
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    77c4:	f8df c190 	ldr.w	ip, [pc, #400]	; 7958 <set_arm_clock+0x2e8>
    77c8:	ea0e 0c0c 	and.w	ip, lr, ip
    77cc:	45d4      	cmp	ip, sl
    77ce:	d009      	beq.n	77e4 <set_arm_clock+0x174>
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    77d0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    77d4:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    77d8:	f8c5 c000 	str.w	ip, [r5]
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    77dc:	602a      	str	r2, [r5, #0]
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    77de:	682a      	ldr	r2, [r5, #0]
    77e0:	2a00      	cmp	r2, #0
    77e2:	dafc      	bge.n	77de <set_arm_clock+0x16e>
	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    77e4:	4a46      	ldr	r2, [pc, #280]	; (7900 <set_arm_clock+0x290>)
    77e6:	6915      	ldr	r5, [r2, #16]
    77e8:	f005 0507 	and.w	r5, r5, #7
    77ec:	429d      	cmp	r5, r3
    77ee:	d003      	beq.n	77f8 <set_arm_clock+0x188>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    77f0:	6113      	str	r3, [r2, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    77f2:	6c93      	ldr	r3, [r2, #72]	; 0x48
    77f4:	03dd      	lsls	r5, r3, #15
    77f6:	d4fc      	bmi.n	77f2 <set_arm_clock+0x182>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    77f8:	f411 5fe0 	tst.w	r1, #7168	; 0x1c00
    77fc:	d009      	beq.n	7812 <set_arm_clock+0x1a2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    77fe:	f426 56e0 	bic.w	r6, r6, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    7802:	f404 54e0 	and.w	r4, r4, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
    7806:	4a3e      	ldr	r2, [pc, #248]	; (7900 <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    7808:	4326      	orrs	r6, r4
		CCM_CBCDR = cbcdr;
    780a:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    780c:	6c93      	ldr	r3, [r2, #72]	; 0x48
    780e:	0799      	lsls	r1, r3, #30
    7810:	d4fc      	bmi.n	780c <set_arm_clock+0x19c>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    7812:	4947      	ldr	r1, [pc, #284]	; (7930 <set_arm_clock+0x2c0>)
	if (div_ipg > 4) div_ipg = 4;
    7814:	4a47      	ldr	r2, [pc, #284]	; (7934 <set_arm_clock+0x2c4>)
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    7816:	4401      	add	r1, r0
	if (div_ipg > 4) div_ipg = 4;
    7818:	4291      	cmp	r1, r2
    781a:	d83c      	bhi.n	7896 <set_arm_clock+0x226>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    781c:	4b46      	ldr	r3, [pc, #280]	; (7938 <set_arm_clock+0x2c8>)
    781e:	09c9      	lsrs	r1, r1, #7
    7820:	fba3 3101 	umull	r3, r1, r3, r1
    7824:	0b09      	lsrs	r1, r1, #12
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    7826:	1e4b      	subs	r3, r1, #1
    7828:	021b      	lsls	r3, r3, #8
    782a:	ea86 0203 	eor.w	r2, r6, r3
    782e:	f412 7f40 	tst.w	r2, #768	; 0x300
    7832:	d006      	beq.n	7842 <set_arm_clock+0x1d2>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    7834:	f426 7640 	bic.w	r6, r6, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    7838:	f403 7340 	and.w	r3, r3, #768	; 0x300
		CCM_CBCDR = cbcdr;
    783c:	4a30      	ldr	r2, [pc, #192]	; (7900 <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    783e:	4333      	orrs	r3, r6
		CCM_CBCDR = cbcdr;
    7840:	6153      	str	r3, [r2, #20]
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    7842:	4a2f      	ldr	r2, [pc, #188]	; (7900 <set_arm_clock+0x290>)
    7844:	6953      	ldr	r3, [r2, #20]
    7846:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
    784a:	6153      	str	r3, [r2, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    784c:	6c93      	ldr	r3, [r2, #72]	; 0x48
    784e:	069b      	lsls	r3, r3, #26
    7850:	d4fc      	bmi.n	784c <set_arm_clock+0x1dc>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    7852:	4b3a      	ldr	r3, [pc, #232]	; (793c <set_arm_clock+0x2cc>)
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    7854:	454f      	cmp	r7, r9
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    7856:	fba3 2300 	umull	r2, r3, r3, r0
    785a:	f04f 32ff 	mov.w	r2, #4294967295
    785e:	ea4f 4393 	mov.w	r3, r3, lsr #18
	F_BUS_ACTUAL = frequency / div_ipg;
    7862:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    7866:	fbb2 f3f3 	udiv	r3, r2, r3
	F_CPU_ACTUAL = frequency;
    786a:	4a35      	ldr	r2, [pc, #212]	; (7940 <set_arm_clock+0x2d0>)
    786c:	6010      	str	r0, [r2, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
    786e:	4a35      	ldr	r2, [pc, #212]	; (7944 <set_arm_clock+0x2d4>)
    7870:	6011      	str	r1, [r2, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    7872:	4a35      	ldr	r2, [pc, #212]	; (7948 <set_arm_clock+0x2d8>)
    7874:	6013      	str	r3, [r2, #0]
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    7876:	d208      	bcs.n	788a <set_arm_clock+0x21a>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    7878:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    787c:	4a21      	ldr	r2, [pc, #132]	; (7904 <set_arm_clock+0x294>)
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    787e:	ea48 0707 	orr.w	r7, r8, r7
		DCDC_REG3 = dcdc;
    7882:	60d7      	str	r7, [r2, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    7884:	6813      	ldr	r3, [r2, #0]
    7886:	2b00      	cmp	r3, #0
    7888:	dafc      	bge.n	7884 <set_arm_clock+0x214>
	}

	return frequency;
}
    788a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    788e:	4673      	mov	r3, lr
    7890:	e762      	b.n	7758 <set_arm_clock+0xe8>
    7892:	2712      	movs	r7, #18
    7894:	e718      	b.n	76c8 <set_arm_clock+0x58>
    7896:	f44f 7340 	mov.w	r3, #768	; 0x300
	if (div_ipg > 4) div_ipg = 4;
    789a:	2104      	movs	r1, #4
    789c:	e7c5      	b.n	782a <set_arm_clock+0x1ba>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    789e:	f10c 31ff 	add.w	r1, ip, #4294967295
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78a2:	4820      	ldr	r0, [pc, #128]	; (7924 <set_arm_clock+0x2b4>)
    78a4:	2307      	movs	r3, #7
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78a6:	028c      	lsls	r4, r1, #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78a8:	4410      	add	r0, r2
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78aa:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78ae:	4a27      	ldr	r2, [pc, #156]	; (794c <set_arm_clock+0x2dc>)
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    78b0:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 795c <set_arm_clock+0x2ec>
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78b4:	fba2 2000 	umull	r2, r0, r2, r0
    78b8:	0d02      	lsrs	r2, r0, #20
	frequency = mult * 12000000 / div_arm / div_ahb;
    78ba:	4825      	ldr	r0, [pc, #148]	; (7950 <set_arm_clock+0x2e0>)
    78bc:	2a36      	cmp	r2, #54	; 0x36
    78be:	bf38      	it	cc
    78c0:	2236      	movcc	r2, #54	; 0x36
    78c2:	fb02 f000 	mul.w	r0, r2, r0
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    78c6:	ea42 0a0a 	orr.w	sl, r2, sl
    78ca:	e774      	b.n	77b6 <set_arm_clock+0x146>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78cc:	ea4f 248c 	mov.w	r4, ip, lsl #10
    78d0:	2300      	movs	r3, #0
    78d2:	ea86 218c 	eor.w	r1, r6, ip, lsl #10
				div_arm = 1;
    78d6:	f04f 0e01 	mov.w	lr, #1
				div_ahb = div_ahb + 1;
    78da:	46ac      	mov	ip, r5
    78dc:	e762      	b.n	77a4 <set_arm_clock+0x134>
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    78de:	461d      	mov	r5, r3
    78e0:	f086 54c0 	eor.w	r4, r6, #402653184	; 0x18000000
    78e4:	4611      	mov	r1, r2
    78e6:	f04f 53c0 	mov.w	r3, #402653184	; 0x18000000
    78ea:	e713      	b.n	7714 <set_arm_clock+0xa4>
	while (frequency * div_arm * div_ahb < 648000000) {
    78ec:	2400      	movs	r4, #0
	uint32_t div_ahb = 1;
    78ee:	f04f 0c01 	mov.w	ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    78f2:	4602      	mov	r2, r0
    78f4:	4631      	mov	r1, r6
    78f6:	4623      	mov	r3, r4
	uint32_t div_arm = 1;
    78f8:	46e6      	mov	lr, ip
    78fa:	e753      	b.n	77a4 <set_arm_clock+0x134>
    78fc:	1f78a400 	.word	0x1f78a400
    7900:	400fc000 	.word	0x400fc000
    7904:	40080000 	.word	0x40080000
    7908:	23c34600 	.word	0x23c34600
    790c:	004cb223 	.word	0x004cb223
    7910:	51eb851f 	.word	0x51eb851f
    7914:	016e3600 	.word	0x016e3600
    7918:	400d8000 	.word	0x400d8000
    791c:	80003040 	.word	0x80003040
    7920:	269fb1ff 	.word	0x269fb1ff
    7924:	005b8d80 	.word	0x005b8d80
    7928:	4df67eff 	.word	0x4df67eff
    792c:	4d3f6400 	.word	0x4d3f6400
    7930:	08f0d17f 	.word	0x08f0d17f
    7934:	2cb4177f 	.word	0x2cb4177f
    7938:	00e5109f 	.word	0x00e5109f
    793c:	431bde83 	.word	0x431bde83
    7940:	20000a64 	.word	0x20000a64
    7944:	20000a60 	.word	0x20000a60
    7948:	20006930 	.word	0x20006930
    794c:	165e9f81 	.word	0x165e9f81
    7950:	00b71b00 	.word	0x00b71b00
    7954:	8000206c 	.word	0x8000206c
    7958:	8001307f 	.word	0x8001307f
    795c:	80002000 	.word	0x80002000

00007960 <rtc_get>:
	uint32_t hi1 = SNVS_HPRTCMR;
    7960:	4a07      	ldr	r2, [pc, #28]	; (7980 <rtc_get+0x20>)
    7962:	6a50      	ldr	r0, [r2, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
    7964:	6a93      	ldr	r3, [r2, #40]	; 0x28
		uint32_t hi2 = SNVS_HPRTCMR;
    7966:	4619      	mov	r1, r3
    7968:	4684      	mov	ip, r0
    796a:	6a50      	ldr	r0, [r2, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    796c:	6a93      	ldr	r3, [r2, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    796e:	4299      	cmp	r1, r3
    7970:	d1f9      	bne.n	7966 <rtc_get+0x6>
    7972:	4584      	cmp	ip, r0
    7974:	d1f7      	bne.n	7966 <rtc_get+0x6>
			return (hi2 << 17) | (lo2 >> 15);
    7976:	0bdb      	lsrs	r3, r3, #15
}
    7978:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
    797c:	4770      	bx	lr
    797e:	bf00      	nop
    7980:	400d4000 	.word	0x400d4000

00007984 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
}
    7984:	4770      	bx	lr
    7986:	bf00      	nop

00007988 <memmove>:
    7988:	4288      	cmp	r0, r1
    798a:	d90d      	bls.n	79a8 <memmove+0x20>
    798c:	188b      	adds	r3, r1, r2
    798e:	4283      	cmp	r3, r0
    7990:	d90a      	bls.n	79a8 <memmove+0x20>
    7992:	eb00 0c02 	add.w	ip, r0, r2
    7996:	b1ba      	cbz	r2, 79c8 <memmove+0x40>
    7998:	4662      	mov	r2, ip
    799a:	f813 cd01 	ldrb.w	ip, [r3, #-1]!
    799e:	f802 cd01 	strb.w	ip, [r2, #-1]!
    79a2:	4299      	cmp	r1, r3
    79a4:	d1f9      	bne.n	799a <memmove+0x12>
    79a6:	4770      	bx	lr
    79a8:	2a0f      	cmp	r2, #15
    79aa:	d80e      	bhi.n	79ca <memmove+0x42>
    79ac:	4603      	mov	r3, r0
    79ae:	f102 3cff 	add.w	ip, r2, #4294967295
    79b2:	b14a      	cbz	r2, 79c8 <memmove+0x40>
    79b4:	f10c 0c01 	add.w	ip, ip, #1
    79b8:	3b01      	subs	r3, #1
    79ba:	448c      	add	ip, r1
    79bc:	f811 2b01 	ldrb.w	r2, [r1], #1
    79c0:	f803 2f01 	strb.w	r2, [r3, #1]!
    79c4:	4561      	cmp	r1, ip
    79c6:	d1f9      	bne.n	79bc <memmove+0x34>
    79c8:	4770      	bx	lr
    79ca:	ea40 0301 	orr.w	r3, r0, r1
    79ce:	079b      	lsls	r3, r3, #30
    79d0:	d150      	bne.n	7a74 <memmove+0xec>
    79d2:	f1a2 0310 	sub.w	r3, r2, #16
    79d6:	b570      	push	{r4, r5, r6, lr}
    79d8:	f101 0c20 	add.w	ip, r1, #32
    79dc:	f023 050f 	bic.w	r5, r3, #15
    79e0:	f101 0e10 	add.w	lr, r1, #16
    79e4:	f100 0410 	add.w	r4, r0, #16
    79e8:	44ac      	add	ip, r5
    79ea:	091b      	lsrs	r3, r3, #4
    79ec:	f85e 5c10 	ldr.w	r5, [lr, #-16]
    79f0:	f844 5c10 	str.w	r5, [r4, #-16]
    79f4:	f85e 5c0c 	ldr.w	r5, [lr, #-12]
    79f8:	f844 5c0c 	str.w	r5, [r4, #-12]
    79fc:	f85e 5c08 	ldr.w	r5, [lr, #-8]
    7a00:	f844 5c08 	str.w	r5, [r4, #-8]
    7a04:	f85e 5c04 	ldr.w	r5, [lr, #-4]
    7a08:	f844 5c04 	str.w	r5, [r4, #-4]
    7a0c:	f10e 0e10 	add.w	lr, lr, #16
    7a10:	45e6      	cmp	lr, ip
    7a12:	f104 0410 	add.w	r4, r4, #16
    7a16:	d1e9      	bne.n	79ec <memmove+0x64>
    7a18:	3301      	adds	r3, #1
    7a1a:	f012 0f0c 	tst.w	r2, #12
    7a1e:	eb01 1103 	add.w	r1, r1, r3, lsl #4
    7a22:	f002 040f 	and.w	r4, r2, #15
    7a26:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    7a2a:	d027      	beq.n	7a7c <memmove+0xf4>
    7a2c:	3c04      	subs	r4, #4
    7a2e:	f024 0603 	bic.w	r6, r4, #3
    7a32:	ea4f 0c94 	mov.w	ip, r4, lsr #2
    7a36:	441e      	add	r6, r3
    7a38:	1f1c      	subs	r4, r3, #4
    7a3a:	468e      	mov	lr, r1
    7a3c:	f85e 5b04 	ldr.w	r5, [lr], #4
    7a40:	f844 5f04 	str.w	r5, [r4, #4]!
    7a44:	42b4      	cmp	r4, r6
    7a46:	d1f9      	bne.n	7a3c <memmove+0xb4>
    7a48:	f10c 0401 	add.w	r4, ip, #1
    7a4c:	f002 0203 	and.w	r2, r2, #3
    7a50:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    7a54:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    7a58:	f102 3cff 	add.w	ip, r2, #4294967295
    7a5c:	b14a      	cbz	r2, 7a72 <memmove+0xea>
    7a5e:	f10c 0c01 	add.w	ip, ip, #1
    7a62:	3b01      	subs	r3, #1
    7a64:	448c      	add	ip, r1
    7a66:	f811 2b01 	ldrb.w	r2, [r1], #1
    7a6a:	f803 2f01 	strb.w	r2, [r3, #1]!
    7a6e:	4561      	cmp	r1, ip
    7a70:	d1f9      	bne.n	7a66 <memmove+0xde>
    7a72:	bd70      	pop	{r4, r5, r6, pc}
    7a74:	f102 3cff 	add.w	ip, r2, #4294967295
    7a78:	4603      	mov	r3, r0
    7a7a:	e79b      	b.n	79b4 <memmove+0x2c>
    7a7c:	4622      	mov	r2, r4
    7a7e:	e7eb      	b.n	7a58 <memmove+0xd0>

00007a80 <memset>:
    7a80:	0783      	lsls	r3, r0, #30
    7a82:	b530      	push	{r4, r5, lr}
    7a84:	d048      	beq.n	7b18 <memset+0x98>
    7a86:	1e54      	subs	r4, r2, #1
    7a88:	2a00      	cmp	r2, #0
    7a8a:	d03f      	beq.n	7b0c <memset+0x8c>
    7a8c:	b2ca      	uxtb	r2, r1
    7a8e:	4603      	mov	r3, r0
    7a90:	e001      	b.n	7a96 <memset+0x16>
    7a92:	3c01      	subs	r4, #1
    7a94:	d33a      	bcc.n	7b0c <memset+0x8c>
    7a96:	f803 2b01 	strb.w	r2, [r3], #1
    7a9a:	079d      	lsls	r5, r3, #30
    7a9c:	d1f9      	bne.n	7a92 <memset+0x12>
    7a9e:	2c03      	cmp	r4, #3
    7aa0:	d92d      	bls.n	7afe <memset+0x7e>
    7aa2:	b2cd      	uxtb	r5, r1
    7aa4:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    7aa8:	2c0f      	cmp	r4, #15
    7aaa:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    7aae:	d936      	bls.n	7b1e <memset+0x9e>
    7ab0:	f1a4 0210 	sub.w	r2, r4, #16
    7ab4:	f022 0c0f 	bic.w	ip, r2, #15
    7ab8:	f103 0e20 	add.w	lr, r3, #32
    7abc:	44e6      	add	lr, ip
    7abe:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    7ac2:	f103 0210 	add.w	r2, r3, #16
    7ac6:	e942 5504 	strd	r5, r5, [r2, #-16]
    7aca:	e942 5502 	strd	r5, r5, [r2, #-8]
    7ace:	3210      	adds	r2, #16
    7ad0:	4572      	cmp	r2, lr
    7ad2:	d1f8      	bne.n	7ac6 <memset+0x46>
    7ad4:	f10c 0201 	add.w	r2, ip, #1
    7ad8:	f014 0f0c 	tst.w	r4, #12
    7adc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    7ae0:	f004 0c0f 	and.w	ip, r4, #15
    7ae4:	d013      	beq.n	7b0e <memset+0x8e>
    7ae6:	f1ac 0304 	sub.w	r3, ip, #4
    7aea:	f023 0303 	bic.w	r3, r3, #3
    7aee:	3304      	adds	r3, #4
    7af0:	4413      	add	r3, r2
    7af2:	f842 5b04 	str.w	r5, [r2], #4
    7af6:	4293      	cmp	r3, r2
    7af8:	d1fb      	bne.n	7af2 <memset+0x72>
    7afa:	f00c 0403 	and.w	r4, ip, #3
    7afe:	b12c      	cbz	r4, 7b0c <memset+0x8c>
    7b00:	b2c9      	uxtb	r1, r1
    7b02:	441c      	add	r4, r3
    7b04:	f803 1b01 	strb.w	r1, [r3], #1
    7b08:	429c      	cmp	r4, r3
    7b0a:	d1fb      	bne.n	7b04 <memset+0x84>
    7b0c:	bd30      	pop	{r4, r5, pc}
    7b0e:	4664      	mov	r4, ip
    7b10:	4613      	mov	r3, r2
    7b12:	2c00      	cmp	r4, #0
    7b14:	d1f4      	bne.n	7b00 <memset+0x80>
    7b16:	e7f9      	b.n	7b0c <memset+0x8c>
    7b18:	4603      	mov	r3, r0
    7b1a:	4614      	mov	r4, r2
    7b1c:	e7bf      	b.n	7a9e <memset+0x1e>
    7b1e:	461a      	mov	r2, r3
    7b20:	46a4      	mov	ip, r4
    7b22:	e7e0      	b.n	7ae6 <memset+0x66>

00007b24 <__libc_init_array>:
    7b24:	b570      	push	{r4, r5, r6, lr}
    7b26:	4e0d      	ldr	r6, [pc, #52]	; (7b5c <__libc_init_array+0x38>)
    7b28:	4d0d      	ldr	r5, [pc, #52]	; (7b60 <__libc_init_array+0x3c>)
    7b2a:	1b76      	subs	r6, r6, r5
    7b2c:	10b6      	asrs	r6, r6, #2
    7b2e:	d006      	beq.n	7b3e <__libc_init_array+0x1a>
    7b30:	2400      	movs	r4, #0
    7b32:	f855 3b04 	ldr.w	r3, [r5], #4
    7b36:	3401      	adds	r4, #1
    7b38:	4798      	blx	r3
    7b3a:	42a6      	cmp	r6, r4
    7b3c:	d1f9      	bne.n	7b32 <__libc_init_array+0xe>
    7b3e:	4e09      	ldr	r6, [pc, #36]	; (7b64 <__libc_init_array+0x40>)
    7b40:	4d09      	ldr	r5, [pc, #36]	; (7b68 <__libc_init_array+0x44>)
    7b42:	1b76      	subs	r6, r6, r5
    7b44:	f000 f814 	bl	7b70 <___init_veneer>
    7b48:	10b6      	asrs	r6, r6, #2
    7b4a:	d006      	beq.n	7b5a <__libc_init_array+0x36>
    7b4c:	2400      	movs	r4, #0
    7b4e:	f855 3b04 	ldr.w	r3, [r5], #4
    7b52:	3401      	adds	r4, #1
    7b54:	4798      	blx	r3
    7b56:	42a6      	cmp	r6, r4
    7b58:	d1f9      	bne.n	7b4e <__libc_init_array+0x2a>
    7b5a:	bd70      	pop	{r4, r5, r6, pc}
    7b5c:	60001ab8 	.word	0x60001ab8
    7b60:	60001ab8 	.word	0x60001ab8
    7b64:	60001adc 	.word	0x60001adc
    7b68:	60001ab8 	.word	0x60001ab8
    7b6c:	00000000 	.word	0x00000000

00007b70 <___init_veneer>:
    7b70:	f85f f000 	ldr.w	pc, [pc]	; 7b74 <___init_veneer+0x4>
    7b74:	60001a75 	.word	0x60001a75

00007b78 <___reboot_Teensyduino__veneer>:
    7b78:	f85f f000 	ldr.w	pc, [pc]	; 7b7c <___reboot_Teensyduino__veneer+0x4>
    7b7c:	600019cd 	.word	0x600019cd

Disassembly of section .fini:

00007b80 <_fini>:
    7b80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7b82:	bf00      	nop
