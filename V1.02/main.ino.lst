
C:\Users\Adam\AppData\Local\Temp\arduino\sketches\7EEAED8D91ED3DE9C164BD85930F6797/main.ino.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
	}
}
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
	}
}
60001426:	4770      	bx	lr

60001428 <ResetHandler2>:
{
60001428:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
6000142c:	f000 f910 	bl	60001650 <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001430:	2408      	movs	r4, #8
60001432:	4b60      	ldr	r3, [pc, #384]	; (600015b4 <ResetHandler2+0x18c>)
	memory_copy(&_stext, &_stextload, &_etext);
60001434:	4a60      	ldr	r2, [pc, #384]	; (600015b8 <ResetHandler2+0x190>)
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001436:	f8c3 4154 	str.w	r4, [r3, #340]	; 0x154
	memory_copy(&_stext, &_stextload, &_etext);
6000143a:	4960      	ldr	r1, [pc, #384]	; (600015bc <ResetHandler2+0x194>)
6000143c:	4860      	ldr	r0, [pc, #384]	; (600015c0 <ResetHandler2+0x198>)
6000143e:	f7ff ffdf 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
60001442:	4a60      	ldr	r2, [pc, #384]	; (600015c4 <ResetHandler2+0x19c>)
60001444:	4960      	ldr	r1, [pc, #384]	; (600015c8 <ResetHandler2+0x1a0>)
60001446:	4861      	ldr	r0, [pc, #388]	; (600015cc <ResetHandler2+0x1a4>)
60001448:	f7ff ffda 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
6000144c:	4960      	ldr	r1, [pc, #384]	; (600015d0 <ResetHandler2+0x1a8>)
6000144e:	4861      	ldr	r0, [pc, #388]	; (600015d4 <ResetHandler2+0x1ac>)
60001450:	f7ff ffe2 	bl	60001418 <memory_clear>
	SCB_CPACR = 0x00F00000;
60001454:	4c60      	ldr	r4, [pc, #384]	; (600015d8 <ResetHandler2+0x1b0>)
60001456:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
6000145a:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000145e:	2300      	movs	r3, #0
60001460:	4a5e      	ldr	r2, [pc, #376]	; (600015dc <ResetHandler2+0x1b4>)
	SCB_CPACR = 0x00F00000;
60001462:	f8c1 0d88 	str.w	r0, [r1, #3464]	; 0xd88
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001466:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
6000146a:	3301      	adds	r3, #1
6000146c:	2bb0      	cmp	r3, #176	; 0xb0
6000146e:	d1fa      	bne.n	60001466 <ResetHandler2+0x3e>
60001470:	4b5b      	ldr	r3, [pc, #364]	; (600015e0 <ResetHandler2+0x1b8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
60001472:	2180      	movs	r1, #128	; 0x80
60001474:	4a5b      	ldr	r2, [pc, #364]	; (600015e4 <ResetHandler2+0x1bc>)
60001476:	f803 1b01 	strb.w	r1, [r3], #1
6000147a:	4293      	cmp	r3, r2
6000147c:	d1fb      	bne.n	60001476 <ResetHandler2+0x4e>
	SCB_VTOR = (uint32_t)_VectorsRam;
6000147e:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001482:	4e4c      	ldr	r6, [pc, #304]	; (600015b4 <ResetHandler2+0x18c>)
60001484:	f04f 3980 	mov.w	r9, #2155905152	; 0x80808080
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001488:	f8df b188 	ldr.w	fp, [pc, #392]	; 60001614 <ResetHandler2+0x1ec>
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000148c:	f8df a188 	ldr.w	sl, [pc, #392]	; 60001618 <ResetHandler2+0x1f0>
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001490:	f04f 31ff 	mov.w	r1, #4294967295
	SCB_VTOR = (uint32_t)_VectorsRam;
60001494:	f8c5 4d08 	str.w	r4, [r5, #3336]	; 0xd08
	SYST_CVR = 0;
60001498:	2700      	movs	r7, #0
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
6000149a:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000149e:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014a2:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014a6:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014aa:	f8d5 3d24 	ldr.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ae:	f8df 816c 	ldr.w	r8, [pc, #364]	; 6000161c <ResetHandler2+0x1f4>
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014b2:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014b6:	4a4c      	ldr	r2, [pc, #304]	; (600015e8 <ResetHandler2+0x1c0>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014b8:	f8c5 3d24 	str.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014bc:	f8d8 301c 	ldr.w	r3, [r8, #28]
600014c0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014c8:	f8c8 301c 	str.w	r3, [r8, #28]
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014cc:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
600014d0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d8:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014dc:	6691      	str	r1, [r2, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014de:	66d1      	str	r1, [r2, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e0:	6711      	str	r1, [r2, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014e2:	6751      	str	r1, [r2, #116]	; 0x74
	configure_cache();
600014e4:	f000 f8bc 	bl	60001660 <configure_cache>
	_VectorsRam[14] = pendablesrvreq_isr;
600014e8:	4b40      	ldr	r3, [pc, #256]	; (600015ec <ResetHandler2+0x1c4>)
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
600014ea:	4941      	ldr	r1, [pc, #260]	; (600015f0 <ResetHandler2+0x1c8>)
	_VectorsRam[14] = pendablesrvreq_isr;
600014ec:	63a3      	str	r3, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
600014ee:	4b41      	ldr	r3, [pc, #260]	; (600015f4 <ResetHandler2+0x1cc>)
600014f0:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f2:	2363      	movs	r3, #99	; 0x63
600014f4:	616b      	str	r3, [r5, #20]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f6:	2303      	movs	r3, #3
	SYST_CVR = 0;
600014f8:	61af      	str	r7, [r5, #24]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014fa:	612b      	str	r3, [r5, #16]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
600014fc:	4b3e      	ldr	r3, [pc, #248]	; (600015f8 <ResetHandler2+0x1d0>)
600014fe:	f8c5 3d20 	str.w	r3, [r5, #3360]	; 0xd20
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001502:	f8d5 3dfc 	ldr.w	r3, [r5, #3580]	; 0xdfc
60001506:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
6000150a:	f8c5 3dfc 	str.w	r3, [r5, #3580]	; 0xdfc
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000150e:	4b3b      	ldr	r3, [pc, #236]	; (600015fc <ResetHandler2+0x1d4>)
60001510:	681a      	ldr	r2, [r3, #0]
60001512:	f042 0201 	orr.w	r2, r2, #1
60001516:	601a      	str	r2, [r3, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001518:	685b      	ldr	r3, [r3, #4]
6000151a:	600b      	str	r3, [r1, #0]
	usb_pll_start();	
6000151c:	f000 f91c 	bl	60001758 <usb_pll_start>
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001520:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	set_arm_clock(F_CPU);
60001524:	4836      	ldr	r0, [pc, #216]	; (60001600 <ResetHandler2+0x1d8>)
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001526:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000152a:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000152e:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	set_arm_clock(F_CPU);
60001532:	f000 faad 	bl	60001a90 <__set_arm_clock_veneer>
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001536:	f8d8 106c 	ldr.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
6000153a:	4b32      	ldr	r3, [pc, #200]	; (60001604 <ResetHandler2+0x1dc>)
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000153c:	4a32      	ldr	r2, [pc, #200]	; (60001608 <ResetHandler2+0x1e0>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000153e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
60001542:	f8c8 106c 	str.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
60001546:	601f      	str	r7, [r3, #0]
	PIT_TCTRL0 = 0;
60001548:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000154c:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001550:	f8c3 7128 	str.w	r7, [r3, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001554:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001558:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000155a:	07db      	lsls	r3, r3, #31
6000155c:	d408      	bmi.n	60001570 <ResetHandler2+0x148>
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000155e:	f642 6315 	movw	r3, #11797	; 0x2e15
		SNVS_LPSRTCLR = 1546300800u << 15;
60001562:	492a      	ldr	r1, [pc, #168]	; (6000160c <ResetHandler2+0x1e4>)
60001564:	6551      	str	r1, [r2, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001566:	6513      	str	r3, [r2, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001568:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000156a:	f043 0301 	orr.w	r3, r3, #1
6000156e:	6393      	str	r3, [r2, #56]	; 0x38
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001570:	4a25      	ldr	r2, [pc, #148]	; (60001608 <ResetHandler2+0x1e0>)
60001572:	4c27      	ldr	r4, [pc, #156]	; (60001610 <ResetHandler2+0x1e8>)
60001574:	6893      	ldr	r3, [r2, #8]
60001576:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000157a:	6093      	str	r3, [r2, #8]
	analog_init();
6000157c:	f000 fa50 	bl	60001a20 <analog_init>
	pwm_init();
60001580:	f000 fa96 	bl	60001ab0 <__pwm_init_veneer>
	tempmon_init();
60001584:	f000 f916 	bl	600017b4 <tempmon_init>
	startup_middle_hook();
60001588:	f000 f864 	bl	60001654 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
6000158c:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
6000158e:	2b13      	cmp	r3, #19
60001590:	d9fc      	bls.n	6000158c <ResetHandler2+0x164>
	usb_init();
60001592:	f000 f9a7 	bl	600018e4 <usb_init>
60001596:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
60001598:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
6000159c:	d3fb      	bcc.n	60001596 <ResetHandler2+0x16e>
	startup_debug_reset();
6000159e:	f000 f85d 	bl	6000165c <startup_debug_reset>
	startup_late_hook();
600015a2:	f000 f859 	bl	60001658 <startup_default_late_hook>
	__libc_init_array();
600015a6:	f000 fa6f 	bl	60001a88 <____libc_init_array_veneer>
	main();
600015aa:	f000 fa79 	bl	60001aa0 <__main_veneer>
	while (1) asm("WFI");
600015ae:	bf30      	wfi
600015b0:	e7fd      	b.n	600015ae <ResetHandler2+0x186>
600015b2:	bf00      	nop
600015b4:	400d8000 	.word	0x400d8000
600015b8:	00007b90 	.word	0x00007b90
600015bc:	60001be8 	.word	0x60001be8
600015c0:	00000000 	.word	0x00000000
600015c4:	200012c0 	.word	0x200012c0
600015c8:	6000977c 	.word	0x6000977c
600015cc:	20000000 	.word	0x20000000
600015d0:	20006b20 	.word	0x20006b20
600015d4:	200012c0 	.word	0x200012c0
600015d8:	20001000 	.word	0x20001000
600015dc:	00006301 	.word	0x00006301
600015e0:	e000e400 	.word	0xe000e400
600015e4:	e000e4a0 	.word	0xe000e4a0
600015e8:	400ac000 	.word	0x400ac000
600015ec:	00004eb5 	.word	0x00004eb5
600015f0:	20006974 	.word	0x20006974
600015f4:	00004eb9 	.word	0x00004eb9
600015f8:	20200000 	.word	0x20200000
600015fc:	e0001000 	.word	0xe0001000
60001600:	23c34600 	.word	0x23c34600
60001604:	40084000 	.word	0x40084000
60001608:	400d4000 	.word	0x400d4000
6000160c:	56c00000 	.word	0x56c00000
60001610:	20006978 	.word	0x20006978
60001614:	2018101b 	.word	0x2018101b
60001618:	13110d0c 	.word	0x13110d0c
6000161c:	400fc000 	.word	0x400fc000

60001620 <ResetHandler>:
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001620:	4b07      	ldr	r3, [pc, #28]	; (60001640 <ResetHandler+0x20>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001622:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001626:	4a07      	ldr	r2, [pc, #28]	; (60001644 <ResetHandler+0x24>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001628:	4807      	ldr	r0, [pc, #28]	; (60001648 <ResetHandler+0x28>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000162a:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
6000162c:	6418      	str	r0, [r3, #64]	; 0x40
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000162e:	4a07      	ldr	r2, [pc, #28]	; (6000164c <ResetHandler+0x2c>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001630:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001632:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001634:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001638:	f3bf 8f6f 	isb	sy
	ResetHandler2();
6000163c:	f7ff fef4 	bl	60001428 <ResetHandler2>
60001640:	400ac000 	.word	0x400ac000
60001644:	aaaaaaab 	.word	0xaaaaaaab
60001648:	00200007 	.word	0x00200007
6000164c:	20078000 	.word	0x20078000

60001650 <startup_default_early_hook>:
FLASHMEM void startup_default_early_hook(void) {}
60001650:	4770      	bx	lr
60001652:	bf00      	nop

60001654 <startup_default_middle_hook>:
60001654:	4770      	bx	lr
60001656:	bf00      	nop

60001658 <startup_default_late_hook>:
60001658:	4770      	bx	lr
6000165a:	bf00      	nop

6000165c <startup_debug_reset>:
FLASHMEM void startup_debug_reset(void) { __asm__ volatile("nop"); }
6000165c:	bf00      	nop
6000165e:	4770      	bx	lr

60001660 <configure_cache>:
{
60001660:	b410      	push	{r4}
	SCB_MPU_CTRL = 0; // turn off MPU
60001662:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60001666:	2100      	movs	r1, #0
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001668:	2410      	movs	r4, #16
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
6000166a:	482b      	ldr	r0, [pc, #172]	; (60001718 <configure_cache+0xb8>)
	SCB_MPU_CTRL = 0; // turn off MPU
6000166c:	f8c3 1d94 	str.w	r1, [r3, #3476]	; 0xd94
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001670:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001674:	2411      	movs	r4, #17
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001676:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
6000167a:	4828      	ldr	r0, [pc, #160]	; (6000171c <configure_cache+0xbc>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
6000167c:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001680:	2412      	movs	r4, #18
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
60001682:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
60001686:	4826      	ldr	r0, [pc, #152]	; (60001720 <configure_cache+0xc0>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001688:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
6000168c:	4a25      	ldr	r2, [pc, #148]	; (60001724 <configure_cache+0xc4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
6000168e:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
60001692:	4c25      	ldr	r4, [pc, #148]	; (60001728 <configure_cache+0xc8>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001694:	f042 0215 	orr.w	r2, r2, #21
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
60001698:	4824      	ldr	r0, [pc, #144]	; (6000172c <configure_cache+0xcc>)
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
6000169a:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
6000169e:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016a2:	4c23      	ldr	r4, [pc, #140]	; (60001730 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016a4:	4823      	ldr	r0, [pc, #140]	; (60001734 <configure_cache+0xd4>)
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016a6:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016aa:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016ae:	4c22      	ldr	r4, [pc, #136]	; (60001738 <configure_cache+0xd8>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016b0:	f8c3 2d9c 	str.w	r2, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016b4:	4821      	ldr	r0, [pc, #132]	; (6000173c <configure_cache+0xdc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016b6:	4a22      	ldr	r2, [pc, #136]	; (60001740 <configure_cache+0xe0>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016b8:	f8c3 4da0 	str.w	r4, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016bc:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016c0:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016c4:	f502 22a0 	add.w	r2, r2, #327680	; 0x50000
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016c8:	4c1e      	ldr	r4, [pc, #120]	; (60001744 <configure_cache+0xe4>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016ca:	320c      	adds	r2, #12
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016cc:	481e      	ldr	r0, [pc, #120]	; (60001748 <configure_cache+0xe8>)
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016ce:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016d2:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016d6:	4a1d      	ldr	r2, [pc, #116]	; (6000174c <configure_cache+0xec>)
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016d8:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600016dc:	4c1c      	ldr	r4, [pc, #112]	; (60001750 <configure_cache+0xf0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016de:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016e2:	2201      	movs	r2, #1
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600016e4:	481b      	ldr	r0, [pc, #108]	; (60001754 <configure_cache+0xf4>)
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600016e6:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600016ea:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016ee:	f8c3 2d94 	str.w	r2, [r3, #3476]	; 0xd94
	asm("dsb");
600016f2:	f3bf 8f4f 	dsb	sy
	asm("isb");
600016f6:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
600016fa:	f8c3 1f50 	str.w	r1, [r3, #3920]	; 0xf50
	asm("dsb");
600016fe:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001702:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
60001706:	f8d3 2d14 	ldr.w	r2, [r3, #3348]	; 0xd14
}
6000170a:	f85d 4b04 	ldr.w	r4, [sp], #4
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000170e:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
60001712:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
}
60001716:	4770      	bx	lr
60001718:	1000003f 	.word	0x1000003f
6000171c:	03080025 	.word	0x03080025
60001720:	00100009 	.word	0x00100009
60001724:	20006b20 	.word	0x20006b20
60001728:	00200013 	.word	0x00200013
6000172c:	07020021 	.word	0x07020021
60001730:	20000014 	.word	0x20000014
60001734:	13080025 	.word	0x13080025
60001738:	10000009 	.word	0x10000009
6000173c:	20200016 	.word	0x20200016
60001740:	130b0027 	.word	0x130b0027
60001744:	40000017 	.word	0x40000017
60001748:	60000018 	.word	0x60000018
6000174c:	070b002f 	.word	0x070b002f
60001750:	70000019 	.word	0x70000019
60001754:	130b002f 	.word	0x130b002f

60001758 <usb_pll_start>:
{
60001758:	b4f0      	push	{r4, r5, r6, r7}
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
6000175a:	4a15      	ldr	r2, [pc, #84]	; (600017b0 <usb_pll_start+0x58>)
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
6000175c:	2740      	movs	r7, #64	; 0x40
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
6000175e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001762:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001766:	f44f 5500 	mov.w	r5, #8192	; 0x2000
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000176a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
6000176e:	f243 0042 	movw	r0, #12354	; 0x3042
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001772:	6913      	ldr	r3, [r2, #16]
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001774:	f013 0f02 	tst.w	r3, #2
60001778:	d10e      	bne.n	60001798 <usb_pll_start+0x40>
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
6000177a:	f413 5f00 	tst.w	r3, #8192	; 0x2000
6000177e:	d00f      	beq.n	600017a0 <usb_pll_start+0x48>
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001780:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001784:	d00e      	beq.n	600017a4 <usb_pll_start+0x4c>
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001786:	2b00      	cmp	r3, #0
60001788:	daf3      	bge.n	60001772 <usb_pll_start+0x1a>
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
6000178a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
6000178e:	d10b      	bne.n	600017a8 <usb_pll_start+0x50>
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001790:	065b      	lsls	r3, r3, #25
60001792:	d50b      	bpl.n	600017ac <usb_pll_start+0x54>
}
60001794:	bcf0      	pop	{r4, r5, r6, r7}
60001796:	4770      	bx	lr
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001798:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
6000179a:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
6000179c:	6190      	str	r0, [r2, #24]
			continue;
6000179e:	e7e8      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
600017a0:	6155      	str	r5, [r2, #20]
			continue;
600017a2:	e7e6      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
600017a4:	6156      	str	r6, [r2, #20]
			continue;
600017a6:	e7e4      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600017a8:	6191      	str	r1, [r2, #24]
			continue;
600017aa:	e7e2      	b.n	60001772 <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600017ac:	6157      	str	r7, [r2, #20]
			continue;
600017ae:	e7e0      	b.n	60001772 <usb_pll_start+0x1a>
600017b0:	400d8000 	.word	0x400d8000

600017b4 <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017b4:	4a3f      	ldr	r2, [pc, #252]	; (600018b4 <tempmon_init+0x100>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600017b6:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600017b8:	493f      	ldr	r1, [pc, #252]	; (600018b8 <tempmon_init+0x104>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017ba:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017be:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600017c2:	f04f 0c00 	mov.w	ip, #0
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600017c6:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 600018bc <tempmon_init+0x108>
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017ca:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600017ce:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 600018c0 <tempmon_init+0x10c>
{
600017d2:	b430      	push	{r4, r5}
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017d4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600017d8:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  calibrationData = HW_OCOTP_ANA1;
600017dc:	f8d1 10e0 	ldr.w	r1, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600017e0:	4d38      	ldr	r5, [pc, #224]	; (600018c4 <tempmon_init+0x110>)
600017e2:	b2cb      	uxtb	r3, r1
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600017e4:	4c38      	ldr	r4, [pc, #224]	; (600018c8 <tempmon_init+0x114>)
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017e6:	4839      	ldr	r0, [pc, #228]	; (600018cc <tempmon_init+0x118>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600017e8:	602b      	str	r3, [r5, #0]
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017ea:	ee07 3a90 	vmov	s15, r3
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
600017ee:	0d0b      	lsrs	r3, r1, #20
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600017f0:	f3c1 210b 	ubfx	r1, r1, #8, #12
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
600017f8:	ee06 3a90 	vmov	s13, r3
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
600017fc:	ee07 1a10 	vmov	s14, r1
60001800:	4b33      	ldr	r3, [pc, #204]	; (600018d0 <tempmon_init+0x11c>)
60001802:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001806:	6021      	str	r1, [r4, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001808:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000180c:	4931      	ldr	r1, [pc, #196]	; (600018d4 <tempmon_init+0x120>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000180e:	ee37 6ac6 	vsub.f32	s12, s15, s12
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001812:	ee37 5ac5 	vsub.f32	s10, s15, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001816:	ee76 6ac7 	vsub.f32	s13, s13, s14
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000181a:	ee77 7ae5 	vsub.f32	s15, s15, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000181e:	ee26 6a26 	vmul.f32	s12, s12, s13
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001822:	edc3 6a00 	vstr	s13, [r3]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001826:	ee25 5a26 	vmul.f32	s10, s10, s13
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
6000182a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000182e:	ee67 4aa6 	vmul.f32	s9, s15, s13
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001832:	edc0 7a00 	vstr	s15, [r0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001836:	eec6 5a27 	vdiv.f32	s11, s12, s15
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
6000183a:	4827      	ldr	r0, [pc, #156]	; (600018d8 <tempmon_init+0x124>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000183c:	ee85 6a27 	vdiv.f32	s12, s10, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001840:	eec4 6aa7 	vdiv.f32	s13, s9, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001844:	ee75 5a87 	vadd.f32	s11, s11, s14
60001848:	eefc 5ae5 	vcvt.u32.f32	s11, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000184c:	ee36 6a07 	vadd.f32	s12, s12, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001850:	ee15 4a90 	vmov	r4, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001854:	eebc 6ac6 	vcvt.u32.f32	s12, s12
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001858:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000185c:	ee76 7a87 	vadd.f32	s15, s13, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001860:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001864:	ee16 3a10 	vmov	r3, s12
60001868:	f8d2 4190 	ldr.w	r4, [r2, #400]	; 0x190
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000186c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001870:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001874:	4321      	orrs	r1, r4
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001876:	ee17 3a90 	vmov	r3, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000187a:	f8c2 1190 	str.w	r1, [r2, #400]	; 0x190
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000187e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001882:	f8d2 1190 	ldr.w	r1, [r2, #400]	; 0x190
60001886:	430b      	orrs	r3, r1
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001888:	4914      	ldr	r1, [pc, #80]	; (600018dc <tempmon_init+0x128>)
6000188a:	f8c2 3190 	str.w	r3, [r2, #400]	; 0x190
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
6000188e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
60001892:	f043 0302 	orr.w	r3, r3, #2
60001896:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
6000189a:	4b11      	ldr	r3, [pc, #68]	; (600018e0 <tempmon_init+0x12c>)
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
6000189c:	f880 c040 	strb.w	ip, [r0, #64]	; 0x40
600018a0:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018a4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
600018a8:	2201      	movs	r2, #1
}
600018aa:	bc30      	pop	{r4, r5}
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018ac:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
}
600018b0:	4770      	bx	lr
600018b2:	bf00      	nop
600018b4:	400d8100 	.word	0x400d8100
600018b8:	401f4400 	.word	0x401f4400
600018bc:	42aa0000 	.word	0x42aa0000
600018c0:	42b40000 	.word	0x42b40000
600018c4:	20006920 	.word	0x20006920
600018c8:	2000691c 	.word	0x2000691c
600018cc:	20006924 	.word	0x20006924
600018d0:	20006928 	.word	0x20006928
600018d4:	0fff0000 	.word	0x0fff0000
600018d8:	e000e400 	.word	0xe000e400
600018dc:	20001000 	.word	0x20001000
600018e0:	00006481 	.word	0x00006481

600018e4 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600018e4:	4b31      	ldr	r3, [pc, #196]	; (600019ac <usb_init+0xc8>)
600018e6:	f640 7261 	movw	r2, #3937	; 0xf61
{
600018ea:	b510      	push	{r4, lr}
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600018ec:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600018f0:	f240 4404 	movw	r4, #1028	; 0x404
	usb_init_serialnumber();
600018f4:	f000 f8c4 	bl	60001a80 <__usb_init_serialnumber_veneer>
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600018f8:	4a2d      	ldr	r2, [pc, #180]	; (600019b0 <usb_init+0xcc>)
	USB1_BURSTSIZE = 0x0404;
600018fa:	492e      	ldr	r1, [pc, #184]	; (600019b4 <usb_init+0xd0>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600018fc:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001900:	482d      	ldr	r0, [pc, #180]	; (600019b8 <usb_init+0xd4>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001902:	f043 0303 	orr.w	r3, r3, #3
60001906:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
6000190a:	4b2c      	ldr	r3, [pc, #176]	; (600019bc <usb_init+0xd8>)
	USB1_BURSTSIZE = 0x0404;
6000190c:	f8c1 4160 	str.w	r4, [r1, #352]	; 0x160
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001910:	6802      	ldr	r2, [r0, #0]
60001912:	421a      	tst	r2, r3
60001914:	d103      	bne.n	6000191e <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001916:	f8d1 31a8 	ldr.w	r3, [r1, #424]	; 0x1a8
6000191a:	079a      	lsls	r2, r3, #30
6000191c:	d01b      	beq.n	60001956 <usb_init+0x72>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
6000191e:	4a25      	ldr	r2, [pc, #148]	; (600019b4 <usb_init+0xd0>)
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001920:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001924:	4b24      	ldr	r3, [pc, #144]	; (600019b8 <usb_init+0xd4>)
60001926:	6359      	str	r1, [r3, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001928:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
6000192c:	f043 0302 	orr.w	r3, r3, #2
60001930:	f8c2 3140 	str.w	r3, [r2, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001934:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001938:	079b      	lsls	r3, r3, #30
6000193a:	d4fb      	bmi.n	60001934 <usb_init+0x50>
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000193c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001940:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001944:	4b1c      	ldr	r3, [pc, #112]	; (600019b8 <usb_init+0xd4>)
60001946:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000194a:	f8c1 028c 	str.w	r0, [r1, #652]	; 0x28c
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
6000194e:	2019      	movs	r0, #25
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001950:	639a      	str	r2, [r3, #56]	; 0x38
		delay(25);
60001952:	f000 f8a1 	bl	60001a98 <__delay_veneer>
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001956:	4a18      	ldr	r2, [pc, #96]	; (600019b8 <usb_init+0xd4>)
60001958:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000195c:	4c15      	ldr	r4, [pc, #84]	; (600019b4 <usb_init+0xd0>)
	USBPHY1_PWD = 0;
6000195e:	2100      	movs	r1, #0
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001960:	6390      	str	r0, [r2, #56]	; 0x38
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001962:	200a      	movs	r0, #10
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001964:	4b16      	ldr	r3, [pc, #88]	; (600019c0 <usb_init+0xdc>)
	USBPHY1_PWD = 0;
60001966:	6011      	str	r1, [r2, #0]
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001968:	f44f 7220 	mov.w	r2, #640	; 0x280
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000196c:	f8c4 01a8 	str.w	r0, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001970:	4618      	mov	r0, r3
60001972:	f000 f899 	bl	60001aa8 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001976:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000197a:	4603      	mov	r3, r0
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
6000197c:	f44f 0081 	mov.w	r0, #4227072	; 0x408000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001980:	f240 1143 	movw	r1, #323	; 0x143
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001984:	6018      	str	r0, [r3, #0]
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001986:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
	endpoint_queue_head[1].config = (64 << 16);
6000198a:	641a      	str	r2, [r3, #64]	; 0x40
6000198c:	4b0d      	ldr	r3, [pc, #52]	; (600019c4 <usb_init+0xe0>)
6000198e:	4a0e      	ldr	r2, [pc, #56]	; (600019c8 <usb_init+0xe4>)
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001990:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001994:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001998:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
6000199c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600019a0:	2301      	movs	r3, #1
	NVIC_ENABLE_IRQ(IRQ_USB1);
600019a2:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
	USB1_USBCMD = USB_USBCMD_RS;
600019a6:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	//transfer_log_head = 0;
	//transfer_log_count = 0;
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}
600019aa:	bd10      	pop	{r4, pc}
600019ac:	400d8000 	.word	0x400d8000
600019b0:	400fc000 	.word	0x400fc000
600019b4:	402e0000 	.word	0x402e0000
600019b8:	400d9000 	.word	0x400d9000
600019bc:	001e1c00 	.word	0x001e1c00
600019c0:	20000000 	.word	0x20000000
600019c4:	20001000 	.word	0x20001000
600019c8:	00006669 	.word	0x00006669

600019cc <_reboot_Teensyduino_>:


FLASHMEM void _reboot_Teensyduino_(void)
{
600019cc:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
600019ce:	4b0e      	ldr	r3, [pc, #56]	; (60001a08 <_reboot_Teensyduino_+0x3c>)
600019d0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
600019d2:	079b      	lsls	r3, r3, #30
600019d4:	d400      	bmi.n	600019d8 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
600019d6:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
600019d8:	b672      	cpsid	i
		USB1_USBCMD = 0;
600019da:	4b0c      	ldr	r3, [pc, #48]	; (60001a0c <_reboot_Teensyduino_+0x40>)
600019dc:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
600019de:	4a0c      	ldr	r2, [pc, #48]	; (60001a10 <_reboot_Teensyduino_+0x44>)
		USB1_USBCMD = 0;
600019e0:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
600019e4:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
		IOMUXC_GPR_GPR16 = 0x00200003;
600019e8:	490a      	ldr	r1, [pc, #40]	; (60001a14 <_reboot_Teensyduino_+0x48>)
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
600019ea:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
		IOMUXC_GPR_GPR16 = 0x00200003;
600019ee:	6411      	str	r1, [r2, #64]	; 0x40
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
600019f0:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
600019f2:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
600019f6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
		*p = 0xEB120000;
600019fa:	4807      	ldr	r0, [pc, #28]	; (60001a18 <_reboot_Teensyduino_+0x4c>)
600019fc:	4a07      	ldr	r2, [pc, #28]	; (60001a1c <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
600019fe:	69db      	ldr	r3, [r3, #28]
		*p = 0xEB120000;
60001a00:	6002      	str	r2, [r0, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a02:	689b      	ldr	r3, [r3, #8]
60001a04:	4798      	blx	r3
	}
	__builtin_unreachable();
60001a06:	bf00      	nop
60001a08:	401f4400 	.word	0x401f4400
60001a0c:	402e0000 	.word	0x402e0000
60001a10:	400ac000 	.word	0x400ac000
60001a14:	00200003 	.word	0x00200003
60001a18:	20208000 	.word	0x20208000
60001a1c:	eb120000 	.word	0xeb120000

60001a20 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a20:	4b10      	ldr	r3, [pc, #64]	; (60001a64 <analog_init+0x44>)
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a22:	20a0      	movs	r0, #160	; 0xa0
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a24:	4a10      	ldr	r2, [pc, #64]	; (60001a68 <analog_init+0x48>)
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a26:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a28:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
{
60001a2c:	b410      	push	{r4}
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a2e:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a30:	f240 6437 	movw	r4, #1591	; 0x637
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001a34:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a36:	f441 7140 	orr.w	r1, r1, #768	; 0x300
60001a3a:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a3c:	6454      	str	r4, [r2, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a3e:	6490      	str	r0, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001a40:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a42:	061b      	lsls	r3, r3, #24
60001a44:	d4fc      	bmi.n	60001a40 <analog_init+0x20>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a46:	4a09      	ldr	r2, [pc, #36]	; (60001a6c <analog_init+0x4c>)
60001a48:	f240 6137 	movw	r1, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a4c:	23a0      	movs	r3, #160	; 0xa0
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a4e:	6451      	str	r1, [r2, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a50:	6493      	str	r3, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001a52:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a54:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001a58:	d1fb      	bne.n	60001a52 <analog_init+0x32>
		//yield();
	}
	calibrating = 0;
60001a5a:	4a05      	ldr	r2, [pc, #20]	; (60001a70 <analog_init+0x50>)
60001a5c:	7013      	strb	r3, [r2, #0]
}
60001a5e:	f85d 4b04 	ldr.w	r4, [sp], #4
60001a62:	4770      	bx	lr
60001a64:	400fc000 	.word	0x400fc000
60001a68:	400c4000 	.word	0x400c4000
60001a6c:	400c8000 	.word	0x400c8000
60001a70:	20006add 	.word	0x20006add

60001a74 <_init>:
60001a74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60001a76:	bf00      	nop
60001a78:	bcf8      	pop	{r3, r4, r5, r6, r7}
60001a7a:	bc08      	pop	{r3}
60001a7c:	469e      	mov	lr, r3
60001a7e:	4770      	bx	lr

60001a80 <__usb_init_serialnumber_veneer>:
60001a80:	f85f f000 	ldr.w	pc, [pc]	; 60001a84 <__usb_init_serialnumber_veneer+0x4>
60001a84:	00006dd9 	.word	0x00006dd9

60001a88 <____libc_init_array_veneer>:
60001a88:	f85f f000 	ldr.w	pc, [pc]	; 60001a8c <____libc_init_array_veneer+0x4>
60001a8c:	00007b2d 	.word	0x00007b2d

60001a90 <__set_arm_clock_veneer>:
60001a90:	f85f f000 	ldr.w	pc, [pc]	; 60001a94 <__set_arm_clock_veneer+0x4>
60001a94:	00007679 	.word	0x00007679

60001a98 <__delay_veneer>:
60001a98:	f85f f000 	ldr.w	pc, [pc]	; 60001a9c <__delay_veneer+0x4>
60001a9c:	000057f1 	.word	0x000057f1

60001aa0 <__main_veneer>:
60001aa0:	f85f f000 	ldr.w	pc, [pc]	; 60001aa4 <__main_veneer+0x4>
60001aa4:	00005e65 	.word	0x00005e65

60001aa8 <__memset_veneer>:
60001aa8:	f85f f000 	ldr.w	pc, [pc]	; 60001aac <__memset_veneer+0x4>
60001aac:	00007a89 	.word	0x00007a89

60001ab0 <__pwm_init_veneer>:
60001ab0:	f85f f000 	ldr.w	pc, [pc]	; 60001ab4 <__pwm_init_veneer+0x4>
60001ab4:	00006209 	.word	0x00006209

60001ab8 <__frame_dummy_init_array_entry>:
60001ab8:	00000101 0000024d 0000034d 000008c9     ....M...M.......
60001ac8:	00000b29 0000495d 00004ba5 00004da5     )...]I...K...M..
60001ad8:	000055b5                                .U..

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <irq_gpio6789>:
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
                        return (void *)-1;
      20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
      22:	f04f 4384 	mov.w	r3, #1107296256	; 0x42000000
                }
                __brkval = prev + incr;
        }
        return prev;
}
      26:	699d      	ldr	r5, [r3, #24]
      28:	695a      	ldr	r2, [r3, #20]
      2a:	4015      	ands	r5, r2
      2c:	d00d      	beq.n	4a <_teensy_model_identifier+0x26>
      2e:	4f24      	ldr	r7, [pc, #144]	; (c0 <_teensy_model_identifier+0x9c>)
      30:	2601      	movs	r6, #1
      32:	619d      	str	r5, [r3, #24]
	// set the SRTC
	SNVS_LPSRTCLR = t << 15;
	SNVS_LPSRTCMR = t >> 17;
	// start the SRTC
	SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
	while (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)); // wait
      34:	fa95 f4a5 	rbit	r4, r5
	// start the RTC and sync it to the SRTC
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
      38:	fab4 f484 	clz	r4, r4
      3c:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
}
      40:	fa06 f404 	lsl.w	r4, r6, r4
      44:	4798      	blx	r3
      46:	43a5      	bics	r5, r4
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
	return usec;
}
      48:	d1f4      	bne.n	34 <_teensy_model_identifier+0x10>
      4a:	4b1e      	ldr	r3, [pc, #120]	; (c4 <_teensy_model_identifier+0xa0>)
      4c:	699d      	ldr	r5, [r3, #24]
      4e:	695a      	ldr	r2, [r3, #20]
      50:	4015      	ands	r5, r2
      52:	d00d      	beq.n	70 <_teensy_model_identifier+0x4c>
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      54:	4f1c      	ldr	r7, [pc, #112]	; (c8 <_teensy_model_identifier+0xa4>)
      56:	2601      	movs	r6, #1
      58:	619d      	str	r5, [r3, #24]
      5a:	fa95 f4a5 	rbit	r4, r5
}
      5e:	fab4 f484 	clz	r4, r4
      62:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      66:	fa06 f404 	lsl.w	r4, r6, r4
      6a:	4798      	blx	r3
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      6c:	43a5      	bics	r5, r4
      6e:	d1f4      	bne.n	5a <_teensy_model_identifier+0x36>
      70:	4b16      	ldr	r3, [pc, #88]	; (cc <_teensy_model_identifier+0xa8>)
		return ADC2_R0;
      72:	699d      	ldr	r5, [r3, #24]
      74:	695a      	ldr	r2, [r3, #20]
}
      76:	4015      	ands	r5, r2
	if (pin > sizeof(pin_to_channel)) return 0;
      78:	d00d      	beq.n	96 <_teensy_model_identifier+0x72>
}
      7a:	4f15      	ldr	r7, [pc, #84]	; (d0 <_teensy_model_identifier+0xac>)
      7c:	2601      	movs	r6, #1
      7e:	619d      	str	r5, [r3, #24]
      80:	fa95 f4a5 	rbit	r4, r5
      84:	fab4 f484 	clz	r4, r4
      88:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
			break;
      8c:	fa06 f404 	lsl.w	r4, r6, r4
      90:	4798      	blx	r3
      92:	43a5      	bics	r5, r4
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x52) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FF8000;
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
      94:	d1f4      	bne.n	80 <_teensy_model_identifier+0x5c>
      96:	4b0f      	ldr	r3, [pc, #60]	; (d4 <_teensy_model_identifier+0xb0>)
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
      98:	699d      	ldr	r5, [r3, #24]
      9a:	695a      	ldr	r2, [r3, #20]
      9c:	4015      	ands	r5, r2
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
      9e:	d00d      	beq.n	bc <_teensy_model_identifier+0x98>
	flash_wait();
}
      a0:	4f0d      	ldr	r7, [pc, #52]	; (d8 <_teensy_model_identifier+0xb4>)
      a2:	2601      	movs	r6, #1
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
      a4:	619d      	str	r5, [r3, #24]
	flash_wait();
      a6:	fa95 f4a5 	rbit	r4, r5
      aa:	fab4 f484 	clz	r4, r4
      ae:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      b2:	fa06 f404 	lsl.w	r4, r6, r4
      b6:	4798      	blx	r3
      b8:	43a5      	bics	r5, r4
      ba:	d1f4      	bne.n	a6 <_teensy_model_identifier+0x82>
{
	irq_anyport(&GPIO6_DR, isr_table_gpio1);
	irq_anyport(&GPIO7_DR, isr_table_gpio2);
	irq_anyport(&GPIO8_DR, isr_table_gpio3);
	irq_anyport(&GPIO9_DR, isr_table_gpio4);
}
      bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      be:	bf00      	nop
      c0:	20000af0 	.word	0x20000af0
      c4:	42004000 	.word	0x42004000
      c8:	20000b70 	.word	0x20000b70
      cc:	42008000 	.word	0x42008000
      d0:	20000bf0 	.word	0x20000bf0
      d4:	4200c000 	.word	0x4200c000
      d8:	20000c70 	.word	0x20000c70

000000dc <register_tm_clones>:
    if(c == skipChar)
      ; // ignore
    else if(c == '-')
      isNegative = true;
    else if (c == '.')
      isFraction = true;
      dc:	4805      	ldr	r0, [pc, #20]	; (f4 <register_tm_clones+0x18>)
      de:	4b06      	ldr	r3, [pc, #24]	; (f8 <register_tm_clones+0x1c>)
      e0:	1a1b      	subs	r3, r3, r0
    return 0; // zero returned if timeout
      e2:	0fd9      	lsrs	r1, r3, #31
      e4:	eb01 01a3 	add.w	r1, r1, r3, asr #2
    value = -value;
  if(isFraction)
    return value * fraction;
  else
    return value;
}
      e8:	1049      	asrs	r1, r1, #1
      ea:	d002      	beq.n	f2 <register_tm_clones+0x16>
      ec:	4b03      	ldr	r3, [pc, #12]	; (fc <register_tm_clones+0x20>)
      ee:	b103      	cbz	r3, f2 <register_tm_clones+0x16>
      f0:	4718      	bx	r3
      f2:	4770      	bx	lr
      f4:	200012c0 	.word	0x200012c0
      f8:	200012c0 	.word	0x200012c0
      fc:	00000000 	.word	0x00000000

00000100 <frame_dummy>:
     100:	b508      	push	{r3, lr}
     102:	4b05      	ldr	r3, [pc, #20]	; (118 <frame_dummy+0x18>)
  brakes1.buf[3] = 0xa;
  HaldexCAN.write(brakes1);


  CAN_message_t brakes3;
  brakes3.id = BRAKES3_ID;
     104:	b11b      	cbz	r3, 10e <frame_dummy+0xe>
  brakes3.len = 8;
  brakes3.buf[0] = 0xff;
     106:	4905      	ldr	r1, [pc, #20]	; (11c <frame_dummy+0x1c>)
  CAN_message_t brakes3;
     108:	4805      	ldr	r0, [pc, #20]	; (120 <frame_dummy+0x20>)
     10a:	f3af 8000 	nop.w
  brakes3.buf[3] = 0xa;
  brakes3.buf[4] = 0x0;
  brakes3.buf[5] = 0xa;
  brakes3.buf[6] = 0x0;
  brakes3.buf[7] = 0xa;
  HaldexCAN.write(brakes3);
     10e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  brakes3.buf[5] = 0xa;
     112:	f7ff bfe3 	b.w	dc <register_tm_clones>
  brakes3.buf[7] = 0xa;
     116:	bf00      	nop
  HaldexCAN.write(brakes3);
     118:	00000000 	.word	0x00000000
}
     11c:	200068c8 	.word	0x200068c8
     120:	6000b800 	.word	0x6000b800

00000124 <setup>:
bool printMode(void *params) {
  Serial.printf("OpenHaldex mode=%d\n", state.mode);
  return true;
}

void setup() {
     124:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	// is always initialized early during startup.  The baud rate setting
	// is not used.  Communication occurs at USB native speed.  For
	// compatibility with Arduino code, Serial.begin waits up to 2 seconds
	// for your PC to open the virtual serial port.
        void begin(long baud_unused __attribute__((unused))) {
		uint32_t millis_begin = systick_millis_count;
     128:	4d3e      	ldr	r5, [pc, #248]	; (224 <setup+0x100>)
				// Wait up to 2 seconds for Arduino Serial Monitor
				if (elapsed > 2000) break;
			} else {
				// But wait only 3/4 second if there is no sign the
				// USB host has begun the USB enumeration process.
				if (elapsed > 750) break;
     12a:	f240 28ee 	movw	r8, #750	; 0x2ee
     12e:	4c3e      	ldr	r4, [pc, #248]	; (228 <setup+0x104>)
	// Testing Serial as a boolean indicates whether USB is active and a program
	// running on your PC has raised the DTR signal, which typically means it has
	// opened the port and is ready to communicate.
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     130:	4f3e      	ldr	r7, [pc, #248]	; (22c <setup+0x108>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     132:	f8df 9114 	ldr.w	r9, [pc, #276]	; 248 <setup+0x124>
		uint32_t millis_begin = systick_millis_count;
     136:	682e      	ldr	r6, [r5, #0]
		yield();
     138:	f007 fa26 	bl	7588 <yield>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     13c:	7823      	ldrb	r3, [r4, #0]
     13e:	2b00      	cmp	r3, #0
     140:	d050      	beq.n	1e4 <setup+0xc0>
     142:	783b      	ldrb	r3, [r7, #0]
     144:	07db      	lsls	r3, r3, #31
     146:	d54d      	bpl.n	1e4 <setup+0xc0>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     148:	682b      	ldr	r3, [r5, #0]
     14a:	f8d9 2000 	ldr.w	r2, [r9]
     14e:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     150:	2b0e      	cmp	r3, #14
     152:	d947      	bls.n	1e4 <setup+0xc0>
  Serial.println(F("\nOpenHaldexTeensy 4.0 Initialisation"));
  Serial.printf("Running at %dMHz\r\n", F_CPU_ACTUAL / (1000 * 1000));
#endif /* stateDebug */


  Serial2.begin(baudBT);
     154:	2200      	movs	r2, #0
     156:	f44f 4116 	mov.w	r1, #38400	; 0x9600
     15a:	4835      	ldr	r0, [pc, #212]	; (230 <setup+0x10c>)
     15c:	f004 ff92 	bl	5084 <HardwareSerial::begin(unsigned long, unsigned short)>
#if stateDebug
  Serial.println(F("\nBluetooth initialised!"));
#endif /* stateDebug */

  // Turn off the power LED for power saving
  pinMode(LED_BUILTIN, OUTPUT);
     160:	2101      	movs	r1, #1
     162:	200d      	movs	r0, #13
     164:	f005 fbd4 	bl	5910 <pinMode>
  canInit();
     168:	f002 fa56 	bl	2618 <canInit()>
  readEEP();
     16c:	f004 fc58 	bl	4a20 <readEEP()>

  // Setup the RGB LED pins for outputs
  pinMode(pinLED_R, OUTPUT);
     170:	2101      	movs	r1, #1
     172:	200c      	movs	r0, #12
     174:	f005 fbcc 	bl	5910 <pinMode>
  pinMode(pinLED_G, OUTPUT);
     178:	2101      	movs	r1, #1
     17a:	200a      	movs	r0, #10
     17c:	f005 fbc8 	bl	5910 <pinMode>
  pinMode(pinLED_B, OUTPUT);
     180:	2101      	movs	r1, #1
     182:	200b      	movs	r0, #11
     184:	f005 fbc4 	bl	5910 <pinMode>

  // Setup the switches (Switch Mode & Bluetooth) for interrupt / inputs (keeps response quick)
  // can't have BT_Conf as an interrupt and change the pin state...
  attachInterrupt(pinSwitchMode, checkSwitchMode, HIGH);
     188:	2201      	movs	r2, #1
     18a:	492a      	ldr	r1, [pc, #168]	; (234 <setup+0x110>)
     18c:	2011      	movs	r0, #17
     18e:	f005 fded 	bl	5d6c <attachInterrupt>
  pinMode(pinBT_Conf, INPUT);
     192:	2100      	movs	r1, #0
     194:	2004      	movs	r0, #4
     196:	f005 fbbb 	bl	5910 <pinMode>

    inline
    struct task *
    next_task_slot()
    {
        timer_foreach_task(slot) {
     19a:	4b27      	ldr	r3, [pc, #156]	; (238 <setup+0x114>)
     19c:	6828      	ldr	r0, [r5, #0]
     19e:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     1a2:	681a      	ldr	r2, [r3, #0]
     1a4:	b3aa      	cbz	r2, 212 <setup+0xee>
        timer_foreach_task(slot) {
     1a6:	3314      	adds	r3, #20
     1a8:	428b      	cmp	r3, r1
     1aa:	d1fa      	bne.n	1a2 <setup+0x7e>
     1ac:	4b22      	ldr	r3, [pc, #136]	; (238 <setup+0x114>)
     1ae:	6828      	ldr	r0, [r5, #0]
     1b0:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     1b4:	681a      	ldr	r2, [r3, #0]
     1b6:	b312      	cbz	r2, 1fe <setup+0xda>
        timer_foreach_task(slot) {
     1b8:	3314      	adds	r3, #20
     1ba:	428b      	cmp	r3, r1
     1bc:	d1fa      	bne.n	1b4 <setup+0x90>
#if isStandalone
  timer.every(50, sendStandaloneCAN);
#endif /* Standalone Haldex Control */

  // Disable unwanted Teensy optionals
  CCM_ANALOG_PLL_AUDIO |= CCM_ANALOG_PLL_AUDIO_POWERDOWN;
     1be:	4b1f      	ldr	r3, [pc, #124]	; (23c <setup+0x118>)
     1c0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
     1c2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     1c6:	671a      	str	r2, [r3, #112]	; 0x70
  CCM_ANALOG_PLL_VIDEO |= CCM_ANALOG_PLL_VIDEO_POWERDOWN;
     1c8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
     1cc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     1d0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  CCM_ANALOG_PLL_ENET |= CCM_ANALOG_PLL_ENET_POWERDOWN;
     1d4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
     1d8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     1dc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
}
     1e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			uint32_t elapsed = systick_millis_count - millis_begin;
     1e4:	682b      	ldr	r3, [r5, #0]
			if (usb_configuration) {
     1e6:	7822      	ldrb	r2, [r4, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
     1e8:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
     1ea:	b12a      	cbz	r2, 1f8 <setup+0xd4>
				if (elapsed > 2000) break;
     1ec:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
     1f0:	d8b0      	bhi.n	154 <setup+0x30>
			yield();
     1f2:	f007 f9c9 	bl	7588 <yield>
     1f6:	e79f      	b.n	138 <setup+0x14>
				if (elapsed > 750) break;
     1f8:	4543      	cmp	r3, r8
     1fa:	d9fa      	bls.n	1f2 <setup+0xce>
     1fc:	e7aa      	b.n	154 <setup+0x30>
    {
        struct task * const slot = next_task_slot();

        if (!slot) return NULL;

        slot->handler = h;
     1fe:	4c10      	ldr	r4, [pc, #64]	; (240 <setup+0x11c>)
        slot->opaque = opaque;
        slot->start = start;
        slot->expires = expires;
     200:	f241 3188 	movw	r1, #5000	; 0x1388
        slot->start = start;
     204:	e9c3 2001 	strd	r2, r0, [r3, #4]
        slot->repeat = repeat;
     208:	2201      	movs	r2, #1
        slot->handler = h;
     20a:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     20c:	e9c3 1203 	strd	r1, r2, [r3, #12]

        return slot;
     210:	e7d5      	b.n	1be <setup+0x9a>
        slot->handler = h;
     212:	4c0c      	ldr	r4, [pc, #48]	; (244 <setup+0x120>)
        slot->expires = expires;
     214:	2164      	movs	r1, #100	; 0x64
        slot->opaque = opaque;
     216:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     218:	2201      	movs	r2, #1
        slot->start = start;
     21a:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     21c:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     21e:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     222:	e7c3      	b.n	1ac <setup+0x88>
     224:	20006978 	.word	0x20006978
     228:	20006aeb 	.word	0x20006aeb
     22c:	20006aea 	.word	0x20006aea
     230:	200067a8 	.word	0x200067a8
     234:	00000679 	.word	0x00000679
     238:	20006980 	.word	0x20006980
     23c:	400d8000 	.word	0x400d8000
     240:	00004af5 	.word	0x00004af5
     244:	00000351 	.word	0x00000351
     248:	20006ac8 	.word	0x20006ac8

0000024c <_GLOBAL__sub_I_state>:
    btInit();   // can't have BT_Conf as an interrupt and change the pin state...
  }

  // light up the LED as per the 'state.mode'
  LED();
}
     24c:	b508      	push	{r3, lr}
***/

struct EEPROMClass{

#if defined(__arm__) && defined(TEENSYDUINO)
    EEPROMClass()                        { eeprom_initialize(); }
     24e:	f005 fbc5 	bl	59dc <eeprom_initialize>
    Timer() : tasks{} {}
     252:	f44f 72a0 	mov.w	r2, #320	; 0x140
     256:	2100      	movs	r1, #0
     258:	4801      	ldr	r0, [pc, #4]	; (260 <_GLOBAL__sub_I_state+0x14>)
     25a:	f007 fc15 	bl	7a88 <memset>
     25e:	bd08      	pop	{r3, pc}
     260:	20006980 	.word	0x20006980

00000264 <loop>:
void loop() {
     264:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     268:	4d35      	ldr	r5, [pc, #212]	; (340 <loop+0xdc>)
     26a:	b084      	sub	sp, #16
     26c:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 348 <loop+0xe4>
        task->handler = NULL;
     270:	2700      	movs	r7, #0
                    task->repeat = task->handler(task->opaque) && task->repeat;
     272:	f04f 0a01 	mov.w	sl, #1
     276:	f505 76a0 	add.w	r6, r5, #320	; 0x140
     27a:	462c      	mov	r4, r5
     27c:	e009      	b.n	292 <loop+0x2e>
     27e:	f854 3c04 	ldr.w	r3, [r4, #-4]
     282:	b1bb      	cbz	r3, 2b4 <loop+0x50>
     284:	f844 ac04 	str.w	sl, [r4, #-4]
                    if (task->repeat) task->start = t;
     288:	f844 9c0c 	str.w	r9, [r4, #-12]
        timer_foreach_task(task) {
     28c:	3414      	adds	r4, #20
     28e:	42b4      	cmp	r4, r6
     290:	d019      	beq.n	2c6 <loop+0x62>
            if (task->handler) {
     292:	f854 2c14 	ldr.w	r2, [r4, #-20]
     296:	2a00      	cmp	r2, #0
     298:	d0f8      	beq.n	28c <loop+0x28>
     29a:	f8d8 9000 	ldr.w	r9, [r8]
                if (duration >= task->expires) {
     29e:	e954 3103 	ldrd	r3, r1, [r4, #-12]
                const unsigned long duration = t - task->start;
     2a2:	eba9 0303 	sub.w	r3, r9, r3
                if (duration >= task->expires) {
     2a6:	428b      	cmp	r3, r1
     2a8:	d3f0      	bcc.n	28c <loop+0x28>
                    task->repeat = task->handler(task->opaque) && task->repeat;
     2aa:	f854 0c10 	ldr.w	r0, [r4, #-16]
     2ae:	4790      	blx	r2
     2b0:	2800      	cmp	r0, #0
     2b2:	d1e4      	bne.n	27e <loop+0x1a>
        task->repeat = 0;
     2b4:	f844 7c04 	str.w	r7, [r4, #-4]
        task->opaque = T();
     2b8:	e944 7705 	strd	r7, r7, [r4, #-20]
        task->expires = 0;
     2bc:	e944 7703 	strd	r7, r7, [r4, #-12]
        timer_foreach_task(task) {
     2c0:	3414      	adds	r4, #20
     2c2:	42b4      	cmp	r4, r6
     2c4:	d1e5      	bne.n	292 <loop+0x2e>
     2c6:	f8d8 3000 	ldr.w	r3, [r8]
            if (task->handler) {
     2ca:	f855 3c14 	ldr.w	r3, [r5, #-20]
     2ce:	b133      	cbz	r3, 2de <loop+0x7a>
     2d0:	f8d8 3000 	ldr.w	r3, [r8]
                if (duration >= task->expires) {
     2d4:	e955 1203 	ldrd	r1, r2, [r5, #-12]
                const unsigned long duration = t - task->start;
     2d8:	1a5b      	subs	r3, r3, r1
                if (duration >= task->expires) {
     2da:	4293      	cmp	r3, r2
     2dc:	d202      	bcs.n	2e4 <loop+0x80>
        timer_foreach_const_task(task) {
     2de:	3514      	adds	r5, #20
     2e0:	42b5      	cmp	r5, r6
     2e2:	d1f2      	bne.n	2ca <loop+0x66>
  if (Serial2.available()) {
     2e4:	4817      	ldr	r0, [pc, #92]	; (344 <loop+0xe0>)
     2e6:	f8d8 3000 	ldr.w	r3, [r8]
     2ea:	f004 fe05 	bl	4ef8 <HardwareSerial::available()>
     2ee:	b940      	cbnz	r0, 302 <loop+0x9e>
  if (digitalRead(pinBT_Conf)) {
     2f0:	2004      	movs	r0, #4
     2f2:	f005 fafb 	bl	58ec <digitalRead>
     2f6:	b9d8      	cbnz	r0, 330 <loop+0xcc>
}
     2f8:	b004      	add	sp, #16
     2fa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     2fe:	f000 ba79 	b.w	7f4 <LED()>
    bt_packet rx_packet = { 0 };
     302:	2000      	movs	r0, #0
	float parseFloat();
	float parseFloat(char skipChar);
	size_t readBytes(char *buffer, size_t length);
	size_t readBytes(uint8_t *buffer, size_t length) { return readBytes((char *)buffer, length); }
	size_t readBytesUntil(char terminator, char *buffer, size_t length);
	size_t readBytesUntil(char terminator, uint8_t *buffer, size_t length) { return readBytesUntil(terminator, (char *)buffer, length); }
     304:	2308      	movs	r3, #8
     306:	f10d 0205 	add.w	r2, sp, #5
     30a:	21ff      	movs	r1, #255	; 0xff
     30c:	f88d 000c 	strb.w	r0, [sp, #12]
     310:	e9cd 0001 	strd	r0, r0, [sp, #4]
     314:	480b      	ldr	r0, [pc, #44]	; (344 <loop+0xe0>)
     316:	f005 fa27 	bl	5768 <Stream::readBytesUntil(char, char*, unsigned int)>
     31a:	4603      	mov	r3, r0
    btProcess(&rx_packet);
     31c:	a801      	add	r0, sp, #4
    rx_packet.len = Serial2.readBytesUntil(SERIAL_PACKET_END, rx_packet.data, ARRAY_SIZE(rx_packet.data));
     31e:	f88d 3004 	strb.w	r3, [sp, #4]
    btProcess(&rx_packet);
     322:	f000 f86f 	bl	404 <btProcess(bt_packet*)>
  if (digitalRead(pinBT_Conf)) {
     326:	2004      	movs	r0, #4
     328:	f005 fae0 	bl	58ec <digitalRead>
     32c:	2800      	cmp	r0, #0
     32e:	d0e3      	beq.n	2f8 <loop+0x94>
    btInit();   // can't have BT_Conf as an interrupt and change the pin state...
     330:	f000 f90e 	bl	550 <btInit()>
}
     334:	b004      	add	sp, #16
     336:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     33a:	f000 ba5b 	b.w	7f4 <LED()>
     33e:	bf00      	nop
     340:	20006994 	.word	0x20006994
     344:	200067a8 	.word	0x200067a8
     348:	20006978 	.word	0x20006978

0000034c <_GLOBAL__sub_I__Z12btSendStatusPv>:
     34c:	f005 bb46 	b.w	59dc <eeprom_initialize>

00000350 <btSendStatus(void*)>:
bool btSendStatus(void *params) {
  bt_packet packet;
  packet.data[0] = APP_MSG_STATUS;
  packet.data[1] = 0;  // was haldexStatus
  packet.data[2] = haldexEngagement;
  packet.data[3] = lockTarget;
     350:	4925      	ldr	r1, [pc, #148]	; (3e8 <btSendStatus(void*)+0x98>)
  packet.data[2] = haldexEngagement;
     352:	4a26      	ldr	r2, [pc, #152]	; (3ec <btSendStatus(void*)+0x9c>)
  packet.data[3] = lockTarget;
     354:	edd1 7a00 	vldr	s15, [r1]
  packet.data[4] = vehicleSpeed;
     358:	4b25      	ldr	r3, [pc, #148]	; (3f0 <btSendStatus(void*)+0xa0>)
  packet.data[3] = lockTarget;
     35a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  packet.data[5] = state.mode_override;
  packet.data[6] = SERIAL_PACKET_END;
  packet.len = 7;

  if (isScreen) {
     35e:	4925      	ldr	r1, [pc, #148]	; (3f4 <btSendStatus(void*)+0xa4>)
bool btSendStatus(void *params) {
     360:	b510      	push	{r4, lr}
  packet.data[5] = state.mode_override;
     362:	4c25      	ldr	r4, [pc, #148]	; (3f8 <btSendStatus(void*)+0xa8>)
bool btSendStatus(void *params) {
     364:	b084      	sub	sp, #16
  packet.data[2] = haldexEngagement;
     366:	7810      	ldrb	r0, [r2, #0]
  packet.data[4] = vehicleSpeed;
     368:	781a      	ldrb	r2, [r3, #0]
  packet.data[3] = lockTarget;
     36a:	ee17 3a90 	vmov	r3, s15
  packet.data[5] = state.mode_override;
     36e:	f894 c023 	ldrb.w	ip, [r4, #35]	; 0x23
  packet.data[2] = haldexEngagement;
     372:	f88d 0007 	strb.w	r0, [sp, #7]
  packet.len = 7;
     376:	f240 1007 	movw	r0, #263	; 0x107
  packet.data[4] = vehicleSpeed;
     37a:	f88d 2009 	strb.w	r2, [sp, #9]
  packet.data[6] = SERIAL_PACKET_END;
     37e:	22ff      	movs	r2, #255	; 0xff
  packet.data[3] = lockTarget;
     380:	f88d 3008 	strb.w	r3, [sp, #8]
  packet.data[1] = 0;  // was haldexStatus
     384:	2300      	movs	r3, #0
  if (isScreen) {
     386:	7809      	ldrb	r1, [r1, #0]
  packet.data[5] = state.mode_override;
     388:	f88d c00a 	strb.w	ip, [sp, #10]
  packet.data[6] = SERIAL_PACKET_END;
     38c:	f88d 200b 	strb.w	r2, [sp, #11]
  packet.len = 7;
     390:	f8ad 0004 	strh.w	r0, [sp, #4]
  packet.data[1] = 0;  // was haldexStatus
     394:	f88d 3006 	strb.w	r3, [sp, #6]
  if (isScreen) {
     398:	b311      	cbz	r1, 3e0 <btSendStatus(void*)+0x90>
    packet.data[3] = lockTarget;
    packet.data[4] = vehicleSpeed;
    packet.data[5] = state.mode_override;
    packet.data[6] = softwareVersion;
    packet.data[7] = SERIAL_PACKET_END;
    packet.len = 8;
     39a:	2308      	movs	r3, #8
    packet.data[6] = softwareVersion;
     39c:	4917      	ldr	r1, [pc, #92]	; (3fc <btSendStatus(void*)+0xac>)
    packet.data[7] = SERIAL_PACKET_END;
     39e:	f88d 200c 	strb.w	r2, [sp, #12]
     3a2:	f04f 0c07 	mov.w	ip, #7
    packet.data[6] = softwareVersion;
     3a6:	6809      	ldr	r1, [r1, #0]
     3a8:	461a      	mov	r2, r3
    packet.len = 8;
     3aa:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[6] = softwareVersion;
     3ae:	f88d 100b 	strb.w	r1, [sp, #11]
bool btSendStatus(void *params) {
     3b2:	2300      	movs	r3, #0
  }

  for (int i = 0; i < packet.len - 1; i++) {
    if (packet.data[i] == SERIAL_PACKET_END) {
      packet.data[i] = SERIAL_PACKET_END - 1;
     3b4:	f04f 0efe 	mov.w	lr, #254	; 0xfe
     3b8:	f10d 0105 	add.w	r1, sp, #5
    if (packet.data[i] == SERIAL_PACKET_END) {
     3bc:	e005      	b.n	3ca <btSendStatus(void*)+0x7a>
     3be:	f811 0f01 	ldrb.w	r0, [r1, #1]!
     3c2:	28ff      	cmp	r0, #255	; 0xff
      packet.data[i] = SERIAL_PACKET_END - 1;
     3c4:	bf08      	it	eq
     3c6:	f881 e000 	strbeq.w	lr, [r1]
  for (int i = 0; i < packet.len - 1; i++) {
     3ca:	3301      	adds	r3, #1
     3cc:	459c      	cmp	ip, r3
     3ce:	dcf6      	bgt.n	3be <btSendStatus(void*)+0x6e>
    }
  }

  Serial2.write(packet.data, packet.len);
     3d0:	f10d 0105 	add.w	r1, sp, #5
     3d4:	480a      	ldr	r0, [pc, #40]	; (400 <btSendStatus(void*)+0xb0>)
     3d6:	f005 f96d 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
  return true;
}
     3da:	2001      	movs	r0, #1
     3dc:	b004      	add	sp, #16
     3de:	bd10      	pop	{r4, pc}
     3e0:	f04f 0c06 	mov.w	ip, #6
     3e4:	2207      	movs	r2, #7
     3e6:	e7e4      	b.n	3b2 <btSendStatus(void*)+0x62>
     3e8:	200068c4 	.word	0x200068c4
     3ec:	20006ade 	.word	0x20006ade
     3f0:	20006aee 	.word	0x20006aee
     3f4:	20006ae2 	.word	0x20006ae2
     3f8:	20006950 	.word	0x20006950
     3fc:	20000d2c 	.word	0x20000d2c
     400:	200067a8 	.word	0x200067a8

00000404 <btProcess(bt_packet*)>:

void btProcess(bt_packet *rx_packet) {
  byte lockpoint_index;
  bt_packet tx_packet;

  switch (rx_packet->data[0]) {
     404:	7843      	ldrb	r3, [r0, #1]
     406:	2b02      	cmp	r3, #2
     408:	d003      	beq.n	412 <btProcess(bt_packet*)+0xe>
     40a:	2b03      	cmp	r3, #3
     40c:	d035      	beq.n	47a <btProcess(bt_packet*)+0x76>
     40e:	b303      	cbz	r3, 452 <btProcess(bt_packet*)+0x4e>
     410:	4770      	bx	lr
#endif

      break;

    case APP_MSG_CUSTOM_DATA:
      lockpoint_index = rx_packet->data[1];
     412:	7883      	ldrb	r3, [r0, #2]

      if (lockpoint_index < NUM_LOCK_POINTS) {
     414:	2b09      	cmp	r3, #9
     416:	d8fb      	bhi.n	410 <btProcess(bt_packet*)+0xc>
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     418:	4947      	ldr	r1, [pc, #284]	; (538 <btProcess(bt_packet*)+0x134>)
     41a:	eb03 0243 	add.w	r2, r3, r3, lsl #1
     41e:	f890 c003 	ldrb.w	ip, [r0, #3]
        state.custom_mode.lockpoints[lockpoint_index].lock = rx_packet->data[3];
        state.custom_mode.lockpoints[lockpoint_index].intensity = rx_packet->data[4];

        if (lockpoint_index > 6) {
     422:	2b06      	cmp	r3, #6
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     424:	440a      	add	r2, r1
     426:	f882 c001 	strb.w	ip, [r2, #1]
        state.custom_mode.lockpoints[lockpoint_index].lock = rx_packet->data[3];
     42a:	f890 c004 	ldrb.w	ip, [r0, #4]
     42e:	f882 c002 	strb.w	ip, [r2, #2]
        state.custom_mode.lockpoints[lockpoint_index].intensity = rx_packet->data[4];
     432:	7940      	ldrb	r0, [r0, #5]
     434:	70d0      	strb	r0, [r2, #3]
        if (lockpoint_index > 6) {
     436:	d975      	bls.n	524 <btProcess(bt_packet*)+0x120>
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     438:	3b07      	subs	r3, #7
     43a:	2201      	movs	r2, #1
     43c:	7fc8      	ldrb	r0, [r1, #31]
     43e:	fa02 f303 	lsl.w	r3, r2, r3
     442:	4303      	orrs	r3, r0
     444:	77cb      	strb	r3, [r1, #31]
        } else {
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
        }

        state.custom_mode.lockpoint_count++;
     446:	f891 3021 	ldrb.w	r3, [r1, #33]	; 0x21
     44a:	3301      	adds	r3, #1
     44c:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21
     450:	4770      	bx	lr
      if (state.mode_override) {
     452:	4b39      	ldr	r3, [pc, #228]	; (538 <btProcess(bt_packet*)+0x134>)
     454:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
     458:	2a00      	cmp	r2, #0
     45a:	d1d9      	bne.n	410 <btProcess(bt_packet*)+0xc>
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     45c:	7881      	ldrb	r1, [r0, #2]
     45e:	2903      	cmp	r1, #3
     460:	d956      	bls.n	510 <btProcess(bt_packet*)+0x10c>
      state.ped_threshold = rx_packet->data[2];
     462:	78c1      	ldrb	r1, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     464:	701a      	strb	r2, [r3, #0]
      state.ped_threshold = rx_packet->data[2];
     466:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
      if (rx_packet->data[1] == MODE_CUSTOM) {
     46a:	7883      	ldrb	r3, [r0, #2]
     46c:	2b03      	cmp	r3, #3
        isCustom = true;
     46e:	4b33      	ldr	r3, [pc, #204]	; (53c <btProcess(bt_packet*)+0x138>)
     470:	bf0c      	ite	eq
     472:	2201      	moveq	r2, #1
        isCustom = false;
     474:	2200      	movne	r2, #0
     476:	701a      	strb	r2, [r3, #0]
     478:	4770      	bx	lr
void btProcess(bt_packet *rx_packet) {
     47a:	b500      	push	{lr}
     47c:	7883      	ldrb	r3, [r0, #2]
     47e:	b085      	sub	sp, #20
     480:	2b03      	cmp	r3, #3
     482:	d81c      	bhi.n	4be <btProcess(bt_packet*)+0xba>
     484:	e8df f003 	tbb	[pc, r3]
     488:	1e3a2c02 	.word	0x1e3a2c02
    case APP_MSG_CUSTOM_CTRL:
      switch (rx_packet->data[1]) {
        case DATA_CTRL_CHECK_LOCKPOINTS:
          tx_packet.data[0] = APP_MSG_CUSTOM_CTRL;
          tx_packet.data[1] = DATA_CTRL_CHECK_LOCKPOINTS;
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     48c:	4b2a      	ldr	r3, [pc, #168]	; (538 <btProcess(bt_packet*)+0x134>)
          tx_packet.data[3] = state.custom_mode.lockpoint_rx_h;
          tx_packet.data[4] = SERIAL_PACKET_END;
     48e:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     490:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_LOCKPOINTS;
     494:	f04f 0c00 	mov.w	ip, #0
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     498:	f893 0020 	ldrb.w	r0, [r3, #32]
          tx_packet.data[3] = state.custom_mode.lockpoint_rx_h;
     49c:	7fdb      	ldrb	r3, [r3, #31]
        case DATA_CTRL_CHECK_MODE:
          tx_packet.data[0] = APP_MSG_CUSTOM_CTRL;
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
          tx_packet.data[2] = state.mode;
          tx_packet.data[3] = state.ped_threshold;
          tx_packet.data[4] = SERIAL_PACKET_END;
     49e:	f88d 2009 	strb.w	r2, [sp, #9]
          tx_packet.len = 5;

          Serial2.write(tx_packet.data, tx_packet.len);
     4a2:	2205      	movs	r2, #5
          tx_packet.data[2] = state.mode;
     4a4:	f88d 0007 	strb.w	r0, [sp, #7]
          tx_packet.len = 5;
     4a8:	f8ad 1004 	strh.w	r1, [sp, #4]
          Serial2.write(tx_packet.data, tx_packet.len);
     4ac:	eb0d 0102 	add.w	r1, sp, r2
     4b0:	4823      	ldr	r0, [pc, #140]	; (540 <btProcess(bt_packet*)+0x13c>)
          tx_packet.data[3] = state.ped_threshold;
     4b2:	f88d 3008 	strb.w	r3, [sp, #8]
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     4b6:	f88d c006 	strb.w	ip, [sp, #6]
          Serial2.write(tx_packet.data, tx_packet.len);
     4ba:	f005 f8fb 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
          Serial.println("App assumed control of override");
          break;
      }
      break;
  }
}
     4be:	b005      	add	sp, #20
     4c0:	f85d fb04 	ldr.w	pc, [sp], #4
          state.mode_override = false;
     4c4:	4b1c      	ldr	r3, [pc, #112]	; (538 <btProcess(bt_packet*)+0x134>)
     4c6:	2200      	movs	r2, #0
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     4c8:	211f      	movs	r1, #31
     4ca:	481e      	ldr	r0, [pc, #120]	; (544 <btProcess(bt_packet*)+0x140>)
     4cc:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
     4d0:	f006 ffdc 	bl	748c <usb_serial_write>
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     4d4:	481c      	ldr	r0, [pc, #112]	; (548 <btProcess(bt_packet*)+0x144>)
}
     4d6:	b005      	add	sp, #20
     4d8:	f85d eb04 	ldr.w	lr, [sp], #4
     4dc:	f005 b91e 	b.w	571c <Print::println()>
          state.custom_mode.lockpoint_rx_l = 0;
     4e0:	4b15      	ldr	r3, [pc, #84]	; (538 <btProcess(bt_packet*)+0x134>)
     4e2:	2100      	movs	r1, #0
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     4e4:	221e      	movs	r2, #30
     4e6:	1c58      	adds	r0, r3, #1
          state.custom_mode.lockpoint_rx_l = 0;
     4e8:	f883 1020 	strb.w	r1, [r3, #32]
          state.custom_mode.lockpoint_rx_h = 0;
     4ec:	77d9      	strb	r1, [r3, #31]
          state.custom_mode.lockpoint_count = 0;
     4ee:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
}
     4f2:	b005      	add	sp, #20
     4f4:	f85d eb04 	ldr.w	lr, [sp], #4
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     4f8:	f007 bac6 	b.w	7a88 <memset>
          tx_packet.data[2] = state.mode;
     4fc:	4b0e      	ldr	r3, [pc, #56]	; (538 <btProcess(bt_packet*)+0x134>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     4fe:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     500:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     504:	f04f 0c02 	mov.w	ip, #2
          tx_packet.data[2] = state.mode;
     508:	7818      	ldrb	r0, [r3, #0]
          tx_packet.data[3] = state.ped_threshold;
     50a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     50e:	e7c6      	b.n	49e <btProcess(bt_packet*)+0x9a>
      state.ped_threshold = rx_packet->data[2];
     510:	78c2      	ldrb	r2, [r0, #3]
      if (state.mode == MODE_FWD) {
     512:	2901      	cmp	r1, #1
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     514:	7019      	strb	r1, [r3, #0]
      state.ped_threshold = rx_packet->data[2];
     516:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      if (state.mode == MODE_FWD) {
     51a:	d1a6      	bne.n	46a <btProcess(bt_packet*)+0x66>
        lockTarget = 0;
     51c:	4b0b      	ldr	r3, [pc, #44]	; (54c <btProcess(bt_packet*)+0x148>)
     51e:	2200      	movs	r2, #0
     520:	601a      	str	r2, [r3, #0]
     522:	e7a2      	b.n	46a <btProcess(bt_packet*)+0x66>
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     524:	2001      	movs	r0, #1
     526:	f891 2020 	ldrb.w	r2, [r1, #32]
     52a:	fa00 f303 	lsl.w	r3, r0, r3
     52e:	4313      	orrs	r3, r2
     530:	f881 3020 	strb.w	r3, [r1, #32]
     534:	e787      	b.n	446 <btProcess(bt_packet*)+0x42>
     536:	bf00      	nop
     538:	20006950 	.word	0x20006950
     53c:	20006ae1 	.word	0x20006ae1
     540:	200067a8 	.word	0x200067a8
     544:	20000360 	.word	0x20000360
     548:	20000a68 	.word	0x20000a68
     54c:	200068c4 	.word	0x200068c4

00000550 <btInit()>:

void btInit() {
     550:	b530      	push	{r4, r5, lr}
#if stateDebug
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
#endif                          /* stateDebug */

  // drive all LEDs low to save power!
  digitalWrite(pinLED_R, LOW);
     552:	2100      	movs	r1, #0
void btInit() {
     554:	b083      	sub	sp, #12
  digitalWrite(pinLED_R, LOW);
     556:	200c      	movs	r0, #12
  digitalWrite(pinLED_G, LOW);
  digitalWrite(pinLED_B, LOW);

  Serial2.end();  // end current (if any) Serial2/Bluetooth connections
     558:	4d41      	ldr	r5, [pc, #260]	; (660 <btInit()+0x110>)
  digitalWrite(pinLED_R, LOW);
     55a:	f005 f99d 	bl	5898 <digitalWrite>
  digitalWrite(pinLED_G, LOW);
     55e:	2100      	movs	r1, #0
     560:	200a      	movs	r0, #10
     562:	f005 f999 	bl	5898 <digitalWrite>
  digitalWrite(pinLED_B, LOW);
     566:	2100      	movs	r1, #0
     568:	200b      	movs	r0, #11
  pinMode(pinBT_Conf, OUTPUT);
  delay(10);

  digitalWrite(pinBT_Conf, HIGH);
  digitalWrite(pinBT_Reset, HIGH);
  blinkLED(312, 1, 10, 0, 0); // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
     56a:	460c      	mov	r4, r1
  digitalWrite(pinLED_B, LOW);
     56c:	f005 f994 	bl	5898 <digitalWrite>
  Serial2.end();  // end current (if any) Serial2/Bluetooth connections
     570:	4628      	mov	r0, r5
     572:	f004 fec3 	bl	52fc <HardwareSerial::end()>
  pinMode(pinBT_Conf, OUTPUT);
     576:	2101      	movs	r1, #1
     578:	2004      	movs	r0, #4
     57a:	f005 f9c9 	bl	5910 <pinMode>
  delay(10);
     57e:	200a      	movs	r0, #10
     580:	f005 f936 	bl	57f0 <delay>
  digitalWrite(pinBT_Conf, HIGH);
     584:	2101      	movs	r1, #1
     586:	2004      	movs	r0, #4
     588:	f005 f986 	bl	5898 <digitalWrite>
  digitalWrite(pinBT_Reset, HIGH);
     58c:	2101      	movs	r1, #1
     58e:	2005      	movs	r0, #5
     590:	f005 f982 	bl	5898 <digitalWrite>
  blinkLED(312, 1, 10, 0, 0); // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
     594:	4623      	mov	r3, r4
     596:	220a      	movs	r2, #10
     598:	2101      	movs	r1, #1
     59a:	f44f 709c 	mov.w	r0, #312	; 0x138
     59e:	9400      	str	r4, [sp, #0]
     5a0:	f000 f964 	bl	86c <blinkLED(int, int, int, int, int)>
  digitalWrite(pinBT_Reset, LOW);
     5a4:	4621      	mov	r1, r4
     5a6:	2005      	movs	r0, #5
     5a8:	f005 f976 	bl	5898 <digitalWrite>
  delay(100);
     5ac:	2064      	movs	r0, #100	; 0x64
     5ae:	f005 f91f 	bl	57f0 <delay>

  Serial2.begin(38400);  // AT mode requires Baud 38400
     5b2:	4622      	mov	r2, r4
     5b4:	4628      	mov	r0, r5
     5b6:	f44f 4116 	mov.w	r1, #38400	; 0x9600
     5ba:	f004 fd63 	bl	5084 <HardwareSerial::begin(unsigned long, unsigned short)>
							  return write((const uint8_t *)str, strlen(str)); }
     5be:	2204      	movs	r2, #4
     5c0:	4928      	ldr	r1, [pc, #160]	; (664 <btInit()+0x114>)
     5c2:	4628      	mov	r0, r5
     5c4:	f005 f876 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\r', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     5c8:	4623      	mov	r3, r4
     5ca:	220a      	movs	r2, #10
     5cc:	2101      	movs	r1, #1
     5ce:	f44f 709c 	mov.w	r0, #312	; 0x138
     5d2:	9400      	str	r4, [sp, #0]
     5d4:	f000 f94a 	bl	86c <blinkLED(int, int, int, int, int)>
     5d8:	2213      	movs	r2, #19
     5da:	4923      	ldr	r1, [pc, #140]	; (668 <btInit()+0x118>)
     5dc:	4628      	mov	r0, r5
     5de:	f005 f869 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+UART=38400,0,0"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     5e2:	4623      	mov	r3, r4
     5e4:	220a      	movs	r2, #10
     5e6:	2101      	movs	r1, #1
     5e8:	f44f 709c 	mov.w	r0, #312	; 0x138
     5ec:	9400      	str	r4, [sp, #0]
     5ee:	f000 f93d 	bl	86c <blinkLED(int, int, int, int, int)>
     5f2:	2216      	movs	r2, #22
     5f4:	491d      	ldr	r1, [pc, #116]	; (66c <btInit()+0x11c>)
     5f6:	4628      	mov	r0, r5
     5f8:	f005 f85c 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+NAME=OpenHaldexT4"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     5fc:	4623      	mov	r3, r4
     5fe:	220a      	movs	r2, #10
     600:	2101      	movs	r1, #1
     602:	f44f 709c 	mov.w	r0, #312	; 0x138
     606:	9400      	str	r4, [sp, #0]
     608:	f000 f930 	bl	86c <blinkLED(int, int, int, int, int)>
     60c:	220b      	movs	r2, #11
     60e:	4918      	ldr	r1, [pc, #96]	; (670 <btInit()+0x120>)
     610:	4628      	mov	r0, r5
     612:	f005 f84f 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+ROLE=0"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     616:	4623      	mov	r3, r4
     618:	220a      	movs	r2, #10
     61a:	2101      	movs	r1, #1
     61c:	f44f 709c 	mov.w	r0, #312	; 0x138
     620:	9400      	str	r4, [sp, #0]
     622:	f000 f923 	bl	86c <blinkLED(int, int, int, int, int)>
     626:	220a      	movs	r2, #10
     628:	4912      	ldr	r1, [pc, #72]	; (674 <btInit()+0x124>)
     62a:	4628      	mov	r0, r5
     62c:	f005 f842 	bl	56b4 <Print::write(unsigned char const*, unsigned int)>
  Serial.println(F("AT+RESET"));
  while (!Serial2.available()) {}
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     630:	4623      	mov	r3, r4
     632:	2101      	movs	r1, #1
     634:	220a      	movs	r2, #10
     636:	f44f 709c 	mov.w	r0, #312	; 0x138
     63a:	9400      	str	r4, [sp, #0]
     63c:	f000 f916 	bl	86c <blinkLED(int, int, int, int, int)>

  Serial2.end();          // end AT mode
     640:	4628      	mov	r0, r5
     642:	f004 fe5b 	bl	52fc <HardwareSerial::end()>
  Serial2.begin(baudBT);  // begin normal mode with the above baud
     646:	4628      	mov	r0, r5
     648:	4622      	mov	r2, r4
     64a:	f44f 4116 	mov.w	r1, #38400	; 0x9600
     64e:	f004 fd19 	bl	5084 <HardwareSerial::begin(unsigned long, unsigned short)>

  pinMode(pinBT_Conf, INPUT);
     652:	4621      	mov	r1, r4
     654:	2004      	movs	r0, #4

#if stateDebug
  Serial.println(F("Bluetooth initialised!"));
#endif /* stateDebug */
}
     656:	b003      	add	sp, #12
     658:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  pinMode(pinBT_Conf, INPUT);
     65c:	f005 b958 	b.w	5910 <pinMode>
     660:	200067a8 	.word	0x200067a8
     664:	20000300 	.word	0x20000300
     668:	20000308 	.word	0x20000308
     66c:	2000031c 	.word	0x2000031c
     670:	20000334 	.word	0x20000334
     674:	20000340 	.word	0x20000340

00000678 <checkSwitchMode()>:
#include "openhaldex.h"

void checkSwitchMode() {
     678:	b510      	push	{r4, lr}
  int i = 0;
     67a:	2400      	movs	r4, #0
#if stateDebug
  Serial.println(F("Switch mode button pressed!"));
#endif /* stateDebug */

  while (digitalRead(pinBT_Conf) && (i < 11)) {
     67c:	e01c      	b.n	6b8 <checkSwitchMode()+0x40>
  }
}

void blinkLED(int duration, int flashes, int R, int G, int B) {
  for (int i = 0; i < flashes; i++) {
    delay(duration);
     67e:	f005 f8b7 	bl	57f0 <delay>
    analogWrite(pinLED_R, R);
     682:	2105      	movs	r1, #5
     684:	200c      	movs	r0, #12
     686:	f005 fd1b 	bl	60c0 <analogWrite>
    analogWrite(pinLED_G, G);
     68a:	2100      	movs	r1, #0
     68c:	200a      	movs	r0, #10
     68e:	f005 fd17 	bl	60c0 <analogWrite>
    analogWrite(pinLED_B, B);
     692:	2105      	movs	r1, #5
     694:	200b      	movs	r0, #11
     696:	f005 fd13 	bl	60c0 <analogWrite>
    delay(duration);
     69a:	2064      	movs	r0, #100	; 0x64
     69c:	f005 f8a8 	bl	57f0 <delay>
    analogWrite(pinLED_R, 0);
     6a0:	2100      	movs	r1, #0
     6a2:	200c      	movs	r0, #12
     6a4:	f005 fd0c 	bl	60c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     6a8:	2100      	movs	r1, #0
     6aa:	200a      	movs	r0, #10
     6ac:	f005 fd08 	bl	60c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     6b0:	2100      	movs	r1, #0
     6b2:	200b      	movs	r0, #11
     6b4:	f005 fd04 	bl	60c0 <analogWrite>
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     6b8:	2004      	movs	r0, #4
     6ba:	f005 f917 	bl	58ec <digitalRead>
     6be:	4603      	mov	r3, r0
    delay(duration);
     6c0:	2064      	movs	r0, #100	; 0x64
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     6c2:	b363      	cbz	r3, 71e <checkSwitchMode()+0xa6>
     6c4:	2c0b      	cmp	r4, #11
    i++;
     6c6:	f104 0401 	add.w	r4, r4, #1
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     6ca:	d1d8      	bne.n	67e <checkSwitchMode()+0x6>
    isStandalone = !isStandalone;
     6cc:	4a45      	ldr	r2, [pc, #276]	; (7e4 <checkSwitchMode()+0x16c>)
     6ce:	240b      	movs	r4, #11
     6d0:	7813      	ldrb	r3, [r2, #0]
     6d2:	f083 0301 	eor.w	r3, r3, #1
     6d6:	7013      	strb	r3, [r2, #0]
    delay(duration);
     6d8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     6dc:	f005 f888 	bl	57f0 <delay>
    analogWrite(pinLED_R, R);
     6e0:	2105      	movs	r1, #5
     6e2:	200c      	movs	r0, #12
     6e4:	f005 fcec 	bl	60c0 <analogWrite>
    analogWrite(pinLED_G, G);
     6e8:	2100      	movs	r1, #0
     6ea:	200a      	movs	r0, #10
     6ec:	f005 fce8 	bl	60c0 <analogWrite>
    analogWrite(pinLED_B, B);
     6f0:	2105      	movs	r1, #5
     6f2:	200b      	movs	r0, #11
     6f4:	f005 fce4 	bl	60c0 <analogWrite>
    delay(duration);
     6f8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     6fc:	f005 f878 	bl	57f0 <delay>
    analogWrite(pinLED_R, 0);
     700:	2100      	movs	r1, #0
     702:	200c      	movs	r0, #12
     704:	f005 fcdc 	bl	60c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     708:	2100      	movs	r1, #0
     70a:	200a      	movs	r0, #10
     70c:	f005 fcd8 	bl	60c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     710:	2100      	movs	r1, #0
     712:	200b      	movs	r0, #11
     714:	f005 fcd4 	bl	60c0 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     718:	3c01      	subs	r4, #1
     71a:	d1dd      	bne.n	6d8 <checkSwitchMode()+0x60>
     71c:	e001      	b.n	722 <checkSwitchMode()+0xaa>
  if (i >= 11) {
     71e:	2c0b      	cmp	r4, #11
     720:	d0d4      	beq.n	6cc <checkSwitchMode()+0x54>
  buttonToggle++;
     722:	4a31      	ldr	r2, [pc, #196]	; (7e8 <checkSwitchMode()+0x170>)
     724:	6813      	ldr	r3, [r2, #0]
     726:	3301      	adds	r3, #1
  if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     728:	2b03      	cmp	r3, #3
  buttonToggle++;
     72a:	6013      	str	r3, [r2, #0]
  if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     72c:	dd0d      	ble.n	74a <checkSwitchMode()+0xd2>
    buttonToggle = 0;
     72e:	2300      	movs	r3, #0
     730:	6013      	str	r3, [r2, #0]
      if (isStandalone) {  // jump over 'stock' since it's Standalone and can't see Body CAN
     732:	4b2c      	ldr	r3, [pc, #176]	; (7e4 <checkSwitchMode()+0x16c>)
     734:	781b      	ldrb	r3, [r3, #0]
     736:	2b00      	cmp	r3, #0
     738:	d041      	beq.n	7be <checkSwitchMode()+0x146>
        buttonToggle++;
     73a:	2301      	movs	r3, #1
     73c:	6013      	str	r3, [r2, #0]
  delay(300);  // reduce button bashing
     73e:	f44f 7096 	mov.w	r0, #300	; 0x12c
}
     742:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  delay(300);  // reduce button bashing
     746:	f005 b853 	b.w	57f0 <delay>
  switch (buttonToggle) {
     74a:	2b03      	cmp	r3, #3
     74c:	d8f7      	bhi.n	73e <checkSwitchMode()+0xc6>
     74e:	a101      	add	r1, pc, #4	; (adr r1, 754 <checkSwitchMode()+0xdc>)
     750:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
     754:	00000733 	.word	0x00000733
     758:	00000791 	.word	0x00000791
     75c:	00000779 	.word	0x00000779
     760:	00000765 	.word	0x00000765
      if (isStandalone) {
     764:	4b1f      	ldr	r3, [pc, #124]	; (7e4 <checkSwitchMode()+0x16c>)
     766:	781b      	ldrb	r3, [r3, #0]
     768:	b9eb      	cbnz	r3, 7a6 <checkSwitchMode()+0x12e>
      if (!isCustom) {
     76a:	4b20      	ldr	r3, [pc, #128]	; (7ec <checkSwitchMode()+0x174>)
     76c:	781b      	ldrb	r3, [r3, #0]
     76e:	bb73      	cbnz	r3, 7ce <checkSwitchMode()+0x156>
        state.mode = MODE_STOCK;
     770:	491f      	ldr	r1, [pc, #124]	; (7f0 <checkSwitchMode()+0x178>)
        buttonToggle = 0;
     772:	6013      	str	r3, [r2, #0]
        state.mode = MODE_STOCK;
     774:	700b      	strb	r3, [r1, #0]
        break;
     776:	e7e2      	b.n	73e <checkSwitchMode()+0xc6>
      state.mode_override = true;
     778:	4b1d      	ldr	r3, [pc, #116]	; (7f0 <checkSwitchMode()+0x178>)
     77a:	2101      	movs	r1, #1
      state.mode = MODE_5050;
     77c:	2202      	movs	r2, #2
  delay(300);  // reduce button bashing
     77e:	f44f 7096 	mov.w	r0, #300	; 0x12c
      state.mode_override = true;
     782:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
      state.mode = MODE_5050;
     786:	701a      	strb	r2, [r3, #0]
}
     788:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  delay(300);  // reduce button bashing
     78c:	f005 b830 	b.w	57f0 <delay>
      state.mode_override = true;
     790:	4b17      	ldr	r3, [pc, #92]	; (7f0 <checkSwitchMode()+0x178>)
     792:	2201      	movs	r2, #1
  delay(300);  // reduce button bashing
     794:	f44f 7096 	mov.w	r0, #300	; 0x12c
      state.mode_override = true;
     798:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
      state.mode = MODE_FWD;
     79c:	701a      	strb	r2, [r3, #0]
}
     79e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  delay(300);  // reduce button bashing
     7a2:	f005 b825 	b.w	57f0 <delay>
        state.mode_override = true;
     7a6:	2301      	movs	r3, #1
     7a8:	4911      	ldr	r1, [pc, #68]	; (7f0 <checkSwitchMode()+0x178>)
  delay(300);  // reduce button bashing
     7aa:	f44f 7096 	mov.w	r0, #300	; 0x12c
        buttonToggle = 1;
     7ae:	6013      	str	r3, [r2, #0]
        state.mode_override = true;
     7b0:	f881 3023 	strb.w	r3, [r1, #35]	; 0x23
        state.mode = MODE_FWD;
     7b4:	700b      	strb	r3, [r1, #0]
}
     7b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  delay(300);  // reduce button bashing
     7ba:	f005 b819 	b.w	57f0 <delay>
      state.mode = MODE_STOCK;
     7be:	4a0c      	ldr	r2, [pc, #48]	; (7f0 <checkSwitchMode()+0x178>)
  delay(300);  // reduce button bashing
     7c0:	f44f 7096 	mov.w	r0, #300	; 0x12c
}
     7c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      state.mode = MODE_STOCK;
     7c8:	7013      	strb	r3, [r2, #0]
  delay(300);  // reduce button bashing
     7ca:	f005 b811 	b.w	57f0 <delay>
      state.mode_override = true;
     7ce:	4b08      	ldr	r3, [pc, #32]	; (7f0 <checkSwitchMode()+0x178>)
     7d0:	2401      	movs	r4, #1
      state.mode = MODE_CUSTOM;
     7d2:	2003      	movs	r0, #3
      buttonToggle = -1;
     7d4:	f04f 31ff 	mov.w	r1, #4294967295
      state.mode_override = true;
     7d8:	f883 4023 	strb.w	r4, [r3, #35]	; 0x23
      state.mode = MODE_CUSTOM;
     7dc:	7018      	strb	r0, [r3, #0]
      buttonToggle = -1;
     7de:	6011      	str	r1, [r2, #0]
      break;
     7e0:	e7ad      	b.n	73e <checkSwitchMode()+0xc6>
     7e2:	bf00      	nop
     7e4:	20006ae3 	.word	0x20006ae3
     7e8:	200068ac 	.word	0x200068ac
     7ec:	20006ae1 	.word	0x20006ae1
     7f0:	20006950 	.word	0x20006950

000007f4 <LED()>:
void LED() {
     7f4:	b508      	push	{r3, lr}
  switch (state.mode) {
     7f6:	4b1c      	ldr	r3, [pc, #112]	; (868 <LED()+0x74>)
     7f8:	781b      	ldrb	r3, [r3, #0]
     7fa:	2b03      	cmp	r3, #3
     7fc:	d833      	bhi.n	866 <LED()+0x72>
     7fe:	e8df f003 	tbb	[pc, r3]
     802:	1e2c      	.short	0x1e2c
     804:	0210      	.short	0x0210
      analogWrite(pinLED_R, 5);
     806:	2105      	movs	r1, #5
     808:	200c      	movs	r0, #12
     80a:	f005 fc59 	bl	60c0 <analogWrite>
      analogWrite(pinLED_G, 0);
     80e:	2100      	movs	r1, #0
     810:	200a      	movs	r0, #10
     812:	f005 fc55 	bl	60c0 <analogWrite>
      analogWrite(pinLED_B, 5);
     816:	2105      	movs	r1, #5
     818:	200b      	movs	r0, #11
}
     81a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 5);
     81e:	f005 bc4f 	b.w	60c0 <analogWrite>
      analogWrite(pinLED_R, 0);
     822:	2100      	movs	r1, #0
     824:	200c      	movs	r0, #12
     826:	f005 fc4b 	bl	60c0 <analogWrite>
      analogWrite(pinLED_G, 0);
     82a:	2100      	movs	r1, #0
     82c:	200a      	movs	r0, #10
     82e:	f005 fc47 	bl	60c0 <analogWrite>
      analogWrite(pinLED_B, 10);
     832:	210a      	movs	r1, #10
     834:	200b      	movs	r0, #11
}
     836:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 10);
     83a:	f005 bc41 	b.w	60c0 <analogWrite>
      analogWrite(pinLED_R, 0);
     83e:	2100      	movs	r1, #0
     840:	200c      	movs	r0, #12
     842:	f005 fc3d 	bl	60c0 <analogWrite>
      analogWrite(pinLED_G, 10);
     846:	210a      	movs	r1, #10
      analogWrite(pinLED_G, 0);
     848:	200a      	movs	r0, #10
     84a:	f005 fc39 	bl	60c0 <analogWrite>
      analogWrite(pinLED_B, 0);
     84e:	2100      	movs	r1, #0
     850:	200b      	movs	r0, #11
}
     852:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 0);
     856:	f005 bc33 	b.w	60c0 <analogWrite>
      analogWrite(pinLED_R, 10);
     85a:	210a      	movs	r1, #10
     85c:	200c      	movs	r0, #12
     85e:	f005 fc2f 	bl	60c0 <analogWrite>
      analogWrite(pinLED_G, 0);
     862:	2100      	movs	r1, #0
     864:	e7f0      	b.n	848 <LED()+0x54>
}
     866:	bd08      	pop	{r3, pc}
     868:	20006950 	.word	0x20006950

0000086c <blinkLED(int, int, int, int, int)>:
void blinkLED(int duration, int flashes, int R, int G, int B) {
     86c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (int i = 0; i < flashes; i++) {
     870:	1e0e      	subs	r6, r1, #0
void blinkLED(int duration, int flashes, int R, int G, int B) {
     872:	f8dd 9020 	ldr.w	r9, [sp, #32]
  for (int i = 0; i < flashes; i++) {
     876:	dd24      	ble.n	8c2 <blinkLED(int, int, int, int, int)+0x56>
     878:	4605      	mov	r5, r0
     87a:	4617      	mov	r7, r2
     87c:	4698      	mov	r8, r3
     87e:	2400      	movs	r4, #0
    delay(duration);
     880:	4628      	mov	r0, r5
  for (int i = 0; i < flashes; i++) {
     882:	3401      	adds	r4, #1
    delay(duration);
     884:	f004 ffb4 	bl	57f0 <delay>
    analogWrite(pinLED_R, R);
     888:	4639      	mov	r1, r7
     88a:	200c      	movs	r0, #12
     88c:	f005 fc18 	bl	60c0 <analogWrite>
    analogWrite(pinLED_G, G);
     890:	4641      	mov	r1, r8
     892:	200a      	movs	r0, #10
     894:	f005 fc14 	bl	60c0 <analogWrite>
    analogWrite(pinLED_B, B);
     898:	4649      	mov	r1, r9
     89a:	200b      	movs	r0, #11
     89c:	f005 fc10 	bl	60c0 <analogWrite>
    delay(duration);
     8a0:	4628      	mov	r0, r5
     8a2:	f004 ffa5 	bl	57f0 <delay>
    analogWrite(pinLED_R, 0);
     8a6:	2100      	movs	r1, #0
     8a8:	200c      	movs	r0, #12
     8aa:	f005 fc09 	bl	60c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     8ae:	2100      	movs	r1, #0
     8b0:	200a      	movs	r0, #10
     8b2:	f005 fc05 	bl	60c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     8b6:	2100      	movs	r1, #0
     8b8:	200b      	movs	r0, #11
     8ba:	f005 fc01 	bl	60c0 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     8be:	42a6      	cmp	r6, r4
     8c0:	d1de      	bne.n	880 <blinkLED(int, int, int, int, int)+0x14>
  }
     8c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     8c6:	bf00      	nop

000008c8 <_GLOBAL__sub_I__Z15checkSwitchModev>:
     8c8:	f005 b888 	b.w	59dc <eeprom_initialize>

000008cc <get_lockTarget_adjusted_value(unsigned char)>:

  return target;
}

static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
  if (state.mode == MODE_5050) {
     8cc:	4b1c      	ldr	r3, [pc, #112]	; (940 <get_lockTarget_adjusted_value(unsigned char)+0x74>)
     8ce:	781a      	ldrb	r2, [r3, #0]
     8d0:	2a02      	cmp	r2, #2
     8d2:	d022      	beq.n	91a <get_lockTarget_adjusted_value(unsigned char)+0x4e>
    }

    return 0;
  } else {
    // Potentially avoid doing math below..
    if (lockTarget == 0) {
     8d4:	4b1b      	ldr	r3, [pc, #108]	; (944 <get_lockTarget_adjusted_value(unsigned char)+0x78>)
     8d6:	ed93 7a00 	vldr	s14, [r3]
     8da:	eeb5 7a40 	vcmp.f32	s14, #0.0
     8de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     8e2:	d101      	bne.n	8e8 <get_lockTarget_adjusted_value(unsigned char)+0x1c>
    return 0;
     8e4:	2000      	movs	r0, #0
     8e6:	4770      	bx	lr

    /* Hackery to get the response closer to the target... we are trying to control the
        Haldex as if it's linear.. but it's not. In future, I'd like to implement some sort
        of feedback loop to trim the calculation being made here but this will do for now.  */
    float target_fudge_factor = lockTarget;
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     8e8:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5

    return value * (target_fudge_factor / 100);
     8ec:	ed9f 6a16 	vldr	s12, [pc, #88]	; 948 <get_lockTarget_adjusted_value(unsigned char)+0x7c>
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     8f0:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    return value * (target_fudge_factor / 100);
     8f4:	ee07 0a90 	vmov	s15, r0
static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
     8f8:	b082      	sub	sp, #8
    return value * (target_fudge_factor / 100);
     8fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     8fe:	eee7 6a25 	vfma.f32	s13, s14, s11
    return value * (target_fudge_factor / 100);
     902:	ee86 7a86 	vdiv.f32	s14, s13, s12
     906:	ee67 7a87 	vmul.f32	s15, s15, s14
     90a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
     90e:	edcd 7a01 	vstr	s15, [sp, #4]
     912:	f89d 0004 	ldrb.w	r0, [sp, #4]
  }
}
     916:	b002      	add	sp, #8
     918:	4770      	bx	lr
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0) {
     91a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     91e:	4a0b      	ldr	r2, [pc, #44]	; (94c <get_lockTarget_adjusted_value(unsigned char)+0x80>)
     920:	ee07 3a90 	vmov	s15, r3
     924:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     928:	edd2 7a00 	vldr	s15, [r2]
     92c:	eeb4 7ae7 	vcmpe.f32	s14, s15
     930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     934:	d903      	bls.n	93e <get_lockTarget_adjusted_value(unsigned char)+0x72>
      return value;
     936:	2b00      	cmp	r3, #0
     938:	bf18      	it	ne
     93a:	2000      	movne	r0, #0
     93c:	4770      	bx	lr
}
     93e:	4770      	bx	lr
     940:	20006950 	.word	0x20006950
     944:	200068c4 	.word	0x200068c4
     948:	42c80000 	.word	0x42c80000
     94c:	200068e0 	.word	0x200068e0

00000950 <getLockData(CAN_message_t*)>:

void getLockData(CAN_message_t *frame) {
     950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (state.mode == MODE_5050) {
     954:	4d6e      	ldr	r5, [pc, #440]	; (b10 <getLockData(CAN_message_t*)+0x1c0>)
void getLockData(CAN_message_t *frame) {
     956:	4604      	mov	r4, r0
  if (state.mode == MODE_5050) {
     958:	782b      	ldrb	r3, [r5, #0]
     95a:	2b02      	cmp	r3, #2
     95c:	f000 8092 	beq.w	a84 <getLockData(CAN_message_t*)+0x134>
  } else if (state.mode == MODE_FWD) {
     960:	2b01      	cmp	r3, #1
     962:	d060      	beq.n	a26 <getLockData(CAN_message_t*)+0xd6>
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     964:	f895 0021 	ldrb.w	r0, [r5, #33]	; 0x21
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     968:	f895 e001 	ldrb.w	lr, [r5, #1]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     96c:	1e43      	subs	r3, r0, #1
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     96e:	78af      	ldrb	r7, [r5, #2]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     970:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     974:	442b      	add	r3, r5
     976:	f893 8001 	ldrb.w	r8, [r3, #1]
     97a:	789e      	ldrb	r6, [r3, #2]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     97c:	b1d8      	cbz	r0, 9b6 <getLockData(CAN_message_t*)+0x66>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     97e:	4b65      	ldr	r3, [pc, #404]	; (b14 <getLockData(CAN_message_t*)+0x1c4>)
     980:	462a      	mov	r2, r5
     982:	4671      	mov	r1, lr
     984:	f893 c000 	ldrb.w	ip, [r3]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     988:	2300      	movs	r3, #0
     98a:	e003      	b.n	994 <getLockData(CAN_message_t*)+0x44>
     98c:	3301      	adds	r3, #1
     98e:	4298      	cmp	r0, r3
     990:	d011      	beq.n	9b6 <getLockData(CAN_message_t*)+0x66>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     992:	7851      	ldrb	r1, [r2, #1]
     994:	458c      	cmp	ip, r1
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     996:	f102 0203 	add.w	r2, r2, #3
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     99a:	d8f7      	bhi.n	98c <getLockData(CAN_message_t*)+0x3c>
      lp_upper = state.custom_mode.lockpoints[i];
     99c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
     9a0:	442a      	add	r2, r5
     9a2:	7896      	ldrb	r6, [r2, #2]
      lp_lower = state.custom_mode.lockpoints[(i == 0) ? 0 : i - 1];
     9a4:	b133      	cbz	r3, 9b4 <getLockData(CAN_message_t*)+0x64>
     9a6:	3b01      	subs	r3, #1
     9a8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     9ac:	442b      	add	r3, r5
     9ae:	f893 e001 	ldrb.w	lr, [r3, #1]
     9b2:	789f      	ldrb	r7, [r3, #2]
      break;
     9b4:	4688      	mov	r8, r1
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     9b6:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
     9ba:	4a57      	ldr	r2, [pc, #348]	; (b18 <getLockData(CAN_message_t*)+0x1c8>)
     9bc:	ee07 3a90 	vmov	s15, r3
     9c0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     9c4:	edd2 7a00 	vldr	s15, [r2]
     9c8:	eeb4 7ae7 	vcmpe.f32	s14, s15
     9cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     9d0:	d823      	bhi.n	a1a <getLockData(CAN_message_t*)+0xca>
    if (vehicleSpeed <= lp_lower.speed) {
     9d2:	4b50      	ldr	r3, [pc, #320]	; (b14 <getLockData(CAN_message_t*)+0x1c4>)
     9d4:	781b      	ldrb	r3, [r3, #0]
     9d6:	4573      	cmp	r3, lr
     9d8:	f240 8095 	bls.w	b06 <getLockData(CAN_message_t*)+0x1b6>
    if (vehicleSpeed >= lp_upper.speed) {
     9dc:	4543      	cmp	r3, r8
     9de:	f080 808a 	bcs.w	af6 <getLockData(CAN_message_t*)+0x1a6>
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     9e2:	eba8 080e 	sub.w	r8, r8, lr
     9e6:	eba3 030e 	sub.w	r3, r3, lr
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     9ea:	1bf6      	subs	r6, r6, r7
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     9ec:	ee07 8a90 	vmov	s15, r8
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     9f0:	ee06 6a90 	vmov	s13, r6
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     9f4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     9f8:	ee07 3a90 	vmov	s15, r3
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     9fc:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     a00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     a04:	ee87 6a27 	vdiv.f32	s12, s14, s15
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     a08:	ee07 7a90 	vmov	s15, r7
     a0c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     a10:	eec6 7a86 	vdiv.f32	s15, s13, s12
     a14:	ee77 7a87 	vadd.f32	s15, s15, s14
     a18:	e007      	b.n	a2a <getLockData(CAN_message_t*)+0xda>
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     a1a:	2b00      	cmp	r3, #0
     a1c:	d0d9      	beq.n	9d2 <getLockData(CAN_message_t*)+0x82>
     a1e:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
     a22:	2b00      	cmp	r3, #0
     a24:	d1d5      	bne.n	9d2 <getLockData(CAN_message_t*)+0x82>
      return 0;
     a26:	eddf 7a3d 	vldr	s15, [pc, #244]	; b1c <getLockData(CAN_message_t*)+0x1cc>
  // returns 100 if 5050 AND doing something (PED>0 etc), 0 if FWD
  // assumed frame.buf[1] = 0 x (0xF0)?
  // assumed frame.buf[1] = Value x (0xF0)?
  // assumed frame.buf[1] = 100 x (0xF0)?

  switch (frame->id) {
     a2a:	6823      	ldr	r3, [r4, #0]
  lockTarget = get_lockTarget_adjustment();  
     a2c:	4a3c      	ldr	r2, [pc, #240]	; (b20 <getLockData(CAN_message_t*)+0x1d0>)
  switch (frame->id) {
     a2e:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
  lockTarget = get_lockTarget_adjustment();  
     a32:	edc2 7a00 	vstr	s15, [r2]
  switch (frame->id) {
     a36:	d053      	beq.n	ae0 <getLockData(CAN_message_t*)+0x190>
     a38:	d83d      	bhi.n	ab6 <getLockData(CAN_message_t*)+0x166>
     a3a:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
     a3e:	d04a      	beq.n	ad6 <getLockData(CAN_message_t*)+0x186>
     a40:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
     a44:	d11c      	bne.n	a80 <getLockData(CAN_message_t*)+0x130>
    case MOTOR1_ID:
      frame->buf[0] = 0;
     a46:	2300      	movs	r3, #0
      frame->buf[1] = get_lockTarget_adjusted_value(0xf0);
     a48:	20f0      	movs	r0, #240	; 0xf0
      frame->buf[2] = 0x20;
     a4a:	2120      	movs	r1, #32
      frame->buf[0] = 0;
     a4c:	7323      	strb	r3, [r4, #12]
      frame->buf[1] = get_lockTarget_adjusted_value(0xf0);
     a4e:	f7ff ff3d 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     a52:	4603      	mov	r3, r0
      frame->buf[2] = 0x20;
     a54:	73a1      	strb	r1, [r4, #14]
      frame->buf[3] = get_lockTarget_adjusted_value(0x4e);
     a56:	204e      	movs	r0, #78	; 0x4e
      frame->buf[1] = get_lockTarget_adjusted_value(0xf0);
     a58:	7363      	strb	r3, [r4, #13]
      frame->buf[3] = get_lockTarget_adjusted_value(0x4e);
     a5a:	f7ff ff37 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     a5e:	4603      	mov	r3, r0
      frame->buf[4] = get_lockTarget_adjusted_value(0xf0);
     a60:	20f0      	movs	r0, #240	; 0xf0
      frame->buf[3] = get_lockTarget_adjusted_value(0x4e);
     a62:	73e3      	strb	r3, [r4, #15]
      frame->buf[4] = get_lockTarget_adjusted_value(0xf0);
     a64:	f7ff ff32 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     a68:	4603      	mov	r3, r0
      frame->buf[5] = get_lockTarget_adjusted_value(0xf0);
     a6a:	20f0      	movs	r0, #240	; 0xf0
      frame->buf[4] = get_lockTarget_adjusted_value(0xf0);
     a6c:	7423      	strb	r3, [r4, #16]
      frame->buf[5] = get_lockTarget_adjusted_value(0xf0);
     a6e:	f7ff ff2d 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     a72:	4603      	mov	r3, r0
      frame->buf[6] = 0x20;
     a74:	74a1      	strb	r1, [r4, #18]
      frame->buf[7] = get_lockTarget_adjusted_value(0xf0);
     a76:	20f0      	movs	r0, #240	; 0xf0
      frame->buf[5] = get_lockTarget_adjusted_value(0xf0);
     a78:	7463      	strb	r3, [r4, #17]
      frame->buf[7] = get_lockTarget_adjusted_value(0xf0);
     a7a:	f7ff ff27 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     a7e:	74e0      	strb	r0, [r4, #19]
      //frame->buf[1] &= ~0x8;
      frame->buf[2] = 0x0;
      frame->buf[3] = 0xa;
      break;
  }
     a80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     a84:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
     a88:	4a23      	ldr	r2, [pc, #140]	; (b18 <getLockData(CAN_message_t*)+0x1c8>)
     a8a:	ee07 3a90 	vmov	s15, r3
     a8e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     a92:	edd2 7a00 	vldr	s15, [r2]
     a96:	eeb4 7ae7 	vcmpe.f32	s14, s15
     a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a9e:	d92f      	bls.n	b00 <getLockData(CAN_message_t*)+0x1b0>
     aa0:	b373      	cbz	r3, b00 <getLockData(CAN_message_t*)+0x1b0>
     aa2:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
      return 100;
     aa6:	eddf 7a1d 	vldr	s15, [pc, #116]	; b1c <getLockData(CAN_message_t*)+0x1cc>
     aaa:	ed9f 7a1e 	vldr	s14, [pc, #120]	; b24 <getLockData(CAN_message_t*)+0x1d4>
     aae:	2b00      	cmp	r3, #0
     ab0:	fe47 7a87 	vseleq.f32	s15, s15, s14
     ab4:	e7b9      	b.n	a2a <getLockData(CAN_message_t*)+0xda>
  switch (frame->id) {
     ab6:	f5b3 6f94 	cmp.w	r3, #1184	; 0x4a0
     aba:	d1e1      	bne.n	a80 <getLockData(CAN_message_t*)+0x130>
      adjusted_slip = get_lockTarget_adjusted_value(0xff);
     abc:	20ff      	movs	r0, #255	; 0xff
     abe:	f7ff ff05 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
      frame->buf[1] = 0xa;
     ac2:	230a      	movs	r3, #10
      frame->buf[4] = 0x0;
     ac4:	f04f 220a 	mov.w	r2, #167774720	; 0xa000a00
      frame->buf[0] = adjusted_slip;
     ac8:	7320      	strb	r0, [r4, #12]
      frame->buf[1] = 0xa;
     aca:	7363      	strb	r3, [r4, #13]
      frame->buf[3] = 0xa;
     acc:	73e3      	strb	r3, [r4, #15]
      frame->buf[2] = adjusted_slip;
     ace:	73a0      	strb	r0, [r4, #14]
      frame->buf[4] = 0x0;
     ad0:	6122      	str	r2, [r4, #16]
     ad2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = 0x0;
     ad6:	f44f 6320 	mov.w	r3, #2560	; 0xa00
     ada:	81e3      	strh	r3, [r4, #14]
     adc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = get_lockTarget_adjusted_value(0xfa);
     ae0:	20fa      	movs	r0, #250	; 0xfa
     ae2:	f7ff fef3 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     ae6:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xfe);
     ae8:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[2] = get_lockTarget_adjusted_value(0xfa);
     aea:	73a3      	strb	r3, [r4, #14]
      frame->buf[7] = get_lockTarget_adjusted_value(0xfe);
     aec:	f7ff feee 	bl	8cc <get_lockTarget_adjusted_value(unsigned char)>
     af0:	74e0      	strb	r0, [r4, #19]
     af2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return lp_upper.lock;
     af6:	ee07 6a90 	vmov	s15, r6
     afa:	eef8 7a67 	vcvt.f32.u32	s15, s15
     afe:	e794      	b.n	a2a <getLockData(CAN_message_t*)+0xda>
      return 100;
     b00:	eddf 7a08 	vldr	s15, [pc, #32]	; b24 <getLockData(CAN_message_t*)+0x1d4>
     b04:	e791      	b.n	a2a <getLockData(CAN_message_t*)+0xda>
      return lp_lower.lock;
     b06:	ee07 7a90 	vmov	s15, r7
     b0a:	eef8 7a67 	vcvt.f32.u32	s15, s15
     b0e:	e78c      	b.n	a2a <getLockData(CAN_message_t*)+0xda>
     b10:	20006950 	.word	0x20006950
     b14:	20006aee 	.word	0x20006aee
     b18:	200068e0 	.word	0x200068e0
     b1c:	00000000 	.word	0x00000000
     b20:	200068c4 	.word	0x200068c4
     b24:	42c80000 	.word	0x42c80000

00000b28 <_GLOBAL__sub_I_lockTarget>:
     b28:	f004 bf58 	b.w	59dc <eeprom_initialize>

00000b2c <CANListener::frameHandler(CAN_message_t&, int, unsigned char)>:
#define SIZE_LISTENERS 4

class CANListener {
  public:
    CANListener () { callbacksActive = 0; }
    virtual bool frameHandler (CAN_message_t &frame, int mailbox, uint8_t controller) { return false; }
     b2c:	2000      	movs	r0, #0
     b2e:	4770      	bx	lr

00000b30 <flexcan_isr_can1()>:
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
}

#if defined(__IMXRT1062__)
static void flexcan_isr_can1() {
  if ( _CAN1 ) _CAN1->flexcan_interrupt();
     b30:	4b03      	ldr	r3, [pc, #12]	; (b40 <flexcan_isr_can1()+0x10>)
     b32:	6818      	ldr	r0, [r3, #0]
     b34:	b110      	cbz	r0, b3c <flexcan_isr_can1()+0xc>
     b36:	6803      	ldr	r3, [r0, #0]
     b38:	681b      	ldr	r3, [r3, #0]
     b3a:	4718      	bx	r3
}
     b3c:	4770      	bx	lr
     b3e:	bf00      	nop
     b40:	20006870 	.word	0x20006870

00000b44 <flexcan_isr_can2()>:

static void flexcan_isr_can2() {
  if ( _CAN2 ) _CAN2->flexcan_interrupt();
     b44:	4b03      	ldr	r3, [pc, #12]	; (b54 <flexcan_isr_can2()+0x10>)
     b46:	6818      	ldr	r0, [r3, #0]
     b48:	b110      	cbz	r0, b50 <flexcan_isr_can2()+0xc>
     b4a:	6803      	ldr	r3, [r0, #0]
     b4c:	681b      	ldr	r3, [r3, #0]
     b4e:	4718      	bx	r3
}
     b50:	4770      	bx	lr
     b52:	bf00      	nop
     b54:	20006874 	.word	0x20006874

00000b58 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     b58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
     b5c:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     b60:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     b62:	4c57      	ldr	r4, [pc, #348]	; (cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     b64:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     b66:	4b57      	ldr	r3, [pc, #348]	; (cc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     b68:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
     b6a:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     b6e:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     b70:	4855      	ldr	r0, [pc, #340]	; (cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     b72:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     b76:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     b78:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     b7a:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     b7e:	446b      	add	r3, sp
     b80:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
     b84:	4b51      	ldr	r3, [pc, #324]	; (ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
     b86:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     b8a:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     b8c:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     b90:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     b94:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     b98:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     b9a:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     b9c:	6803      	ldr	r3, [r0, #0]
     b9e:	01df      	lsls	r7, r3, #7
     ba0:	d5fc      	bpl.n	b9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
     ba2:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     ba4:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
     ba8:	d92a      	bls.n	c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     baa:	4660      	mov	r0, ip
     bac:	1c83      	adds	r3, r0, #2
    divisor++;
     bae:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
     bb0:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
     bb4:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
     bb6:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
     bba:	d8f7      	bhi.n	bac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     bbc:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
     bc0:	fbb6 f3f3 	udiv	r3, r6, r3
     bc4:	1acb      	subs	r3, r1, r3
     bc6:	2b00      	cmp	r3, #0
     bc8:	bfb8      	it	lt
     bca:	425b      	neglt	r3, r3
      if (error < bestError) {
     bcc:	42ab      	cmp	r3, r5
     bce:	db0b      	blt.n	be8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
     bd0:	f1a7 030c 	sub.w	r3, r7, #12
     bd4:	bf18      	it	ne
     bd6:	f04f 0800 	movne.w	r8, #0
     bda:	2b06      	cmp	r3, #6
     bdc:	d80a      	bhi.n	bf4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
     bde:	f1b8 0f00 	cmp.w	r8, #0
     be2:	d007      	beq.n	bf4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
     be4:	4684      	mov	ip, r0
     be6:	e7e1      	b.n	bac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     be8:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
     bea:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
     bee:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
     bf0:	2b06      	cmp	r3, #6
     bf2:	d9f4      	bls.n	bde <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
     bf4:	2f05      	cmp	r7, #5
     bf6:	d8d9      	bhi.n	bac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
     bf8:	f10c 0301 	add.w	r3, ip, #1
     bfc:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
     c00:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
     c04:	f1a2 0205 	sub.w	r2, r2, #5
     c08:	dc4c      	bgt.n	ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
     c0a:	2a14      	cmp	r2, #20
     c0c:	d84a      	bhi.n	ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     c0e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
     c12:	4f2f      	ldr	r7, [pc, #188]	; (cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
     c14:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     c16:	f8df 80b0 	ldr.w	r8, [pc, #176]	; cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     c1a:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     c1e:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     c22:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
     c26:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     c28:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     c2a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     c2c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     c2e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     c30:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     c32:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
     c36:	c607      	stmia	r6!, {r0, r1, r2}
     c38:	f826 3b02 	strh.w	r3, [r6], #2
     c3c:	ea4f 4313 	mov.w	r3, r3, lsr #16
     c40:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     c42:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     c46:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     c4a:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     c4e:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     c52:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     c56:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
     c5a:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     c5e:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     c62:	ea43 0302 	orr.w	r3, r3, r2
     c66:	ea43 0301 	orr.w	r3, r3, r1
     c6a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     c6e:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
     c72:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     c76:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     c7a:	f8d8 3004 	ldr.w	r3, [r8, #4]
     c7e:	bf14      	ite	ne
     c80:	f023 0308 	bicne.w	r3, r3, #8
     c84:	f043 0308 	orreq.w	r3, r3, #8
     c88:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     c8c:	b93c      	cbnz	r4, c9e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     c8e:	4a0e      	ldr	r2, [pc, #56]	; (cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     c90:	6813      	ldr	r3, [r2, #0]
     c92:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     c96:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     c98:	6813      	ldr	r3, [r2, #0]
     c9a:	01db      	lsls	r3, r3, #7
     c9c:	d4fc      	bmi.n	c98 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
     c9e:	b010      	add	sp, #64	; 0x40
     ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     ca4:	2c00      	cmp	r4, #0
     ca6:	d1fa      	bne.n	c9e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     ca8:	4a07      	ldr	r2, [pc, #28]	; (cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     caa:	6813      	ldr	r3, [r2, #0]
     cac:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     cb0:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     cb2:	6813      	ldr	r3, [r2, #0]
     cb4:	01d9      	lsls	r1, r3, #7
     cb6:	d4fc      	bmi.n	cb2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
     cb8:	b010      	add	sp, #64	; 0x40
     cba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     cbe:	bf00      	nop
     cc0:	0050183c 	.word	0x0050183c
     cc4:	400fc000 	.word	0x400fc000
     cc8:	401d0000 	.word	0x401d0000
     ccc:	000f4240 	.word	0x000f4240
     cd0:	20000280 	.word	0x20000280

00000cd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
     cd8:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     cdc:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     cde:	4c57      	ldr	r4, [pc, #348]	; (e3c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     ce0:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     ce2:	4b57      	ldr	r3, [pc, #348]	; (e40 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     ce4:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
     ce6:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     cea:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     cec:	4855      	ldr	r0, [pc, #340]	; (e44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     cee:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     cf2:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     cf4:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     cf6:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     cfa:	446b      	add	r3, sp
     cfc:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
     d00:	4b51      	ldr	r3, [pc, #324]	; (e48 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
     d02:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     d06:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     d08:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     d0c:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     d10:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     d14:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     d16:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     d18:	6803      	ldr	r3, [r0, #0]
     d1a:	01df      	lsls	r7, r3, #7
     d1c:	d5fc      	bpl.n	d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
     d1e:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     d20:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
     d24:	d92a      	bls.n	d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     d26:	4660      	mov	r0, ip
     d28:	1c83      	adds	r3, r0, #2
    divisor++;
     d2a:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
     d2c:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
     d30:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
     d32:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
     d36:	d8f7      	bhi.n	d28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     d38:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
     d3c:	fbb6 f3f3 	udiv	r3, r6, r3
     d40:	1acb      	subs	r3, r1, r3
     d42:	2b00      	cmp	r3, #0
     d44:	bfb8      	it	lt
     d46:	425b      	neglt	r3, r3
      if (error < bestError) {
     d48:	42ab      	cmp	r3, r5
     d4a:	db0b      	blt.n	d64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
     d4c:	f1a7 030c 	sub.w	r3, r7, #12
     d50:	bf18      	it	ne
     d52:	f04f 0800 	movne.w	r8, #0
     d56:	2b06      	cmp	r3, #6
     d58:	d80a      	bhi.n	d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
     d5a:	f1b8 0f00 	cmp.w	r8, #0
     d5e:	d007      	beq.n	d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
     d60:	4684      	mov	ip, r0
     d62:	e7e1      	b.n	d28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     d64:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
     d66:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
     d6a:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
     d6c:	2b06      	cmp	r3, #6
     d6e:	d9f4      	bls.n	d5a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
     d70:	2f05      	cmp	r7, #5
     d72:	d8d9      	bhi.n	d28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
     d74:	f10c 0301 	add.w	r3, ip, #1
     d78:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
     d7c:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
     d80:	f1a2 0205 	sub.w	r2, r2, #5
     d84:	dc4c      	bgt.n	e20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
     d86:	2a14      	cmp	r2, #20
     d88:	d84a      	bhi.n	e20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     d8a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
     d8e:	4f2f      	ldr	r7, [pc, #188]	; (e4c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
     d90:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     d92:	f8df 80b0 	ldr.w	r8, [pc, #176]	; e44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     d96:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     d9a:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     d9e:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
     da2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     da4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     da6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     da8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     daa:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     dac:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     dae:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
     db2:	c607      	stmia	r6!, {r0, r1, r2}
     db4:	f826 3b02 	strh.w	r3, [r6], #2
     db8:	ea4f 4313 	mov.w	r3, r3, lsr #16
     dbc:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     dbe:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     dc2:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     dc6:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     dca:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     dce:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     dd2:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
     dd6:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     dda:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     dde:	ea43 0302 	orr.w	r3, r3, r2
     de2:	ea43 0301 	orr.w	r3, r3, r1
     de6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     dea:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
     dee:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     df2:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     df6:	f8d8 3004 	ldr.w	r3, [r8, #4]
     dfa:	bf14      	ite	ne
     dfc:	f023 0308 	bicne.w	r3, r3, #8
     e00:	f043 0308 	orreq.w	r3, r3, #8
     e04:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     e08:	b93c      	cbnz	r4, e1a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     e0a:	4a0e      	ldr	r2, [pc, #56]	; (e44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     e0c:	6813      	ldr	r3, [r2, #0]
     e0e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     e12:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     e14:	6813      	ldr	r3, [r2, #0]
     e16:	01db      	lsls	r3, r3, #7
     e18:	d4fc      	bmi.n	e14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
     e1a:	b010      	add	sp, #64	; 0x40
     e1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     e20:	2c00      	cmp	r4, #0
     e22:	d1fa      	bne.n	e1a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     e24:	4a07      	ldr	r2, [pc, #28]	; (e44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
     e26:	6813      	ldr	r3, [r2, #0]
     e28:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     e2c:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     e2e:	6813      	ldr	r3, [r2, #0]
     e30:	01d9      	lsls	r1, r3, #7
     e32:	d4fc      	bmi.n	e2e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
     e34:	b010      	add	sp, #64	; 0x40
     e36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     e3a:	bf00      	nop
     e3c:	0050183c 	.word	0x0050183c
     e40:	400fc000 	.word	0x400fc000
     e44:	401d4000 	.word	0x401d4000
     e48:	000f4240 	.word	0x000f4240
     e4c:	20000280 	.word	0x20000280

00000e50 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3); /* input 3 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4); /* input 4 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4, uint32_t id5); /* input 5 ID's to be filtered */
    bool setMBFilterRange(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2); /* filter a range of ids */
    int write(const CAN_message_t &msg); /* use any available mailbox for transmitting */
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
     e50:	2000      	movs	r0, #0
     e52:	4770      	bx	lr

00000e54 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
     e54:	2000      	movs	r0, #0
     e56:	4770      	bx	lr

00000e58 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
#endif
    void enhanceFilter(FLEXCAN_MAILBOX mb_num);
    void distribute(bool state = 1) { distribution = state; }
    void enableDMA(bool state = 1);
    void disableDMA() { enableDMA(0); }
    uint8_t getFirstTxBoxSize(){ return 8; }
     e58:	2008      	movs	r0, #8
     e5a:	4770      	bx	lr

00000e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
     e5c:	2000      	movs	r0, #0
     e5e:	4770      	bx	lr

00000e60 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
     e60:	2000      	movs	r0, #0
     e62:	4770      	bx	lr

00000e64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
    uint8_t getFirstTxBoxSize(){ return 8; }
     e64:	2008      	movs	r0, #8
     e66:	4770      	bx	lr

00000e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     e68:	4910      	ldr	r1, [pc, #64]	; (eac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     e6a:	680b      	ldr	r3, [r1, #0]
     e6c:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
     e6e:	680a      	ldr	r2, [r1, #0]
     e70:	6b49      	ldr	r1, [r1, #52]	; 0x34
     e72:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     e76:	f3c1 6103 	ubfx	r1, r1, #24, #4
     e7a:	3201      	adds	r2, #1
     e7c:	3104      	adds	r1, #4
     e7e:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
     e82:	d310      	bcc.n	ea6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     e84:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     e88:	f3c0 6003 	ubfx	r0, r0, #24, #4
     e8c:	3b05      	subs	r3, #5
     e8e:	3001      	adds	r0, #1
     e90:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
     e94:	b2db      	uxtb	r3, r3
     e96:	4a05      	ldr	r2, [pc, #20]	; (eac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     e98:	6810      	ldr	r0, [r2, #0]
     e9a:	f000 007f 	and.w	r0, r0, #127	; 0x7f
     e9e:	3001      	adds	r0, #1
     ea0:	1ac0      	subs	r0, r0, r3
}
     ea2:	b2c0      	uxtb	r0, r0
     ea4:	4770      	bx	lr
     ea6:	2300      	movs	r3, #0
     ea8:	e7f5      	b.n	e96 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
     eaa:	bf00      	nop
     eac:	401d0000 	.word	0x401d0000

00000eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     eb0:	4910      	ldr	r1, [pc, #64]	; (ef4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     eb2:	680b      	ldr	r3, [r1, #0]
     eb4:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
     eb6:	680a      	ldr	r2, [r1, #0]
     eb8:	6b49      	ldr	r1, [r1, #52]	; 0x34
     eba:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     ebe:	f3c1 6103 	ubfx	r1, r1, #24, #4
     ec2:	3201      	adds	r2, #1
     ec4:	3104      	adds	r1, #4
     ec6:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
     eca:	d310      	bcc.n	eee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
     ecc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     ed0:	f3c0 6003 	ubfx	r0, r0, #24, #4
     ed4:	3b05      	subs	r3, #5
     ed6:	3001      	adds	r0, #1
     ed8:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
     edc:	b2db      	uxtb	r3, r3
     ede:	4a05      	ldr	r2, [pc, #20]	; (ef4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
     ee0:	6810      	ldr	r0, [r2, #0]
     ee2:	f000 007f 	and.w	r0, r0, #127	; 0x7f
     ee6:	3001      	adds	r0, #1
     ee8:	1ac0      	subs	r0, r0, r3
}
     eea:	b2c0      	uxtb	r0, r0
     eec:	4770      	bx	lr
     eee:	2300      	movs	r3, #0
     ef0:	e7f5      	b.n	ede <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
     ef2:	bf00      	nop
     ef4:	401d4000 	.word	0x401d4000

00000ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     ef8:	4a63      	ldr	r2, [pc, #396]	; (1088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
     efa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     efe:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f00:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     f02:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f06:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
     f0a:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     f0c:	6813      	ldr	r3, [r2, #0]
     f0e:	01dd      	lsls	r5, r3, #7
     f10:	d5fc      	bpl.n	f0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
     f12:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
     f14:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
     f16:	f8df c178 	ldr.w	ip, [pc, #376]	; 1090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
     f1a:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
     f1e:	4f5b      	ldr	r7, [pc, #364]	; (108c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f20:	4e59      	ldr	r6, [pc, #356]	; (1088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
     f22:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
     f24:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
     f26:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
     f28:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f2a:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
     f2c:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
     f30:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f32:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
     f34:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
     f36:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
     f38:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f3a:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
     f3c:	6091      	str	r1, [r2, #8]
     f3e:	6051      	str	r1, [r2, #4]
     f40:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
     f42:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f44:	6832      	ldr	r2, [r6, #0]
     f46:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     f4a:	3201      	adds	r2, #1
     f4c:	4293      	cmp	r3, r2
     f4e:	d3ed      	bcc.n	f2c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
     f50:	64b1      	str	r1, [r6, #72]	; 0x48
     f52:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
     f54:	6af2      	ldr	r2, [r6, #44]	; 0x2c
     f56:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
     f58:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
     f5a:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
     f5c:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
     f5e:	2800      	cmp	r0, #0
     f60:	d149      	bne.n	ff6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
     f62:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f66:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
     f68:	4e47      	ldr	r6, [pc, #284]	; (1088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
     f6a:	4f48      	ldr	r7, [pc, #288]	; (108c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
     f6c:	e019      	b.n	fa2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
     f6e:	6833      	ldr	r3, [r6, #0]
     f70:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     f74:	3301      	adds	r3, #1
     f76:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
     f7a:	bf34      	ite	cc
     f7c:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
     f80:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
     f84:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
     f86:	6b73      	ldr	r3, [r6, #52]	; 0x34
     f88:	f3c3 4300 	ubfx	r3, r3, #16, #1
     f8c:	079b      	lsls	r3, r3, #30
     f8e:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
     f90:	6833      	ldr	r3, [r6, #0]
     f92:	3501      	adds	r5, #1
     f94:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     f98:	b2ed      	uxtb	r5, r5
     f9a:	3301      	adds	r3, #1
     f9c:	4628      	mov	r0, r5
     f9e:	429d      	cmp	r5, r3
     fa0:	d21e      	bcs.n	fe0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
     fa2:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
     fa4:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
     fa8:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
     faa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
     fae:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
     fb0:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
     fb2:	3301      	adds	r3, #1
     fb4:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
     fb8:	d3d9      	bcc.n	f6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
     fba:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
     fbe:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
     fc0:	6833      	ldr	r3, [r6, #0]
     fc2:	009a      	lsls	r2, r3, #2
     fc4:	d503      	bpl.n	fce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
     fc6:	f7ff ff4f 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
     fca:	42a8      	cmp	r0, r5
     fcc:	d8e0      	bhi.n	f90 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
     fce:	2301      	movs	r3, #1
     fd0:	2d1f      	cmp	r5, #31
     fd2:	fa03 f305 	lsl.w	r3, r3, r5
     fd6:	d84c      	bhi.n	1072 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
     fd8:	6ab2      	ldr	r2, [r6, #40]	; 0x28
     fda:	4313      	orrs	r3, r2
     fdc:	62b3      	str	r3, [r6, #40]	; 0x28
     fde:	e7d7      	b.n	f90 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     fe0:	b93c      	cbnz	r4, ff2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     fe2:	4a29      	ldr	r2, [pc, #164]	; (1088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
     fe4:	6813      	ldr	r3, [r2, #0]
     fe6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
     fea:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     fec:	6813      	ldr	r3, [r2, #0]
     fee:	01db      	lsls	r3, r3, #7
     ff0:	d4fc      	bmi.n	fec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
     ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
     ff6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
     ffa:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
     ffc:	6835      	ldr	r5, [r6, #0]
     ffe:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    1002:	d03e      	beq.n	1082 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    1004:	f7ff ff30 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1008:	6833      	ldr	r3, [r6, #0]
    100a:	4605      	mov	r5, r0
    100c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1010:	3301      	adds	r3, #1
    1012:	4283      	cmp	r3, r0
    1014:	d9e4      	bls.n	fe0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1016:	4f1e      	ldr	r7, [pc, #120]	; (1090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    1018:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    101c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    1020:	e00d      	b.n	103e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1022:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    1026:	4313      	orrs	r3, r2
    1028:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    102c:	f8d8 3000 	ldr.w	r3, [r8]
    1030:	3501      	adds	r5, #1
    1032:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1036:	b2ed      	uxtb	r5, r5
    1038:	3301      	adds	r3, #1
    103a:	429d      	cmp	r5, r3
    103c:	d2d0      	bcs.n	fe0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    103e:	19eb      	adds	r3, r5, r7
    1040:	011b      	lsls	r3, r3, #4
    1042:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1044:	f8d8 3000 	ldr.w	r3, [r8]
    1048:	0099      	lsls	r1, r3, #2
    104a:	d503      	bpl.n	1054 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    104c:	f7ff ff0c 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    1050:	4285      	cmp	r5, r0
    1052:	d3eb      	bcc.n	102c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1054:	2301      	movs	r3, #1
    1056:	2d1f      	cmp	r5, #31
    1058:	fa03 f305 	lsl.w	r3, r3, r5
    105c:	d9e1      	bls.n	1022 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    105e:	f1a5 0120 	sub.w	r1, r5, #32
    1062:	2301      	movs	r3, #1
    1064:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    1068:	408b      	lsls	r3, r1
    106a:	4313      	orrs	r3, r2
    106c:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    1070:	e7dc      	b.n	102c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    1072:	f1a5 0120 	sub.w	r1, r5, #32
    1076:	2301      	movs	r3, #1
    1078:	6a72      	ldr	r2, [r6, #36]	; 0x24
    107a:	408b      	lsls	r3, r1
    107c:	4313      	orrs	r3, r2
    107e:	6273      	str	r3, [r6, #36]	; 0x24
    1080:	e786      	b.n	f90 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1082:	6833      	ldr	r3, [r6, #0]
    1084:	e7c7      	b.n	1016 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    1086:	bf00      	nop
    1088:	401d0000 	.word	0x401d0000
    108c:	10074220 	.word	0x10074220
    1090:	0401d008 	.word	0x0401d008

00001094 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1094:	4a63      	ldr	r2, [pc, #396]	; (1224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    1096:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    109a:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    109c:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    109e:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    10a2:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    10a6:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    10a8:	6813      	ldr	r3, [r2, #0]
    10aa:	01dd      	lsls	r5, r3, #7
    10ac:	d5fc      	bpl.n	10a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    10ae:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    10b0:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    10b2:	f8df c178 	ldr.w	ip, [pc, #376]	; 122c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    10b6:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    10ba:	4f5b      	ldr	r7, [pc, #364]	; (1228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    10bc:	4e59      	ldr	r6, [pc, #356]	; (1224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    10be:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    10c0:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    10c2:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    10c4:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    10c6:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    10c8:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    10cc:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    10ce:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    10d0:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    10d2:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    10d4:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    10d6:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    10d8:	6091      	str	r1, [r2, #8]
    10da:	6051      	str	r1, [r2, #4]
    10dc:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    10de:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    10e0:	6832      	ldr	r2, [r6, #0]
    10e2:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    10e6:	3201      	adds	r2, #1
    10e8:	4293      	cmp	r3, r2
    10ea:	d3ed      	bcc.n	10c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    10ec:	64b1      	str	r1, [r6, #72]	; 0x48
    10ee:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    10f0:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    10f2:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    10f4:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    10f6:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    10f8:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    10fa:	2800      	cmp	r0, #0
    10fc:	d149      	bne.n	1192 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    10fe:	f8df 812c 	ldr.w	r8, [pc, #300]	; 122c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1102:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1104:	4e47      	ldr	r6, [pc, #284]	; (1224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1106:	4f48      	ldr	r7, [pc, #288]	; (1228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    1108:	e019      	b.n	113e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    110a:	6833      	ldr	r3, [r6, #0]
    110c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1110:	3301      	adds	r3, #1
    1112:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    1116:	bf34      	ite	cc
    1118:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    111c:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    1120:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1122:	6b73      	ldr	r3, [r6, #52]	; 0x34
    1124:	f3c3 4300 	ubfx	r3, r3, #16, #1
    1128:	079b      	lsls	r3, r3, #30
    112a:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    112c:	6833      	ldr	r3, [r6, #0]
    112e:	3501      	adds	r5, #1
    1130:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1134:	b2ed      	uxtb	r5, r5
    1136:	3301      	adds	r3, #1
    1138:	4628      	mov	r0, r5
    113a:	429d      	cmp	r5, r3
    113c:	d21e      	bcs.n	117c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    113e:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1140:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1144:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1146:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    114a:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    114c:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    114e:	3301      	adds	r3, #1
    1150:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    1154:	d3d9      	bcc.n	110a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1156:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    115a:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    115c:	6833      	ldr	r3, [r6, #0]
    115e:	009a      	lsls	r2, r3, #2
    1160:	d503      	bpl.n	116a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    1162:	f7ff fea5 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    1166:	42a8      	cmp	r0, r5
    1168:	d8e0      	bhi.n	112c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    116a:	2301      	movs	r3, #1
    116c:	2d1f      	cmp	r5, #31
    116e:	fa03 f305 	lsl.w	r3, r3, r5
    1172:	d84c      	bhi.n	120e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    1174:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    1176:	4313      	orrs	r3, r2
    1178:	62b3      	str	r3, [r6, #40]	; 0x28
    117a:	e7d7      	b.n	112c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    117c:	b93c      	cbnz	r4, 118e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    117e:	4a29      	ldr	r2, [pc, #164]	; (1224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    1180:	6813      	ldr	r3, [r2, #0]
    1182:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1186:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1188:	6813      	ldr	r3, [r2, #0]
    118a:	01db      	lsls	r3, r3, #7
    118c:	d4fc      	bmi.n	1188 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    118e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    1192:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    1196:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1198:	6835      	ldr	r5, [r6, #0]
    119a:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    119e:	d03e      	beq.n	121e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    11a0:	f7ff fe86 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    11a4:	6833      	ldr	r3, [r6, #0]
    11a6:	4605      	mov	r5, r0
    11a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    11ac:	3301      	adds	r3, #1
    11ae:	4283      	cmp	r3, r0
    11b0:	d9e4      	bls.n	117c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    11b2:	4f1e      	ldr	r7, [pc, #120]	; (122c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    11b4:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    11b8:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    11bc:	e00d      	b.n	11da <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    11be:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    11c2:	4313      	orrs	r3, r2
    11c4:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    11c8:	f8d8 3000 	ldr.w	r3, [r8]
    11cc:	3501      	adds	r5, #1
    11ce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    11d2:	b2ed      	uxtb	r5, r5
    11d4:	3301      	adds	r3, #1
    11d6:	429d      	cmp	r5, r3
    11d8:	d2d0      	bcs.n	117c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    11da:	19eb      	adds	r3, r5, r7
    11dc:	011b      	lsls	r3, r3, #4
    11de:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    11e0:	f8d8 3000 	ldr.w	r3, [r8]
    11e4:	0099      	lsls	r1, r3, #2
    11e6:	d503      	bpl.n	11f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    11e8:	f7ff fe62 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    11ec:	4285      	cmp	r5, r0
    11ee:	d3eb      	bcc.n	11c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    11f0:	2301      	movs	r3, #1
    11f2:	2d1f      	cmp	r5, #31
    11f4:	fa03 f305 	lsl.w	r3, r3, r5
    11f8:	d9e1      	bls.n	11be <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    11fa:	f1a5 0120 	sub.w	r1, r5, #32
    11fe:	2301      	movs	r3, #1
    1200:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    1204:	408b      	lsls	r3, r1
    1206:	4313      	orrs	r3, r2
    1208:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    120c:	e7dc      	b.n	11c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    120e:	f1a5 0120 	sub.w	r1, r5, #32
    1212:	2301      	movs	r3, #1
    1214:	6a72      	ldr	r2, [r6, #36]	; 0x24
    1216:	408b      	lsls	r3, r1
    1218:	4313      	orrs	r3, r2
    121a:	6273      	str	r3, [r6, #36]	; 0x24
    121c:	e786      	b.n	112c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    121e:	6833      	ldr	r3, [r6, #0]
    1220:	e7c7      	b.n	11b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    1222:	bf00      	nop
    1224:	401d4000 	.word	0x401d4000
    1228:	10075220 	.word	0x10075220
    122c:	0401d408 	.word	0x0401d408

00001230 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    1230:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    1234:	4db7      	ldr	r5, [pc, #732]	; (1514 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1236:	682b      	ldr	r3, [r5, #0]
    1238:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    123c:	f040 819a 	bne.w	1574 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    1240:	211a      	movs	r1, #26
    1242:	48b5      	ldr	r0, [pc, #724]	; (1518 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    1244:	f006 f922 	bl	748c <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1248:	464c      	mov	r4, r9
    124a:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    124c:	4fb3      	ldr	r7, [pc, #716]	; (151c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    124e:	4db4      	ldr	r5, [pc, #720]	; (1520 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1250:	4eb4      	ldr	r6, [pc, #720]	; (1524 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1252:	eb04 0805 	add.w	r8, r4, r5
    1256:	ea4f 1808 	mov.w	r8, r8, lsl #4
    125a:	f8d8 3000 	ldr.w	r3, [r8]
    125e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1262:	2b0e      	cmp	r3, #14
    1264:	f200 809e 	bhi.w	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1268:	e8df f013 	tbh	[pc, r3, lsl #1]
    126c:	01300142 	.word	0x01300142
    1270:	009c011e 	.word	0x009c011e
    1274:	009c0103 	.word	0x009c0103
    1278:	009c00f1 	.word	0x009c00f1
    127c:	00cd00df 	.word	0x00cd00df
    1280:	009c00bb 	.word	0x009c00bb
    1284:	009c000f 	.word	0x009c000f
    1288:	00a9      	.short	0x00a9
    128a:	2104      	movs	r1, #4
    128c:	48a6      	ldr	r0, [pc, #664]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    128e:	f006 f8fd 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1292:	2300      	movs	r3, #0
    1294:	4649      	mov	r1, r9
    1296:	220a      	movs	r2, #10
    1298:	48a4      	ldr	r0, [pc, #656]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    129a:	f004 fa4d 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    129e:	211d      	movs	r1, #29
    12a0:	48a3      	ldr	r0, [pc, #652]	; (1530 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    12a2:	f006 f8f3 	bl	748c <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    12a6:	f8d8 3000 	ldr.w	r3, [r8]
    12aa:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    12ac:	029b      	lsls	r3, r3, #10
    12ae:	f140 81e3 	bpl.w	1678 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    12b2:	48a0      	ldr	r0, [pc, #640]	; (1534 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    12b4:	f006 f8ea 	bl	748c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    12b8:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    12bc:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    12c0:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    12c2:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    12c6:	2107      	movs	r1, #7
    12c8:	489b      	ldr	r0, [pc, #620]	; (1538 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    12ca:	f006 f8df 	bl	748c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    12ce:	2300      	movs	r3, #0
    12d0:	2210      	movs	r2, #16
    12d2:	4651      	mov	r1, sl
    12d4:	4895      	ldr	r0, [pc, #596]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    12d6:	f004 fa2f 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    12da:	2101      	movs	r1, #1
    12dc:	4897      	ldr	r0, [pc, #604]	; (153c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    12de:	f006 f8d5 	bl	748c <usb_serial_write>
    12e2:	210a      	movs	r1, #10
    12e4:	4896      	ldr	r0, [pc, #600]	; (1540 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    12e6:	f006 f8d1 	bl	748c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    12ea:	2300      	movs	r3, #0
    12ec:	2210      	movs	r2, #16
    12ee:	ea4f 6119 	mov.w	r1, r9, lsr #24
    12f2:	488e      	ldr	r0, [pc, #568]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    12f4:	f004 fa20 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    12f8:	2101      	movs	r1, #1
    12fa:	4892      	ldr	r0, [pc, #584]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    12fc:	f006 f8c6 	bl	748c <usb_serial_write>
    1300:	2300      	movs	r3, #0
    1302:	2210      	movs	r2, #16
    1304:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1308:	4888      	ldr	r0, [pc, #544]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    130a:	f004 fa15 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    130e:	2101      	movs	r1, #1
    1310:	488c      	ldr	r0, [pc, #560]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1312:	f006 f8bb 	bl	748c <usb_serial_write>
    1316:	2300      	movs	r3, #0
    1318:	2210      	movs	r2, #16
    131a:	f3c9 2107 	ubfx	r1, r9, #8, #8
    131e:	4883      	ldr	r0, [pc, #524]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1320:	f004 fa0a 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1324:	2101      	movs	r1, #1
    1326:	4887      	ldr	r0, [pc, #540]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1328:	f006 f8b0 	bl	748c <usb_serial_write>
    132c:	2300      	movs	r3, #0
    132e:	2210      	movs	r2, #16
    1330:	fa5f f189 	uxtb.w	r1, r9
    1334:	487d      	ldr	r0, [pc, #500]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1336:	f004 f9ff 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    133a:	f858 8007 	ldr.w	r8, [r8, r7]
    133e:	2101      	movs	r1, #1
    1340:	4880      	ldr	r0, [pc, #512]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1342:	f006 f8a3 	bl	748c <usb_serial_write>
    1346:	2300      	movs	r3, #0
    1348:	2210      	movs	r2, #16
    134a:	ea4f 6118 	mov.w	r1, r8, lsr #24
    134e:	4877      	ldr	r0, [pc, #476]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1350:	f004 f9f2 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1354:	2101      	movs	r1, #1
    1356:	487b      	ldr	r0, [pc, #492]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1358:	f006 f898 	bl	748c <usb_serial_write>
    135c:	2300      	movs	r3, #0
    135e:	2210      	movs	r2, #16
    1360:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1364:	4871      	ldr	r0, [pc, #452]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1366:	f004 f9e7 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    136a:	2101      	movs	r1, #1
    136c:	4875      	ldr	r0, [pc, #468]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    136e:	f006 f88d 	bl	748c <usb_serial_write>
    1372:	2300      	movs	r3, #0
    1374:	2210      	movs	r2, #16
    1376:	f3c8 2107 	ubfx	r1, r8, #8, #8
    137a:	486c      	ldr	r0, [pc, #432]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    137c:	f004 f9dc 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1380:	2101      	movs	r1, #1
    1382:	4870      	ldr	r0, [pc, #448]	; (1544 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1384:	f006 f882 	bl	748c <usb_serial_write>
    1388:	2300      	movs	r3, #0
    138a:	fa5f f188 	uxtb.w	r1, r8
    138e:	2210      	movs	r2, #16
    1390:	4866      	ldr	r0, [pc, #408]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1392:	f004 f9d1 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1396:	2101      	movs	r1, #1
    1398:	4868      	ldr	r0, [pc, #416]	; (153c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    139a:	f006 f877 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    139e:	4863      	ldr	r0, [pc, #396]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    13a0:	f004 f9bc 	bl	571c <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    13a4:	4b5b      	ldr	r3, [pc, #364]	; (1514 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    13a6:	3401      	adds	r4, #1
    13a8:	681b      	ldr	r3, [r3, #0]
    13aa:	b2e4      	uxtb	r4, r4
    13ac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    13b0:	46a1      	mov	r9, r4
    13b2:	3301      	adds	r3, #1
    13b4:	429c      	cmp	r4, r3
    13b6:	f4ff af4c 	bcc.w	1252 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    13ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    13be:	2104      	movs	r1, #4
    13c0:	4859      	ldr	r0, [pc, #356]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    13c2:	f006 f863 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    13c6:	4649      	mov	r1, r9
    13c8:	2300      	movs	r3, #0
    13ca:	220a      	movs	r2, #10
    13cc:	4857      	ldr	r0, [pc, #348]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    13ce:	f004 f9b3 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    13d2:	2111      	movs	r1, #17
    13d4:	485c      	ldr	r0, [pc, #368]	; (1548 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    13d6:	f006 f859 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    13da:	4854      	ldr	r0, [pc, #336]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    13dc:	f004 f99e 	bl	571c <Print::println()>
    13e0:	e7e0      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    13e2:	2104      	movs	r1, #4
    13e4:	4850      	ldr	r0, [pc, #320]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    13e6:	f006 f851 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    13ea:	4649      	mov	r1, r9
    13ec:	2300      	movs	r3, #0
    13ee:	220a      	movs	r2, #10
    13f0:	484e      	ldr	r0, [pc, #312]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    13f2:	f004 f9a1 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    13f6:	2111      	movs	r1, #17
    13f8:	4854      	ldr	r0, [pc, #336]	; (154c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    13fa:	f006 f847 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    13fe:	484b      	ldr	r0, [pc, #300]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1400:	f004 f98c 	bl	571c <Print::println()>
    1404:	e7ce      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1406:	2104      	movs	r1, #4
    1408:	4847      	ldr	r0, [pc, #284]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    140a:	f006 f83f 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    140e:	4649      	mov	r1, r9
    1410:	2300      	movs	r3, #0
    1412:	220a      	movs	r2, #10
    1414:	4845      	ldr	r0, [pc, #276]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1416:	f004 f98f 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    141a:	210f      	movs	r1, #15
    141c:	484c      	ldr	r0, [pc, #304]	; (1550 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    141e:	f006 f835 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1422:	4842      	ldr	r0, [pc, #264]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1424:	f004 f97a 	bl	571c <Print::println()>
    1428:	e7bc      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    142a:	2104      	movs	r1, #4
    142c:	483e      	ldr	r0, [pc, #248]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    142e:	f006 f82d 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1432:	4649      	mov	r1, r9
    1434:	2300      	movs	r3, #0
    1436:	220a      	movs	r2, #10
    1438:	483c      	ldr	r0, [pc, #240]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    143a:	f004 f97d 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    143e:	2112      	movs	r1, #18
    1440:	4844      	ldr	r0, [pc, #272]	; (1554 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    1442:	f006 f823 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1446:	4839      	ldr	r0, [pc, #228]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1448:	f004 f968 	bl	571c <Print::println()>
    144c:	e7aa      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    144e:	2104      	movs	r1, #4
    1450:	4835      	ldr	r0, [pc, #212]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1452:	f006 f81b 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1456:	4649      	mov	r1, r9
    1458:	2300      	movs	r3, #0
    145a:	220a      	movs	r2, #10
    145c:	4833      	ldr	r0, [pc, #204]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    145e:	f004 f96b 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1462:	2111      	movs	r1, #17
    1464:	483c      	ldr	r0, [pc, #240]	; (1558 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    1466:	f006 f811 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    146a:	4830      	ldr	r0, [pc, #192]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    146c:	f004 f956 	bl	571c <Print::println()>
    1470:	e798      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1472:	2104      	movs	r1, #4
    1474:	482c      	ldr	r0, [pc, #176]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1476:	f006 f809 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    147a:	220a      	movs	r2, #10
    147c:	4649      	mov	r1, r9
    147e:	2300      	movs	r3, #0
    1480:	482a      	ldr	r0, [pc, #168]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1482:	f004 f959 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1486:	210f      	movs	r1, #15
    1488:	4834      	ldr	r0, [pc, #208]	; (155c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    148a:	f005 ffff 	bl	748c <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    148e:	f8d8 3000 	ldr.w	r3, [r8]
    1492:	2111      	movs	r1, #17
    1494:	029a      	lsls	r2, r3, #10
    1496:	bf4c      	ite	mi
    1498:	4831      	ldrmi	r0, [pc, #196]	; (1560 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    149a:	4832      	ldrpl	r0, [pc, #200]	; (1564 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    149c:	f005 fff6 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    14a0:	4822      	ldr	r0, [pc, #136]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14a2:	f004 f93b 	bl	571c <Print::println()>
    14a6:	e77d      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    14a8:	2104      	movs	r1, #4
    14aa:	481f      	ldr	r0, [pc, #124]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    14ac:	f005 ffee 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    14b0:	4649      	mov	r1, r9
    14b2:	2300      	movs	r3, #0
    14b4:	220a      	movs	r2, #10
    14b6:	481d      	ldr	r0, [pc, #116]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14b8:	f004 f93e 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14bc:	210e      	movs	r1, #14
    14be:	482a      	ldr	r0, [pc, #168]	; (1568 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    14c0:	f005 ffe4 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    14c4:	4819      	ldr	r0, [pc, #100]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14c6:	f004 f929 	bl	571c <Print::println()>
    14ca:	e76b      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    14cc:	2104      	movs	r1, #4
    14ce:	4816      	ldr	r0, [pc, #88]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    14d0:	f005 ffdc 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    14d4:	4649      	mov	r1, r9
    14d6:	2300      	movs	r3, #0
    14d8:	220a      	movs	r2, #10
    14da:	4814      	ldr	r0, [pc, #80]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14dc:	f004 f92c 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14e0:	210e      	movs	r1, #14
    14e2:	4822      	ldr	r0, [pc, #136]	; (156c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    14e4:	f005 ffd2 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    14e8:	4810      	ldr	r0, [pc, #64]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    14ea:	f004 f917 	bl	571c <Print::println()>
    14ee:	e759      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    14f0:	2104      	movs	r1, #4
    14f2:	480d      	ldr	r0, [pc, #52]	; (1528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    14f4:	f005 ffca 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    14f8:	4649      	mov	r1, r9
    14fa:	2300      	movs	r3, #0
    14fc:	220a      	movs	r2, #10
    14fe:	480b      	ldr	r0, [pc, #44]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1500:	f004 f91a 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1504:	2112      	movs	r1, #18
    1506:	481a      	ldr	r0, [pc, #104]	; (1570 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    1508:	f005 ffc0 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    150c:	4807      	ldr	r0, [pc, #28]	; (152c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    150e:	f004 f905 	bl	571c <Print::println()>
    1512:	e747      	b.n	13a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1514:	401d4000 	.word	0x401d4000
    1518:	2000051c 	.word	0x2000051c
    151c:	401d408c 	.word	0x401d408c
    1520:	0401d408 	.word	0x0401d408
    1524:	bfe2bf80 	.word	0xbfe2bf80
    1528:	200003ec 	.word	0x200003ec
    152c:	20000a68 	.word	0x20000a68
    1530:	200004ac 	.word	0x200004ac
    1534:	200004cc 	.word	0x200004cc
    1538:	200004f4 	.word	0x200004f4
    153c:	20000428 	.word	0x20000428
    1540:	200004fc 	.word	0x200004fc
    1544:	20000390 	.word	0x20000390
    1548:	20000508 	.word	0x20000508
    154c:	20000464 	.word	0x20000464
    1550:	2000049c 	.word	0x2000049c
    1554:	20000488 	.word	0x20000488
    1558:	20000450 	.word	0x20000450
    155c:	20000408 	.word	0x20000408
    1560:	20000418 	.word	0x20000418
    1564:	2000042c 	.word	0x2000042c
    1568:	20000440 	.word	0x20000440
    156c:	20000478 	.word	0x20000478
    1570:	200003f4 	.word	0x200003f4
    1574:	2111      	movs	r1, #17
    1576:	48c4      	ldr	r0, [pc, #784]	; (1888 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    1578:	f005 ff88 	bl	748c <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    157c:	6aab      	ldr	r3, [r5, #40]	; 0x28
    157e:	069a      	lsls	r2, r3, #26
    1580:	f100 81fa 	bmi.w	1978 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    1584:	2112      	movs	r1, #18
    1586:	48c1      	ldr	r0, [pc, #772]	; (188c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    1588:	f005 ff80 	bl	748c <usb_serial_write>
    158c:	48c0      	ldr	r0, [pc, #768]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    158e:	f004 f8c5 	bl	571c <Print::println()>
    1592:	2116      	movs	r1, #22
    1594:	48bf      	ldr	r0, [pc, #764]	; (1894 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    1596:	f005 ff79 	bl	748c <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    159a:	4abf      	ldr	r2, [pc, #764]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    159c:	6814      	ldr	r4, [r2, #0]
    159e:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    15a0:	6813      	ldr	r3, [r2, #0]
    15a2:	6b52      	ldr	r2, [r2, #52]	; 0x34
    15a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    15a8:	f3c2 6203 	ubfx	r2, r2, #24, #4
    15ac:	3301      	adds	r3, #1
    15ae:	3204      	adds	r2, #4
    15b0:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    15b4:	f0c0 81e8 	bcc.w	1988 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    15b8:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    15bc:	f3c1 6103 	ubfx	r1, r1, #24, #4
    15c0:	3c05      	subs	r4, #5
    15c2:	3101      	adds	r1, #1
    15c4:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    15c8:	b2e5      	uxtb	r5, r4
    15ca:	4eb3      	ldr	r6, [pc, #716]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    15cc:	48b0      	ldr	r0, [pc, #704]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    15ce:	6831      	ldr	r1, [r6, #0]
    15d0:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    15d4:	3101      	adds	r1, #1
    15d6:	1b49      	subs	r1, r1, r5
    15d8:	b2c9      	uxtb	r1, r1
    15da:	2920      	cmp	r1, #32
    15dc:	bfa8      	it	ge
    15de:	2120      	movge	r1, #32
    15e0:	f004 f890 	bl	5704 <Print::print(long)>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	// Print an unsigned number and newline
	size_t println(uint8_t b)			{ return print(b) + println(); }
	// Print a signed number and newline
	size_t println(int n)				{ return print(n) + println(); }
    15e4:	48aa      	ldr	r0, [pc, #680]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    15e6:	f004 f899 	bl	571c <Print::println()>
    15ea:	2116      	movs	r1, #22
    15ec:	48ab      	ldr	r0, [pc, #684]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    15ee:	f005 ff4d 	bl	748c <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    15f2:	6833      	ldr	r3, [r6, #0]
    15f4:	6b72      	ldr	r2, [r6, #52]	; 0x34
    15f6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    15fa:	f3c2 6203 	ubfx	r2, r2, #24, #4
    15fe:	3301      	adds	r3, #1
    1600:	3204      	adds	r2, #4
    1602:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1606:	d201      	bcs.n	160c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    1608:	2500      	movs	r5, #0
    160a:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    160c:	2300      	movs	r3, #0
    160e:	4621      	mov	r1, r4
    1610:	220a      	movs	r2, #10
    1612:	489f      	ldr	r0, [pc, #636]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1614:	f004 f890 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	// Print an unsigned number and newline
	size_t println(unsigned int n)			{ return print(n) + println(); }
	// Print a signed number and newline
	size_t println(long n)				{ return print(n) + println(); }
	// Print an unsigned number and newline
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1618:	489d      	ldr	r0, [pc, #628]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    161a:	f004 f87f 	bl	571c <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    161e:	4b9e      	ldr	r3, [pc, #632]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1620:	681c      	ldr	r4, [r3, #0]
    1622:	681b      	ldr	r3, [r3, #0]
    1624:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1628:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    162c:	3401      	adds	r4, #1
    162e:	3301      	adds	r3, #1
    1630:	1b64      	subs	r4, r4, r5
    1632:	b2e4      	uxtb	r4, r4
    1634:	42a3      	cmp	r3, r4
    1636:	f67f aec0 	bls.w	13ba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    163a:	4d99      	ldr	r5, [pc, #612]	; (18a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    163c:	4e99      	ldr	r6, [pc, #612]	; (18a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    163e:	4f9a      	ldr	r7, [pc, #616]	; (18a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1640:	eb04 0805 	add.w	r8, r4, r5
    1644:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1648:	f8d8 3000 	ldr.w	r3, [r8]
    164c:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1650:	2b0e      	cmp	r3, #14
    1652:	f200 80a9 	bhi.w	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1656:	e8df f013 	tbh	[pc, r3, lsl #1]
    165a:	0147      	.short	0x0147
    165c:	00f20104 	.word	0x00f20104
    1660:	00d700a7 	.word	0x00d700a7
    1664:	016b00a7 	.word	0x016b00a7
    1668:	015900a7 	.word	0x015900a7
    166c:	00c5017d 	.word	0x00c5017d
    1670:	001a00a7 	.word	0x001a00a7
    1674:	00b300a7 	.word	0x00b300a7
    1678:	488c      	ldr	r0, [pc, #560]	; (18ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    167a:	f005 ff07 	bl	748c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    167e:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1682:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1686:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1688:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    168c:	e61b      	b.n	12c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    168e:	2104      	movs	r1, #4
    1690:	4887      	ldr	r0, [pc, #540]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1692:	f005 fefb 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1696:	2300      	movs	r3, #0
    1698:	220a      	movs	r2, #10
    169a:	4621      	mov	r1, r4
    169c:	487c      	ldr	r0, [pc, #496]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    169e:	f004 f84b 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16a2:	211d      	movs	r1, #29
    16a4:	4883      	ldr	r0, [pc, #524]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    16a6:	f005 fef1 	bl	748c <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    16aa:	f8d8 3000 	ldr.w	r3, [r8]
    16ae:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    16b0:	0298      	lsls	r0, r3, #10
    16b2:	f140 816c 	bpl.w	198e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    16b6:	4880      	ldr	r0, [pc, #512]	; (18b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    16b8:	f005 fee8 	bl	748c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    16bc:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    16c0:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    16c4:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    16c6:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    16ca:	2107      	movs	r1, #7
    16cc:	487b      	ldr	r0, [pc, #492]	; (18bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    16ce:	f005 fedd 	bl	748c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    16d2:	2300      	movs	r3, #0
    16d4:	2210      	movs	r2, #16
    16d6:	4651      	mov	r1, sl
    16d8:	486d      	ldr	r0, [pc, #436]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    16da:	f004 f82d 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16de:	2101      	movs	r1, #1
    16e0:	4877      	ldr	r0, [pc, #476]	; (18c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    16e2:	f005 fed3 	bl	748c <usb_serial_write>
    16e6:	210a      	movs	r1, #10
    16e8:	4876      	ldr	r0, [pc, #472]	; (18c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    16ea:	f005 fecf 	bl	748c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    16ee:	2300      	movs	r3, #0
    16f0:	2210      	movs	r2, #16
    16f2:	ea4f 6119 	mov.w	r1, r9, lsr #24
    16f6:	4866      	ldr	r0, [pc, #408]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    16f8:	f004 f81e 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16fc:	2101      	movs	r1, #1
    16fe:	4872      	ldr	r0, [pc, #456]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1700:	f005 fec4 	bl	748c <usb_serial_write>
    1704:	2300      	movs	r3, #0
    1706:	2210      	movs	r2, #16
    1708:	f3c9 4107 	ubfx	r1, r9, #16, #8
    170c:	4860      	ldr	r0, [pc, #384]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    170e:	f004 f813 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1712:	2101      	movs	r1, #1
    1714:	486c      	ldr	r0, [pc, #432]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1716:	f005 feb9 	bl	748c <usb_serial_write>
    171a:	2300      	movs	r3, #0
    171c:	2210      	movs	r2, #16
    171e:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1722:	485b      	ldr	r0, [pc, #364]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1724:	f004 f808 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1728:	2101      	movs	r1, #1
    172a:	4867      	ldr	r0, [pc, #412]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    172c:	f005 feae 	bl	748c <usb_serial_write>
    1730:	2300      	movs	r3, #0
    1732:	2210      	movs	r2, #16
    1734:	fa5f f189 	uxtb.w	r1, r9
    1738:	4855      	ldr	r0, [pc, #340]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    173a:	f003 fffd 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    173e:	f858 8006 	ldr.w	r8, [r8, r6]
    1742:	2101      	movs	r1, #1
    1744:	4860      	ldr	r0, [pc, #384]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1746:	f005 fea1 	bl	748c <usb_serial_write>
    174a:	2300      	movs	r3, #0
    174c:	2210      	movs	r2, #16
    174e:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1752:	484f      	ldr	r0, [pc, #316]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1754:	f003 fff0 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1758:	2101      	movs	r1, #1
    175a:	485b      	ldr	r0, [pc, #364]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    175c:	f005 fe96 	bl	748c <usb_serial_write>
    1760:	2300      	movs	r3, #0
    1762:	2210      	movs	r2, #16
    1764:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1768:	4849      	ldr	r0, [pc, #292]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    176a:	f003 ffe5 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    176e:	2101      	movs	r1, #1
    1770:	4855      	ldr	r0, [pc, #340]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1772:	f005 fe8b 	bl	748c <usb_serial_write>
    1776:	2300      	movs	r3, #0
    1778:	2210      	movs	r2, #16
    177a:	f3c8 2107 	ubfx	r1, r8, #8, #8
    177e:	4844      	ldr	r0, [pc, #272]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1780:	f003 ffda 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1784:	2101      	movs	r1, #1
    1786:	4850      	ldr	r0, [pc, #320]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1788:	f005 fe80 	bl	748c <usb_serial_write>
    178c:	2300      	movs	r3, #0
    178e:	fa5f f188 	uxtb.w	r1, r8
    1792:	2210      	movs	r2, #16
    1794:	483e      	ldr	r0, [pc, #248]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1796:	f003 ffcf 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    179a:	2101      	movs	r1, #1
    179c:	4848      	ldr	r0, [pc, #288]	; (18c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    179e:	f005 fe75 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17a2:	483b      	ldr	r0, [pc, #236]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    17a4:	f003 ffba 	bl	571c <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    17a8:	4b3b      	ldr	r3, [pc, #236]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    17aa:	3401      	adds	r4, #1
    17ac:	681b      	ldr	r3, [r3, #0]
    17ae:	b2e4      	uxtb	r4, r4
    17b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    17b4:	3301      	adds	r3, #1
    17b6:	429c      	cmp	r4, r3
    17b8:	f4ff af42 	bcc.w	1640 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    17bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    17c0:	2104      	movs	r1, #4
    17c2:	483b      	ldr	r0, [pc, #236]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    17c4:	f005 fe62 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17c8:	2300      	movs	r3, #0
    17ca:	220a      	movs	r2, #10
    17cc:	4621      	mov	r1, r4
    17ce:	4830      	ldr	r0, [pc, #192]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    17d0:	f003 ffb2 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17d4:	2111      	movs	r1, #17
    17d6:	483d      	ldr	r0, [pc, #244]	; (18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    17d8:	f005 fe58 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17dc:	482c      	ldr	r0, [pc, #176]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    17de:	f003 ff9d 	bl	571c <Print::println()>
    17e2:	e7e1      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    17e4:	2104      	movs	r1, #4
    17e6:	4832      	ldr	r0, [pc, #200]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    17e8:	f005 fe50 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17ec:	2300      	movs	r3, #0
    17ee:	220a      	movs	r2, #10
    17f0:	4621      	mov	r1, r4
    17f2:	4827      	ldr	r0, [pc, #156]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    17f4:	f003 ffa0 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17f8:	2111      	movs	r1, #17
    17fa:	4835      	ldr	r0, [pc, #212]	; (18d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    17fc:	f005 fe46 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1800:	4823      	ldr	r0, [pc, #140]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1802:	f003 ff8b 	bl	571c <Print::println()>
    1806:	e7cf      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1808:	2104      	movs	r1, #4
    180a:	4829      	ldr	r0, [pc, #164]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    180c:	f005 fe3e 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1810:	220a      	movs	r2, #10
    1812:	2300      	movs	r3, #0
    1814:	4621      	mov	r1, r4
    1816:	481e      	ldr	r0, [pc, #120]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1818:	f003 ff8e 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    181c:	210f      	movs	r1, #15
    181e:	482d      	ldr	r0, [pc, #180]	; (18d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    1820:	f005 fe34 	bl	748c <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1824:	f8d8 3000 	ldr.w	r3, [r8]
    1828:	2111      	movs	r1, #17
    182a:	029b      	lsls	r3, r3, #10
    182c:	bf4c      	ite	mi
    182e:	482a      	ldrmi	r0, [pc, #168]	; (18d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    1830:	482a      	ldrpl	r0, [pc, #168]	; (18dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    1832:	f005 fe2b 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1836:	4816      	ldr	r0, [pc, #88]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1838:	f003 ff70 	bl	571c <Print::println()>
    183c:	e7b4      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    183e:	2104      	movs	r1, #4
    1840:	481b      	ldr	r0, [pc, #108]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1842:	f005 fe23 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1846:	2300      	movs	r3, #0
    1848:	220a      	movs	r2, #10
    184a:	4621      	mov	r1, r4
    184c:	4810      	ldr	r0, [pc, #64]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    184e:	f003 ff73 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1852:	210e      	movs	r1, #14
    1854:	4822      	ldr	r0, [pc, #136]	; (18e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    1856:	f005 fe19 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    185a:	480d      	ldr	r0, [pc, #52]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    185c:	f003 ff5e 	bl	571c <Print::println()>
    1860:	e7a2      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1862:	2104      	movs	r1, #4
    1864:	4812      	ldr	r0, [pc, #72]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1866:	f005 fe11 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    186a:	2300      	movs	r3, #0
    186c:	220a      	movs	r2, #10
    186e:	4621      	mov	r1, r4
    1870:	4807      	ldr	r0, [pc, #28]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1872:	f003 ff61 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1876:	210e      	movs	r1, #14
    1878:	481a      	ldr	r0, [pc, #104]	; (18e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    187a:	f005 fe07 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    187e:	4804      	ldr	r0, [pc, #16]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1880:	f003 ff4c 	bl	571c <Print::println()>
    1884:	e790      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1886:	bf00      	nop
    1888:	20000380 	.word	0x20000380
    188c:	200003a8 	.word	0x200003a8
    1890:	20000a68 	.word	0x20000a68
    1894:	200003bc 	.word	0x200003bc
    1898:	401d4000 	.word	0x401d4000
    189c:	200003d4 	.word	0x200003d4
    18a0:	0401d408 	.word	0x0401d408
    18a4:	401d408c 	.word	0x401d408c
    18a8:	bfe2bf80 	.word	0xbfe2bf80
    18ac:	200004e0 	.word	0x200004e0
    18b0:	200003ec 	.word	0x200003ec
    18b4:	200004ac 	.word	0x200004ac
    18b8:	200004cc 	.word	0x200004cc
    18bc:	200004f4 	.word	0x200004f4
    18c0:	20000428 	.word	0x20000428
    18c4:	200004fc 	.word	0x200004fc
    18c8:	20000390 	.word	0x20000390
    18cc:	20000508 	.word	0x20000508
    18d0:	20000464 	.word	0x20000464
    18d4:	20000408 	.word	0x20000408
    18d8:	20000418 	.word	0x20000418
    18dc:	2000042c 	.word	0x2000042c
    18e0:	20000440 	.word	0x20000440
    18e4:	20000478 	.word	0x20000478
    18e8:	2104      	movs	r1, #4
    18ea:	482e      	ldr	r0, [pc, #184]	; (19a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    18ec:	f005 fdce 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    18f0:	2300      	movs	r3, #0
    18f2:	220a      	movs	r2, #10
    18f4:	4621      	mov	r1, r4
    18f6:	482c      	ldr	r0, [pc, #176]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    18f8:	f003 ff1e 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    18fc:	2112      	movs	r1, #18
    18fe:	482b      	ldr	r0, [pc, #172]	; (19ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    1900:	f005 fdc4 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1904:	4828      	ldr	r0, [pc, #160]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1906:	f003 ff09 	bl	571c <Print::println()>
    190a:	e74d      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    190c:	2104      	movs	r1, #4
    190e:	4825      	ldr	r0, [pc, #148]	; (19a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1910:	f005 fdbc 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1914:	2300      	movs	r3, #0
    1916:	220a      	movs	r2, #10
    1918:	4621      	mov	r1, r4
    191a:	4823      	ldr	r0, [pc, #140]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    191c:	f003 ff0c 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1920:	2112      	movs	r1, #18
    1922:	4823      	ldr	r0, [pc, #140]	; (19b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    1924:	f005 fdb2 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1928:	481f      	ldr	r0, [pc, #124]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    192a:	f003 fef7 	bl	571c <Print::println()>
    192e:	e73b      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1930:	2104      	movs	r1, #4
    1932:	481c      	ldr	r0, [pc, #112]	; (19a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1934:	f005 fdaa 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1938:	2300      	movs	r3, #0
    193a:	220a      	movs	r2, #10
    193c:	4621      	mov	r1, r4
    193e:	481a      	ldr	r0, [pc, #104]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1940:	f003 fefa 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1944:	2111      	movs	r1, #17
    1946:	481b      	ldr	r0, [pc, #108]	; (19b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    1948:	f005 fda0 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    194c:	4816      	ldr	r0, [pc, #88]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    194e:	f003 fee5 	bl	571c <Print::println()>
    1952:	e729      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1954:	2104      	movs	r1, #4
    1956:	4813      	ldr	r0, [pc, #76]	; (19a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1958:	f005 fd98 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    195c:	2300      	movs	r3, #0
    195e:	220a      	movs	r2, #10
    1960:	4621      	mov	r1, r4
    1962:	4811      	ldr	r0, [pc, #68]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1964:	f003 fee8 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1968:	210f      	movs	r1, #15
    196a:	4813      	ldr	r0, [pc, #76]	; (19b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    196c:	f005 fd8e 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1970:	480d      	ldr	r0, [pc, #52]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1972:	f003 fed3 	bl	571c <Print::println()>
    1976:	e717      	b.n	17a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1978:	2111      	movs	r1, #17
    197a:	4810      	ldr	r0, [pc, #64]	; (19bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    197c:	f005 fd86 	bl	748c <usb_serial_write>
    1980:	4809      	ldr	r0, [pc, #36]	; (19a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1982:	f003 fecb 	bl	571c <Print::println()>
    1986:	e604      	b.n	1592 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    1988:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    198a:	462c      	mov	r4, r5
    198c:	e61d      	b.n	15ca <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    198e:	480c      	ldr	r0, [pc, #48]	; (19c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    1990:	f005 fd7c 	bl	748c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1994:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1998:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    199c:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    199e:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    19a2:	e692      	b.n	16ca <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    19a4:	200003ec 	.word	0x200003ec
    19a8:	20000a68 	.word	0x20000a68
    19ac:	200003f4 	.word	0x200003f4
    19b0:	20000488 	.word	0x20000488
    19b4:	20000450 	.word	0x20000450
    19b8:	2000049c 	.word	0x2000049c
    19bc:	20000394 	.word	0x20000394
    19c0:	200004e0 	.word	0x200004e0

000019c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    19c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    19c8:	4db7      	ldr	r5, [pc, #732]	; (1ca8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    19ca:	682b      	ldr	r3, [r5, #0]
    19cc:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    19d0:	f040 819a 	bne.w	1d08 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    19d4:	211a      	movs	r1, #26
    19d6:	48b5      	ldr	r0, [pc, #724]	; (1cac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    19d8:	f005 fd58 	bl	748c <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    19dc:	464c      	mov	r4, r9
    19de:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    19e0:	4fb3      	ldr	r7, [pc, #716]	; (1cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    19e2:	4db4      	ldr	r5, [pc, #720]	; (1cb4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    19e4:	4eb4      	ldr	r6, [pc, #720]	; (1cb8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    19e6:	eb04 0805 	add.w	r8, r4, r5
    19ea:	ea4f 1808 	mov.w	r8, r8, lsl #4
    19ee:	f8d8 3000 	ldr.w	r3, [r8]
    19f2:	f3c3 6303 	ubfx	r3, r3, #24, #4
    19f6:	2b0e      	cmp	r3, #14
    19f8:	f200 809e 	bhi.w	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    19fc:	e8df f013 	tbh	[pc, r3, lsl #1]
    1a00:	01300142 	.word	0x01300142
    1a04:	009c011e 	.word	0x009c011e
    1a08:	009c0103 	.word	0x009c0103
    1a0c:	009c00f1 	.word	0x009c00f1
    1a10:	00cd00df 	.word	0x00cd00df
    1a14:	009c00bb 	.word	0x009c00bb
    1a18:	009c000f 	.word	0x009c000f
    1a1c:	00a9      	.short	0x00a9
    1a1e:	2104      	movs	r1, #4
    1a20:	48a6      	ldr	r0, [pc, #664]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1a22:	f005 fd33 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a26:	2300      	movs	r3, #0
    1a28:	4649      	mov	r1, r9
    1a2a:	220a      	movs	r2, #10
    1a2c:	48a4      	ldr	r0, [pc, #656]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1a2e:	f003 fe83 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a32:	211d      	movs	r1, #29
    1a34:	48a3      	ldr	r0, [pc, #652]	; (1cc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    1a36:	f005 fd29 	bl	748c <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1a3a:	f8d8 3000 	ldr.w	r3, [r8]
    1a3e:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1a40:	029b      	lsls	r3, r3, #10
    1a42:	f140 81e3 	bpl.w	1e0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    1a46:	48a0      	ldr	r0, [pc, #640]	; (1cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    1a48:	f005 fd20 	bl	748c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a4c:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a50:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a54:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a56:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1a5a:	2107      	movs	r1, #7
    1a5c:	489b      	ldr	r0, [pc, #620]	; (1ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    1a5e:	f005 fd15 	bl	748c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1a62:	2300      	movs	r3, #0
    1a64:	2210      	movs	r2, #16
    1a66:	4651      	mov	r1, sl
    1a68:	4895      	ldr	r0, [pc, #596]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1a6a:	f003 fe65 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a6e:	2101      	movs	r1, #1
    1a70:	4897      	ldr	r0, [pc, #604]	; (1cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1a72:	f005 fd0b 	bl	748c <usb_serial_write>
    1a76:	210a      	movs	r1, #10
    1a78:	4896      	ldr	r0, [pc, #600]	; (1cd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    1a7a:	f005 fd07 	bl	748c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1a7e:	2300      	movs	r3, #0
    1a80:	2210      	movs	r2, #16
    1a82:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1a86:	488e      	ldr	r0, [pc, #568]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1a88:	f003 fe56 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a8c:	2101      	movs	r1, #1
    1a8e:	4892      	ldr	r0, [pc, #584]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1a90:	f005 fcfc 	bl	748c <usb_serial_write>
    1a94:	2300      	movs	r3, #0
    1a96:	2210      	movs	r2, #16
    1a98:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1a9c:	4888      	ldr	r0, [pc, #544]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1a9e:	f003 fe4b 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1aa2:	2101      	movs	r1, #1
    1aa4:	488c      	ldr	r0, [pc, #560]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1aa6:	f005 fcf1 	bl	748c <usb_serial_write>
    1aaa:	2300      	movs	r3, #0
    1aac:	2210      	movs	r2, #16
    1aae:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1ab2:	4883      	ldr	r0, [pc, #524]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ab4:	f003 fe40 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ab8:	2101      	movs	r1, #1
    1aba:	4887      	ldr	r0, [pc, #540]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1abc:	f005 fce6 	bl	748c <usb_serial_write>
    1ac0:	2300      	movs	r3, #0
    1ac2:	2210      	movs	r2, #16
    1ac4:	fa5f f189 	uxtb.w	r1, r9
    1ac8:	487d      	ldr	r0, [pc, #500]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1aca:	f003 fe35 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1ace:	f858 8007 	ldr.w	r8, [r8, r7]
    1ad2:	2101      	movs	r1, #1
    1ad4:	4880      	ldr	r0, [pc, #512]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1ad6:	f005 fcd9 	bl	748c <usb_serial_write>
    1ada:	2300      	movs	r3, #0
    1adc:	2210      	movs	r2, #16
    1ade:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1ae2:	4877      	ldr	r0, [pc, #476]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ae4:	f003 fe28 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ae8:	2101      	movs	r1, #1
    1aea:	487b      	ldr	r0, [pc, #492]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1aec:	f005 fcce 	bl	748c <usb_serial_write>
    1af0:	2300      	movs	r3, #0
    1af2:	2210      	movs	r2, #16
    1af4:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1af8:	4871      	ldr	r0, [pc, #452]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1afa:	f003 fe1d 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1afe:	2101      	movs	r1, #1
    1b00:	4875      	ldr	r0, [pc, #468]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1b02:	f005 fcc3 	bl	748c <usb_serial_write>
    1b06:	2300      	movs	r3, #0
    1b08:	2210      	movs	r2, #16
    1b0a:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1b0e:	486c      	ldr	r0, [pc, #432]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b10:	f003 fe12 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b14:	2101      	movs	r1, #1
    1b16:	4870      	ldr	r0, [pc, #448]	; (1cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1b18:	f005 fcb8 	bl	748c <usb_serial_write>
    1b1c:	2300      	movs	r3, #0
    1b1e:	fa5f f188 	uxtb.w	r1, r8
    1b22:	2210      	movs	r2, #16
    1b24:	4866      	ldr	r0, [pc, #408]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b26:	f003 fe07 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b2a:	2101      	movs	r1, #1
    1b2c:	4868      	ldr	r0, [pc, #416]	; (1cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1b2e:	f005 fcad 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b32:	4863      	ldr	r0, [pc, #396]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b34:	f003 fdf2 	bl	571c <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1b38:	4b5b      	ldr	r3, [pc, #364]	; (1ca8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1b3a:	3401      	adds	r4, #1
    1b3c:	681b      	ldr	r3, [r3, #0]
    1b3e:	b2e4      	uxtb	r4, r4
    1b40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1b44:	46a1      	mov	r9, r4
    1b46:	3301      	adds	r3, #1
    1b48:	429c      	cmp	r4, r3
    1b4a:	f4ff af4c 	bcc.w	19e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    1b4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1b52:	2104      	movs	r1, #4
    1b54:	4859      	ldr	r0, [pc, #356]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1b56:	f005 fc99 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1b5a:	4649      	mov	r1, r9
    1b5c:	2300      	movs	r3, #0
    1b5e:	220a      	movs	r2, #10
    1b60:	4857      	ldr	r0, [pc, #348]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b62:	f003 fde9 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b66:	2111      	movs	r1, #17
    1b68:	485c      	ldr	r0, [pc, #368]	; (1cdc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    1b6a:	f005 fc8f 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b6e:	4854      	ldr	r0, [pc, #336]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b70:	f003 fdd4 	bl	571c <Print::println()>
    1b74:	e7e0      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1b76:	2104      	movs	r1, #4
    1b78:	4850      	ldr	r0, [pc, #320]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1b7a:	f005 fc87 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1b7e:	4649      	mov	r1, r9
    1b80:	2300      	movs	r3, #0
    1b82:	220a      	movs	r2, #10
    1b84:	484e      	ldr	r0, [pc, #312]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b86:	f003 fdd7 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b8a:	2111      	movs	r1, #17
    1b8c:	4854      	ldr	r0, [pc, #336]	; (1ce0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    1b8e:	f005 fc7d 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b92:	484b      	ldr	r0, [pc, #300]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1b94:	f003 fdc2 	bl	571c <Print::println()>
    1b98:	e7ce      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1b9a:	2104      	movs	r1, #4
    1b9c:	4847      	ldr	r0, [pc, #284]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1b9e:	f005 fc75 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ba2:	4649      	mov	r1, r9
    1ba4:	2300      	movs	r3, #0
    1ba6:	220a      	movs	r2, #10
    1ba8:	4845      	ldr	r0, [pc, #276]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1baa:	f003 fdc5 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bae:	210f      	movs	r1, #15
    1bb0:	484c      	ldr	r0, [pc, #304]	; (1ce4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    1bb2:	f005 fc6b 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bb6:	4842      	ldr	r0, [pc, #264]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bb8:	f003 fdb0 	bl	571c <Print::println()>
    1bbc:	e7bc      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1bbe:	2104      	movs	r1, #4
    1bc0:	483e      	ldr	r0, [pc, #248]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1bc2:	f005 fc63 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1bc6:	4649      	mov	r1, r9
    1bc8:	2300      	movs	r3, #0
    1bca:	220a      	movs	r2, #10
    1bcc:	483c      	ldr	r0, [pc, #240]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bce:	f003 fdb3 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bd2:	2112      	movs	r1, #18
    1bd4:	4844      	ldr	r0, [pc, #272]	; (1ce8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    1bd6:	f005 fc59 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bda:	4839      	ldr	r0, [pc, #228]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bdc:	f003 fd9e 	bl	571c <Print::println()>
    1be0:	e7aa      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1be2:	2104      	movs	r1, #4
    1be4:	4835      	ldr	r0, [pc, #212]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1be6:	f005 fc51 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1bea:	4649      	mov	r1, r9
    1bec:	2300      	movs	r3, #0
    1bee:	220a      	movs	r2, #10
    1bf0:	4833      	ldr	r0, [pc, #204]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1bf2:	f003 fda1 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bf6:	2111      	movs	r1, #17
    1bf8:	483c      	ldr	r0, [pc, #240]	; (1cec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    1bfa:	f005 fc47 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bfe:	4830      	ldr	r0, [pc, #192]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c00:	f003 fd8c 	bl	571c <Print::println()>
    1c04:	e798      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1c06:	2104      	movs	r1, #4
    1c08:	482c      	ldr	r0, [pc, #176]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1c0a:	f005 fc3f 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c0e:	220a      	movs	r2, #10
    1c10:	4649      	mov	r1, r9
    1c12:	2300      	movs	r3, #0
    1c14:	482a      	ldr	r0, [pc, #168]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c16:	f003 fd8f 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c1a:	210f      	movs	r1, #15
    1c1c:	4834      	ldr	r0, [pc, #208]	; (1cf0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    1c1e:	f005 fc35 	bl	748c <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1c22:	f8d8 3000 	ldr.w	r3, [r8]
    1c26:	2111      	movs	r1, #17
    1c28:	029a      	lsls	r2, r3, #10
    1c2a:	bf4c      	ite	mi
    1c2c:	4831      	ldrmi	r0, [pc, #196]	; (1cf4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    1c2e:	4832      	ldrpl	r0, [pc, #200]	; (1cf8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    1c30:	f005 fc2c 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c34:	4822      	ldr	r0, [pc, #136]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c36:	f003 fd71 	bl	571c <Print::println()>
    1c3a:	e77d      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1c3c:	2104      	movs	r1, #4
    1c3e:	481f      	ldr	r0, [pc, #124]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1c40:	f005 fc24 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c44:	4649      	mov	r1, r9
    1c46:	2300      	movs	r3, #0
    1c48:	220a      	movs	r2, #10
    1c4a:	481d      	ldr	r0, [pc, #116]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c4c:	f003 fd74 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c50:	210e      	movs	r1, #14
    1c52:	482a      	ldr	r0, [pc, #168]	; (1cfc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    1c54:	f005 fc1a 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c58:	4819      	ldr	r0, [pc, #100]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c5a:	f003 fd5f 	bl	571c <Print::println()>
    1c5e:	e76b      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1c60:	2104      	movs	r1, #4
    1c62:	4816      	ldr	r0, [pc, #88]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1c64:	f005 fc12 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c68:	4649      	mov	r1, r9
    1c6a:	2300      	movs	r3, #0
    1c6c:	220a      	movs	r2, #10
    1c6e:	4814      	ldr	r0, [pc, #80]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c70:	f003 fd62 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c74:	210e      	movs	r1, #14
    1c76:	4822      	ldr	r0, [pc, #136]	; (1d00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    1c78:	f005 fc08 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c7c:	4810      	ldr	r0, [pc, #64]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c7e:	f003 fd4d 	bl	571c <Print::println()>
    1c82:	e759      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1c84:	2104      	movs	r1, #4
    1c86:	480d      	ldr	r0, [pc, #52]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1c88:	f005 fc00 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c8c:	4649      	mov	r1, r9
    1c8e:	2300      	movs	r3, #0
    1c90:	220a      	movs	r2, #10
    1c92:	480b      	ldr	r0, [pc, #44]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1c94:	f003 fd50 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c98:	2112      	movs	r1, #18
    1c9a:	481a      	ldr	r0, [pc, #104]	; (1d04 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    1c9c:	f005 fbf6 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1ca0:	4807      	ldr	r0, [pc, #28]	; (1cc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ca2:	f003 fd3b 	bl	571c <Print::println()>
    1ca6:	e747      	b.n	1b38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1ca8:	401d0000 	.word	0x401d0000
    1cac:	2000051c 	.word	0x2000051c
    1cb0:	401d008c 	.word	0x401d008c
    1cb4:	0401d008 	.word	0x0401d008
    1cb8:	bfe2ff80 	.word	0xbfe2ff80
    1cbc:	200003ec 	.word	0x200003ec
    1cc0:	20000a68 	.word	0x20000a68
    1cc4:	200004ac 	.word	0x200004ac
    1cc8:	200004cc 	.word	0x200004cc
    1ccc:	200004f4 	.word	0x200004f4
    1cd0:	20000428 	.word	0x20000428
    1cd4:	200004fc 	.word	0x200004fc
    1cd8:	20000390 	.word	0x20000390
    1cdc:	20000508 	.word	0x20000508
    1ce0:	20000464 	.word	0x20000464
    1ce4:	2000049c 	.word	0x2000049c
    1ce8:	20000488 	.word	0x20000488
    1cec:	20000450 	.word	0x20000450
    1cf0:	20000408 	.word	0x20000408
    1cf4:	20000418 	.word	0x20000418
    1cf8:	2000042c 	.word	0x2000042c
    1cfc:	20000440 	.word	0x20000440
    1d00:	20000478 	.word	0x20000478
    1d04:	200003f4 	.word	0x200003f4
    1d08:	2111      	movs	r1, #17
    1d0a:	48c4      	ldr	r0, [pc, #784]	; (201c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    1d0c:	f005 fbbe 	bl	748c <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    1d10:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1d12:	069a      	lsls	r2, r3, #26
    1d14:	f100 81fa 	bmi.w	210c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    1d18:	2112      	movs	r1, #18
    1d1a:	48c1      	ldr	r0, [pc, #772]	; (2020 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    1d1c:	f005 fbb6 	bl	748c <usb_serial_write>
    1d20:	48c0      	ldr	r0, [pc, #768]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1d22:	f003 fcfb 	bl	571c <Print::println()>
    1d26:	2116      	movs	r1, #22
    1d28:	48bf      	ldr	r0, [pc, #764]	; (2028 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    1d2a:	f005 fbaf 	bl	748c <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1d2e:	4abf      	ldr	r2, [pc, #764]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1d30:	6814      	ldr	r4, [r2, #0]
    1d32:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1d34:	6813      	ldr	r3, [r2, #0]
    1d36:	6b52      	ldr	r2, [r2, #52]	; 0x34
    1d38:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1d3c:	f3c2 6203 	ubfx	r2, r2, #24, #4
    1d40:	3301      	adds	r3, #1
    1d42:	3204      	adds	r2, #4
    1d44:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1d48:	f0c0 81e8 	bcc.w	211c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1d4c:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1d50:	f3c1 6103 	ubfx	r1, r1, #24, #4
    1d54:	3c05      	subs	r4, #5
    1d56:	3101      	adds	r1, #1
    1d58:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    1d5c:	b2e5      	uxtb	r5, r4
    1d5e:	4eb3      	ldr	r6, [pc, #716]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    1d60:	48b0      	ldr	r0, [pc, #704]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1d62:	6831      	ldr	r1, [r6, #0]
    1d64:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    1d68:	3101      	adds	r1, #1
    1d6a:	1b49      	subs	r1, r1, r5
    1d6c:	b2c9      	uxtb	r1, r1
    1d6e:	2920      	cmp	r1, #32
    1d70:	bfa8      	it	ge
    1d72:	2120      	movge	r1, #32
    1d74:	f003 fcc6 	bl	5704 <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    1d78:	48aa      	ldr	r0, [pc, #680]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1d7a:	f003 fccf 	bl	571c <Print::println()>
    1d7e:	2116      	movs	r1, #22
    1d80:	48ab      	ldr	r0, [pc, #684]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    1d82:	f005 fb83 	bl	748c <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1d86:	6833      	ldr	r3, [r6, #0]
    1d88:	6b72      	ldr	r2, [r6, #52]	; 0x34
    1d8a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1d8e:	f3c2 6203 	ubfx	r2, r2, #24, #4
    1d92:	3301      	adds	r3, #1
    1d94:	3204      	adds	r2, #4
    1d96:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1d9a:	d201      	bcs.n	1da0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    1d9c:	2500      	movs	r5, #0
    1d9e:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1da0:	2300      	movs	r3, #0
    1da2:	4621      	mov	r1, r4
    1da4:	220a      	movs	r2, #10
    1da6:	489f      	ldr	r0, [pc, #636]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1da8:	f003 fcc6 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1dac:	489d      	ldr	r0, [pc, #628]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1dae:	f003 fcb5 	bl	571c <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1db2:	4b9e      	ldr	r3, [pc, #632]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1db4:	681c      	ldr	r4, [r3, #0]
    1db6:	681b      	ldr	r3, [r3, #0]
    1db8:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1dbc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1dc0:	3401      	adds	r4, #1
    1dc2:	3301      	adds	r3, #1
    1dc4:	1b64      	subs	r4, r4, r5
    1dc6:	b2e4      	uxtb	r4, r4
    1dc8:	42a3      	cmp	r3, r4
    1dca:	f67f aec0 	bls.w	1b4e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1dce:	4d99      	ldr	r5, [pc, #612]	; (2034 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1dd0:	4e99      	ldr	r6, [pc, #612]	; (2038 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1dd2:	4f9a      	ldr	r7, [pc, #616]	; (203c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1dd4:	eb04 0805 	add.w	r8, r4, r5
    1dd8:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1ddc:	f8d8 3000 	ldr.w	r3, [r8]
    1de0:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1de4:	2b0e      	cmp	r3, #14
    1de6:	f200 80a9 	bhi.w	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1dea:	e8df f013 	tbh	[pc, r3, lsl #1]
    1dee:	0147      	.short	0x0147
    1df0:	00f20104 	.word	0x00f20104
    1df4:	00d700a7 	.word	0x00d700a7
    1df8:	016b00a7 	.word	0x016b00a7
    1dfc:	015900a7 	.word	0x015900a7
    1e00:	00c5017d 	.word	0x00c5017d
    1e04:	001a00a7 	.word	0x001a00a7
    1e08:	00b300a7 	.word	0x00b300a7
    1e0c:	488c      	ldr	r0, [pc, #560]	; (2040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    1e0e:	f005 fb3d 	bl	748c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1e12:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1e16:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1e1a:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1e1c:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    1e20:	e61b      	b.n	1a5a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    1e22:	2104      	movs	r1, #4
    1e24:	4887      	ldr	r0, [pc, #540]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1e26:	f005 fb31 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1e2a:	2300      	movs	r3, #0
    1e2c:	220a      	movs	r2, #10
    1e2e:	4621      	mov	r1, r4
    1e30:	487c      	ldr	r0, [pc, #496]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1e32:	f003 fc81 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e36:	211d      	movs	r1, #29
    1e38:	4883      	ldr	r0, [pc, #524]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    1e3a:	f005 fb27 	bl	748c <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1e3e:	f8d8 3000 	ldr.w	r3, [r8]
    1e42:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1e44:	0298      	lsls	r0, r3, #10
    1e46:	f140 816c 	bpl.w	2122 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    1e4a:	4880      	ldr	r0, [pc, #512]	; (204c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    1e4c:	f005 fb1e 	bl	748c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1e50:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1e54:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1e58:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1e5a:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1e5e:	2107      	movs	r1, #7
    1e60:	487b      	ldr	r0, [pc, #492]	; (2050 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    1e62:	f005 fb13 	bl	748c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1e66:	2300      	movs	r3, #0
    1e68:	2210      	movs	r2, #16
    1e6a:	4651      	mov	r1, sl
    1e6c:	486d      	ldr	r0, [pc, #436]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1e6e:	f003 fc63 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e72:	2101      	movs	r1, #1
    1e74:	4877      	ldr	r0, [pc, #476]	; (2054 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1e76:	f005 fb09 	bl	748c <usb_serial_write>
    1e7a:	210a      	movs	r1, #10
    1e7c:	4876      	ldr	r0, [pc, #472]	; (2058 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    1e7e:	f005 fb05 	bl	748c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1e82:	2300      	movs	r3, #0
    1e84:	2210      	movs	r2, #16
    1e86:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1e8a:	4866      	ldr	r0, [pc, #408]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1e8c:	f003 fc54 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e90:	2101      	movs	r1, #1
    1e92:	4872      	ldr	r0, [pc, #456]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1e94:	f005 fafa 	bl	748c <usb_serial_write>
    1e98:	2300      	movs	r3, #0
    1e9a:	2210      	movs	r2, #16
    1e9c:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1ea0:	4860      	ldr	r0, [pc, #384]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ea2:	f003 fc49 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ea6:	2101      	movs	r1, #1
    1ea8:	486c      	ldr	r0, [pc, #432]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1eaa:	f005 faef 	bl	748c <usb_serial_write>
    1eae:	2300      	movs	r3, #0
    1eb0:	2210      	movs	r2, #16
    1eb2:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1eb6:	485b      	ldr	r0, [pc, #364]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1eb8:	f003 fc3e 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ebc:	2101      	movs	r1, #1
    1ebe:	4867      	ldr	r0, [pc, #412]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1ec0:	f005 fae4 	bl	748c <usb_serial_write>
    1ec4:	2300      	movs	r3, #0
    1ec6:	2210      	movs	r2, #16
    1ec8:	fa5f f189 	uxtb.w	r1, r9
    1ecc:	4855      	ldr	r0, [pc, #340]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ece:	f003 fc33 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1ed2:	f858 8006 	ldr.w	r8, [r8, r6]
    1ed6:	2101      	movs	r1, #1
    1ed8:	4860      	ldr	r0, [pc, #384]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1eda:	f005 fad7 	bl	748c <usb_serial_write>
    1ede:	2300      	movs	r3, #0
    1ee0:	2210      	movs	r2, #16
    1ee2:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1ee6:	484f      	ldr	r0, [pc, #316]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ee8:	f003 fc26 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1eec:	2101      	movs	r1, #1
    1eee:	485b      	ldr	r0, [pc, #364]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1ef0:	f005 facc 	bl	748c <usb_serial_write>
    1ef4:	2300      	movs	r3, #0
    1ef6:	2210      	movs	r2, #16
    1ef8:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1efc:	4849      	ldr	r0, [pc, #292]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1efe:	f003 fc1b 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f02:	2101      	movs	r1, #1
    1f04:	4855      	ldr	r0, [pc, #340]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1f06:	f005 fac1 	bl	748c <usb_serial_write>
    1f0a:	2300      	movs	r3, #0
    1f0c:	2210      	movs	r2, #16
    1f0e:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1f12:	4844      	ldr	r0, [pc, #272]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f14:	f003 fc10 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f18:	2101      	movs	r1, #1
    1f1a:	4850      	ldr	r0, [pc, #320]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1f1c:	f005 fab6 	bl	748c <usb_serial_write>
    1f20:	2300      	movs	r3, #0
    1f22:	fa5f f188 	uxtb.w	r1, r8
    1f26:	2210      	movs	r2, #16
    1f28:	483e      	ldr	r0, [pc, #248]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f2a:	f003 fc05 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f2e:	2101      	movs	r1, #1
    1f30:	4848      	ldr	r0, [pc, #288]	; (2054 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1f32:	f005 faab 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f36:	483b      	ldr	r0, [pc, #236]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f38:	f003 fbf0 	bl	571c <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1f3c:	4b3b      	ldr	r3, [pc, #236]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1f3e:	3401      	adds	r4, #1
    1f40:	681b      	ldr	r3, [r3, #0]
    1f42:	b2e4      	uxtb	r4, r4
    1f44:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1f48:	3301      	adds	r3, #1
    1f4a:	429c      	cmp	r4, r3
    1f4c:	f4ff af42 	bcc.w	1dd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    1f50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f54:	2104      	movs	r1, #4
    1f56:	483b      	ldr	r0, [pc, #236]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1f58:	f005 fa98 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f5c:	2300      	movs	r3, #0
    1f5e:	220a      	movs	r2, #10
    1f60:	4621      	mov	r1, r4
    1f62:	4830      	ldr	r0, [pc, #192]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f64:	f003 fbe8 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f68:	2111      	movs	r1, #17
    1f6a:	483d      	ldr	r0, [pc, #244]	; (2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    1f6c:	f005 fa8e 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f70:	482c      	ldr	r0, [pc, #176]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f72:	f003 fbd3 	bl	571c <Print::println()>
    1f76:	e7e1      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1f78:	2104      	movs	r1, #4
    1f7a:	4832      	ldr	r0, [pc, #200]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1f7c:	f005 fa86 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f80:	2300      	movs	r3, #0
    1f82:	220a      	movs	r2, #10
    1f84:	4621      	mov	r1, r4
    1f86:	4827      	ldr	r0, [pc, #156]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f88:	f003 fbd6 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f8c:	2111      	movs	r1, #17
    1f8e:	4835      	ldr	r0, [pc, #212]	; (2064 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    1f90:	f005 fa7c 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f94:	4823      	ldr	r0, [pc, #140]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1f96:	f003 fbc1 	bl	571c <Print::println()>
    1f9a:	e7cf      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1f9c:	2104      	movs	r1, #4
    1f9e:	4829      	ldr	r0, [pc, #164]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1fa0:	f005 fa74 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1fa4:	220a      	movs	r2, #10
    1fa6:	2300      	movs	r3, #0
    1fa8:	4621      	mov	r1, r4
    1faa:	481e      	ldr	r0, [pc, #120]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1fac:	f003 fbc4 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fb0:	210f      	movs	r1, #15
    1fb2:	482d      	ldr	r0, [pc, #180]	; (2068 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    1fb4:	f005 fa6a 	bl	748c <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1fb8:	f8d8 3000 	ldr.w	r3, [r8]
    1fbc:	2111      	movs	r1, #17
    1fbe:	029b      	lsls	r3, r3, #10
    1fc0:	bf4c      	ite	mi
    1fc2:	482a      	ldrmi	r0, [pc, #168]	; (206c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    1fc4:	482a      	ldrpl	r0, [pc, #168]	; (2070 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    1fc6:	f005 fa61 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fca:	4816      	ldr	r0, [pc, #88]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1fcc:	f003 fba6 	bl	571c <Print::println()>
    1fd0:	e7b4      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1fd2:	2104      	movs	r1, #4
    1fd4:	481b      	ldr	r0, [pc, #108]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1fd6:	f005 fa59 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1fda:	2300      	movs	r3, #0
    1fdc:	220a      	movs	r2, #10
    1fde:	4621      	mov	r1, r4
    1fe0:	4810      	ldr	r0, [pc, #64]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1fe2:	f003 fba9 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fe6:	210e      	movs	r1, #14
    1fe8:	4822      	ldr	r0, [pc, #136]	; (2074 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    1fea:	f005 fa4f 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fee:	480d      	ldr	r0, [pc, #52]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ff0:	f003 fb94 	bl	571c <Print::println()>
    1ff4:	e7a2      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1ff6:	2104      	movs	r1, #4
    1ff8:	4812      	ldr	r0, [pc, #72]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1ffa:	f005 fa47 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ffe:	2300      	movs	r3, #0
    2000:	220a      	movs	r2, #10
    2002:	4621      	mov	r1, r4
    2004:	4807      	ldr	r0, [pc, #28]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2006:	f003 fb97 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    200a:	210e      	movs	r1, #14
    200c:	481a      	ldr	r0, [pc, #104]	; (2078 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    200e:	f005 fa3d 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2012:	4804      	ldr	r0, [pc, #16]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2014:	f003 fb82 	bl	571c <Print::println()>
    2018:	e790      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    201a:	bf00      	nop
    201c:	20000380 	.word	0x20000380
    2020:	200003a8 	.word	0x200003a8
    2024:	20000a68 	.word	0x20000a68
    2028:	200003bc 	.word	0x200003bc
    202c:	401d0000 	.word	0x401d0000
    2030:	200003d4 	.word	0x200003d4
    2034:	0401d008 	.word	0x0401d008
    2038:	401d008c 	.word	0x401d008c
    203c:	bfe2ff80 	.word	0xbfe2ff80
    2040:	200004e0 	.word	0x200004e0
    2044:	200003ec 	.word	0x200003ec
    2048:	200004ac 	.word	0x200004ac
    204c:	200004cc 	.word	0x200004cc
    2050:	200004f4 	.word	0x200004f4
    2054:	20000428 	.word	0x20000428
    2058:	200004fc 	.word	0x200004fc
    205c:	20000390 	.word	0x20000390
    2060:	20000508 	.word	0x20000508
    2064:	20000464 	.word	0x20000464
    2068:	20000408 	.word	0x20000408
    206c:	20000418 	.word	0x20000418
    2070:	2000042c 	.word	0x2000042c
    2074:	20000440 	.word	0x20000440
    2078:	20000478 	.word	0x20000478
    207c:	2104      	movs	r1, #4
    207e:	482e      	ldr	r0, [pc, #184]	; (2138 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    2080:	f005 fa04 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2084:	2300      	movs	r3, #0
    2086:	220a      	movs	r2, #10
    2088:	4621      	mov	r1, r4
    208a:	482c      	ldr	r0, [pc, #176]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    208c:	f003 fb54 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2090:	2112      	movs	r1, #18
    2092:	482b      	ldr	r0, [pc, #172]	; (2140 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    2094:	f005 f9fa 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2098:	4828      	ldr	r0, [pc, #160]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    209a:	f003 fb3f 	bl	571c <Print::println()>
    209e:	e74d      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    20a0:	2104      	movs	r1, #4
    20a2:	4825      	ldr	r0, [pc, #148]	; (2138 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    20a4:	f005 f9f2 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20a8:	2300      	movs	r3, #0
    20aa:	220a      	movs	r2, #10
    20ac:	4621      	mov	r1, r4
    20ae:	4823      	ldr	r0, [pc, #140]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    20b0:	f003 fb42 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    20b4:	2112      	movs	r1, #18
    20b6:	4823      	ldr	r0, [pc, #140]	; (2144 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    20b8:	f005 f9e8 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    20bc:	481f      	ldr	r0, [pc, #124]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    20be:	f003 fb2d 	bl	571c <Print::println()>
    20c2:	e73b      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    20c4:	2104      	movs	r1, #4
    20c6:	481c      	ldr	r0, [pc, #112]	; (2138 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    20c8:	f005 f9e0 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20cc:	2300      	movs	r3, #0
    20ce:	220a      	movs	r2, #10
    20d0:	4621      	mov	r1, r4
    20d2:	481a      	ldr	r0, [pc, #104]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    20d4:	f003 fb30 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    20d8:	2111      	movs	r1, #17
    20da:	481b      	ldr	r0, [pc, #108]	; (2148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    20dc:	f005 f9d6 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    20e0:	4816      	ldr	r0, [pc, #88]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    20e2:	f003 fb1b 	bl	571c <Print::println()>
    20e6:	e729      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    20e8:	2104      	movs	r1, #4
    20ea:	4813      	ldr	r0, [pc, #76]	; (2138 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    20ec:	f005 f9ce 	bl	748c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    20f0:	2300      	movs	r3, #0
    20f2:	220a      	movs	r2, #10
    20f4:	4621      	mov	r1, r4
    20f6:	4811      	ldr	r0, [pc, #68]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    20f8:	f003 fb1e 	bl	5738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    20fc:	210f      	movs	r1, #15
    20fe:	4813      	ldr	r0, [pc, #76]	; (214c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    2100:	f005 f9c4 	bl	748c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2104:	480d      	ldr	r0, [pc, #52]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2106:	f003 fb09 	bl	571c <Print::println()>
    210a:	e717      	b.n	1f3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    210c:	2111      	movs	r1, #17
    210e:	4810      	ldr	r0, [pc, #64]	; (2150 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    2110:	f005 f9bc 	bl	748c <usb_serial_write>
    2114:	4809      	ldr	r0, [pc, #36]	; (213c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2116:	f003 fb01 	bl	571c <Print::println()>
    211a:	e604      	b.n	1d26 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    211c:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    211e:	462c      	mov	r4, r5
    2120:	e61d      	b.n	1d5e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    2122:	480c      	ldr	r0, [pc, #48]	; (2154 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    2124:	f005 f9b2 	bl	748c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2128:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    212c:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2130:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    2132:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    2136:	e692      	b.n	1e5e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    2138:	200003ec 	.word	0x200003ec
    213c:	20000a68 	.word	0x20000a68
    2140:	200003f4 	.word	0x200003f4
    2144:	20000488 	.word	0x20000488
    2148:	20000450 	.word	0x20000450
    214c:	2000049c 	.word	0x2000049c
    2150:	20000394 	.word	0x20000394
    2154:	200004e0 	.word	0x200004e0

00002158 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    2158:	b570      	push	{r4, r5, r6, lr}
    215a:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    215c:	bb39      	cbnz	r1, 21ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    215e:	4a3b      	ldr	r2, [pc, #236]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2160:	6a13      	ldr	r3, [r2, #32]
    2162:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2166:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    216a:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    216c:	4b38      	ldr	r3, [pc, #224]	; (2250 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    216e:	6818      	ldr	r0, [r3, #0]
    2170:	b158      	cbz	r0, 218a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    2172:	4a38      	ldr	r2, [pc, #224]	; (2254 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2174:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    2178:	6805      	ldr	r5, [r0, #0]
    217a:	6852      	ldr	r2, [r2, #4]
    217c:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    2180:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2184:	686b      	ldr	r3, [r5, #4]
    2186:	0052      	lsls	r2, r2, #1
    2188:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    218a:	4b33      	ldr	r3, [pc, #204]	; (2258 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    218c:	6818      	ldr	r0, [r3, #0]
    218e:	2800      	cmp	r0, #0
    2190:	d05b      	beq.n	224a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    2192:	4a30      	ldr	r2, [pc, #192]	; (2254 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2194:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2198:	6803      	ldr	r3, [r0, #0]
    219a:	6852      	ldr	r2, [r2, #4]
    219c:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    21a0:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    21a4:	685b      	ldr	r3, [r3, #4]
    21a6:	0052      	lsls	r2, r2, #1
}
    21a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    21ac:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    21ae:	2908      	cmp	r1, #8
    21b0:	d107      	bne.n	21c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    21b2:	4a26      	ldr	r2, [pc, #152]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    21b4:	6a13      	ldr	r3, [r2, #32]
    21b6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    21ba:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    21be:	6213      	str	r3, [r2, #32]
    21c0:	e7d4      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    21c2:	2910      	cmp	r1, #16
    21c4:	d107      	bne.n	21d6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    21c6:	4a21      	ldr	r2, [pc, #132]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    21c8:	6a13      	ldr	r3, [r2, #32]
    21ca:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    21ce:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    21d2:	6213      	str	r3, [r2, #32]
    21d4:	e7ca      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    21d6:	2918      	cmp	r1, #24
    21d8:	d107      	bne.n	21ea <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    21da:	4a1c      	ldr	r2, [pc, #112]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    21dc:	6a13      	ldr	r3, [r2, #32]
    21de:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    21e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    21e6:	6213      	str	r3, [r2, #32]
    21e8:	e7c0      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    21ea:	2914      	cmp	r1, #20
    21ec:	d107      	bne.n	21fe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    21ee:	4a17      	ldr	r2, [pc, #92]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    21f0:	6a13      	ldr	r3, [r2, #32]
    21f2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    21f6:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    21fa:	6213      	str	r3, [r2, #32]
    21fc:	e7b6      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    21fe:	291e      	cmp	r1, #30
    2200:	d107      	bne.n	2212 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    2202:	4a12      	ldr	r2, [pc, #72]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2204:	6a13      	ldr	r3, [r2, #32]
    2206:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    220a:	f043 0304 	orr.w	r3, r3, #4
    220e:	6213      	str	r3, [r2, #32]
    2210:	e7ac      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2212:	2928      	cmp	r1, #40	; 0x28
    2214:	d107      	bne.n	2226 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    2216:	4a0d      	ldr	r2, [pc, #52]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2218:	6a13      	ldr	r3, [r2, #32]
    221a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    221e:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    2222:	6213      	str	r3, [r2, #32]
    2224:	e7a2      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2226:	293c      	cmp	r1, #60	; 0x3c
    2228:	d105      	bne.n	2236 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    222a:	4a08      	ldr	r2, [pc, #32]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    222c:	6a13      	ldr	r3, [r2, #32]
    222e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2232:	6213      	str	r3, [r2, #32]
    2234:	e79a      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2236:	2950      	cmp	r1, #80	; 0x50
    2238:	d198      	bne.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    223a:	4a04      	ldr	r2, [pc, #16]	; (224c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    223c:	6a13      	ldr	r3, [r2, #32]
    223e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2242:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    2246:	6213      	str	r3, [r2, #32]
    2248:	e790      	b.n	216c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    224a:	bd70      	pop	{r4, r5, r6, pc}
    224c:	400fc000 	.word	0x400fc000
    2250:	20006870 	.word	0x20006870
    2254:	401d0000 	.word	0x401d0000
    2258:	20006874 	.word	0x20006874

0000225c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    225c:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    225e:	494e      	ldr	r1, [pc, #312]	; (2398 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    2260:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    2262:	4b4e      	ldr	r3, [pc, #312]	; (239c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    2264:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    2266:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    2268:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    226a:	6a1b      	ldr	r3, [r3, #32]
    226c:	f3c3 2301 	ubfx	r3, r3, #8, #2
    2270:	3308      	adds	r3, #8
    2272:	446b      	add	r3, sp
    2274:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    2278:	e9c0 2201 	strd	r2, r2, [r0, #4]
    227c:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2280:	2b00      	cmp	r3, #0
    2282:	f000 8085 	beq.w	2390 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C000;
    2286:	4945      	ldr	r1, [pc, #276]	; (239c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN1;
    2288:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    228c:	2024      	movs	r0, #36	; 0x24
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    228e:	4b44      	ldr	r3, [pc, #272]	; (23a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    2290:	4a44      	ldr	r2, [pc, #272]	; (23a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 1;
    2292:	2401      	movs	r4, #1
    nvicIrq = IRQ_CAN1;
    2294:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    2298:	2602      	movs	r6, #2
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    229a:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    229e:	2012      	movs	r0, #18
    CCM_CCGR0 |= 0x3C000;
    22a0:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    22a2:	4b41      	ldr	r3, [pc, #260]	; (23a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C000;
    22a4:	f442 3270 	orr.w	r2, r2, #245760	; 0x3c000
    22a8:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    22aa:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 1;
    22ae:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    22b2:	4a3e      	ldr	r2, [pc, #248]	; (23ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    22b4:	4c3e      	ldr	r4, [pc, #248]	; (23b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    22b6:	f8c3 011c 	str.w	r0, [r3, #284]	; 0x11c
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    22ba:	f8c3 130c 	str.w	r1, [r3, #780]	; 0x30c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    22be:	64e6      	str	r6, [r4, #76]	; 0x4c
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 0x12; // pin 23 T4B1+B2
    22c0:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09 = 0x10B0; // pin 23 T4B1+B2
    22c4:	f8c3 1310 	str.w	r1, [r3, #784]	; 0x310
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    22c8:	6813      	ldr	r3, [r2, #0]
    22ca:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    22ce:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    22d0:	6813      	ldr	r3, [r2, #0]
    22d2:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    22d6:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    22d8:	6813      	ldr	r3, [r2, #0]
    22da:	01dc      	lsls	r4, r3, #7
    22dc:	d5fc      	bpl.n	22d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    22de:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    22e0:	4932      	ldr	r1, [pc, #200]	; (23ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    22e2:	f043 0308 	orr.w	r3, r3, #8
    22e6:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    22e8:	6813      	ldr	r3, [r2, #0]
    22ea:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    22ee:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    22f0:	680b      	ldr	r3, [r1, #0]
    22f2:	02d8      	lsls	r0, r3, #11
    22f4:	d4fc      	bmi.n	22f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    22f6:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    22f8:	4a2c      	ldr	r2, [pc, #176]	; (23ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    22fa:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    22fe:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2300:	6813      	ldr	r3, [r2, #0]
    2302:	0199      	lsls	r1, r3, #6
    2304:	d4fc      	bmi.n	2300 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2306:	4c29      	ldr	r4, [pc, #164]	; (23ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    2308:	6823      	ldr	r3, [r4, #0]
    230a:	01da      	lsls	r2, r3, #7
    230c:	d5fc      	bpl.n	2308 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    230e:	6823      	ldr	r3, [r4, #0]
    void disableFIFO() { enableFIFO(0); }
    2310:	2000      	movs	r0, #0
    2312:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    2316:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    2318:	6823      	ldr	r3, [r4, #0]
    231a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    231e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    2320:	6823      	ldr	r3, [r4, #0]
    2322:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2326:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    2328:	6823      	ldr	r3, [r4, #0]
    232a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    232e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    2330:	6823      	ldr	r3, [r4, #0]
    2332:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    2336:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    2338:	6823      	ldr	r3, [r4, #0]
    233a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    233e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    2340:	6823      	ldr	r3, [r4, #0]
    2342:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    2346:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    2348:	6b63      	ldr	r3, [r4, #52]	; 0x34
    234a:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    234e:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    2350:	6823      	ldr	r3, [r4, #0]
    2352:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    2356:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    2358:	6823      	ldr	r3, [r4, #0]
    235a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    235e:	6023      	str	r3, [r4, #0]
    2360:	f7fe fdca 	bl	ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2364:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2366:	4a11      	ldr	r2, [pc, #68]	; (23ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2368:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    236c:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    236e:	6813      	ldr	r3, [r2, #0]
    2370:	01db      	lsls	r3, r3, #7
    2372:	d4fc      	bmi.n	236e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    2374:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    2378:	2101      	movs	r1, #1
    237a:	4b0e      	ldr	r3, [pc, #56]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    237c:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2380:	f002 021f 	and.w	r2, r2, #31
    2384:	009b      	lsls	r3, r3, #2
    2386:	fa01 f202 	lsl.w	r2, r1, r2
    238a:	601a      	str	r2, [r3, #0]
}
    238c:	b002      	add	sp, #8
    238e:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2390:	2118      	movs	r1, #24
    2392:	f7ff fee1 	bl	2158 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    2396:	e776      	b.n	2286 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    2398:	0050183c 	.word	0x0050183c
    239c:	400fc000 	.word	0x400fc000
    23a0:	20001000 	.word	0x20001000
    23a4:	00000b31 	.word	0x00000b31
    23a8:	401f8000 	.word	0x401f8000
    23ac:	401d0000 	.word	0x401d0000
    23b0:	401f8400 	.word	0x401f8400
    23b4:	38003840 	.word	0x38003840

000023b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    23b8:	b570      	push	{r4, r5, r6, lr}
    23ba:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    23bc:	bb39      	cbnz	r1, 240e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    23be:	4a3b      	ldr	r2, [pc, #236]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    23c0:	6a13      	ldr	r3, [r2, #32]
    23c2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    23c6:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    23ca:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    23cc:	4b38      	ldr	r3, [pc, #224]	; (24b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    23ce:	6818      	ldr	r0, [r3, #0]
    23d0:	b158      	cbz	r0, 23ea <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    23d2:	4a38      	ldr	r2, [pc, #224]	; (24b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    23d4:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    23d8:	6805      	ldr	r5, [r0, #0]
    23da:	6852      	ldr	r2, [r2, #4]
    23dc:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    23e0:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    23e4:	686b      	ldr	r3, [r5, #4]
    23e6:	0052      	lsls	r2, r2, #1
    23e8:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    23ea:	4b33      	ldr	r3, [pc, #204]	; (24b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    23ec:	6818      	ldr	r0, [r3, #0]
    23ee:	2800      	cmp	r0, #0
    23f0:	d05b      	beq.n	24aa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    23f2:	4a30      	ldr	r2, [pc, #192]	; (24b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    23f4:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    23f8:	6803      	ldr	r3, [r0, #0]
    23fa:	6852      	ldr	r2, [r2, #4]
    23fc:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    2400:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2404:	685b      	ldr	r3, [r3, #4]
    2406:	0052      	lsls	r2, r2, #1
}
    2408:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    240c:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    240e:	2908      	cmp	r1, #8
    2410:	d107      	bne.n	2422 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    2412:	4a26      	ldr	r2, [pc, #152]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2414:	6a13      	ldr	r3, [r2, #32]
    2416:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    241a:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    241e:	6213      	str	r3, [r2, #32]
    2420:	e7d4      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    2422:	2910      	cmp	r1, #16
    2424:	d107      	bne.n	2436 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    2426:	4a21      	ldr	r2, [pc, #132]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2428:	6a13      	ldr	r3, [r2, #32]
    242a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    242e:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    2432:	6213      	str	r3, [r2, #32]
    2434:	e7ca      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2436:	2918      	cmp	r1, #24
    2438:	d107      	bne.n	244a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    243a:	4a1c      	ldr	r2, [pc, #112]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    243c:	6a13      	ldr	r3, [r2, #32]
    243e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2442:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    2446:	6213      	str	r3, [r2, #32]
    2448:	e7c0      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    244a:	2914      	cmp	r1, #20
    244c:	d107      	bne.n	245e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    244e:	4a17      	ldr	r2, [pc, #92]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2450:	6a13      	ldr	r3, [r2, #32]
    2452:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2456:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    245a:	6213      	str	r3, [r2, #32]
    245c:	e7b6      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    245e:	291e      	cmp	r1, #30
    2460:	d107      	bne.n	2472 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    2462:	4a12      	ldr	r2, [pc, #72]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2464:	6a13      	ldr	r3, [r2, #32]
    2466:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    246a:	f043 0304 	orr.w	r3, r3, #4
    246e:	6213      	str	r3, [r2, #32]
    2470:	e7ac      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2472:	2928      	cmp	r1, #40	; 0x28
    2474:	d107      	bne.n	2486 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    2476:	4a0d      	ldr	r2, [pc, #52]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2478:	6a13      	ldr	r3, [r2, #32]
    247a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    247e:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    2482:	6213      	str	r3, [r2, #32]
    2484:	e7a2      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2486:	293c      	cmp	r1, #60	; 0x3c
    2488:	d105      	bne.n	2496 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    248a:	4a08      	ldr	r2, [pc, #32]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    248c:	6a13      	ldr	r3, [r2, #32]
    248e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2492:	6213      	str	r3, [r2, #32]
    2494:	e79a      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2496:	2950      	cmp	r1, #80	; 0x50
    2498:	d198      	bne.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    249a:	4a04      	ldr	r2, [pc, #16]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    249c:	6a13      	ldr	r3, [r2, #32]
    249e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    24a2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    24a6:	6213      	str	r3, [r2, #32]
    24a8:	e790      	b.n	23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    24aa:	bd70      	pop	{r4, r5, r6, pc}
    24ac:	400fc000 	.word	0x400fc000
    24b0:	20006870 	.word	0x20006870
    24b4:	401d4000 	.word	0x401d4000
    24b8:	20006874 	.word	0x20006874

000024bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    24bc:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    24be:	494e      	ldr	r1, [pc, #312]	; (25f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    24c0:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    24c2:	4b4e      	ldr	r3, [pc, #312]	; (25fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    24c4:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    24c6:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    24c8:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    24ca:	6a1b      	ldr	r3, [r3, #32]
    24cc:	f3c3 2301 	ubfx	r3, r3, #8, #2
    24d0:	3308      	adds	r3, #8
    24d2:	446b      	add	r3, sp
    24d4:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    24d8:	e9c0 2201 	strd	r2, r2, [r0, #4]
    24dc:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    24e0:	2b00      	cmp	r3, #0
    24e2:	f000 8085 	beq.w	25f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C0000;
    24e6:	4945      	ldr	r1, [pc, #276]	; (25fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN2;
    24e8:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    24ec:	2025      	movs	r0, #37	; 0x25
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    24ee:	4b44      	ldr	r3, [pc, #272]	; (2600 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    24f0:	4a44      	ldr	r2, [pc, #272]	; (2604 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 2;
    24f2:	2402      	movs	r4, #2
    nvicIrq = IRQ_CAN2;
    24f4:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    24f8:	2601      	movs	r6, #1
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    24fa:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    24fe:	2010      	movs	r0, #16
    CCM_CCGR0 |= 0x3C0000;
    2500:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    2502:	4b41      	ldr	r3, [pc, #260]	; (2608 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C0000;
    2504:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
    2508:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    250a:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 2;
    250e:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2512:	4a3e      	ldr	r2, [pc, #248]	; (260c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    2514:	4c3e      	ldr	r4, [pc, #248]	; (2610 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    2516:	f8c3 00c4 	str.w	r0, [r3, #196]	; 0xc4
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    251a:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    251e:	6526      	str	r6, [r4, #80]	; 0x50
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03 = 0x10; // pin 0 T4B1+B2
    2520:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03 = 0x10B0; // pin 0 T4B1+B2
    2524:	f8c3 12b8 	str.w	r1, [r3, #696]	; 0x2b8
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2528:	6813      	ldr	r3, [r2, #0]
    252a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    252e:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2530:	6813      	ldr	r3, [r2, #0]
    2532:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    2536:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2538:	6813      	ldr	r3, [r2, #0]
    253a:	01dc      	lsls	r4, r3, #7
    253c:	d5fc      	bpl.n	2538 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    253e:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2540:	4932      	ldr	r1, [pc, #200]	; (260c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2542:	f043 0308 	orr.w	r3, r3, #8
    2546:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    2548:	6813      	ldr	r3, [r2, #0]
    254a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    254e:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2550:	680b      	ldr	r3, [r1, #0]
    2552:	02d8      	lsls	r0, r3, #11
    2554:	d4fc      	bmi.n	2550 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    2556:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2558:	4a2c      	ldr	r2, [pc, #176]	; (260c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    255a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    255e:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2560:	6813      	ldr	r3, [r2, #0]
    2562:	0199      	lsls	r1, r3, #6
    2564:	d4fc      	bmi.n	2560 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2566:	4c29      	ldr	r4, [pc, #164]	; (260c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    2568:	6823      	ldr	r3, [r4, #0]
    256a:	01da      	lsls	r2, r3, #7
    256c:	d5fc      	bpl.n	2568 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    256e:	6823      	ldr	r3, [r4, #0]
    2570:	2000      	movs	r0, #0
    2572:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    2576:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    2578:	6823      	ldr	r3, [r4, #0]
    257a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    257e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    2580:	6823      	ldr	r3, [r4, #0]
    2582:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2586:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    2588:	6823      	ldr	r3, [r4, #0]
    258a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    258e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    2590:	6823      	ldr	r3, [r4, #0]
    2592:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    2596:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    2598:	6823      	ldr	r3, [r4, #0]
    259a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    259e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    25a0:	6823      	ldr	r3, [r4, #0]
    25a2:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    25a6:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    25a8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    25aa:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    25ae:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    25b0:	6823      	ldr	r3, [r4, #0]
    25b2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    25b6:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    25b8:	6823      	ldr	r3, [r4, #0]
    25ba:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    25be:	6023      	str	r3, [r4, #0]
    25c0:	f7fe fd68 	bl	1094 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    25c4:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    25c6:	4a11      	ldr	r2, [pc, #68]	; (260c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    25c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    25cc:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    25ce:	6813      	ldr	r3, [r2, #0]
    25d0:	01db      	lsls	r3, r3, #7
    25d2:	d4fc      	bmi.n	25ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    25d4:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    25d8:	2101      	movs	r1, #1
    25da:	4b0e      	ldr	r3, [pc, #56]	; (2614 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    25dc:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    25e0:	f002 021f 	and.w	r2, r2, #31
    25e4:	009b      	lsls	r3, r3, #2
    25e6:	fa01 f202 	lsl.w	r2, r1, r2
    25ea:	601a      	str	r2, [r3, #0]
}
    25ec:	b002      	add	sp, #8
    25ee:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    25f0:	2118      	movs	r1, #24
    25f2:	f7ff fee1 	bl	23b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    25f6:	e776      	b.n	24e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    25f8:	0050183c 	.word	0x0050183c
    25fc:	400fc000 	.word	0x400fc000
    2600:	20001000 	.word	0x20001000
    2604:	00000b45 	.word	0x00000b45
    2608:	401f8000 	.word	0x401f8000
    260c:	401d4000 	.word	0x401d4000
    2610:	401f8400 	.word	0x401f8400
    2614:	38003840 	.word	0x38003840

00002618 <canInit()>:
void canInit(void) {
    2618:	b538      	push	{r3, r4, r5, lr}
  HaldexCAN.begin();
    261a:	484a      	ldr	r0, [pc, #296]	; (2744 <canInit()+0x12c>)
    261c:	f7ff fe1e 	bl	225c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2620:	4c49      	ldr	r4, [pc, #292]	; (2748 <canInit()+0x130>)
  HaldexCAN.setClock(CLK_60MHz);
    2622:	213c      	movs	r1, #60	; 0x3c
    2624:	4847      	ldr	r0, [pc, #284]	; (2744 <canInit()+0x12c>)
    2626:	f7ff fd97 	bl	2158 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  HaldexCAN.setBaudRate(500000);
    262a:	2200      	movs	r2, #0
    262c:	4947      	ldr	r1, [pc, #284]	; (274c <canInit()+0x134>)
    262e:	4845      	ldr	r0, [pc, #276]	; (2744 <canInit()+0x12c>)
    2630:	f7fe fa92 	bl	b58 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    2634:	6823      	ldr	r3, [r4, #0]
    2636:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    263a:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    263c:	6823      	ldr	r3, [r4, #0]
    263e:	01dd      	lsls	r5, r3, #7
    2640:	d5fc      	bpl.n	263c <canInit()+0x24>
    2642:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    2644:	6825      	ldr	r5, [r4, #0]
    2646:	f7fe fc57 	bl	ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    264a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    264c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    264e:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    2650:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    2652:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    2654:	6823      	ldr	r3, [r4, #0]
    2656:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    265a:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    265c:	6823      	ldr	r3, [r4, #0]
    265e:	f043 030f 	orr.w	r3, r3, #15
    2662:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    2664:	d469      	bmi.n	273a <canInit()+0x122>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2666:	4c38      	ldr	r4, [pc, #224]	; (2748 <canInit()+0x130>)
    2668:	6823      	ldr	r3, [r4, #0]
    266a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    266e:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2670:	6823      	ldr	r3, [r4, #0]
    2672:	01d9      	lsls	r1, r3, #7
    2674:	d4fc      	bmi.n	2670 <canInit()+0x58>
  _mainHandler = handler;
    2676:	4b36      	ldr	r3, [pc, #216]	; (2750 <canInit()+0x138>)
  HaldexCAN.enableFIFO();
    2678:	2001      	movs	r0, #1
    267a:	4a36      	ldr	r2, [pc, #216]	; (2754 <canInit()+0x13c>)
    267c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    2680:	f7fe fc3a 	bl	ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    2684:	6823      	ldr	r3, [r4, #0]
    2686:	009a      	lsls	r2, r3, #2
    2688:	d50a      	bpl.n	26a0 <canInit()+0x88>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    268a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    268c:	069b      	lsls	r3, r3, #26
    268e:	d407      	bmi.n	26a0 <canInit()+0x88>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    2690:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2692:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2696:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2698:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    269a:	f043 0320 	orr.w	r3, r3, #32
    269e:	62a3      	str	r3, [r4, #40]	; 0x28
  HaldexCAN.mailboxStatus();
    26a0:	f7ff f990 	bl	19c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  ChassisCAN.begin();
    26a4:	482c      	ldr	r0, [pc, #176]	; (2758 <canInit()+0x140>)
    26a6:	f7ff ff09 	bl	24bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    26aa:	4c2c      	ldr	r4, [pc, #176]	; (275c <canInit()+0x144>)
  ChassisCAN.setClock(CLK_60MHz);
    26ac:	213c      	movs	r1, #60	; 0x3c
    26ae:	482a      	ldr	r0, [pc, #168]	; (2758 <canInit()+0x140>)
    26b0:	f7ff fe82 	bl	23b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  ChassisCAN.setBaudRate(500000);
    26b4:	2200      	movs	r2, #0
    26b6:	4925      	ldr	r1, [pc, #148]	; (274c <canInit()+0x134>)
    26b8:	4827      	ldr	r0, [pc, #156]	; (2758 <canInit()+0x140>)
    26ba:	f7fe fb0b 	bl	cd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    26be:	6823      	ldr	r3, [r4, #0]
    26c0:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    26c4:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    26c6:	6823      	ldr	r3, [r4, #0]
    26c8:	01dd      	lsls	r5, r3, #7
    26ca:	d5fc      	bpl.n	26c6 <canInit()+0xae>
    26cc:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    26ce:	6825      	ldr	r5, [r4, #0]
    26d0:	f7fe fce0 	bl	1094 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    26d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    26d6:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    26d8:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    26da:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    26dc:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    26de:	6823      	ldr	r3, [r4, #0]
    26e0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    26e4:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    26e6:	6823      	ldr	r3, [r4, #0]
    26e8:	f043 030f 	orr.w	r3, r3, #15
    26ec:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    26ee:	d420      	bmi.n	2732 <canInit()+0x11a>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    26f0:	4c1a      	ldr	r4, [pc, #104]	; (275c <canInit()+0x144>)
    26f2:	6823      	ldr	r3, [r4, #0]
    26f4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    26f8:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    26fa:	6823      	ldr	r3, [r4, #0]
    26fc:	01d9      	lsls	r1, r3, #7
    26fe:	d4fc      	bmi.n	26fa <canInit()+0xe2>
  _mainHandler = handler;
    2700:	4b17      	ldr	r3, [pc, #92]	; (2760 <canInit()+0x148>)
  ChassisCAN.enableFIFO();
    2702:	2001      	movs	r0, #1
    2704:	4a17      	ldr	r2, [pc, #92]	; (2764 <canInit()+0x14c>)
    2706:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    270a:	f7fe fcc3 	bl	1094 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    270e:	6823      	ldr	r3, [r4, #0]
    2710:	009a      	lsls	r2, r3, #2
    2712:	d50a      	bpl.n	272a <canInit()+0x112>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    2714:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2716:	069b      	lsls	r3, r3, #26
    2718:	d407      	bmi.n	272a <canInit()+0x112>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    271a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    271c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2720:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2722:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2724:	f043 0320 	orr.w	r3, r3, #32
    2728:	62a3      	str	r3, [r4, #40]	; 0x28
}
    272a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ChassisCAN.mailboxStatus();
    272e:	f7fe bd7f 	b.w	1230 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  if ( fifo_was_cleared ) enableFIFO();
    2732:	2001      	movs	r0, #1
    2734:	f7fe fcae 	bl	1094 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2738:	e7da      	b.n	26f0 <canInit()+0xd8>
    273a:	2001      	movs	r0, #1
    273c:	f7fe fbdc 	bl	ef8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2740:	e791      	b.n	2666 <canInit()+0x4e>
    2742:	bf00      	nop
    2744:	20003da0 	.word	0x20003da0
    2748:	401d0000 	.word	0x401d0000
    274c:	0007a120 	.word	0x0007a120
    2750:	20005da0 	.word	0x20005da0
    2754:	00003235 	.word	0x00003235
    2758:	20001488 	.word	0x20001488
    275c:	401d4000 	.word	0x401d4000
    2760:	20003488 	.word	0x20003488
    2764:	00002fe9 	.word	0x00002fe9

00002768 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
}
#endif


FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
  if ( mb_num == FIFO ) {
    2768:	780b      	ldrb	r3, [r1, #0]
    276a:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    276c:	b510      	push	{r4, lr}
    276e:	4604      	mov	r4, r0
    2770:	b082      	sub	sp, #8
    2772:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2774:	d013      	beq.n	279e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    if ( _mainHandler ) _mainHandler(msg);
    return;
  }
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2776:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    277a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    277e:	685b      	ldr	r3, [r3, #4]
    2780:	b113      	cbz	r3, 2788 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2782:	9201      	str	r2, [sp, #4]
    2784:	4798      	blx	r3
    2786:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2788:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    278c:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2790:	b11b      	cbz	r3, 279a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2792:	b002      	add	sp, #8
    2794:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2798:	4718      	bx	r3
}
    279a:	b002      	add	sp, #8
    279c:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    279e:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    27a2:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    27a6:	2b00      	cmp	r3, #0
    27a8:	d0f0      	beq.n	278c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    27aa:	9201      	str	r2, [sp, #4]
    27ac:	4798      	blx	r3
    27ae:	9801      	ldr	r0, [sp, #4]
    27b0:	e7ec      	b.n	278c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    27b2:	bf00      	nop

000027b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    27b4:	291f      	cmp	r1, #31
    27b6:	481c      	ldr	r0, [pc, #112]	; (2828 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    27b8:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    27ba:	d823      	bhi.n	2804 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    27bc:	2301      	movs	r3, #1
    27be:	6b04      	ldr	r4, [r0, #48]	; 0x30
    27c0:	408b      	lsls	r3, r1
    27c2:	4323      	orrs	r3, r4
    27c4:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    27c6:	4b19      	ldr	r3, [pc, #100]	; (282c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    27c8:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    27cc:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    27ce:	440b      	add	r3, r1
    27d0:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    27d2:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    27d4:	b1f8      	cbz	r0, 2816 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    27d6:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    27d8:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    27da:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    27dc:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    27e0:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    27e4:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    27e6:	68d0      	ldr	r0, [r2, #12]
}
    27e8:	f85d 4b04 	ldr.w	r4, [sp], #4
    27ec:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    27ee:	6098      	str	r0, [r3, #8]
    27f0:	6910      	ldr	r0, [r2, #16]
    27f2:	ba00      	rev	r0, r0
    27f4:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    27f6:	7ad2      	ldrb	r2, [r2, #11]
    27f8:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    27fc:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2800:	601a      	str	r2, [r3, #0]
}
    2802:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2804:	f1a1 0c20 	sub.w	ip, r1, #32
    2808:	2301      	movs	r3, #1
    280a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    280c:	fa03 f30c 	lsl.w	r3, r3, ip
    2810:	4323      	orrs	r3, r4
    2812:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2814:	e7d7      	b.n	27c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2816:	6814      	ldr	r4, [r2, #0]
    2818:	4805      	ldr	r0, [pc, #20]	; (2830 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    281a:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    281c:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2820:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2822:	6058      	str	r0, [r3, #4]
    2824:	e7df      	b.n	27e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2826:	bf00      	nop
    2828:	401d0000 	.word	0x401d0000
    282c:	0401d008 	.word	0x0401d008
    2830:	1ffc0000 	.word	0x1ffc0000

00002834 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2834:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2838:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    283c:	b08f      	sub	sp, #60	; 0x3c
    283e:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2840:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2844:	b913      	cbnz	r3, 284c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2846:	2301      	movs	r3, #1
    2848:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        T readBytes(T *buffer, uint16_t length);
        void flush() { clear(); }
        void clear() { head = tail = _available = 0; }
        void print(const char *p);
        void println(const char *p);
        uint16_t size() { return _available; }
    284c:	8b23      	ldrh	r3, [r4, #24]
    284e:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2850:	2b00      	cmp	r3, #0
    2852:	d157      	bne.n	2904 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2854:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2858:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    285c:	4b72      	ldr	r3, [pc, #456]	; (2a28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    285e:	f002 011f 	and.w	r1, r2, #31
    2862:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2866:	2201      	movs	r2, #1
    2868:	009b      	lsls	r3, r3, #2
    286a:	408a      	lsls	r2, r1
    286c:	601a      	str	r2, [r3, #0]
    286e:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2872:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2874:	b383      	cbz	r3, 28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>


template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::peek_front(T *buffer, uint16_t length, uint32_t entry) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2876:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    287a:	221a      	movs	r2, #26
    287c:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    287e:	f10d 0c08 	add.w	ip, sp, #8
    2882:	f003 030f 	and.w	r3, r3, #15
    2886:	46ae      	mov	lr, r5
    2888:	fb02 4303 	mla	r3, r2, r3, r4
    288c:	f641 3232 	movw	r2, #6962	; 0x1b32
    2890:	eb03 0802 	add.w	r8, r3, r2
    2894:	5898      	ldr	r0, [r3, r2]
    2896:	f8d8 1004 	ldr.w	r1, [r8, #4]
    289a:	f8d8 2008 	ldr.w	r2, [r8, #8]
    289e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    28a2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    28a4:	f8d8 0010 	ldr.w	r0, [r8, #16]
    28a8:	f8d8 1014 	ldr.w	r1, [r8, #20]
    28ac:	c503      	stmia	r5!, {r0, r1}
    28ae:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    28b2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    28b6:	e89e 0003 	ldmia.w	lr, {r0, r1}
    28ba:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    28be:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    28c2:	1c4b      	adds	r3, r1, #1
    28c4:	d054      	beq.n	2970 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    28c6:	4b59      	ldr	r3, [pc, #356]	; (2a2c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    28c8:	440b      	add	r3, r1
    28ca:	011b      	lsls	r3, r3, #4
    28cc:	681b      	ldr	r3, [r3, #0]
    28ce:	f3c3 6303 	ubfx	r3, r3, #24, #4
    28d2:	2b08      	cmp	r3, #8
    28d4:	f000 808b 	beq.w	29ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    28d8:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    28dc:	4b54      	ldr	r3, [pc, #336]	; (2a30 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    28de:	f002 011f 	and.w	r1, r2, #31
    28e2:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    28e6:	2201      	movs	r2, #1
    28e8:	009b      	lsls	r3, r3, #2
    28ea:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    28ec:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    28ee:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    28f0:	8b23      	ldrh	r3, [r4, #24]
    28f2:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    28f6:	b29b      	uxth	r3, r3
    28f8:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    28fa:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    28fe:	b00f      	add	sp, #60	; 0x3c
    2900:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
}

template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::readBytes(T *buffer, uint16_t length) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2904:	8aa6      	ldrh	r6, [r4, #20]
    2906:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2908:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    290c:	ad08      	add	r5, sp, #32
    290e:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2910:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2914:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2918:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    291c:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2920:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2924:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2928:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    292c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    292e:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2932:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2936:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    293a:	8b23      	ldrh	r3, [r4, #24]
    293c:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    293e:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2940:	b11b      	cbz	r3, 294a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2942:	8b23      	ldrh	r3, [r4, #24]
    2944:	3b01      	subs	r3, #1
    2946:	b29b      	uxth	r3, r3
    2948:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    294a:	ad08      	add	r5, sp, #32
    294c:	ae02      	add	r6, sp, #8
    294e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2950:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2952:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2956:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2958:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    295c:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2960:	f10d 0107 	add.w	r1, sp, #7
    2964:	4620      	mov	r0, r4
    2966:	f88d 3007 	strb.w	r3, [sp, #7]
    296a:	f7ff fefd 	bl	2768 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    296e:	e771      	b.n	2854 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2970:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2a34 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2974:	f8d8 5000 	ldr.w	r5, [r8]
    2978:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    297c:	d050      	beq.n	2a20 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    297e:	f7fe fa73 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2982:	f8d8 3000 	ldr.w	r3, [r8]
    2986:	4605      	mov	r5, r0
    2988:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    298c:	3301      	adds	r3, #1
    298e:	4283      	cmp	r3, r0
    2990:	d9a2      	bls.n	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2992:	f8df 9098 	ldr.w	r9, [pc, #152]	; 2a2c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2996:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2a34 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    299a:	e008      	b.n	29ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    299c:	f8d8 3000 	ldr.w	r3, [r8]
    29a0:	3501      	adds	r5, #1
    29a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    29a6:	b2ed      	uxtb	r5, r5
    29a8:	3301      	adds	r3, #1
    29aa:	429d      	cmp	r5, r3
    29ac:	d294      	bcs.n	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    29ae:	eb05 0309 	add.w	r3, r5, r9
    29b2:	011b      	lsls	r3, r3, #4
    29b4:	681b      	ldr	r3, [r3, #0]
    29b6:	f3c3 6303 	ubfx	r3, r3, #24, #4
    29ba:	2b08      	cmp	r3, #8
    29bc:	d1ee      	bne.n	299c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    29be:	aa02      	add	r2, sp, #8
    29c0:	4629      	mov	r1, r5
    29c2:	4620      	mov	r0, r4
    29c4:	f7ff fef6 	bl	27b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    29c8:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    29cc:	3301      	adds	r3, #1
    29ce:	f003 031f 	and.w	r3, r3, #31
    29d2:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    29d6:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    29da:	b29b      	uxth	r3, r3
    29dc:	2b00      	cmp	r3, #0
    29de:	d0dd      	beq.n	299c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    29e0:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    29e4:	3b01      	subs	r3, #1
    29e6:	b29b      	uxth	r3, r3
    29e8:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    29ec:	e7d6      	b.n	299c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    29ee:	aa02      	add	r2, sp, #8
    29f0:	b2c9      	uxtb	r1, r1
    29f2:	4620      	mov	r0, r4
    29f4:	f7ff fede 	bl	27b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    29f8:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    29fc:	3301      	adds	r3, #1
    29fe:	f003 031f 	and.w	r3, r3, #31
    2a02:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2a06:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2a0a:	b29b      	uxth	r3, r3
    2a0c:	2b00      	cmp	r3, #0
    2a0e:	f43f af63 	beq.w	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    2a12:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2a16:	3b01      	subs	r3, #1
    2a18:	b29b      	uxth	r3, r3
    2a1a:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2a1e:	e75b      	b.n	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2a20:	f8d8 3000 	ldr.w	r3, [r8]
    2a24:	e7b5      	b.n	2992 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    2a26:	bf00      	nop
    2a28:	38003860 	.word	0x38003860
    2a2c:	0401d008 	.word	0x0401d008
    2a30:	38003840 	.word	0x38003840
    2a34:	401d0000 	.word	0x401d0000

00002a38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
  if ( mb_num == FIFO ) {
    2a38:	780b      	ldrb	r3, [r1, #0]
    2a3a:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2a3c:	b510      	push	{r4, lr}
    2a3e:	4604      	mov	r4, r0
    2a40:	b082      	sub	sp, #8
    2a42:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2a44:	d013      	beq.n	2a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2a46:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    2a4a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2a4e:	685b      	ldr	r3, [r3, #4]
    2a50:	b113      	cbz	r3, 2a58 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2a52:	9201      	str	r2, [sp, #4]
    2a54:	4798      	blx	r3
    2a56:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2a58:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2a5c:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2a60:	b11b      	cbz	r3, 2a6a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2a62:	b002      	add	sp, #8
    2a64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2a68:	4718      	bx	r3
}
    2a6a:	b002      	add	sp, #8
    2a6c:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    2a6e:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2a72:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    2a76:	2b00      	cmp	r3, #0
    2a78:	d0f0      	beq.n	2a5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2a7a:	9201      	str	r2, [sp, #4]
    2a7c:	4798      	blx	r3
    2a7e:	9801      	ldr	r0, [sp, #4]
    2a80:	e7ec      	b.n	2a5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2a82:	bf00      	nop

00002a84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2a84:	291f      	cmp	r1, #31
    2a86:	481c      	ldr	r0, [pc, #112]	; (2af8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    2a88:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2a8a:	d823      	bhi.n	2ad4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    2a8c:	2301      	movs	r3, #1
    2a8e:	6b04      	ldr	r4, [r0, #48]	; 0x30
    2a90:	408b      	lsls	r3, r1
    2a92:	4323      	orrs	r3, r4
    2a94:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2a96:	4b19      	ldr	r3, [pc, #100]	; (2afc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2a98:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2a9c:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2a9e:	440b      	add	r3, r1
    2aa0:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2aa2:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2aa4:	b1f8      	cbz	r0, 2ae6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    2aa6:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2aa8:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    2aaa:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2aac:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2ab0:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2ab4:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2ab6:	68d0      	ldr	r0, [r2, #12]
}
    2ab8:	f85d 4b04 	ldr.w	r4, [sp], #4
    2abc:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2abe:	6098      	str	r0, [r3, #8]
    2ac0:	6910      	ldr	r0, [r2, #16]
    2ac2:	ba00      	rev	r0, r0
    2ac4:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    2ac6:	7ad2      	ldrb	r2, [r2, #11]
    2ac8:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2acc:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2ad0:	601a      	str	r2, [r3, #0]
}
    2ad2:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2ad4:	f1a1 0c20 	sub.w	ip, r1, #32
    2ad8:	2301      	movs	r3, #1
    2ada:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2adc:	fa03 f30c 	lsl.w	r3, r3, ip
    2ae0:	4323      	orrs	r3, r4
    2ae2:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2ae4:	e7d7      	b.n	2a96 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2ae6:	6814      	ldr	r4, [r2, #0]
    2ae8:	4805      	ldr	r0, [pc, #20]	; (2b00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    2aea:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2aec:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2af0:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2af2:	6058      	str	r0, [r3, #4]
    2af4:	e7df      	b.n	2ab6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2af6:	bf00      	nop
    2af8:	401d4000 	.word	0x401d4000
    2afc:	0401d408 	.word	0x0401d408
    2b00:	1ffc0000 	.word	0x1ffc0000

00002b04 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2b04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2b08:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2b0c:	b08f      	sub	sp, #60	; 0x3c
    2b0e:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2b10:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2b14:	b913      	cbnz	r3, 2b1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2b16:	2301      	movs	r3, #1
    2b18:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        uint16_t size() { return _available; }
    2b1c:	8b23      	ldrh	r3, [r4, #24]
    2b1e:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2b20:	2b00      	cmp	r3, #0
    2b22:	d157      	bne.n	2bd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2b24:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2b28:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2b2c:	4b72      	ldr	r3, [pc, #456]	; (2cf8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2b2e:	f002 011f 	and.w	r1, r2, #31
    2b32:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2b36:	2201      	movs	r2, #1
    2b38:	009b      	lsls	r3, r3, #2
    2b3a:	408a      	lsls	r2, r1
    2b3c:	601a      	str	r2, [r3, #0]
    2b3e:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2b42:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2b44:	b383      	cbz	r3, 2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2b46:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2b4a:	221a      	movs	r2, #26
    2b4c:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    2b4e:	f10d 0c08 	add.w	ip, sp, #8
    2b52:	f003 030f 	and.w	r3, r3, #15
    2b56:	46ae      	mov	lr, r5
    2b58:	fb02 4303 	mla	r3, r2, r3, r4
    2b5c:	f641 3232 	movw	r2, #6962	; 0x1b32
    2b60:	eb03 0802 	add.w	r8, r3, r2
    2b64:	5898      	ldr	r0, [r3, r2]
    2b66:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2b6a:	f8d8 2008 	ldr.w	r2, [r8, #8]
    2b6e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2b72:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2b74:	f8d8 0010 	ldr.w	r0, [r8, #16]
    2b78:	f8d8 1014 	ldr.w	r1, [r8, #20]
    2b7c:	c503      	stmia	r5!, {r0, r1}
    2b7e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2b82:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2b86:	e89e 0003 	ldmia.w	lr, {r0, r1}
    2b8a:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    2b8e:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    2b92:	1c4b      	adds	r3, r1, #1
    2b94:	d054      	beq.n	2c40 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2b96:	4b59      	ldr	r3, [pc, #356]	; (2cfc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    2b98:	440b      	add	r3, r1
    2b9a:	011b      	lsls	r3, r3, #4
    2b9c:	681b      	ldr	r3, [r3, #0]
    2b9e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2ba2:	2b08      	cmp	r3, #8
    2ba4:	f000 808b 	beq.w	2cbe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    2ba8:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2bac:	4b54      	ldr	r3, [pc, #336]	; (2d00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2bae:	f002 011f 	and.w	r1, r2, #31
    2bb2:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2bb6:	2201      	movs	r2, #1
    2bb8:	009b      	lsls	r3, r3, #2
    2bba:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2bbc:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2bbe:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2bc0:	8b23      	ldrh	r3, [r4, #24]
    2bc2:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2bc6:	b29b      	uxth	r3, r3
    2bc8:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2bca:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2bce:	b00f      	add	sp, #60	; 0x3c
    2bd0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2bd4:	8aa6      	ldrh	r6, [r4, #20]
    2bd6:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2bd8:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2bdc:	ad08      	add	r5, sp, #32
    2bde:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2be0:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2be4:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2be8:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2bec:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2bf0:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2bf4:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2bf8:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2bfc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2bfe:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2c02:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2c06:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2c0a:	8b23      	ldrh	r3, [r4, #24]
    2c0c:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c0e:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2c10:	b11b      	cbz	r3, 2c1a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2c12:	8b23      	ldrh	r3, [r4, #24]
    2c14:	3b01      	subs	r3, #1
    2c16:	b29b      	uxth	r3, r3
    2c18:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2c1a:	ad08      	add	r5, sp, #32
    2c1c:	ae02      	add	r6, sp, #8
    2c1e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2c20:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2c22:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2c26:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2c28:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2c2c:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2c30:	f10d 0107 	add.w	r1, sp, #7
    2c34:	4620      	mov	r0, r4
    2c36:	f88d 3007 	strb.w	r3, [sp, #7]
    2c3a:	f7ff fefd 	bl	2a38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    2c3e:	e771      	b.n	2b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2c40:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2d04 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2c44:	f8d8 5000 	ldr.w	r5, [r8]
    2c48:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    2c4c:	d050      	beq.n	2cf0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    2c4e:	f7fe f92f 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2c52:	f8d8 3000 	ldr.w	r3, [r8]
    2c56:	4605      	mov	r5, r0
    2c58:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2c5c:	3301      	adds	r3, #1
    2c5e:	4283      	cmp	r3, r0
    2c60:	d9a2      	bls.n	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2c62:	f8df 9098 	ldr.w	r9, [pc, #152]	; 2cfc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2c66:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2d04 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2c6a:	e008      	b.n	2c7e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    2c6c:	f8d8 3000 	ldr.w	r3, [r8]
    2c70:	3501      	adds	r5, #1
    2c72:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2c76:	b2ed      	uxtb	r5, r5
    2c78:	3301      	adds	r3, #1
    2c7a:	429d      	cmp	r5, r3
    2c7c:	d294      	bcs.n	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2c7e:	eb05 0309 	add.w	r3, r5, r9
    2c82:	011b      	lsls	r3, r3, #4
    2c84:	681b      	ldr	r3, [r3, #0]
    2c86:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2c8a:	2b08      	cmp	r3, #8
    2c8c:	d1ee      	bne.n	2c6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    2c8e:	aa02      	add	r2, sp, #8
    2c90:	4629      	mov	r1, r5
    2c92:	4620      	mov	r0, r4
    2c94:	f7ff fef6 	bl	2a84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2c98:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2c9c:	3301      	adds	r3, #1
    2c9e:	f003 031f 	and.w	r3, r3, #31
    2ca2:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2ca6:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2caa:	b29b      	uxth	r3, r3
    2cac:	2b00      	cmp	r3, #0
    2cae:	d0dd      	beq.n	2c6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    2cb0:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2cb4:	3b01      	subs	r3, #1
    2cb6:	b29b      	uxth	r3, r3
    2cb8:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2cbc:	e7d6      	b.n	2c6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    2cbe:	aa02      	add	r2, sp, #8
    2cc0:	b2c9      	uxtb	r1, r1
    2cc2:	4620      	mov	r0, r4
    2cc4:	f7ff fede 	bl	2a84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2cc8:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2ccc:	3301      	adds	r3, #1
    2cce:	f003 031f 	and.w	r3, r3, #31
    2cd2:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2cd6:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2cda:	b29b      	uxth	r3, r3
    2cdc:	2b00      	cmp	r3, #0
    2cde:	f43f af63 	beq.w	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    2ce2:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2ce6:	3b01      	subs	r3, #1
    2ce8:	b29b      	uxth	r3, r3
    2cea:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2cee:	e75b      	b.n	2ba8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2cf0:	f8d8 3000 	ldr.w	r3, [r8]
    2cf4:	e7b5      	b.n	2c62 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    2cf6:	bf00      	nop
    2cf8:	38003860 	.word	0x38003860
    2cfc:	0401d408 	.word	0x0401d408
    2d00:	38003840 	.word	0x38003840
    2d04:	401d4000 	.word	0x401d4000

00002d08 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    2d08:	8843      	ldrh	r3, [r0, #2]
    2d0a:	f04f 0c1a 	mov.w	ip, #26
    2d0e:	f003 030f 	and.w	r3, r3, #15
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    2d12:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    2d14:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    2d18:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    2d1a:	2000      	movs	r0, #0
    2d1c:	7598      	strb	r0, [r3, #22]
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    2d1e:	8863      	ldrh	r3, [r4, #2]
    2d20:	f003 030f 	and.w	r3, r3, #15
    2d24:	fb0c 4303 	mla	r3, ip, r3, r4
    2d28:	75da      	strb	r2, [r3, #23]
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    2d2a:	8860      	ldrh	r0, [r4, #2]
    2d2c:	f000 000f 	and.w	r0, r0, #15
    2d30:	fb0c 4000 	mla	r0, ip, r0, r4
    2d34:	3018      	adds	r0, #24
    2d36:	f004 fe2b 	bl	7990 <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    2d3a:	8862      	ldrh	r2, [r4, #2]
    2d3c:	8823      	ldrh	r3, [r4, #0]
    2d3e:	b292      	uxth	r2, r2
    2d40:	b29b      	uxth	r3, r3
    2d42:	f083 0310 	eor.w	r3, r3, #16
    2d46:	429a      	cmp	r2, r3
    2d48:	d104      	bne.n	2d54 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    2d4a:	8823      	ldrh	r3, [r4, #0]
    2d4c:	3301      	adds	r3, #1
    2d4e:	f003 031f 	and.w	r3, r3, #31
    2d52:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    2d54:	8863      	ldrh	r3, [r4, #2]
    2d56:	3301      	adds	r3, #1
    2d58:	f003 031f 	and.w	r3, r3, #31
    2d5c:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    2d5e:	88a3      	ldrh	r3, [r4, #4]
    2d60:	b29b      	uxth	r3, r3
    2d62:	2b0f      	cmp	r3, #15
    2d64:	d803      	bhi.n	2d6e <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    2d66:	88a3      	ldrh	r3, [r4, #4]
    2d68:	3301      	adds	r3, #1
    2d6a:	b29b      	uxth	r3, r3
    2d6c:	80a3      	strh	r3, [r4, #4]
}
    2d6e:	bd10      	pop	{r4, pc}

00002d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    2d70:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    2d72:	b5f0      	push	{r4, r5, r6, r7, lr}
    2d74:	460d      	mov	r5, r1
    2d76:	b08d      	sub	sp, #52	; 0x34
    2d78:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2d7a:	4e4b      	ldr	r6, [pc, #300]	; (2ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    2d7c:	2b00      	cmp	r3, #0
    2d7e:	d14c      	bne.n	2e1a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2d80:	6833      	ldr	r3, [r6, #0]
    2d82:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    2d86:	d025      	beq.n	2dd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    2d88:	f7fe f86e 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d8c:	6833      	ldr	r3, [r6, #0]
    2d8e:	4684      	mov	ip, r0
    2d90:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2d94:	3301      	adds	r3, #1
    2d96:	4298      	cmp	r0, r3
    2d98:	d21e      	bcs.n	2dd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2d9a:	4944      	ldr	r1, [pc, #272]	; (2eac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d9c:	4842      	ldr	r0, [pc, #264]	; (2ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    2d9e:	e007      	b.n	2db0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    2da0:	6803      	ldr	r3, [r0, #0]
    2da2:	fa5f fc82 	uxtb.w	ip, r2
    2da6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2daa:	3301      	adds	r3, #1
    2dac:	459c      	cmp	ip, r3
    2dae:	d213      	bcs.n	2dd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2db0:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2db4:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2db8:	011b      	lsls	r3, r3, #4
    2dba:	681b      	ldr	r3, [r3, #0]
    2dbc:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2dc0:	2b08      	cmp	r3, #8
    2dc2:	d1ed      	bne.n	2da0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    2dc4:	4620      	mov	r0, r4
    2dc6:	462a      	mov	r2, r5
    2dc8:	4661      	mov	r1, ip
    2dca:	f7ff fcf3 	bl	27b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    2dce:	2001      	movs	r0, #1
}
    2dd0:	b00d      	add	sp, #52	; 0x34
    2dd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2dd4:	6833      	ldr	r3, [r6, #0]
    2dd6:	e7e0      	b.n	2d9a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    2dd8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2dda:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    2ddc:	27ff      	movs	r7, #255	; 0xff
    2dde:	466e      	mov	r6, sp
    2de0:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    2de4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2de8:	e895 0003 	ldmia.w	r5, {r0, r1}
    2dec:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    2df0:	f88d 7014 	strb.w	r7, [sp, #20]
    2df4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    2df6:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    2dfa:	e89c 0003 	ldmia.w	ip, {r0, r1}
    2dfe:	e88e 0003 	stmia.w	lr, {r0, r1}
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    2e02:	2218      	movs	r2, #24
    2e04:	f641 301a 	movw	r0, #6938	; 0x1b1a
    2e08:	eb0d 0102 	add.w	r1, sp, r2
    2e0c:	4420      	add	r0, r4
    2e0e:	f7ff ff7b 	bl	2d08 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    2e12:	f04f 30ff 	mov.w	r0, #4294967295
}
    2e16:	b00d      	add	sp, #52	; 0x34
    2e18:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2e1a:	6830      	ldr	r0, [r6, #0]
    2e1c:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    2e20:	d040      	beq.n	2ea4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    2e22:	f7fe f821 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2e26:	6833      	ldr	r3, [r6, #0]
    2e28:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2e2c:	3301      	adds	r3, #1
    2e2e:	4283      	cmp	r3, r0
    2e30:	d927      	bls.n	2e82 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2e32:	491e      	ldr	r1, [pc, #120]	; (2eac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2e34:	4e1c      	ldr	r6, [pc, #112]	; (2ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    2e36:	e005      	b.n	2e44 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    2e38:	6833      	ldr	r3, [r6, #0]
    2e3a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2e3e:	3301      	adds	r3, #1
    2e40:	4298      	cmp	r0, r3
    2e42:	d21e      	bcs.n	2e82 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2e44:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2e46:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2e48:	4684      	mov	ip, r0
    2e4a:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2e4c:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    2e4e:	681a      	ldr	r2, [r3, #0]
    2e50:	0112      	lsls	r2, r2, #4
    2e52:	d5f1      	bpl.n	2e38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2e54:	681b      	ldr	r3, [r3, #0]
    2e56:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2e5a:	2b08      	cmp	r3, #8
    2e5c:	d019      	beq.n	2e92 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    2e5e:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    2e60:	466f      	mov	r7, sp
    2e62:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    2e66:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2e68:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2e6a:	e895 0003 	ldmia.w	r5, {r0, r1}
    2e6e:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    2e72:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    2e76:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    2e78:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    2e7c:	e896 0003 	ldmia.w	r6, {r0, r1}
    2e80:	e7bd      	b.n	2dfe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2e82:	4b0b      	ldr	r3, [pc, #44]	; (2eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    2e84:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2e88:	681b      	ldr	r3, [r3, #0]
    2e8a:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2e8e:	2b08      	cmp	r3, #8
    2e90:	d1e5      	bne.n	2e5e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    2e92:	4620      	mov	r0, r4
    2e94:	462a      	mov	r2, r5
    2e96:	fa5f f18c 	uxtb.w	r1, ip
    2e9a:	f7ff fc8b 	bl	27b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    2e9e:	2001      	movs	r0, #1
}
    2ea0:	b00d      	add	sp, #52	; 0x34
    2ea2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2ea4:	6833      	ldr	r3, [r6, #0]
    2ea6:	e7c4      	b.n	2e32 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    2ea8:	401d0000 	.word	0x401d0000
    2eac:	0401d008 	.word	0x0401d008
    2eb0:	401d0070 	.word	0x401d0070

00002eb4 <sendEmptyFrame()>:
void sendEmptyFrame() {
    2eb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CAN_message_t frame;
    2eb8:	4d49      	ldr	r5, [pc, #292]	; (2fe0 <sendEmptyFrame()+0x12c>)
void sendEmptyFrame() {
    2eba:	b08c      	sub	sp, #48	; 0x30
  HaldexCAN.write(frame);
    2ebc:	4c49      	ldr	r4, [pc, #292]	; (2fe4 <sendEmptyFrame()+0x130>)
  frame.id = MOTOR1_ID;
    2ebe:	f44f 7820 	mov.w	r8, #640	; 0x280
  CAN_message_t frame;
    2ec2:	f105 0e40 	add.w	lr, r5, #64	; 0x40
    2ec6:	46ec      	mov	ip, sp
  frame.len = 1;
    2ec8:	2701      	movs	r7, #1
  frame.buf[0] = 0xff;
    2eca:	26ff      	movs	r6, #255	; 0xff
  CAN_message_t frame;
    2ecc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2ed0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2ed4:	e89e 0003 	ldmia.w	lr, {r0, r1}
  frame.id = MOTOR1_ID;
    2ed8:	f8cd 8000 	str.w	r8, [sp]
  motor2.id = MOTOR2_ID;
    2edc:	f44f 7822 	mov.w	r8, #648	; 0x288
  CAN_message_t frame;
    2ee0:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(frame);
    2ee4:	4669      	mov	r1, sp
    2ee6:	4620      	mov	r0, r4
    2ee8:	f7ff ff42 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t motor2;
    2eec:	f105 0c40 	add.w	ip, r5, #64	; 0x40
    2ef0:	ad06      	add	r5, sp, #24
  motor2.len = 4;
    2ef2:	f04f 0e04 	mov.w	lr, #4
  CAN_message_t motor2;
    2ef6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    2efa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2efc:	e89c 0003 	ldmia.w	ip, {r0, r1}
  motor2.len = 4;
    2f00:	f88d e023 	strb.w	lr, [sp, #35]	; 0x23
  motor2.id = MOTOR2_ID;
    2f04:	f8cd 8018 	str.w	r8, [sp, #24]
  CAN_message_t motor2;
    2f08:	e885 0003 	stmia.w	r5, {r0, r1}
  HaldexCAN.write(motor2);
    2f0c:	a906      	add	r1, sp, #24
    2f0e:	4620      	mov	r0, r4
    2f10:	f7ff ff2e 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = MOTOR3_ID;
    2f14:	f44f 7360 	mov.w	r3, #896	; 0x380
  HaldexCAN.write(frame);
    2f18:	4669      	mov	r1, sp
    2f1a:	4620      	mov	r0, r4
  frame.id = MOTOR3_ID;
    2f1c:	9300      	str	r3, [sp, #0]
  frame.len = 1;
    2f1e:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.buf[0] = 0xff;
    2f22:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2f26:	f7ff ff23 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = MOTOR5_ID;
    2f2a:	f44f 6390 	mov.w	r3, #1152	; 0x480
  HaldexCAN.write(frame);
    2f2e:	4669      	mov	r1, sp
    2f30:	4620      	mov	r0, r4
  frame.len = 1;
    2f32:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = MOTOR5_ID;
    2f36:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2f38:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2f3c:	f7ff ff18 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = MOTOR6_ID;
    2f40:	f44f 6391 	mov.w	r3, #1160	; 0x488
  HaldexCAN.write(frame);
    2f44:	4669      	mov	r1, sp
    2f46:	4620      	mov	r0, r4
  frame.len = 1;
    2f48:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = MOTOR6_ID;
    2f4c:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2f4e:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2f52:	f7ff ff0d 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = MOTOR7_ID;
    2f56:	f44f 63b1 	mov.w	r3, #1416	; 0x588
  HaldexCAN.write(frame);
    2f5a:	4669      	mov	r1, sp
    2f5c:	4620      	mov	r0, r4
  frame.len = 1;
    2f5e:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = MOTOR7_ID;
    2f62:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2f64:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2f68:	f7ff ff02 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = MOTOR_FLEX_ID;
    2f6c:	f44f 63b0 	mov.w	r3, #1408	; 0x580
  HaldexCAN.write(frame);
    2f70:	4669      	mov	r1, sp
    2f72:	4620      	mov	r0, r4
  frame.len = 1;
    2f74:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = MOTOR_FLEX_ID;
    2f78:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2f7a:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2f7e:	f7ff fef7 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = BRAKES1_ID;
    2f82:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
  HaldexCAN.write(frame);
    2f86:	4669      	mov	r1, sp
    2f88:	4620      	mov	r0, r4
  frame.len = 1;
    2f8a:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = BRAKES1_ID;
    2f8e:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2f90:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2f94:	f7ff feec 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = BRAKES2_ID;
    2f98:	f44f 7328 	mov.w	r3, #672	; 0x2a0
  HaldexCAN.write(frame);
    2f9c:	4669      	mov	r1, sp
    2f9e:	4620      	mov	r0, r4
  frame.len = 1;
    2fa0:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = BRAKES2_ID;
    2fa4:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2fa6:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2faa:	f7ff fee1 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = BRAKES3_ID;
    2fae:	f44f 6394 	mov.w	r3, #1184	; 0x4a0
  HaldexCAN.write(frame);
    2fb2:	4669      	mov	r1, sp
    2fb4:	4620      	mov	r0, r4
  frame.len = 1;
    2fb6:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = BRAKES3_ID;
    2fba:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2fbc:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2fc0:	f7ff fed6 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  frame.id = BRAKES5_ID;
    2fc4:	f44f 63b4 	mov.w	r3, #1440	; 0x5a0
  HaldexCAN.write(frame);
    2fc8:	4669      	mov	r1, sp
    2fca:	4620      	mov	r0, r4
  frame.len = 1;
    2fcc:	f88d 700b 	strb.w	r7, [sp, #11]
  frame.id = BRAKES5_ID;
    2fd0:	9300      	str	r3, [sp, #0]
  frame.buf[0] = 0xff;
    2fd2:	f88d 600c 	strb.w	r6, [sp, #12]
  HaldexCAN.write(frame);
    2fd6:	f7ff fecb 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
}
    2fda:	b00c      	add	sp, #48	; 0x30
    2fdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2fe0:	20000280 	.word	0x20000280
    2fe4:	20003da0 	.word	0x20003da0

00002fe8 <onBodyRX(CAN_message_t const&)>:
void onBodyRX(const CAN_message_t &frame) {
    2fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
  CAN_message_t frame_out;
    2fea:	4c39      	ldr	r4, [pc, #228]	; (30d0 <onBodyRX(CAN_message_t const&)+0xe8>)
void onBodyRX(const CAN_message_t &frame) {
    2fec:	b087      	sub	sp, #28
  frame_out.len = frame.len;
    2fee:	f890 e00b 	ldrb.w	lr, [r0, #11]
void onBodyRX(const CAN_message_t &frame) {
    2ff2:	4605      	mov	r5, r0
  frame_out.id = frame.id;
    2ff4:	6806      	ldr	r6, [r0, #0]
  CAN_message_t frame_out;
    2ff6:	46ec      	mov	ip, sp
  frame_out.flags = frame.flags;
    2ff8:	f8d0 7007 	ldr.w	r7, [r0, #7]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    2ffc:	f1be 0f08 	cmp.w	lr, #8
  CAN_message_t frame_out;
    3000:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    3002:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3006:	e894 0003 	ldmia.w	r4, {r0, r1}
  frame_out.flags = frame.flags;
    300a:	f8cd 7007 	str.w	r7, [sp, #7]
  frame_out.id = frame.id;
    300e:	9600      	str	r6, [sp, #0]
  frame_out.len = frame.len;
    3010:	f88d e00b 	strb.w	lr, [sp, #11]
  CAN_message_t frame_out;
    3014:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3018:	d94d      	bls.n	30b6 <onBodyRX(CAN_message_t const&)+0xce>
  switch (frame.id) {
    301a:	f5b6 7f20 	cmp.w	r6, #640	; 0x280
    301e:	d01e      	beq.n	305e <onBodyRX(CAN_message_t const&)+0x76>
    3020:	f5b6 7f22 	cmp.w	r6, #648	; 0x288
    3024:	d10d      	bne.n	3042 <onBodyRX(CAN_message_t const&)+0x5a>
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    3026:	7beb      	ldrb	r3, [r5, #15]
    3028:	f44f 5048 	mov.w	r0, #12800	; 0x3200
    302c:	4a29      	ldr	r2, [pc, #164]	; (30d4 <onBodyRX(CAN_message_t const&)+0xec>)
    302e:	fb00 f303 	mul.w	r3, r0, r3
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    3032:	4929      	ldr	r1, [pc, #164]	; (30d8 <onBodyRX(CAN_message_t const&)+0xf0>)
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    3034:	fba2 2303 	umull	r2, r3, r2, r3
    3038:	0b5b      	lsrs	r3, r3, #13
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    303a:	2bff      	cmp	r3, #255	; 0xff
    303c:	bfa8      	it	ge
    303e:	23ff      	movge	r3, #255	; 0xff
    3040:	700b      	strb	r3, [r1, #0]
  if (state.mode == MODE_FWD) {
    3042:	4c26      	ldr	r4, [pc, #152]	; (30dc <onBodyRX(CAN_message_t const&)+0xf4>)
    3044:	7823      	ldrb	r3, [r4, #0]
    3046:	2b01      	cmp	r3, #1
    3048:	d01b      	beq.n	3082 <onBodyRX(CAN_message_t const&)+0x9a>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    304a:	3b02      	subs	r3, #2
    304c:	2b01      	cmp	r3, #1
    304e:	d91e      	bls.n	308e <onBodyRX(CAN_message_t const&)+0xa6>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    3050:	4669      	mov	r1, sp
    3052:	4823      	ldr	r0, [pc, #140]	; (30e0 <onBodyRX(CAN_message_t const&)+0xf8>)
    3054:	f7ff fe8c 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3058:	b310      	cbz	r0, 30a0 <onBodyRX(CAN_message_t const&)+0xb8>
}
    305a:	b007      	add	sp, #28
    305c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pedValue = frame.buf[5] * 0.4;
    305e:	7c6b      	ldrb	r3, [r5, #17]
  if (state.mode == MODE_FWD) {
    3060:	4c1e      	ldr	r4, [pc, #120]	; (30dc <onBodyRX(CAN_message_t const&)+0xf4>)
      pedValue = frame.buf[5] * 0.4;
    3062:	ee07 3a10 	vmov	s14, r3
    3066:	4b1f      	ldr	r3, [pc, #124]	; (30e4 <onBodyRX(CAN_message_t const&)+0xfc>)
    3068:	ed9f 6b17 	vldr	d6, [pc, #92]	; 30c8 <onBodyRX(CAN_message_t const&)+0xe0>
    306c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    3070:	ee27 7b06 	vmul.f64	d7, d7, d6
    3074:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    3078:	ed83 7a00 	vstr	s14, [r3]
  if (state.mode == MODE_FWD) {
    307c:	7823      	ldrb	r3, [r4, #0]
    307e:	2b01      	cmp	r3, #1
    3080:	d1e3      	bne.n	304a <onBodyRX(CAN_message_t const&)+0x62>
    sendEmptyFrame();
    3082:	f7ff ff17 	bl	2eb4 <sendEmptyFrame()>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    3086:	7823      	ldrb	r3, [r4, #0]
    3088:	3b02      	subs	r3, #2
    308a:	2b01      	cmp	r3, #1
    308c:	d8e0      	bhi.n	3050 <onBodyRX(CAN_message_t const&)+0x68>
    getLockData(&frame_out);
    308e:	4668      	mov	r0, sp
    3090:	f7fd fc5e 	bl	950 <getLockData(CAN_message_t*)>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    3094:	4669      	mov	r1, sp
    3096:	4812      	ldr	r0, [pc, #72]	; (30e0 <onBodyRX(CAN_message_t const&)+0xf8>)
    3098:	f7ff fe6a 	bl	2d70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    309c:	2800      	cmp	r0, #0
    309e:	d1dc      	bne.n	305a <onBodyRX(CAN_message_t const&)+0x72>
    30a0:	2113      	movs	r1, #19
    30a2:	4811      	ldr	r0, [pc, #68]	; (30e8 <onBodyRX(CAN_message_t const&)+0x100>)
    30a4:	f004 f9f2 	bl	748c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    30a8:	4810      	ldr	r0, [pc, #64]	; (30ec <onBodyRX(CAN_message_t const&)+0x104>)
    30aa:	f002 fb37 	bl	571c <Print::println()>
    HaldexCAN.mailboxStatus();                 // print the mailbox status if there's a failure
    30ae:	f7fe fc89 	bl	19c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    30b2:	b007      	add	sp, #28
    30b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memcpy(frame_out.buf, frame.buf, frame.len);
    30b6:	4672      	mov	r2, lr
    30b8:	f105 010c 	add.w	r1, r5, #12
    30bc:	a803      	add	r0, sp, #12
    30be:	f002 fed9 	bl	5e74 <memcpy>
    30c2:	e7aa      	b.n	301a <onBodyRX(CAN_message_t const&)+0x32>
    30c4:	f3af 8000 	nop.w
    30c8:	9999999a 	.word	0x9999999a
    30cc:	3fd99999 	.word	0x3fd99999
    30d0:	200002c0 	.word	0x200002c0
    30d4:	d1b71759 	.word	0xd1b71759
    30d8:	20006aee 	.word	0x20006aee
    30dc:	20006950 	.word	0x20006950
    30e0:	20003da0 	.word	0x20003da0
    30e4:	200068e0 	.word	0x200068e0
    30e8:	2000034c 	.word	0x2000034c
    30ec:	20000a68 	.word	0x20000a68

000030f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    30f0:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    30f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    30f4:	460d      	mov	r5, r1
    30f6:	b08d      	sub	sp, #52	; 0x34
    30f8:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    30fa:	4e4b      	ldr	r6, [pc, #300]	; (3228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    30fc:	2b00      	cmp	r3, #0
    30fe:	d14c      	bne.n	319a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3100:	6833      	ldr	r3, [r6, #0]
    3102:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    3106:	d025      	beq.n	3154 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    3108:	f7fd fed2 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    310c:	6833      	ldr	r3, [r6, #0]
    310e:	4684      	mov	ip, r0
    3110:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3114:	3301      	adds	r3, #1
    3116:	4298      	cmp	r0, r3
    3118:	d21e      	bcs.n	3158 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    311a:	4944      	ldr	r1, [pc, #272]	; (322c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    311c:	4842      	ldr	r0, [pc, #264]	; (3228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    311e:	e007      	b.n	3130 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    3120:	6803      	ldr	r3, [r0, #0]
    3122:	fa5f fc82 	uxtb.w	ip, r2
    3126:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    312a:	3301      	adds	r3, #1
    312c:	459c      	cmp	ip, r3
    312e:	d213      	bcs.n	3158 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3130:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3134:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3138:	011b      	lsls	r3, r3, #4
    313a:	681b      	ldr	r3, [r3, #0]
    313c:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3140:	2b08      	cmp	r3, #8
    3142:	d1ed      	bne.n	3120 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    3144:	4620      	mov	r0, r4
    3146:	462a      	mov	r2, r5
    3148:	4661      	mov	r1, ip
    314a:	f7ff fc9b 	bl	2a84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    314e:	2001      	movs	r0, #1
}
    3150:	b00d      	add	sp, #52	; 0x34
    3152:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3154:	6833      	ldr	r3, [r6, #0]
    3156:	e7e0      	b.n	311a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    3158:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    315a:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    315c:	27ff      	movs	r7, #255	; 0xff
    315e:	466e      	mov	r6, sp
    3160:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    3164:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3168:	e895 0003 	ldmia.w	r5, {r0, r1}
    316c:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    3170:	f88d 7014 	strb.w	r7, [sp, #20]
    3174:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    3176:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    317a:	e89c 0003 	ldmia.w	ip, {r0, r1}
    317e:	e88e 0003 	stmia.w	lr, {r0, r1}
    3182:	2218      	movs	r2, #24
    3184:	f641 301a 	movw	r0, #6938	; 0x1b1a
    3188:	eb0d 0102 	add.w	r1, sp, r2
    318c:	4420      	add	r0, r4
    318e:	f7ff fdbb 	bl	2d08 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    3192:	f04f 30ff 	mov.w	r0, #4294967295
}
    3196:	b00d      	add	sp, #52	; 0x34
    3198:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    319a:	6830      	ldr	r0, [r6, #0]
    319c:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    31a0:	d040      	beq.n	3224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    31a2:	f7fd fe85 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31a6:	6833      	ldr	r3, [r6, #0]
    31a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    31ac:	3301      	adds	r3, #1
    31ae:	4283      	cmp	r3, r0
    31b0:	d927      	bls.n	3202 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31b2:	491e      	ldr	r1, [pc, #120]	; (322c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31b4:	4e1c      	ldr	r6, [pc, #112]	; (3228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    31b6:	e005      	b.n	31c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    31b8:	6833      	ldr	r3, [r6, #0]
    31ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    31be:	3301      	adds	r3, #1
    31c0:	4298      	cmp	r0, r3
    31c2:	d21e      	bcs.n	3202 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31c4:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31c6:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31c8:	4684      	mov	ip, r0
    31ca:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31cc:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31ce:	681a      	ldr	r2, [r3, #0]
    31d0:	0112      	lsls	r2, r2, #4
    31d2:	d5f1      	bpl.n	31b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    31d4:	681b      	ldr	r3, [r3, #0]
    31d6:	f3c3 6303 	ubfx	r3, r3, #24, #4
    31da:	2b08      	cmp	r3, #8
    31dc:	d019      	beq.n	3212 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    31de:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    31e0:	466f      	mov	r7, sp
    31e2:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    31e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    31e8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    31ea:	e895 0003 	ldmia.w	r5, {r0, r1}
    31ee:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    31f2:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    31f6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    31f8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    31fc:	e896 0003 	ldmia.w	r6, {r0, r1}
    3200:	e7bd      	b.n	317e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3202:	4b0b      	ldr	r3, [pc, #44]	; (3230 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    3204:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3208:	681b      	ldr	r3, [r3, #0]
    320a:	f3c3 6303 	ubfx	r3, r3, #24, #4
    320e:	2b08      	cmp	r3, #8
    3210:	d1e5      	bne.n	31de <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    3212:	4620      	mov	r0, r4
    3214:	462a      	mov	r2, r5
    3216:	fa5f f18c 	uxtb.w	r1, ip
    321a:	f7ff fc33 	bl	2a84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    321e:	2001      	movs	r0, #1
}
    3220:	b00d      	add	sp, #52	; 0x34
    3222:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3224:	6833      	ldr	r3, [r6, #0]
    3226:	e7c4      	b.n	31b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    3228:	401d4000 	.word	0x401d4000
    322c:	0401d408 	.word	0x0401d408
    3230:	401d4070 	.word	0x401d4070

00003234 <onHaldexRX(CAN_message_t const&)>:
void onHaldexRX(const CAN_message_t &frame) {
    3234:	b570      	push	{r4, r5, r6, lr}
  haldexState = frame.buf[0];
    3236:	4b1d      	ldr	r3, [pc, #116]	; (32ac <onHaldexRX(CAN_message_t const&)+0x78>)
void onHaldexRX(const CAN_message_t &frame) {
    3238:	b086      	sub	sp, #24
  haldexState = frame.buf[0];
    323a:	7b02      	ldrb	r2, [r0, #12]
void onHaldexRX(const CAN_message_t &frame) {
    323c:	4686      	mov	lr, r0
  CAN_message_t frame_out;
    323e:	4c1c      	ldr	r4, [pc, #112]	; (32b0 <onHaldexRX(CAN_message_t const&)+0x7c>)
    3240:	46ec      	mov	ip, sp
  haldexState = frame.buf[0];
    3242:	701a      	strb	r2, [r3, #0]
  haldexEngagement = frame.buf[1];
    3244:	4b1b      	ldr	r3, [pc, #108]	; (32b4 <onHaldexRX(CAN_message_t const&)+0x80>)
    3246:	7b42      	ldrb	r2, [r0, #13]
  frame_out.len = frame.len;
    3248:	7ac5      	ldrb	r5, [r0, #11]
  frame_out.flags = frame.flags;
    324a:	f8d0 6007 	ldr.w	r6, [r0, #7]
  haldexEngagement = frame.buf[1];
    324e:	701a      	strb	r2, [r3, #0]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3250:	2d08      	cmp	r5, #8
  CAN_message_t frame_out;
    3252:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    3254:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  frame_out.id = frame.id;
    3258:	f8de 3000 	ldr.w	r3, [lr]
  frame_out.flags = frame.flags;
    325c:	f8cd 6007 	str.w	r6, [sp, #7]
  frame_out.id = frame.id;
    3260:	9300      	str	r3, [sp, #0]
  frame_out.len = frame.len;
    3262:	f88d 500b 	strb.w	r5, [sp, #11]
  CAN_message_t frame_out;
    3266:	e894 0003 	ldmia.w	r4, {r0, r1}
    326a:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    326e:	d906      	bls.n	327e <onHaldexRX(CAN_message_t const&)+0x4a>
  if (!ChassisCAN.write(frame_out)) {
    3270:	4669      	mov	r1, sp
    3272:	4811      	ldr	r0, [pc, #68]	; (32b8 <onHaldexRX(CAN_message_t const&)+0x84>)
    3274:	f7ff ff3c 	bl	30f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3278:	b168      	cbz	r0, 3296 <onHaldexRX(CAN_message_t const&)+0x62>
}
    327a:	b006      	add	sp, #24
    327c:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(frame_out.buf, frame.buf, frame.len);
    327e:	f10e 010c 	add.w	r1, lr, #12
    3282:	462a      	mov	r2, r5
    3284:	a803      	add	r0, sp, #12
    3286:	f002 fdf5 	bl	5e74 <memcpy>
  if (!ChassisCAN.write(frame_out)) {
    328a:	4669      	mov	r1, sp
    328c:	480a      	ldr	r0, [pc, #40]	; (32b8 <onHaldexRX(CAN_message_t const&)+0x84>)
    328e:	f7ff ff2f 	bl	30f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3292:	2800      	cmp	r0, #0
    3294:	d1f1      	bne.n	327a <onHaldexRX(CAN_message_t const&)+0x46>
    3296:	2111      	movs	r1, #17
    3298:	4808      	ldr	r0, [pc, #32]	; (32bc <onHaldexRX(CAN_message_t const&)+0x88>)
    329a:	f004 f8f7 	bl	748c <usb_serial_write>
    329e:	4808      	ldr	r0, [pc, #32]	; (32c0 <onHaldexRX(CAN_message_t const&)+0x8c>)
    32a0:	f002 fa3c 	bl	571c <Print::println()>
    ChassisCAN.mailboxStatus();
    32a4:	f7fd ffc4 	bl	1230 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    32a8:	b006      	add	sp, #24
    32aa:	bd70      	pop	{r4, r5, r6, pc}
    32ac:	20006adf 	.word	0x20006adf
    32b0:	200002c0 	.word	0x200002c0
    32b4:	20006ade 	.word	0x20006ade
    32b8:	20001488 	.word	0x20001488
    32bc:	200002ec 	.word	0x200002ec
    32c0:	20000a68 	.word	0x20000a68

000032c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( mb_num == FIFO ) fifo_filter_table[0][0] |= (1UL << 28); /* enable fifo enhancement */
  else mb_filter_table[mb_num][0] |= (1UL << 28); /* enable mb enhancement */
}

FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    32c4:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    32c8:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    32cc:	00db      	lsls	r3, r3, #3
    32ce:	d569      	bpl.n	33a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32d0:	4b37      	ldr	r3, [pc, #220]	; (33b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    32d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32d6:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    32d8:	f04f 0e00 	mov.w	lr, #0
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    }
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    32dc:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    32e0:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32e4:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    32e8:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    32ec:	00f6      	lsls	r6, r6, #3
    32ee:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    32f0:	e009      	b.n	3306 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    32f2:	6813      	ldr	r3, [r2, #0]
    32f4:	0f5b      	lsrs	r3, r3, #29
    32f6:	2b05      	cmp	r3, #5
    32f8:	d034      	beq.n	3364 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    32fa:	f10e 0e01 	add.w	lr, lr, #1
    32fe:	fa5f f38e 	uxtb.w	r3, lr
    3302:	429e      	cmp	r6, r3
    3304:	d950      	bls.n	33a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3306:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    330a:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    330e:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    3312:	6813      	ldr	r3, [r2, #0]
    3314:	0f5b      	lsrs	r3, r3, #29
    3316:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3318:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    331a:	d00d      	beq.n	3338 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    331c:	0f5b      	lsrs	r3, r3, #29
    331e:	2b02      	cmp	r3, #2
    3320:	d1e7      	bne.n	32f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3322:	f85c 3007 	ldr.w	r3, [ip, r7]
    3326:	428b      	cmp	r3, r1
    3328:	d8e7      	bhi.n	32fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    332a:	f85c 3008 	ldr.w	r3, [ip, r8]
    332e:	428b      	cmp	r3, r1
    3330:	d3e3      	bcc.n	32fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3332:	2001      	movs	r0, #1
      }
    }
  }
  return 0;
}
    3334:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3338:	f413 7f60 	tst.w	r3, #896	; 0x380
    333c:	d0dd      	beq.n	32fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    333e:	006d      	lsls	r5, r5, #1
    3340:	2300      	movs	r3, #0
    3342:	e004      	b.n	334e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    3344:	6814      	ldr	r4, [r2, #0]
    3346:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    334a:	4563      	cmp	r3, ip
    334c:	d2d5      	bcs.n	32fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    334e:	3301      	adds	r3, #1
    3350:	eb05 0c03 	add.w	ip, r5, r3
    3354:	b2db      	uxtb	r3, r3
    3356:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    335a:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    335e:	428c      	cmp	r4, r1
    3360:	d1f0      	bne.n	3344 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    3362:	e7e6      	b.n	3332 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3364:	6813      	ldr	r3, [r2, #0]
    3366:	f413 7f60 	tst.w	r3, #896	; 0x380
    336a:	d0c6      	beq.n	32fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    336c:	44cc      	add	ip, r9
    336e:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3370:	2401      	movs	r4, #1
    3372:	e005      	b.n	3380 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    3374:	6813      	ldr	r3, [r2, #0]
    3376:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    337a:	3301      	adds	r3, #1
    337c:	429c      	cmp	r4, r3
    337e:	d2bc      	bcs.n	32fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3380:	192b      	adds	r3, r5, r4
    3382:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3386:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3388:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    338c:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3390:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3392:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    3396:	f8dc b000 	ldr.w	fp, [ip]
    339a:	ea03 030b 	and.w	r3, r3, fp
    339e:	459a      	cmp	sl, r3
    33a0:	d1e8      	bne.n	3374 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    33a2:	e7c6      	b.n	3332 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    33a4:	2001      	movs	r0, #1
}
    33a6:	4770      	bx	lr
  return 0;
    33a8:	2000      	movs	r0, #0
}
    33aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    33ae:	bf00      	nop
    33b0:	401d4000 	.word	0x401d4000

000033b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:

FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    33b4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    33b8:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    33ba:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    33be:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    33c2:	f8de 3000 	ldr.w	r3, [lr]
    33c6:	00db      	lsls	r3, r3, #3
    33c8:	d528      	bpl.n	341c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    33ca:	f8de 3000 	ldr.w	r3, [lr]
    33ce:	0f5b      	lsrs	r3, r3, #29
    33d0:	2b01      	cmp	r3, #1
    33d2:	d00b      	beq.n	33ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    33d4:	f8de 3000 	ldr.w	r3, [lr]
    33d8:	0f5b      	lsrs	r3, r3, #29
    33da:	2b02      	cmp	r3, #2
    33dc:	d042      	beq.n	3464 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    33de:	f8de 3000 	ldr.w	r3, [lr]
    33e2:	0f5b      	lsrs	r3, r3, #29
    33e4:	2b05      	cmp	r3, #5
    33e6:	d01b      	beq.n	3420 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    }
  }
  return 0;
    33e8:	2000      	movs	r0, #0
}
    33ea:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    33ec:	f8de 4000 	ldr.w	r4, [lr]
    33f0:	f414 7f60 	tst.w	r4, #896	; 0x380
    33f4:	d0f8      	beq.n	33e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    33f6:	2300      	movs	r3, #0
    33f8:	004d      	lsls	r5, r1, #1
    33fa:	e005      	b.n	3408 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    33fc:	f8de 1000 	ldr.w	r1, [lr]
    3400:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    3404:	4563      	cmp	r3, ip
    3406:	d2ef      	bcs.n	33e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3408:	3301      	adds	r3, #1
    340a:	eb05 0c03 	add.w	ip, r5, r3
    340e:	b2db      	uxtb	r3, r3
    3410:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    3414:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3418:	4294      	cmp	r4, r2
    341a:	d1ef      	bne.n	33fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    341c:	2001      	movs	r0, #1
}
    341e:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3420:	f8de 5000 	ldr.w	r5, [lr]
    3424:	f415 7f60 	tst.w	r5, #896	; 0x380
    3428:	d0de      	beq.n	33e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    342a:	f242 1514 	movw	r5, #8468	; 0x2114
    342e:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3430:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3432:	4425      	add	r5, r4
    3434:	e007      	b.n	3446 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3436:	f8de 4000 	ldr.w	r4, [lr]
    343a:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    343e:	f10c 0c01 	add.w	ip, ip, #1
    3442:	4563      	cmp	r3, ip
    3444:	d2d0      	bcs.n	33e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3446:	682c      	ldr	r4, [r5, #0]
    3448:	ea04 0c02 	and.w	ip, r4, r2
    344c:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    344e:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3450:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3454:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3456:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    345a:	682e      	ldr	r6, [r5, #0]
    345c:	4034      	ands	r4, r6
    345e:	45a4      	cmp	ip, r4
    3460:	d1e9      	bne.n	3436 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    3462:	e7db      	b.n	341c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    3464:	f242 1304 	movw	r3, #8452	; 0x2104
    3468:	58e3      	ldr	r3, [r4, r3]
    346a:	4293      	cmp	r3, r2
    346c:	d8bc      	bhi.n	33e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    346e:	f242 1308 	movw	r3, #8456	; 0x2108
    3472:	58e0      	ldr	r0, [r4, r3]
    3474:	4290      	cmp	r0, r2
    3476:	bf34      	ite	cc
    3478:	2000      	movcc	r0, #0
    347a:	2001      	movcs	r0, #1
}
    347c:	bd70      	pop	{r4, r5, r6, pc}
    347e:	bf00      	nop

00003480 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>:
  if ( _available < _size ) _available++;
    3480:	8883      	ldrh	r3, [r0, #4]
    3482:	b29b      	uxth	r3, r3
    3484:	2b0f      	cmp	r3, #15
    3486:	d803      	bhi.n	3490 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x10>
    3488:	8883      	ldrh	r3, [r0, #4]
    348a:	3301      	adds	r3, #1
    348c:	b29b      	uxth	r3, r3
    348e:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    3490:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3492:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    3496:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    3498:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    349c:	fa1f fc8c 	uxth.w	ip, ip
    34a0:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    34a2:	3202      	adds	r2, #2
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34a4:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    34a8:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34ac:	459c      	cmp	ip, r3
    34ae:	d104      	bne.n	34ba <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x3a>
    34b0:	8803      	ldrh	r3, [r0, #0]
    34b2:	3301      	adds	r3, #1
    34b4:	f003 031f 	and.w	r3, r3, #31
    34b8:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    34ba:	8843      	ldrh	r3, [r0, #2]
    34bc:	3301      	adds	r3, #1
    34be:	f003 031f 	and.w	r3, r3, #31
    34c2:	8043      	strh	r3, [r0, #2]
}
    34c4:	4770      	bx	lr
    34c6:	bf00      	nop

000034c8 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>:
  if ( _available < _size ) _available++;
    34c8:	8883      	ldrh	r3, [r0, #4]
    34ca:	b29b      	uxth	r3, r3
    34cc:	2b0f      	cmp	r3, #15
    34ce:	d803      	bhi.n	34d8 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x10>
    34d0:	8883      	ldrh	r3, [r0, #4]
    34d2:	3301      	adds	r3, #1
    34d4:	b29b      	uxth	r3, r3
    34d6:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    34d8:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34da:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    34de:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    34e0:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34e4:	fa1f fc8c 	uxth.w	ip, ip
    34e8:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    34ea:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34ee:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    34f2:	80d1      	strh	r1, [r2, #6]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    34f4:	459c      	cmp	ip, r3
    34f6:	d104      	bne.n	3502 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x3a>
    34f8:	8803      	ldrh	r3, [r0, #0]
    34fa:	3301      	adds	r3, #1
    34fc:	f003 031f 	and.w	r3, r3, #31
    3500:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    3502:	8843      	ldrh	r3, [r0, #2]
    3504:	3301      	adds	r3, #1
    3506:	f003 031f 	and.w	r3, r3, #31
    350a:	8043      	strh	r3, [r0, #2]
}
    350c:	4770      	bx	lr
    350e:	bf00      	nop

00003510 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3510:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    3514:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    3518:	00db      	lsls	r3, r3, #3
    351a:	d569      	bpl.n	35f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    351c:	4b37      	ldr	r3, [pc, #220]	; (35fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    351e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3522:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    3524:	f04f 0e00 	mov.w	lr, #0
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3528:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    352c:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3530:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3534:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3538:	00f6      	lsls	r6, r6, #3
    353a:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    353c:	e009      	b.n	3552 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    353e:	6813      	ldr	r3, [r2, #0]
    3540:	0f5b      	lsrs	r3, r3, #29
    3542:	2b05      	cmp	r3, #5
    3544:	d034      	beq.n	35b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3546:	f10e 0e01 	add.w	lr, lr, #1
    354a:	fa5f f38e 	uxtb.w	r3, lr
    354e:	429e      	cmp	r6, r3
    3550:	d950      	bls.n	35f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3552:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    3556:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    355a:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    355e:	6813      	ldr	r3, [r2, #0]
    3560:	0f5b      	lsrs	r3, r3, #29
    3562:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3564:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3566:	d00d      	beq.n	3584 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3568:	0f5b      	lsrs	r3, r3, #29
    356a:	2b02      	cmp	r3, #2
    356c:	d1e7      	bne.n	353e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    356e:	f85c 3007 	ldr.w	r3, [ip, r7]
    3572:	428b      	cmp	r3, r1
    3574:	d8e7      	bhi.n	3546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3576:	f85c 3008 	ldr.w	r3, [ip, r8]
    357a:	428b      	cmp	r3, r1
    357c:	d3e3      	bcc.n	3546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    357e:	2001      	movs	r0, #1
}
    3580:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3584:	f413 7f60 	tst.w	r3, #896	; 0x380
    3588:	d0dd      	beq.n	3546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    358a:	006d      	lsls	r5, r5, #1
    358c:	2300      	movs	r3, #0
    358e:	e004      	b.n	359a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    3590:	6814      	ldr	r4, [r2, #0]
    3592:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3596:	4563      	cmp	r3, ip
    3598:	d2d5      	bcs.n	3546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    359a:	3301      	adds	r3, #1
    359c:	eb05 0c03 	add.w	ip, r5, r3
    35a0:	b2db      	uxtb	r3, r3
    35a2:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    35a6:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    35aa:	428c      	cmp	r4, r1
    35ac:	d1f0      	bne.n	3590 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    35ae:	e7e6      	b.n	357e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35b0:	6813      	ldr	r3, [r2, #0]
    35b2:	f413 7f60 	tst.w	r3, #896	; 0x380
    35b6:	d0c6      	beq.n	3546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35b8:	44cc      	add	ip, r9
    35ba:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35bc:	2401      	movs	r4, #1
    35be:	e005      	b.n	35cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    35c0:	6813      	ldr	r3, [r2, #0]
    35c2:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    35c6:	3301      	adds	r3, #1
    35c8:	429c      	cmp	r4, r3
    35ca:	d2bc      	bcs.n	3546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35cc:	192b      	adds	r3, r5, r4
    35ce:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35d2:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35d4:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    35d8:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    35dc:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    35de:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    35e2:	f8dc b000 	ldr.w	fp, [ip]
    35e6:	ea03 030b 	and.w	r3, r3, fp
    35ea:	459a      	cmp	sl, r3
    35ec:	d1e8      	bne.n	35c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    35ee:	e7c6      	b.n	357e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    35f0:	2001      	movs	r0, #1
}
    35f2:	4770      	bx	lr
  return 0;
    35f4:	2000      	movs	r0, #0
}
    35f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    35fa:	bf00      	nop
    35fc:	401d0000 	.word	0x401d0000

00003600 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3600:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    3604:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3606:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    360a:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    360e:	f8de 3000 	ldr.w	r3, [lr]
    3612:	00db      	lsls	r3, r3, #3
    3614:	d528      	bpl.n	3668 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3616:	f8de 3000 	ldr.w	r3, [lr]
    361a:	0f5b      	lsrs	r3, r3, #29
    361c:	2b01      	cmp	r3, #1
    361e:	d00b      	beq.n	3638 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3620:	f8de 3000 	ldr.w	r3, [lr]
    3624:	0f5b      	lsrs	r3, r3, #29
    3626:	2b02      	cmp	r3, #2
    3628:	d042      	beq.n	36b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    362a:	f8de 3000 	ldr.w	r3, [lr]
    362e:	0f5b      	lsrs	r3, r3, #29
    3630:	2b05      	cmp	r3, #5
    3632:	d01b      	beq.n	366c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
  return 0;
    3634:	2000      	movs	r0, #0
}
    3636:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    3638:	f8de 4000 	ldr.w	r4, [lr]
    363c:	f414 7f60 	tst.w	r4, #896	; 0x380
    3640:	d0f8      	beq.n	3634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3642:	2300      	movs	r3, #0
    3644:	004d      	lsls	r5, r1, #1
    3646:	e005      	b.n	3654 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    3648:	f8de 1000 	ldr.w	r1, [lr]
    364c:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    3650:	4563      	cmp	r3, ip
    3652:	d2ef      	bcs.n	3634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3654:	3301      	adds	r3, #1
    3656:	eb05 0c03 	add.w	ip, r5, r3
    365a:	b2db      	uxtb	r3, r3
    365c:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    3660:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3664:	4294      	cmp	r4, r2
    3666:	d1ef      	bne.n	3648 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3668:	2001      	movs	r0, #1
}
    366a:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    366c:	f8de 5000 	ldr.w	r5, [lr]
    3670:	f415 7f60 	tst.w	r5, #896	; 0x380
    3674:	d0de      	beq.n	3634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3676:	f242 1514 	movw	r5, #8468	; 0x2114
    367a:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    367c:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    367e:	4425      	add	r5, r4
    3680:	e007      	b.n	3692 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3682:	f8de 4000 	ldr.w	r4, [lr]
    3686:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    368a:	f10c 0c01 	add.w	ip, ip, #1
    368e:	4563      	cmp	r3, ip
    3690:	d2d0      	bcs.n	3634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3692:	682c      	ldr	r4, [r5, #0]
    3694:	ea04 0c02 	and.w	ip, r4, r2
    3698:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    369a:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    369c:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    36a0:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    36a2:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    36a6:	682e      	ldr	r6, [r5, #0]
    36a8:	4034      	ands	r4, r6
    36aa:	45a4      	cmp	ip, r4
    36ac:	d1e9      	bne.n	3682 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    36ae:	e7db      	b.n	3668 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    36b0:	f242 1304 	movw	r3, #8452	; 0x2104
    36b4:	58e3      	ldr	r3, [r4, r3]
    36b6:	4293      	cmp	r3, r2
    36b8:	d8bc      	bhi.n	3634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    36ba:	f242 1308 	movw	r3, #8456	; 0x2108
    36be:	58e0      	ldr	r0, [r4, r3]
    36c0:	4290      	cmp	r0, r2
    36c2:	bf34      	ite	cc
    36c4:	2000      	movcc	r0, #0
    36c6:	2001      	movcs	r0, #1
}
    36c8:	bd70      	pop	{r4, r5, r6, pc}
    36ca:	bf00      	nop

000036cc <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    36cc:	8843      	ldrh	r3, [r0, #2]
    36ce:	f04f 0c1a 	mov.w	ip, #26
    36d2:	b2db      	uxtb	r3, r3
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    36d4:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    36d6:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    36da:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    36dc:	2000      	movs	r0, #0
    36de:	f883 0106 	strb.w	r0, [r3, #262]	; 0x106
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    36e2:	8863      	ldrh	r3, [r4, #2]
    36e4:	b2db      	uxtb	r3, r3
    36e6:	fb0c 4303 	mla	r3, ip, r3, r4
    36ea:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    36ee:	8860      	ldrh	r0, [r4, #2]
    36f0:	b2c0      	uxtb	r0, r0
    36f2:	fb0c 4000 	mla	r0, ip, r0, r4
    36f6:	f500 7084 	add.w	r0, r0, #264	; 0x108
    36fa:	f004 f949 	bl	7990 <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    36fe:	8862      	ldrh	r2, [r4, #2]
    3700:	8823      	ldrh	r3, [r4, #0]
    3702:	b292      	uxth	r2, r2
    3704:	b29b      	uxth	r3, r3
    3706:	f483 7380 	eor.w	r3, r3, #256	; 0x100
    370a:	429a      	cmp	r2, r3
    370c:	d104      	bne.n	3718 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    370e:	8823      	ldrh	r3, [r4, #0]
    3710:	3301      	adds	r3, #1
    3712:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3716:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    3718:	8863      	ldrh	r3, [r4, #2]
    371a:	3301      	adds	r3, #1
    371c:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3720:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    3722:	88a3      	ldrh	r3, [r4, #4]
    3724:	b29b      	uxth	r3, r3
    3726:	2bff      	cmp	r3, #255	; 0xff
    3728:	d803      	bhi.n	3732 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    372a:	88a3      	ldrh	r3, [r4, #4]
    372c:	3301      	adds	r3, #1
    372e:	b29b      	uxth	r3, r3
    3730:	80a3      	strh	r3, [r4, #4]
}
    3732:	bd10      	pop	{r4, pc}

00003734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    3734:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    3738:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    373a:	b08d      	sub	sp, #52	; 0x34
    373c:	460e      	mov	r6, r1
    373e:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    3740:	466c      	mov	r4, sp
    3742:	4605      	mov	r5, r0
    3744:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3748:	f04f 0901 	mov.w	r9, #1
    374c:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 37f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    3750:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3754:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3756:	e89c 0003 	ldmia.w	ip, {r0, r1}
    375a:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    375e:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    3762:	b15c      	cbz	r4, 377c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3764:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    3768:	68a3      	ldr	r3, [r4, #8]
    376a:	fa09 f102 	lsl.w	r1, r9, r2
    376e:	4219      	tst	r1, r3
    3770:	d023      	beq.n	37ba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    3772:	6823      	ldr	r3, [r4, #0]
    3774:	f8d3 b000 	ldr.w	fp, [r3]
    3778:	45d3      	cmp	fp, sl
    377a:	d119      	bne.n	37b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    377c:	4545      	cmp	r5, r8
    377e:	d1ee      	bne.n	375e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    3780:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    3784:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    3788:	b33b      	cbz	r3, 37da <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    378a:	6830      	ldr	r0, [r6, #0]
    378c:	ac06      	add	r4, sp, #24
    378e:	6871      	ldr	r1, [r6, #4]
    3790:	68b2      	ldr	r2, [r6, #8]
    3792:	68f3      	ldr	r3, [r6, #12]
    3794:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3796:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    3798:	2218      	movs	r2, #24
    379a:	6971      	ldr	r1, [r6, #20]
    379c:	c403      	stmia	r4!, {r0, r1}
    379e:	eb0d 0102 	add.w	r1, sp, r2
    37a2:	f107 0014 	add.w	r0, r7, #20
    37a6:	f7ff ff91 	bl	36cc <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    37aa:	b00d      	add	sp, #52	; 0x34
    37ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    37b0:	f89d 3015 	ldrb.w	r3, [sp, #21]
    37b4:	4669      	mov	r1, sp
    37b6:	4620      	mov	r0, r4
    37b8:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    37ba:	7c23      	ldrb	r3, [r4, #16]
    37bc:	2b00      	cmp	r3, #0
    37be:	d0dd      	beq.n	377c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    37c0:	6823      	ldr	r3, [r4, #0]
    37c2:	f8d3 b000 	ldr.w	fp, [r3]
    37c6:	f89d 3015 	ldrb.w	r3, [sp, #21]
    37ca:	45d3      	cmp	fp, sl
    37cc:	d0d6      	beq.n	377c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    37ce:	4620      	mov	r0, r4
    37d0:	f04f 32ff 	mov.w	r2, #4294967295
    37d4:	4669      	mov	r1, sp
    37d6:	47d8      	blx	fp
    37d8:	e7d0      	b.n	377c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    37da:	7d33      	ldrb	r3, [r6, #20]
    37dc:	4632      	mov	r2, r6
    37de:	a906      	add	r1, sp, #24
    37e0:	4638      	mov	r0, r7
    37e2:	f88d 3018 	strb.w	r3, [sp, #24]
    37e6:	f7ff f927 	bl	2a38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    37ea:	b00d      	add	sp, #52	; 0x34
    37ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    37f0:	00000b2d 	.word	0x00000b2d

000037f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  mb_filter_table[mb_num][4] = id4; // id4
  mb_filter_table[mb_num][5] = id5; // id5
}

FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
  if ( !distribution ) return; /* distribution not enabled */
    37f4:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    37f8:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    37fc:	2b00      	cmp	r3, #0
    37fe:	f000 80db 	beq.w	39b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  CAN_message_t frame = msg;

  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3802:	f8df c26c 	ldr.w	ip, [pc, #620]	; 3a70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    3806:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    380a:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    380c:	b089      	sub	sp, #36	; 0x24
    380e:	4605      	mov	r5, r0
    3810:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    3812:	ac02      	add	r4, sp, #8
    3814:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3816:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3818:	e897 0003 	ldmia.w	r7, {r0, r1}
    381c:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3820:	f8dc 3000 	ldr.w	r3, [ip]
    3824:	009b      	lsls	r3, r3, #2
    3826:	d552      	bpl.n	38ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3828:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    382c:	2400      	movs	r4, #0
        }
      }
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
            frame.mb = FIFO;
    382e:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3832:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    3836:	4622      	mov	r2, r4
    3838:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    383c:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3840:	e00c      	b.n	385c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3842:	0f5b      	lsrs	r3, r3, #29
    3844:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3846:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3848:	f000 809a 	beq.w	3980 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    384c:	0f5b      	lsrs	r3, r3, #29
    384e:	2b05      	cmp	r3, #5
    3850:	f000 80dd 	beq.w	3a0e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3854:	3401      	adds	r4, #1
    3856:	b2e2      	uxtb	r2, r4
    3858:	4592      	cmp	sl, r2
    385a:	d938      	bls.n	38ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    385c:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3860:	2b63      	cmp	r3, #99	; 0x63
    3862:	d034      	beq.n	38ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    3864:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    3868:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    386c:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    3870:	683b      	ldr	r3, [r7, #0]
    3872:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3876:	d0ed      	beq.n	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3878:	683b      	ldr	r3, [r7, #0]
    387a:	0f5b      	lsrs	r3, r3, #29
    387c:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    387e:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3880:	d1df      	bne.n	3842 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3882:	f3c3 4300 	ubfx	r3, r3, #16, #1
    3886:	79f2      	ldrb	r2, [r6, #7]
    3888:	429a      	cmp	r2, r3
    388a:	d1e3      	bne.n	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    388c:	683b      	ldr	r3, [r7, #0]
    388e:	f413 7f60 	tst.w	r3, #896	; 0x380
    3892:	d0df      	beq.n	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    3894:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3898:	2300      	movs	r3, #0
    389a:	e006      	b.n	38aa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    389c:	683a      	ldr	r2, [r7, #0]
    389e:	fa5f f388 	uxtb.w	r3, r8
    38a2:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    38a6:	4293      	cmp	r3, r2
    38a8:	d2d4      	bcs.n	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    38aa:	f103 0801 	add.w	r8, r3, #1
    38ae:	9a02      	ldr	r2, [sp, #8]
    38b0:	eb0b 0308 	add.w	r3, fp, r8
    38b4:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    38b8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    38bc:	429a      	cmp	r2, r3
    38be:	d1ed      	bne.n	389c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    38c0:	a902      	add	r1, sp, #8
    38c2:	4628      	mov	r0, r5
            frame.mb = FIFO;
    38c4:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    38c8:	f7ff ff34 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    38cc:	e7e6      	b.n	389c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
        }
      }
    } /* end of fifo scan */
  } /* end of fifo checking */

  frame.idhit = 0;
    38ce:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    38d0:	4f67      	ldr	r7, [pc, #412]	; (3a70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    38d2:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    38d6:	683c      	ldr	r4, [r7, #0]
    38d8:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    38dc:	d03f      	beq.n	395e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    38de:	f7fd fae7 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>

  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    38e2:	683b      	ldr	r3, [r7, #0]
    38e4:	4604      	mov	r4, r0
    38e6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    38ea:	3301      	adds	r3, #1
    38ec:	4283      	cmp	r3, r0
    38ee:	d933      	bls.n	3958 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
          struct2queueRx(frame);
        }
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    38f0:	f242 1704 	movw	r7, #8452	; 0x2104
    38f4:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    38f8:	f8df 9174 	ldr.w	r9, [pc, #372]	; 3a70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    38fc:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3900:	42a3      	cmp	r3, r4
    3902:	d020      	beq.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    3904:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    3908:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    390c:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    3910:	f8da 3000 	ldr.w	r3, [sl]
    3914:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3918:	d015      	beq.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    391a:	f8da 3000 	ldr.w	r3, [sl]
    391e:	79f0      	ldrb	r0, [r6, #7]
    3920:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    3924:	4298      	cmp	r0, r3
    3926:	d10e      	bne.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3928:	f8da 3000 	ldr.w	r3, [sl]
    392c:	0f5b      	lsrs	r3, r3, #29
    392e:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3930:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3934:	d041      	beq.n	39ba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3936:	0f5b      	lsrs	r3, r3, #29
    3938:	2b02      	cmp	r3, #2
    393a:	d012      	beq.n	3962 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    393c:	f8da 3000 	ldr.w	r3, [sl]
    3940:	0f5b      	lsrs	r3, r3, #29
    3942:	2b05      	cmp	r3, #5
    3944:	d05b      	beq.n	39fe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3946:	f8d9 3000 	ldr.w	r3, [r9]
    394a:	3401      	adds	r4, #1
    394c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3950:	b2e4      	uxtb	r4, r4
    3952:	3301      	adds	r3, #1
    3954:	429c      	cmp	r4, r3
    3956:	d3d1      	bcc.n	38fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
  } /* end of mb scan */
}
    3958:	b009      	add	sp, #36	; 0x24
    395a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    395e:	683b      	ldr	r3, [r7, #0]
    3960:	e7c6      	b.n	38f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    3962:	59d1      	ldr	r1, [r2, r7]
    3964:	9b02      	ldr	r3, [sp, #8]
    3966:	428b      	cmp	r3, r1
    3968:	d3ed      	bcc.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    396a:	f852 2008 	ldr.w	r2, [r2, r8]
    396e:	4293      	cmp	r3, r2
    3970:	d8e9      	bhi.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    3972:	a902      	add	r1, sp, #8
    3974:	4628      	mov	r0, r5
        frame.mb = i;
    3976:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    397a:	f7ff fedb 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    397e:	e7e2      	b.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3980:	f3c3 4300 	ubfx	r3, r3, #16, #1
    3984:	79f2      	ldrb	r2, [r6, #7]
    3986:	429a      	cmp	r2, r3
    3988:	f47f af64 	bne.w	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    398c:	f641 6304 	movw	r3, #7684	; 0x1e04
    3990:	f85b 2003 	ldr.w	r2, [fp, r3]
    3994:	9b02      	ldr	r3, [sp, #8]
    3996:	4293      	cmp	r3, r2
    3998:	f4ff af5c 	bcc.w	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    399c:	f641 6208 	movw	r2, #7688	; 0x1e08
    39a0:	f85b 2002 	ldr.w	r2, [fp, r2]
    39a4:	4293      	cmp	r3, r2
    39a6:	f63f af55 	bhi.w	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    39aa:	a902      	add	r1, sp, #8
    39ac:	4628      	mov	r0, r5
          frame.mb = FIFO;
    39ae:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    39b2:	f7ff febf 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    39b6:	e74d      	b.n	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    39b8:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    39ba:	f413 7f60 	tst.w	r3, #896	; 0x380
    39be:	d0c2      	beq.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    39c0:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    39c2:	2300      	movs	r3, #0
    39c4:	e007      	b.n	39d6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    39c6:	f8da 1000 	ldr.w	r1, [sl]
    39ca:	fa5f f38b 	uxtb.w	r3, fp
    39ce:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    39d2:	428b      	cmp	r3, r1
    39d4:	d2b7      	bcs.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    39d6:	f103 0b01 	add.w	fp, r3, #1
    39da:	9902      	ldr	r1, [sp, #8]
    39dc:	eb02 030b 	add.w	r3, r2, fp
    39e0:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    39e4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    39e8:	4299      	cmp	r1, r3
    39ea:	d1ec      	bne.n	39c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    39ec:	a902      	add	r1, sp, #8
    39ee:	4628      	mov	r0, r5
    39f0:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    39f2:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    39f6:	f7ff fe9d 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    39fa:	9a00      	ldr	r2, [sp, #0]
    39fc:	e7e3      	b.n	39c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    39fe:	9a02      	ldr	r2, [sp, #8]
    3a00:	4621      	mov	r1, r4
    3a02:	4628      	mov	r0, r5
    3a04:	f7ff fcd6 	bl	33b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3a08:	2800      	cmp	r0, #0
    3a0a:	d09c      	beq.n	3946 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3a0c:	e7b1      	b.n	3972 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3a0e:	683b      	ldr	r3, [r7, #0]
    3a10:	f413 7f60 	tst.w	r3, #896	; 0x380
    3a14:	f43f af1e 	beq.w	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3a18:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3a1c:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3a1e:	445b      	add	r3, fp
    3a20:	e00a      	b.n	3a38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3a22:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    3a26:	3701      	adds	r7, #1
    3a28:	6809      	ldr	r1, [r1, #0]
    3a2a:	b2ff      	uxtb	r7, r7
    3a2c:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    3a30:	3101      	adds	r1, #1
    3a32:	428f      	cmp	r7, r1
    3a34:	f4bf af0e 	bcs.w	3854 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3a38:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    3a3c:	6818      	ldr	r0, [r3, #0]
    3a3e:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    3a42:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    3a46:	9902      	ldr	r1, [sp, #8]
    3a48:	f8d3 c000 	ldr.w	ip, [r3]
    3a4c:	4008      	ands	r0, r1
    3a4e:	ea0e 010c 	and.w	r1, lr, ip
    3a52:	4288      	cmp	r0, r1
    3a54:	d1e5      	bne.n	3a22 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    3a56:	a902      	add	r1, sp, #8
    3a58:	4628      	mov	r0, r5
    3a5a:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    3a5c:	f88d 200e 	strb.w	r2, [sp, #14]
    3a60:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    3a62:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    3a66:	f7ff fe65 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3a6a:	e9dd 2300 	ldrd	r2, r3, [sp]
    3a6e:	e7d8      	b.n	3a22 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    3a70:	401d4000 	.word	0x401d4000

00003a74 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3a74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    3a78:	4d94      	ldr	r5, [pc, #592]	; (3ccc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3a7a:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3a7c:	4f94      	ldr	r7, [pc, #592]	; (3cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    3a7e:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3a80:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    3a82:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3a84:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3a86:	e895 0003 	ldmia.w	r5, {r0, r1}
    3a8a:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3a8e:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    3a90:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3a92:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    3a96:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3a98:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3a9a:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3a9c:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3aa0:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3aa2:	d103      	bne.n	3aac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    3aa4:	683a      	ldr	r2, [r7, #0]
    3aa6:	0094      	lsls	r4, r2, #2
    3aa8:	f100 811a 	bmi.w	3ce0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3aac:	9b03      	ldr	r3, [sp, #12]
    3aae:	f043 0301 	orr.w	r3, r3, #1
    3ab2:	f1bb 0f00 	cmp.w	fp, #0
    3ab6:	f000 8105 	beq.w	3cc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    3aba:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3abe:	4d84      	ldr	r5, [pc, #528]	; (3cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3ac0:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ac4:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3ac6:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ac8:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3acc:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ace:	f000 8284 	beq.w	3fda <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    3ad2:	f7fd f9ed 	bl	eb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3ad6:	682b      	ldr	r3, [r5, #0]
    3ad8:	4604      	mov	r4, r0
    3ada:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3ade:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    3ae0:	4283      	cmp	r3, r0
    3ae2:	f240 80c2 	bls.w	3c6a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    3ae6:	4287      	cmp	r7, r0
    3ae8:	f240 80bf 	bls.w	3c6a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    3aec:	9b04      	ldr	r3, [sp, #16]
    3aee:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3af0:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 3cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    3af4:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    3af8:	b2fd      	uxtb	r5, r7
    3afa:	9305      	str	r3, [sp, #20]
    3afc:	e018      	b.n	3b30 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    3afe:	2a04      	cmp	r2, #4
    3b00:	f000 8162 	beq.w	3dc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3b04:	2a08      	cmp	r2, #8
    3b06:	f000 8203 	beq.w	3f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3b0a:	f8d9 3000 	ldr.w	r3, [r9]
    3b0e:	b2fc      	uxtb	r4, r7
    3b10:	9a01      	ldr	r2, [sp, #4]
    3b12:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3b16:	3301      	adds	r3, #1
    3b18:	42a2      	cmp	r2, r4
    3b1a:	bf88      	it	hi
    3b1c:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    3b1e:	f105 0501 	add.w	r5, r5, #1
    3b22:	bf94      	ite	ls
    3b24:	2301      	movls	r3, #1
    3b26:	2300      	movhi	r3, #0
    3b28:	2b00      	cmp	r3, #0
    3b2a:	f040 809e 	bne.w	3c6a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    3b2e:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    3b30:	f1c4 0220 	rsb	r2, r4, #32
    3b34:	9b02      	ldr	r3, [sp, #8]
    3b36:	f1a4 0a20 	sub.w	sl, r4, #32
    3b3a:	fa06 f102 	lsl.w	r1, r6, r2
    3b3e:	40e3      	lsrs	r3, r4
    3b40:	430b      	orrs	r3, r1
    3b42:	fa26 f10a 	lsr.w	r1, r6, sl
    3b46:	430b      	orrs	r3, r1
    3b48:	07d8      	lsls	r0, r3, #31
    3b4a:	d5de      	bpl.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    3b4c:	9b03      	ldr	r3, [sp, #12]
    3b4e:	fa0b f202 	lsl.w	r2, fp, r2
    3b52:	40e3      	lsrs	r3, r4
    3b54:	4313      	orrs	r3, r2
    3b56:	fa2b f20a 	lsr.w	r2, fp, sl
    3b5a:	4313      	orrs	r3, r2
    3b5c:	07d9      	lsls	r1, r3, #31
    3b5e:	d5d4      	bpl.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    3b60:	f8df 8178 	ldr.w	r8, [pc, #376]	; 3cdc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    3b64:	44a0      	add	r8, r4
    3b66:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    3b6a:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    3b6e:	0e19      	lsrs	r1, r3, #24
    3b70:	f3c3 6203 	ubfx	r2, r3, #24, #4
    3b74:	f001 010b 	and.w	r1, r1, #11
    3b78:	2902      	cmp	r1, #2
    3b7a:	d1c0      	bne.n	3afe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b7c:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3b80:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b84:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    3b88:	2800      	cmp	r0, #0
    3b8a:	bf12      	itee	ne
    3b8c:	f04f 0c01 	movne.w	ip, #1
    3b90:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b94:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    3b96:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    3b98:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3b9c:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    3b9e:	d102      	bne.n	3ba6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    3ba0:	2201      	movs	r2, #1
    3ba2:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    3ba6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3baa:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3bae:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3bb2:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    3bb4:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    3bb8:	9b05      	ldr	r3, [sp, #20]
    3bba:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    3bbe:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3bc2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bc6:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3bca:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bce:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3bd2:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3bd6:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3bda:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3bde:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3be2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3be6:	ea4f 6313 	mov.w	r3, r3, lsr #24
    3bea:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3bee:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3bf2:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3bf6:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3bfa:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3bfe:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3c02:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3c06:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3c0a:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    3c0e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3c12:	ea4f 6313 	mov.w	r3, r3, lsr #24
    3c16:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3c1a:	bf14      	ite	ne
    3c1c:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    3c20:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3c24:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3c26:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    3c2a:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3c2e:	f04f 0301 	mov.w	r3, #1
    3c32:	d834      	bhi.n	3c9e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    3c34:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    3c38:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3c3a:	4621      	mov	r1, r4
    3c3c:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3c3e:	4313      	orrs	r3, r2
    3c40:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3c44:	9a08      	ldr	r2, [sp, #32]
    3c46:	f7ff fbb5 	bl	33b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3c4a:	2800      	cmp	r0, #0
    3c4c:	d135      	bne.n	3cba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    3c4e:	a908      	add	r1, sp, #32
    3c50:	9804      	ldr	r0, [sp, #16]
    3c52:	f7ff fdcf 	bl	37f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    3c56:	a808      	add	r0, sp, #32
    3c58:	f3af 8000 	nop.w
      ext_output2(msg);
    3c5c:	a808      	add	r0, sp, #32
    3c5e:	f3af 8000 	nop.w
      ext_output3(msg);
    3c62:	a808      	add	r0, sp, #32
    3c64:	f3af 8000 	nop.w
    3c68:	e74f      	b.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    3c6a:	4e19      	ldr	r6, [pc, #100]	; (3cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    3c6c:	4d19      	ldr	r5, [pc, #100]	; (3cd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    3c6e:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    3c70:	682a      	ldr	r2, [r5, #0]
    3c72:	4b19      	ldr	r3, [pc, #100]	; (3cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    3c74:	4062      	eors	r2, r4
    3c76:	4013      	ands	r3, r2
    3c78:	b143      	cbz	r3, 3c8c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    3c7a:	9b04      	ldr	r3, [sp, #16]
    3c7c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    3c80:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    3c84:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    3c86:	2b0f      	cmp	r3, #15
    3c88:	f240 81a9 	bls.w	3fde <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    3c8c:	4a10      	ldr	r2, [pc, #64]	; (3cd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    3c8e:	6a13      	ldr	r3, [r2, #32]
    3c90:	4323      	orrs	r3, r4
    3c92:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    3c94:	f3bf 8f4f 	dsb	sy
}
    3c98:	b01b      	add	sp, #108	; 0x6c
    3c9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3c9e:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    3ca2:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3ca6:	4621      	mov	r1, r4
    3ca8:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3caa:	4313      	orrs	r3, r2
    3cac:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3cb0:	9a08      	ldr	r2, [sp, #32]
    3cb2:	f7ff fb7f 	bl	33b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3cb6:	2800      	cmp	r0, #0
    3cb8:	d0c9      	beq.n	3c4e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    3cba:	a908      	add	r1, sp, #32
    3cbc:	9804      	ldr	r0, [sp, #16]
    3cbe:	f7ff fd39 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3cc2:	e7c4      	b.n	3c4e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3cc4:	fab3 f383 	clz	r3, r3
    3cc8:	3320      	adds	r3, #32
    3cca:	e6f8      	b.n	3abe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    3ccc:	200002c0 	.word	0x200002c0
    3cd0:	401d4000 	.word	0x401d4000
    3cd4:	200068a8 	.word	0x200068a8
    3cd8:	0007ffbf 	.word	0x0007ffbf
    3cdc:	0401d408 	.word	0x0401d408
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    3ce0:	0689      	lsls	r1, r1, #26
    3ce2:	f57f aee3 	bpl.w	3aac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    3ce6:	0682      	lsls	r2, r0, #26
    3ce8:	f57f aee0 	bpl.w	3aac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    3cec:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3cf0:	4cc3      	ldr	r4, [pc, #780]	; (4000 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    3cf2:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    3cf6:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    3cfa:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    3cfe:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    3d00:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    3d04:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    3d08:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d0c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    3d10:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    3d14:	bf18      	it	ne
    3d16:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d18:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    3d1c:	bf08      	it	eq
    3d1e:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    3d20:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    3d24:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d28:	bf08      	it	eq
    3d2a:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    3d2c:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    3d30:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3d32:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3d34:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    3d38:	40d1      	lsrs	r1, r2
    3d3a:	3208      	adds	r2, #8
    3d3c:	2a20      	cmp	r2, #32
    3d3e:	f800 1d01 	strb.w	r1, [r0, #-1]!
    3d42:	d1f7      	bne.n	3d34 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    3d44:	a80d      	add	r0, sp, #52	; 0x34
    3d46:	49ae      	ldr	r1, [pc, #696]	; (4000 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    3d48:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    3d4c:	40da      	lsrs	r2, r3
    3d4e:	3308      	adds	r3, #8
    3d50:	2b20      	cmp	r3, #32
    3d52:	f800 2d01 	strb.w	r2, [r0, #-1]!
    3d56:	d1f7      	bne.n	3d48 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    3d58:	9b04      	ldr	r3, [sp, #16]
    3d5a:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    3d5e:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    3d62:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    3d66:	2363      	movs	r3, #99	; 0x63
    3d68:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    3d6c:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3d6e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    3d70:	f043 0320 	orr.w	r3, r3, #32
    3d74:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    3d76:	9b03      	ldr	r3, [sp, #12]
    3d78:	065d      	lsls	r5, r3, #25
    3d7a:	d503      	bpl.n	3d84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3d7c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    3d7e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3d82:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    3d84:	9b03      	ldr	r3, [sp, #12]
    3d86:	061c      	lsls	r4, r3, #24
    3d88:	d504      	bpl.n	3d94 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3d8a:	4a9d      	ldr	r2, [pc, #628]	; (4000 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    3d8c:	6b13      	ldr	r3, [r2, #48]	; 0x30
    3d8e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3d92:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    3d94:	9c04      	ldr	r4, [sp, #16]
    3d96:	a908      	add	r1, sp, #32
    3d98:	4620      	mov	r0, r4
    3d9a:	f7ff fd2b 	bl	37f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    3d9e:	a808      	add	r0, sp, #32
    3da0:	f3af 8000 	nop.w
      ext_output2(msg);
    3da4:	a808      	add	r0, sp, #32
    3da6:	f3af 8000 	nop.w
      ext_output3(msg);
    3daa:	a808      	add	r0, sp, #32
    3dac:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    3db0:	9908      	ldr	r1, [sp, #32]
    3db2:	4620      	mov	r0, r4
    3db4:	f7ff fa86 	bl	32c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    3db8:	2800      	cmp	r0, #0
    3dba:	f43f ae77 	beq.w	3aac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    3dbe:	a908      	add	r1, sp, #32
    3dc0:	9804      	ldr	r0, [sp, #16]
    3dc2:	f7ff fcb7 	bl	3734 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3dc6:	e671      	b.n	3aac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    3dc8:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    3dcc:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3dce:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    3dd2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3dd6:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3dda:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3dde:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    3de2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    3de6:	bf18      	it	ne
    3de8:	2101      	movne	r1, #1
      msg.bus = busNumber;
    3dea:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3dec:	bf04      	itt	eq
    3dee:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    3df0:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    3df2:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3df6:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    3df8:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3dfc:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3e00:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3e02:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3e06:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3e0a:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3e0e:	0a1b      	lsrs	r3, r3, #8
    3e10:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3e14:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3e18:	0c1b      	lsrs	r3, r3, #16
    3e1a:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3e1e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3e22:	0e1b      	lsrs	r3, r3, #24
    3e24:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3e28:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3e2c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3e30:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3e34:	0a1b      	lsrs	r3, r3, #8
    3e36:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3e3a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3e3e:	0c1b      	lsrs	r3, r3, #16
    3e40:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3e44:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    3e48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3e4c:	f8d8 200c 	ldr.w	r2, [r8, #12]
    3e50:	0e12      	lsrs	r2, r2, #24
    3e52:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3e56:	b10b      	cbz	r3, 3e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    3e58:	a808      	add	r0, sp, #32
    3e5a:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    3e5c:	9b05      	ldr	r3, [sp, #20]
    3e5e:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    3e62:	b10b      	cbz	r3, 3e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    3e64:	a808      	add	r0, sp, #32
    3e66:	4798      	blx	r3
    3e68:	9904      	ldr	r1, [sp, #16]
    3e6a:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    3e6e:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3e72:	9207      	str	r2, [sp, #28]
    3e74:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    3e76:	2b00      	cmp	r3, #0
    3e78:	f000 80c4 	beq.w	4004 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    3e7c:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    3e80:	221a      	movs	r2, #26
    3e82:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    3e86:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    3e8a:	46e0      	mov	r8, ip
    3e8c:	fb02 1303 	mla	r3, r2, r3, r1
    3e90:	f641 3232 	movw	r2, #6962	; 0x1b32
    3e94:	a90e      	add	r1, sp, #56	; 0x38
    3e96:	eb03 0a02 	add.w	sl, r3, r2
    3e9a:	9106      	str	r1, [sp, #24]
    3e9c:	468e      	mov	lr, r1
    3e9e:	5898      	ldr	r0, [r3, r2]
    3ea0:	f8da 1004 	ldr.w	r1, [sl, #4]
    3ea4:	f8da 2008 	ldr.w	r2, [sl, #8]
    3ea8:	f8da 300c 	ldr.w	r3, [sl, #12]
    3eac:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3eb0:	f8da 0010 	ldr.w	r0, [sl, #16]
    3eb4:	f8da 1014 	ldr.w	r1, [sl, #20]
    3eb8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    3ebc:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    3ec0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3ec4:	e898 0003 	ldmia.w	r8, {r0, r1}
    3ec8:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    3ecc:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    3ed0:	1c5a      	adds	r2, r3, #1
    3ed2:	f000 80a6 	beq.w	4022 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    3ed6:	429c      	cmp	r4, r3
    3ed8:	f47f ae17 	bne.w	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    3edc:	9a06      	ldr	r2, [sp, #24]
    3ede:	b2e1      	uxtb	r1, r4
    3ee0:	9804      	ldr	r0, [sp, #16]
    3ee2:	f7fe fdcf 	bl	2a84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    3ee6:	9a07      	ldr	r2, [sp, #28]
    3ee8:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    3eec:	3301      	adds	r3, #1
    3eee:	f003 031f 	and.w	r3, r3, #31
    3ef2:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    3ef6:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3efa:	b29b      	uxth	r3, r3
    3efc:	2b00      	cmp	r3, #0
    3efe:	f43f ae04 	beq.w	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    3f02:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3f06:	3b01      	subs	r3, #1
    3f08:	b29b      	uxth	r3, r3
    3f0a:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    3f0e:	e5fc      	b.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f10:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    3f14:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f16:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    3f1a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3f1e:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3f22:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f26:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    3f2a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f2e:	bf18      	it	ne
    3f30:	2101      	movne	r1, #1
      msg.bus = busNumber;
    3f32:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f34:	bf04      	itt	eq
    3f36:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f38:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    3f3a:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f3e:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    3f40:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f44:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3f48:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f4a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3f4e:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f52:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f56:	0a1b      	lsrs	r3, r3, #8
    3f58:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3f5c:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f60:	0c1b      	lsrs	r3, r3, #16
    3f62:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3f66:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f6a:	0e1b      	lsrs	r3, r3, #24
    3f6c:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3f70:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f74:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3f78:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f7c:	0a1b      	lsrs	r3, r3, #8
    3f7e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3f82:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f86:	0c1b      	lsrs	r3, r3, #16
    3f88:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    3f8c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f90:	0e1b      	lsrs	r3, r3, #24
    3f92:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    3f96:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    3f9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3f9e:	b10b      	cbz	r3, 3fa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    3fa0:	a808      	add	r0, sp, #32
    3fa2:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    3fa4:	9b05      	ldr	r3, [sp, #20]
    3fa6:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    3faa:	b10b      	cbz	r3, 3fb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    3fac:	a808      	add	r0, sp, #32
    3fae:	4798      	blx	r3
        uint16_t size() { return _available; }
    3fb0:	9904      	ldr	r1, [sp, #16]
    3fb2:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    3fb6:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    3fba:	9207      	str	r2, [sp, #28]
    3fbc:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    3fbe:	2b00      	cmp	r3, #0
    3fc0:	f47f af5c 	bne.w	3e7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3fc4:	2c1f      	cmp	r4, #31
    3fc6:	f04f 0301 	mov.w	r3, #1
    3fca:	d835      	bhi.n	4038 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    3fcc:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    3fd0:	40a3      	lsls	r3, r4
    3fd2:	4313      	orrs	r3, r2
    3fd4:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    3fd8:	e597      	b.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3fda:	682b      	ldr	r3, [r5, #0]
    3fdc:	e586      	b.n	3aec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    3fde:	9f04      	ldr	r7, [sp, #16]
    3fe0:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    3fe4:	4621      	mov	r1, r4
    3fe6:	4438      	add	r0, r7
    3fe8:	f7ff fa4a 	bl	3480 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    3fec:	69f1      	ldr	r1, [r6, #28]
    3fee:	f641 5098 	movw	r0, #7576	; 0x1d98
    3ff2:	b289      	uxth	r1, r1
    3ff4:	4438      	add	r0, r7
    3ff6:	f7ff fa67 	bl	34c8 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    3ffa:	602c      	str	r4, [r5, #0]
    3ffc:	e646      	b.n	3c8c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    3ffe:	bf00      	nop
    4000:	401d4000 	.word	0x401d4000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4004:	2c1f      	cmp	r4, #31
    4006:	f04f 0301 	mov.w	r3, #1
    400a:	d80d      	bhi.n	4028 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    400c:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4010:	40a3      	lsls	r3, r4
    4012:	4313      	orrs	r3, r2
    4014:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4018:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    401c:	f8c8 3000 	str.w	r3, [r8]
    4020:	e573      	b.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    4022:	9a06      	ldr	r2, [sp, #24]
    4024:	4621      	mov	r1, r4
    4026:	e75b      	b.n	3ee0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4028:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    402c:	fa03 f30a 	lsl.w	r3, r3, sl
    4030:	4313      	orrs	r3, r2
    4032:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4036:	e7ef      	b.n	4018 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4038:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    403c:	fa03 f30a 	lsl.w	r3, r3, sl
    4040:	4313      	orrs	r3, r2
    4042:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4046:	e560      	b.n	3b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

00004048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    4048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    404c:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    404e:	b08d      	sub	sp, #52	; 0x34
    4050:	460e      	mov	r6, r1
    4052:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    4054:	466c      	mov	r4, sp
    4056:	4605      	mov	r5, r0
    4058:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    405c:	f04f 0901 	mov.w	r9, #1
    4060:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 4104 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    4064:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    4068:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    406a:	e89c 0003 	ldmia.w	ip, {r0, r1}
    406e:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    4072:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    4076:	b15c      	cbz	r4, 4090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    4078:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    407c:	68a3      	ldr	r3, [r4, #8]
    407e:	fa09 f102 	lsl.w	r1, r9, r2
    4082:	4219      	tst	r1, r3
    4084:	d023      	beq.n	40ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    4086:	6823      	ldr	r3, [r4, #0]
    4088:	f8d3 b000 	ldr.w	fp, [r3]
    408c:	45d3      	cmp	fp, sl
    408e:	d119      	bne.n	40c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    4090:	4545      	cmp	r5, r8
    4092:	d1ee      	bne.n	4072 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    4094:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    4098:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    409c:	b33b      	cbz	r3, 40ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    409e:	6830      	ldr	r0, [r6, #0]
    40a0:	ac06      	add	r4, sp, #24
    40a2:	6871      	ldr	r1, [r6, #4]
    40a4:	68b2      	ldr	r2, [r6, #8]
    40a6:	68f3      	ldr	r3, [r6, #12]
    40a8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    40aa:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    40ac:	2218      	movs	r2, #24
    40ae:	6971      	ldr	r1, [r6, #20]
    40b0:	c403      	stmia	r4!, {r0, r1}
    40b2:	eb0d 0102 	add.w	r1, sp, r2
    40b6:	f107 0014 	add.w	r0, r7, #20
    40ba:	f7ff fb07 	bl	36cc <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    40be:	b00d      	add	sp, #52	; 0x34
    40c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    40c4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    40c8:	4669      	mov	r1, sp
    40ca:	4620      	mov	r0, r4
    40cc:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    40ce:	7c23      	ldrb	r3, [r4, #16]
    40d0:	2b00      	cmp	r3, #0
    40d2:	d0dd      	beq.n	4090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    40d4:	6823      	ldr	r3, [r4, #0]
    40d6:	f8d3 b000 	ldr.w	fp, [r3]
    40da:	f89d 3015 	ldrb.w	r3, [sp, #21]
    40de:	45d3      	cmp	fp, sl
    40e0:	d0d6      	beq.n	4090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    40e2:	4620      	mov	r0, r4
    40e4:	f04f 32ff 	mov.w	r2, #4294967295
    40e8:	4669      	mov	r1, sp
    40ea:	47d8      	blx	fp
    40ec:	e7d0      	b.n	4090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    40ee:	7d33      	ldrb	r3, [r6, #20]
    40f0:	4632      	mov	r2, r6
    40f2:	a906      	add	r1, sp, #24
    40f4:	4638      	mov	r0, r7
    40f6:	f88d 3018 	strb.w	r3, [sp, #24]
    40fa:	f7fe fb35 	bl	2768 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    40fe:	b00d      	add	sp, #52	; 0x34
    4100:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4104:	00000b2d 	.word	0x00000b2d

00004108 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  if ( !distribution ) return; /* distribution not enabled */
    4108:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    410c:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    4110:	2b00      	cmp	r3, #0
    4112:	f000 80db 	beq.w	42cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    4116:	f8df c26c 	ldr.w	ip, [pc, #620]	; 4384 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    411a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    411e:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    4120:	b089      	sub	sp, #36	; 0x24
    4122:	4605      	mov	r5, r0
    4124:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    4126:	ac02      	add	r4, sp, #8
    4128:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    412a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    412c:	e897 0003 	ldmia.w	r7, {r0, r1}
    4130:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    4134:	f8dc 3000 	ldr.w	r3, [ip]
    4138:	009b      	lsls	r3, r3, #2
    413a:	d552      	bpl.n	41e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    413c:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    4140:	2400      	movs	r4, #0
            frame.mb = FIFO;
    4142:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    4146:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    414a:	4622      	mov	r2, r4
    414c:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    4150:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    4154:	e00c      	b.n	4170 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    4156:	0f5b      	lsrs	r3, r3, #29
    4158:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    415a:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    415c:	f000 809a 	beq.w	4294 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    4160:	0f5b      	lsrs	r3, r3, #29
    4162:	2b05      	cmp	r3, #5
    4164:	f000 80dd 	beq.w	4322 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    4168:	3401      	adds	r4, #1
    416a:	b2e2      	uxtb	r2, r4
    416c:	4592      	cmp	sl, r2
    416e:	d938      	bls.n	41e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    4170:	f996 3014 	ldrsb.w	r3, [r6, #20]
    4174:	2b63      	cmp	r3, #99	; 0x63
    4176:	d034      	beq.n	41e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    4178:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    417c:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    4180:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    4184:	683b      	ldr	r3, [r7, #0]
    4186:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    418a:	d0ed      	beq.n	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    418c:	683b      	ldr	r3, [r7, #0]
    418e:	0f5b      	lsrs	r3, r3, #29
    4190:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4192:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4194:	d1df      	bne.n	4156 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4196:	f3c3 4300 	ubfx	r3, r3, #16, #1
    419a:	79f2      	ldrb	r2, [r6, #7]
    419c:	429a      	cmp	r2, r3
    419e:	d1e3      	bne.n	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    41a0:	683b      	ldr	r3, [r7, #0]
    41a2:	f413 7f60 	tst.w	r3, #896	; 0x380
    41a6:	d0df      	beq.n	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    41a8:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    41ac:	2300      	movs	r3, #0
    41ae:	e006      	b.n	41be <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    41b0:	683a      	ldr	r2, [r7, #0]
    41b2:	fa5f f388 	uxtb.w	r3, r8
    41b6:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    41ba:	4293      	cmp	r3, r2
    41bc:	d2d4      	bcs.n	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    41be:	f103 0801 	add.w	r8, r3, #1
    41c2:	9a02      	ldr	r2, [sp, #8]
    41c4:	eb0b 0308 	add.w	r3, fp, r8
    41c8:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    41cc:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    41d0:	429a      	cmp	r2, r3
    41d2:	d1ed      	bne.n	41b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    41d4:	a902      	add	r1, sp, #8
    41d6:	4628      	mov	r0, r5
            frame.mb = FIFO;
    41d8:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    41dc:	f7ff ff34 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    41e0:	e7e6      	b.n	41b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
  frame.idhit = 0;
    41e2:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    41e4:	4f67      	ldr	r7, [pc, #412]	; (4384 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    41e6:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    41ea:	683c      	ldr	r4, [r7, #0]
    41ec:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    41f0:	d03f      	beq.n	4272 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    41f2:	f7fc fe39 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    41f6:	683b      	ldr	r3, [r7, #0]
    41f8:	4604      	mov	r4, r0
    41fa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    41fe:	3301      	adds	r3, #1
    4200:	4283      	cmp	r3, r0
    4202:	d933      	bls.n	426c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    4204:	f242 1704 	movw	r7, #8452	; 0x2104
    4208:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    420c:	f8df 9174 	ldr.w	r9, [pc, #372]	; 4384 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    4210:	f996 3014 	ldrsb.w	r3, [r6, #20]
    4214:	42a3      	cmp	r3, r4
    4216:	d020      	beq.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    4218:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    421c:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    4220:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    4224:	f8da 3000 	ldr.w	r3, [sl]
    4228:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    422c:	d015      	beq.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    422e:	f8da 3000 	ldr.w	r3, [sl]
    4232:	79f0      	ldrb	r0, [r6, #7]
    4234:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    4238:	4298      	cmp	r0, r3
    423a:	d10e      	bne.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    423c:	f8da 3000 	ldr.w	r3, [sl]
    4240:	0f5b      	lsrs	r3, r3, #29
    4242:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    4244:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4248:	d041      	beq.n	42ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    424a:	0f5b      	lsrs	r3, r3, #29
    424c:	2b02      	cmp	r3, #2
    424e:	d012      	beq.n	4276 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    4250:	f8da 3000 	ldr.w	r3, [sl]
    4254:	0f5b      	lsrs	r3, r3, #29
    4256:	2b05      	cmp	r3, #5
    4258:	d05b      	beq.n	4312 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    425a:	f8d9 3000 	ldr.w	r3, [r9]
    425e:	3401      	adds	r4, #1
    4260:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4264:	b2e4      	uxtb	r4, r4
    4266:	3301      	adds	r3, #1
    4268:	429c      	cmp	r4, r3
    426a:	d3d1      	bcc.n	4210 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
}
    426c:	b009      	add	sp, #36	; 0x24
    426e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    4272:	683b      	ldr	r3, [r7, #0]
    4274:	e7c6      	b.n	4204 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    4276:	59d1      	ldr	r1, [r2, r7]
    4278:	9b02      	ldr	r3, [sp, #8]
    427a:	428b      	cmp	r3, r1
    427c:	d3ed      	bcc.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    427e:	f852 2008 	ldr.w	r2, [r2, r8]
    4282:	4293      	cmp	r3, r2
    4284:	d8e9      	bhi.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    4286:	a902      	add	r1, sp, #8
    4288:	4628      	mov	r0, r5
        frame.mb = i;
    428a:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    428e:	f7ff fedb 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4292:	e7e2      	b.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4294:	f3c3 4300 	ubfx	r3, r3, #16, #1
    4298:	79f2      	ldrb	r2, [r6, #7]
    429a:	429a      	cmp	r2, r3
    429c:	f47f af64 	bne.w	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    42a0:	f641 6304 	movw	r3, #7684	; 0x1e04
    42a4:	f85b 2003 	ldr.w	r2, [fp, r3]
    42a8:	9b02      	ldr	r3, [sp, #8]
    42aa:	4293      	cmp	r3, r2
    42ac:	f4ff af5c 	bcc.w	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    42b0:	f641 6208 	movw	r2, #7688	; 0x1e08
    42b4:	f85b 2002 	ldr.w	r2, [fp, r2]
    42b8:	4293      	cmp	r3, r2
    42ba:	f63f af55 	bhi.w	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    42be:	a902      	add	r1, sp, #8
    42c0:	4628      	mov	r0, r5
          frame.mb = FIFO;
    42c2:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    42c6:	f7ff febf 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    42ca:	e74d      	b.n	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    42cc:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    42ce:	f413 7f60 	tst.w	r3, #896	; 0x380
    42d2:	d0c2      	beq.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    42d4:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    42d6:	2300      	movs	r3, #0
    42d8:	e007      	b.n	42ea <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    42da:	f8da 1000 	ldr.w	r1, [sl]
    42de:	fa5f f38b 	uxtb.w	r3, fp
    42e2:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    42e6:	428b      	cmp	r3, r1
    42e8:	d2b7      	bcs.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    42ea:	f103 0b01 	add.w	fp, r3, #1
    42ee:	9902      	ldr	r1, [sp, #8]
    42f0:	eb02 030b 	add.w	r3, r2, fp
    42f4:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    42f8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    42fc:	4299      	cmp	r1, r3
    42fe:	d1ec      	bne.n	42da <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    4300:	a902      	add	r1, sp, #8
    4302:	4628      	mov	r0, r5
    4304:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    4306:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    430a:	f7ff fe9d 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    430e:	9a00      	ldr	r2, [sp, #0]
    4310:	e7e3      	b.n	42da <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    4312:	9a02      	ldr	r2, [sp, #8]
    4314:	4621      	mov	r1, r4
    4316:	4628      	mov	r0, r5
    4318:	f7ff f972 	bl	3600 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    431c:	2800      	cmp	r0, #0
    431e:	d09c      	beq.n	425a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    4320:	e7b1      	b.n	4286 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    4322:	683b      	ldr	r3, [r7, #0]
    4324:	f413 7f60 	tst.w	r3, #896	; 0x380
    4328:	f43f af1e 	beq.w	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    432c:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    4330:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    4332:	445b      	add	r3, fp
    4334:	e00a      	b.n	434c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    4336:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    433a:	3701      	adds	r7, #1
    433c:	6809      	ldr	r1, [r1, #0]
    433e:	b2ff      	uxtb	r7, r7
    4340:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    4344:	3101      	adds	r1, #1
    4346:	428f      	cmp	r7, r1
    4348:	f4bf af0e 	bcs.w	4168 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    434c:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    4350:	6818      	ldr	r0, [r3, #0]
    4352:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    4356:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    435a:	9902      	ldr	r1, [sp, #8]
    435c:	f8d3 c000 	ldr.w	ip, [r3]
    4360:	4008      	ands	r0, r1
    4362:	ea0e 010c 	and.w	r1, lr, ip
    4366:	4288      	cmp	r0, r1
    4368:	d1e5      	bne.n	4336 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    436a:	a902      	add	r1, sp, #8
    436c:	4628      	mov	r0, r5
    436e:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    4370:	f88d 200e 	strb.w	r2, [sp, #14]
    4374:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    4376:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    437a:	f7ff fe65 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    437e:	e9dd 2300 	ldrd	r2, r3, [sp]
    4382:	e7d8      	b.n	4336 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    4384:	401d0000 	.word	0x401d0000

00004388 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    4388:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    438c:	4d94      	ldr	r5, [pc, #592]	; (45e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    438e:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    4390:	4f94      	ldr	r7, [pc, #592]	; (45e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    4392:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    4394:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    4396:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    4398:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    439a:	e895 0003 	ldmia.w	r5, {r0, r1}
    439e:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    43a2:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    43a4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    43a6:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    43aa:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    43ac:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    43ae:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    43b0:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    43b4:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    43b6:	d103      	bne.n	43c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    43b8:	683a      	ldr	r2, [r7, #0]
    43ba:	0094      	lsls	r4, r2, #2
    43bc:	f100 811a 	bmi.w	45f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43c0:	9b03      	ldr	r3, [sp, #12]
    43c2:	f043 0301 	orr.w	r3, r3, #1
    43c6:	f1bb 0f00 	cmp.w	fp, #0
    43ca:	f000 8105 	beq.w	45d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    43ce:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43d2:	4d84      	ldr	r5, [pc, #528]	; (45e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43d4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43d8:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43da:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43dc:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    43e0:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    43e2:	f000 8284 	beq.w	48ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    43e6:	f7fc fd3f 	bl	e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    43ea:	682b      	ldr	r3, [r5, #0]
    43ec:	4604      	mov	r4, r0
    43ee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    43f2:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    43f4:	4283      	cmp	r3, r0
    43f6:	f240 80c2 	bls.w	457e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    43fa:	4287      	cmp	r7, r0
    43fc:	f240 80bf 	bls.w	457e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    4400:	9b04      	ldr	r3, [sp, #16]
    4402:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4404:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 45e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    4408:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    440c:	b2fd      	uxtb	r5, r7
    440e:	9305      	str	r3, [sp, #20]
    4410:	e018      	b.n	4444 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    4412:	2a04      	cmp	r2, #4
    4414:	f000 8162 	beq.w	46dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    4418:	2a08      	cmp	r2, #8
    441a:	f000 8203 	beq.w	4824 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    441e:	f8d9 3000 	ldr.w	r3, [r9]
    4422:	b2fc      	uxtb	r4, r7
    4424:	9a01      	ldr	r2, [sp, #4]
    4426:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    442a:	3301      	adds	r3, #1
    442c:	42a2      	cmp	r2, r4
    442e:	bf88      	it	hi
    4430:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    4432:	f105 0501 	add.w	r5, r5, #1
    4436:	bf94      	ite	ls
    4438:	2301      	movls	r3, #1
    443a:	2300      	movhi	r3, #0
    443c:	2b00      	cmp	r3, #0
    443e:	f040 809e 	bne.w	457e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    4442:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    4444:	f1c4 0220 	rsb	r2, r4, #32
    4448:	9b02      	ldr	r3, [sp, #8]
    444a:	f1a4 0a20 	sub.w	sl, r4, #32
    444e:	fa06 f102 	lsl.w	r1, r6, r2
    4452:	40e3      	lsrs	r3, r4
    4454:	430b      	orrs	r3, r1
    4456:	fa26 f10a 	lsr.w	r1, r6, sl
    445a:	430b      	orrs	r3, r1
    445c:	07d8      	lsls	r0, r3, #31
    445e:	d5de      	bpl.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    4460:	9b03      	ldr	r3, [sp, #12]
    4462:	fa0b f202 	lsl.w	r2, fp, r2
    4466:	40e3      	lsrs	r3, r4
    4468:	4313      	orrs	r3, r2
    446a:	fa2b f20a 	lsr.w	r2, fp, sl
    446e:	4313      	orrs	r3, r2
    4470:	07d9      	lsls	r1, r3, #31
    4472:	d5d4      	bpl.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    4474:	f8df 8178 	ldr.w	r8, [pc, #376]	; 45f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    4478:	44a0      	add	r8, r4
    447a:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    447e:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    4482:	0e19      	lsrs	r1, r3, #24
    4484:	f3c3 6203 	ubfx	r2, r3, #24, #4
    4488:	f001 010b 	and.w	r1, r1, #11
    448c:	2902      	cmp	r1, #2
    448e:	d1c0      	bne.n	4412 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4490:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4494:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4498:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    449c:	2800      	cmp	r0, #0
    449e:	bf12      	itee	ne
    44a0:	f04f 0c01 	movne.w	ip, #1
    44a4:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    44a8:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    44aa:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    44ac:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    44b0:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    44b2:	d102      	bne.n	44ba <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    44b4:	2201      	movs	r2, #1
    44b6:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    44ba:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    44be:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    44c2:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    44c6:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    44c8:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    44cc:	9b05      	ldr	r3, [sp, #20]
    44ce:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    44d2:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    44d6:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44da:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    44de:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44e2:	ea4f 2313 	mov.w	r3, r3, lsr #8
    44e6:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    44ea:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44ee:	ea4f 4313 	mov.w	r3, r3, lsr #16
    44f2:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    44f6:	f8d8 3008 	ldr.w	r3, [r8, #8]
    44fa:	ea4f 6313 	mov.w	r3, r3, lsr #24
    44fe:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4502:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4506:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    450a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    450e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4512:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4516:	f8d8 300c 	ldr.w	r3, [r8, #12]
    451a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    451e:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4522:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4526:	ea4f 6313 	mov.w	r3, r3, lsr #24
    452a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    452e:	bf14      	ite	ne
    4530:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    4534:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4538:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    453a:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    453e:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4542:	f04f 0301 	mov.w	r3, #1
    4546:	d834      	bhi.n	45b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    4548:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    454c:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    454e:	4621      	mov	r1, r4
    4550:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4552:	4313      	orrs	r3, r2
    4554:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4558:	9a08      	ldr	r2, [sp, #32]
    455a:	f7ff f851 	bl	3600 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    455e:	2800      	cmp	r0, #0
    4560:	d135      	bne.n	45ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    4562:	a908      	add	r1, sp, #32
    4564:	9804      	ldr	r0, [sp, #16]
    4566:	f7ff fdcf 	bl	4108 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    456a:	a808      	add	r0, sp, #32
    456c:	f3af 8000 	nop.w
      ext_output2(msg);
    4570:	a808      	add	r0, sp, #32
    4572:	f3af 8000 	nop.w
      ext_output3(msg);
    4576:	a808      	add	r0, sp, #32
    4578:	f3af 8000 	nop.w
    457c:	e74f      	b.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    457e:	4e19      	ldr	r6, [pc, #100]	; (45e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4580:	4d19      	ldr	r5, [pc, #100]	; (45e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    4582:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4584:	682a      	ldr	r2, [r5, #0]
    4586:	4b19      	ldr	r3, [pc, #100]	; (45ec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    4588:	4062      	eors	r2, r4
    458a:	4013      	ands	r3, r2
    458c:	b143      	cbz	r3, 45a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    458e:	9b04      	ldr	r3, [sp, #16]
    4590:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    4594:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    4598:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    459a:	2b0f      	cmp	r3, #15
    459c:	f240 81a9 	bls.w	48f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    45a0:	4a10      	ldr	r2, [pc, #64]	; (45e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    45a2:	6a13      	ldr	r3, [r2, #32]
    45a4:	4323      	orrs	r3, r4
    45a6:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    45a8:	f3bf 8f4f 	dsb	sy
}
    45ac:	b01b      	add	sp, #108	; 0x6c
    45ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    45b2:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    45b6:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    45ba:	4621      	mov	r1, r4
    45bc:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    45be:	4313      	orrs	r3, r2
    45c0:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    45c4:	9a08      	ldr	r2, [sp, #32]
    45c6:	f7ff f81b 	bl	3600 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    45ca:	2800      	cmp	r0, #0
    45cc:	d0c9      	beq.n	4562 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    45ce:	a908      	add	r1, sp, #32
    45d0:	9804      	ldr	r0, [sp, #16]
    45d2:	f7ff fd39 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    45d6:	e7c4      	b.n	4562 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    45d8:	fab3 f383 	clz	r3, r3
    45dc:	3320      	adds	r3, #32
    45de:	e6f8      	b.n	43d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    45e0:	200002c0 	.word	0x200002c0
    45e4:	401d0000 	.word	0x401d0000
    45e8:	200068a4 	.word	0x200068a4
    45ec:	0007ffbf 	.word	0x0007ffbf
    45f0:	0401d008 	.word	0x0401d008
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    45f4:	0689      	lsls	r1, r1, #26
    45f6:	f57f aee3 	bpl.w	43c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    45fa:	0682      	lsls	r2, r0, #26
    45fc:	f57f aee0 	bpl.w	43c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    4600:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4604:	4cc3      	ldr	r4, [pc, #780]	; (4914 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    4606:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    460a:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    460e:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    4612:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    4614:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    4618:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    461c:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4620:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    4624:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    4628:	bf18      	it	ne
    462a:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    462c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    4630:	bf08      	it	eq
    4632:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    4634:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    4638:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    463c:	bf08      	it	eq
    463e:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4640:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    4644:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4646:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4648:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    464c:	40d1      	lsrs	r1, r2
    464e:	3208      	adds	r2, #8
    4650:	2a20      	cmp	r2, #32
    4652:	f800 1d01 	strb.w	r1, [r0, #-1]!
    4656:	d1f7      	bne.n	4648 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    4658:	a80d      	add	r0, sp, #52	; 0x34
    465a:	49ae      	ldr	r1, [pc, #696]	; (4914 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    465c:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    4660:	40da      	lsrs	r2, r3
    4662:	3308      	adds	r3, #8
    4664:	2b20      	cmp	r3, #32
    4666:	f800 2d01 	strb.w	r2, [r0, #-1]!
    466a:	d1f7      	bne.n	465c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    466c:	9b04      	ldr	r3, [sp, #16]
    466e:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    4672:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    4676:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    467a:	2363      	movs	r3, #99	; 0x63
    467c:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    4680:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4682:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4684:	f043 0320 	orr.w	r3, r3, #32
    4688:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    468a:	9b03      	ldr	r3, [sp, #12]
    468c:	065d      	lsls	r5, r3, #25
    468e:	d503      	bpl.n	4698 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4690:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4692:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4696:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    4698:	9b03      	ldr	r3, [sp, #12]
    469a:	061c      	lsls	r4, r3, #24
    469c:	d504      	bpl.n	46a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    469e:	4a9d      	ldr	r2, [pc, #628]	; (4914 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    46a0:	6b13      	ldr	r3, [r2, #48]	; 0x30
    46a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    46a6:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    46a8:	9c04      	ldr	r4, [sp, #16]
    46aa:	a908      	add	r1, sp, #32
    46ac:	4620      	mov	r0, r4
    46ae:	f7ff fd2b 	bl	4108 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    46b2:	a808      	add	r0, sp, #32
    46b4:	f3af 8000 	nop.w
      ext_output2(msg);
    46b8:	a808      	add	r0, sp, #32
    46ba:	f3af 8000 	nop.w
      ext_output3(msg);
    46be:	a808      	add	r0, sp, #32
    46c0:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    46c4:	9908      	ldr	r1, [sp, #32]
    46c6:	4620      	mov	r0, r4
    46c8:	f7fe ff22 	bl	3510 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    46cc:	2800      	cmp	r0, #0
    46ce:	f43f ae77 	beq.w	43c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    46d2:	a908      	add	r1, sp, #32
    46d4:	9804      	ldr	r0, [sp, #16]
    46d6:	f7ff fcb7 	bl	4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    46da:	e671      	b.n	43c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    46dc:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    46e0:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    46e2:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    46e6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    46ea:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    46ee:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    46f2:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    46f6:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    46fa:	bf18      	it	ne
    46fc:	2101      	movne	r1, #1
      msg.bus = busNumber;
    46fe:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4700:	bf04      	itt	eq
    4702:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4704:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4706:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    470a:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    470c:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4710:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4714:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4716:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    471a:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    471e:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4722:	0a1b      	lsrs	r3, r3, #8
    4724:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4728:	f8d8 3008 	ldr.w	r3, [r8, #8]
    472c:	0c1b      	lsrs	r3, r3, #16
    472e:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4732:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4736:	0e1b      	lsrs	r3, r3, #24
    4738:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    473c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4740:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4744:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4748:	0a1b      	lsrs	r3, r3, #8
    474a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    474e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4752:	0c1b      	lsrs	r3, r3, #16
    4754:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4758:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    475c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4760:	f8d8 200c 	ldr.w	r2, [r8, #12]
    4764:	0e12      	lsrs	r2, r2, #24
    4766:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    476a:	b10b      	cbz	r3, 4770 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    476c:	a808      	add	r0, sp, #32
    476e:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4770:	9b05      	ldr	r3, [sp, #20]
    4772:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    4776:	b10b      	cbz	r3, 477c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    4778:	a808      	add	r0, sp, #32
    477a:	4798      	blx	r3
    477c:	9904      	ldr	r1, [sp, #16]
    477e:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4782:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4786:	9207      	str	r2, [sp, #28]
    4788:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    478a:	2b00      	cmp	r3, #0
    478c:	f000 80c4 	beq.w	4918 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    4790:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4794:	221a      	movs	r2, #26
    4796:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    479a:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    479e:	46e0      	mov	r8, ip
    47a0:	fb02 1303 	mla	r3, r2, r3, r1
    47a4:	f641 3232 	movw	r2, #6962	; 0x1b32
    47a8:	a90e      	add	r1, sp, #56	; 0x38
    47aa:	eb03 0a02 	add.w	sl, r3, r2
    47ae:	9106      	str	r1, [sp, #24]
    47b0:	468e      	mov	lr, r1
    47b2:	5898      	ldr	r0, [r3, r2]
    47b4:	f8da 1004 	ldr.w	r1, [sl, #4]
    47b8:	f8da 2008 	ldr.w	r2, [sl, #8]
    47bc:	f8da 300c 	ldr.w	r3, [sl, #12]
    47c0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    47c4:	f8da 0010 	ldr.w	r0, [sl, #16]
    47c8:	f8da 1014 	ldr.w	r1, [sl, #20]
    47cc:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    47d0:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    47d4:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    47d8:	e898 0003 	ldmia.w	r8, {r0, r1}
    47dc:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    47e0:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    47e4:	1c5a      	adds	r2, r3, #1
    47e6:	f000 80a6 	beq.w	4936 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    47ea:	429c      	cmp	r4, r3
    47ec:	f47f ae17 	bne.w	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    47f0:	9a06      	ldr	r2, [sp, #24]
    47f2:	b2e1      	uxtb	r1, r4
    47f4:	9804      	ldr	r0, [sp, #16]
    47f6:	f7fd ffdd 	bl	27b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    47fa:	9a07      	ldr	r2, [sp, #28]
    47fc:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4800:	3301      	adds	r3, #1
    4802:	f003 031f 	and.w	r3, r3, #31
    4806:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    480a:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    480e:	b29b      	uxth	r3, r3
    4810:	2b00      	cmp	r3, #0
    4812:	f43f ae04 	beq.w	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    4816:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    481a:	3b01      	subs	r3, #1
    481c:	b29b      	uxth	r3, r3
    481e:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4822:	e5fc      	b.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4824:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4828:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    482a:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    482e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4832:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4836:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    483a:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    483e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4842:	bf18      	it	ne
    4844:	2101      	movne	r1, #1
      msg.bus = busNumber;
    4846:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4848:	bf04      	itt	eq
    484a:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    484c:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    484e:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4852:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4854:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4858:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    485c:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    485e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4862:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4866:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    486a:	0a1b      	lsrs	r3, r3, #8
    486c:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4870:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4874:	0c1b      	lsrs	r3, r3, #16
    4876:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    487a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    487e:	0e1b      	lsrs	r3, r3, #24
    4880:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4884:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4888:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    488c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4890:	0a1b      	lsrs	r3, r3, #8
    4892:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4896:	f8d8 300c 	ldr.w	r3, [r8, #12]
    489a:	0c1b      	lsrs	r3, r3, #16
    489c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    48a0:	f8d8 300c 	ldr.w	r3, [r8, #12]
    48a4:	0e1b      	lsrs	r3, r3, #24
    48a6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    48aa:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    48ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    48b2:	b10b      	cbz	r3, 48b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    48b4:	a808      	add	r0, sp, #32
    48b6:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    48b8:	9b05      	ldr	r3, [sp, #20]
    48ba:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    48be:	b10b      	cbz	r3, 48c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    48c0:	a808      	add	r0, sp, #32
    48c2:	4798      	blx	r3
        uint16_t size() { return _available; }
    48c4:	9904      	ldr	r1, [sp, #16]
    48c6:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    48ca:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    48ce:	9207      	str	r2, [sp, #28]
    48d0:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    48d2:	2b00      	cmp	r3, #0
    48d4:	f47f af5c 	bne.w	4790 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    48d8:	2c1f      	cmp	r4, #31
    48da:	f04f 0301 	mov.w	r3, #1
    48de:	d835      	bhi.n	494c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    48e0:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    48e4:	40a3      	lsls	r3, r4
    48e6:	4313      	orrs	r3, r2
    48e8:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    48ec:	e597      	b.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    48ee:	682b      	ldr	r3, [r5, #0]
    48f0:	e586      	b.n	4400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    48f2:	9f04      	ldr	r7, [sp, #16]
    48f4:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    48f8:	4621      	mov	r1, r4
    48fa:	4438      	add	r0, r7
    48fc:	f7fe fdc0 	bl	3480 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    4900:	69f1      	ldr	r1, [r6, #28]
    4902:	f641 5098 	movw	r0, #7576	; 0x1d98
    4906:	b289      	uxth	r1, r1
    4908:	4438      	add	r0, r7
    490a:	f7fe fddd 	bl	34c8 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    490e:	602c      	str	r4, [r5, #0]
    4910:	e646      	b.n	45a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    4912:	bf00      	nop
    4914:	401d0000 	.word	0x401d0000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4918:	2c1f      	cmp	r4, #31
    491a:	f04f 0301 	mov.w	r3, #1
    491e:	d80d      	bhi.n	493c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    4920:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4924:	40a3      	lsls	r3, r4
    4926:	4313      	orrs	r3, r2
    4928:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    492c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    4930:	f8c8 3000 	str.w	r3, [r8]
    4934:	e573      	b.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    4936:	9a06      	ldr	r2, [sp, #24]
    4938:	4621      	mov	r1, r4
    493a:	e75b      	b.n	47f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    493c:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4940:	fa03 f30a 	lsl.w	r3, r3, sl
    4944:	4313      	orrs	r3, r2
    4946:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    494a:	e7ef      	b.n	492c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    494c:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4950:	fa03 f30a 	lsl.w	r3, r3, sl
    4954:	4313      	orrs	r3, r2
    4956:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    495a:	e560      	b.n	441e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

0000495c <_GLOBAL__sub_I_HaldexCAN>:
}
    495c:	b538      	push	{r3, r4, r5, lr}
    495e:	f001 f83d 	bl	59dc <eeprom_initialize>
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4962:	4829      	ldr	r0, [pc, #164]	; (4a08 <_GLOBAL__sub_I_HaldexCAN+0xac>)
    4964:	4929      	ldr	r1, [pc, #164]	; (4a0c <_GLOBAL__sub_I_HaldexCAN+0xb0>)
class Circular_Buffer {
    4966:	2300      	movs	r3, #0
    4968:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
  if ( _bus == CAN1 ) _CAN1 = this;
    496c:	4c28      	ldr	r4, [pc, #160]	; (4a10 <_GLOBAL__sub_I_HaldexCAN+0xb4>)
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    496e:	6001      	str	r1, [r0, #0]
    4970:	f500 5c00 	add.w	ip, r0, #8192	; 0x2000
    4974:	4927      	ldr	r1, [pc, #156]	; (4a14 <_GLOBAL__sub_I_HaldexCAN+0xb8>)
    4976:	8283      	strh	r3, [r0, #20]
  if ( _bus == CAN1 ) _CAN1 = this;
    4978:	6020      	str	r0, [r4, #0]
    497a:	82c3      	strh	r3, [r0, #22]
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    497c:	4d26      	ldr	r5, [pc, #152]	; (4a18 <_GLOBAL__sub_I_HaldexCAN+0xbc>)
    497e:	8303      	strh	r3, [r0, #24]
    4980:	f501 5000 	add.w	r0, r1, #8192	; 0x2000
    4984:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
  if ( _bus == CAN2 ) _CAN2 = this;
    4988:	4c24      	ldr	r4, [pc, #144]	; (4a1c <_GLOBAL__sub_I_HaldexCAN+0xc0>)
    498a:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    498e:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4992:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    4996:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    499a:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    499e:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    49a2:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    49a6:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    49aa:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    49ae:	f88c 3700 	strb.w	r3, [ip, #1792]	; 0x700
    49b2:	f8cc 390c 	str.w	r3, [ip, #2316]	; 0x90c
    49b6:	f88c 3701 	strb.w	r3, [ip, #1793]	; 0x701
    49ba:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
    49be:	828b      	strh	r3, [r1, #20]
    49c0:	f88c 3914 	strb.w	r3, [ip, #2324]	; 0x914
    49c4:	82cb      	strh	r3, [r1, #22]
    49c6:	600d      	str	r5, [r1, #0]
    49c8:	830b      	strh	r3, [r1, #24]
    49ca:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    49ce:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    49d2:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    49d6:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    49da:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    49de:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    49e2:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    49e6:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    49ea:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    49ee:	f880 3700 	strb.w	r3, [r0, #1792]	; 0x700
    49f2:	f880 3701 	strb.w	r3, [r0, #1793]	; 0x701
    49f6:	f8c0 390c 	str.w	r3, [r0, #2316]	; 0x90c
    49fa:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
    49fe:	f880 3914 	strb.w	r3, [r0, #2324]	; 0x914
  if ( _bus == CAN2 ) _CAN2 = this;
    4a02:	6021      	str	r1, [r4, #0]
    4a04:	bd38      	pop	{r3, r4, r5, pc}
    4a06:	bf00      	nop
    4a08:	20003da0 	.word	0x20003da0
    4a0c:	20000630 	.word	0x20000630
    4a10:	20006870 	.word	0x20006870
    4a14:	20001488 	.word	0x20001488
    4a18:	20000654 	.word	0x20000654
    4a1c:	20006874 	.word	0x20006874

00004a20 <readEEP()>:
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4a20:	2000      	movs	r0, #0
#include "openhaldex.h"

void readEEP() {
    4a22:	b510      	push	{r4, lr}
    4a24:	f000 fffe 	bl	5a24 <eeprom_read_byte>
#if stateDebug
  Serial.println(F("EEPROM initialising!"));
#endif /* stateDebug */

  if (EEPROM.read(0) == 255) {
    4a28:	28ff      	cmp	r0, #255	; 0xff
    4a2a:	d014      	beq.n	4a56 <readEEP()+0x36>
    EERef( const int index )
    4a2c:	4603      	mov	r3, r0
    EEPROM.write(1, 0);                    // EEP Address 1: isCustom
    EEPROM.write(2, 0);                    // EEP Address 2: lastMode
    EEPROM.write(3, 0);                    // EEP Address 2: isStandalone
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
  } else {
    softwareVersion = EEPROM.read(0);
    4a2e:	4a2c      	ldr	r2, [pc, #176]	; (4ae0 <readEEP()+0xc0>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4a30:	2001      	movs	r0, #1
    4a32:	6013      	str	r3, [r2, #0]
    4a34:	f000 fff6 	bl	5a24 <eeprom_read_byte>
    4a38:	4603      	mov	r3, r0
    isCustom = EEPROM.read(1);
    4a3a:	4a2a      	ldr	r2, [pc, #168]	; (4ae4 <readEEP()+0xc4>)
    4a3c:	2002      	movs	r0, #2
    4a3e:	3b00      	subs	r3, #0
    4a40:	bf18      	it	ne
    4a42:	2301      	movne	r3, #1
    4a44:	7013      	strb	r3, [r2, #0]
    4a46:	f000 ffed 	bl	5a24 <eeprom_read_byte>

    switch (EEPROM.read(2)) {
    4a4a:	2803      	cmp	r0, #3
    4a4c:	d846      	bhi.n	4adc <readEEP()+0xbc>
    4a4e:	e8df f000 	tbb	[pc, r0]
    4a52:	3a34      	.short	0x3a34
    4a54:	1d42      	.short	0x1d42
    btInit();
    4a56:	f7fb fd7b 	bl	550 <btInit()>
    EEPROM.write(0, softwareVersion);      // EEP Address 0: SW Version
    4a5a:	4b21      	ldr	r3, [pc, #132]	; (4ae0 <readEEP()+0xc0>)
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4a5c:	2000      	movs	r0, #0
    4a5e:	7819      	ldrb	r1, [r3, #0]
    4a60:	f001 f8ec 	bl	5c3c <eeprom_write_byte>
    4a64:	2100      	movs	r1, #0
    4a66:	2001      	movs	r0, #1
    4a68:	f001 f8e8 	bl	5c3c <eeprom_write_byte>
    4a6c:	2100      	movs	r1, #0
    4a6e:	2002      	movs	r0, #2
    4a70:	f001 f8e4 	bl	5c3c <eeprom_write_byte>
    4a74:	2100      	movs	r1, #0
    4a76:	2003      	movs	r0, #3
    4a78:	f001 f8e0 	bl	5c3c <eeprom_write_byte>
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
    4a7c:	4b1a      	ldr	r3, [pc, #104]	; (4ae8 <readEEP()+0xc8>)
    4a7e:	2004      	movs	r0, #4
    4a80:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
    state.ped_threshold = EEPROM.read(4);
  }
#if stateDebug
  Serial.println(F("EEPROM initialised!"));
#endif /* stateDebug */
}
    4a84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4a88:	f001 b8d8 	b.w	5c3c <eeprom_write_byte>
        state.mode_override = true;
    4a8c:	4c16      	ldr	r4, [pc, #88]	; (4ae8 <readEEP()+0xc8>)
        state.mode = MODE_CUSTOM;
    4a8e:	2303      	movs	r3, #3
        state.mode_override = true;
    4a90:	2101      	movs	r1, #1
        lastMode = 3;
    4a92:	4a16      	ldr	r2, [pc, #88]	; (4aec <readEEP()+0xcc>)
        state.mode = MODE_CUSTOM;
    4a94:	7023      	strb	r3, [r4, #0]
        state.mode_override = true;
    4a96:	f884 1023 	strb.w	r1, [r4, #35]	; 0x23
        lastMode = 3;
    4a9a:	6013      	str	r3, [r2, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4a9c:	2003      	movs	r0, #3
    4a9e:	f000 ffc1 	bl	5a24 <eeprom_read_byte>
    4aa2:	4603      	mov	r3, r0
    isStandalone = EEPROM.read(3);
    4aa4:	4a12      	ldr	r2, [pc, #72]	; (4af0 <readEEP()+0xd0>)
    4aa6:	2004      	movs	r0, #4
    4aa8:	3b00      	subs	r3, #0
    4aaa:	bf18      	it	ne
    4aac:	2301      	movne	r3, #1
    4aae:	7013      	strb	r3, [r2, #0]
    4ab0:	f000 ffb8 	bl	5a24 <eeprom_read_byte>
    state.ped_threshold = EEPROM.read(4);
    4ab4:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
}
    4ab8:	bd10      	pop	{r4, pc}
        state.mode = MODE_STOCK;
    4aba:	2300      	movs	r3, #0
    4abc:	4c0a      	ldr	r4, [pc, #40]	; (4ae8 <readEEP()+0xc8>)
        lastMode = 0;
    4abe:	4a0b      	ldr	r2, [pc, #44]	; (4aec <readEEP()+0xcc>)
        state.mode = MODE_STOCK;
    4ac0:	7023      	strb	r3, [r4, #0]
        lastMode = 0;
    4ac2:	6013      	str	r3, [r2, #0]
        break;
    4ac4:	e7ea      	b.n	4a9c <readEEP()+0x7c>
        state.mode_override = true;
    4ac6:	2301      	movs	r3, #1
    4ac8:	4c07      	ldr	r4, [pc, #28]	; (4ae8 <readEEP()+0xc8>)
        lastMode = 1;
    4aca:	4a08      	ldr	r2, [pc, #32]	; (4aec <readEEP()+0xcc>)
        state.mode_override = true;
    4acc:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
        state.mode = MODE_FWD;
    4ad0:	7023      	strb	r3, [r4, #0]
        lastMode = 1;
    4ad2:	6013      	str	r3, [r2, #0]
        break;
    4ad4:	e7e2      	b.n	4a9c <readEEP()+0x7c>
        state.mode_override = true;
    4ad6:	4c04      	ldr	r4, [pc, #16]	; (4ae8 <readEEP()+0xc8>)
        state.mode = MODE_5050;
    4ad8:	2302      	movs	r3, #2
    4ada:	e7d9      	b.n	4a90 <readEEP()+0x70>
    4adc:	4c02      	ldr	r4, [pc, #8]	; (4ae8 <readEEP()+0xc8>)
    4ade:	e7dd      	b.n	4a9c <readEEP()+0x7c>
    4ae0:	20000d2c 	.word	0x20000d2c
    4ae4:	20006ae1 	.word	0x20006ae1
    4ae8:	20006950 	.word	0x20006950
    4aec:	200068c0 	.word	0x200068c0
    4af0:	20006ae3 	.word	0x20006ae3

00004af4 <writeEEP(void*)>:

bool writeEEP(void *params) {
    4af4:	b570      	push	{r4, r5, r6, lr}
  // only update if the value has changed
  switch (state.mode) {
    4af6:	4c26      	ldr	r4, [pc, #152]	; (4b90 <writeEEP(void*)+0x9c>)
    4af8:	4d26      	ldr	r5, [pc, #152]	; (4b94 <writeEEP(void*)+0xa0>)
    4afa:	7823      	ldrb	r3, [r4, #0]
    4afc:	2b03      	cmp	r3, #3
    4afe:	d805      	bhi.n	4b0c <writeEEP(void*)+0x18>
    4b00:	e8df f003 	tbb	[pc, r3]
    4b04:	023c3f42 	.word	0x023c3f42
      break;
    case MODE_5050:
      lastMode = 2;
      break;
    case MODE_CUSTOM:
      lastMode = 3;
    4b08:	2303      	movs	r3, #3
    4b0a:	602b      	str	r3, [r5, #0]
      break;
  }

  // update EEP only if changes have been made
  EEPROM.update(0, softwareVersion);
    4b0c:	4b22      	ldr	r3, [pc, #136]	; (4b98 <writeEEP(void*)+0xa4>)
    4b0e:	2000      	movs	r0, #0
    4b10:	781e      	ldrb	r6, [r3, #0]
    4b12:	f000 ff87 	bl	5a24 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b16:	4286      	cmp	r6, r0
    4b18:	d003      	beq.n	4b22 <writeEEP(void*)+0x2e>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b1a:	4631      	mov	r1, r6
    4b1c:	2000      	movs	r0, #0
    4b1e:	f001 f88d 	bl	5c3c <eeprom_write_byte>
  EEPROM.update(1, isCustom);
    4b22:	4b1e      	ldr	r3, [pc, #120]	; (4b9c <writeEEP(void*)+0xa8>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b24:	2001      	movs	r0, #1
    4b26:	781e      	ldrb	r6, [r3, #0]
    4b28:	f000 ff7c 	bl	5a24 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b2c:	4286      	cmp	r6, r0
    4b2e:	d003      	beq.n	4b38 <writeEEP(void*)+0x44>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b30:	4631      	mov	r1, r6
    4b32:	2001      	movs	r0, #1
    4b34:	f001 f882 	bl	5c3c <eeprom_write_byte>
  EEPROM.update(2, lastMode);
    4b38:	782d      	ldrb	r5, [r5, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b3a:	2002      	movs	r0, #2
    4b3c:	f000 ff72 	bl	5a24 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b40:	4285      	cmp	r5, r0
    4b42:	d003      	beq.n	4b4c <writeEEP(void*)+0x58>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b44:	4629      	mov	r1, r5
    4b46:	2002      	movs	r0, #2
    4b48:	f001 f878 	bl	5c3c <eeprom_write_byte>
  EEPROM.update(3, isStandalone);
    4b4c:	4b14      	ldr	r3, [pc, #80]	; (4ba0 <writeEEP(void*)+0xac>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b4e:	2003      	movs	r0, #3
    4b50:	781d      	ldrb	r5, [r3, #0]
    4b52:	f000 ff67 	bl	5a24 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b56:	4285      	cmp	r5, r0
    4b58:	d003      	beq.n	4b62 <writeEEP(void*)+0x6e>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b5a:	4629      	mov	r1, r5
    4b5c:	2003      	movs	r0, #3
    4b5e:	f001 f86d 	bl	5c3c <eeprom_write_byte>
  EEPROM.update(4, state.ped_threshold);
    4b62:	f894 4022 	ldrb.w	r4, [r4, #34]	; 0x22
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4b66:	2004      	movs	r0, #4
    4b68:	f000 ff5c 	bl	5a24 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4b6c:	4284      	cmp	r4, r0
    4b6e:	d003      	beq.n	4b78 <writeEEP(void*)+0x84>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4b70:	4621      	mov	r1, r4
    4b72:	2004      	movs	r0, #4
    4b74:	f001 f862 	bl	5c3c <eeprom_write_byte>
  Serial.printf("Is Standalone: %d\n", isStandalone);
  Serial.printf("Minimum Pedal: %d%\n", state.ped_threshold);
#endif /* stateDebug */

  return true;
}
    4b78:	2001      	movs	r0, #1
    4b7a:	bd70      	pop	{r4, r5, r6, pc}
      lastMode = 2;
    4b7c:	2302      	movs	r3, #2
    4b7e:	602b      	str	r3, [r5, #0]
      break;
    4b80:	e7c4      	b.n	4b0c <writeEEP(void*)+0x18>
      lastMode = 1;
    4b82:	2301      	movs	r3, #1
    4b84:	602b      	str	r3, [r5, #0]
      break;
    4b86:	e7c1      	b.n	4b0c <writeEEP(void*)+0x18>
      lastMode = 0;
    4b88:	2300      	movs	r3, #0
    4b8a:	602b      	str	r3, [r5, #0]
      break;
    4b8c:	e7be      	b.n	4b0c <writeEEP(void*)+0x18>
    4b8e:	bf00      	nop
    4b90:	20006950 	.word	0x20006950
    4b94:	200068c0 	.word	0x200068c0
    4b98:	20000d2c 	.word	0x20000d2c
    4b9c:	20006ae1 	.word	0x20006ae1
    4ba0:	20006ae3 	.word	0x20006ae3

00004ba4 <_GLOBAL__sub_I__Z7readEEPv>:
    EEPROMClass()                        { eeprom_initialize(); }
    4ba4:	f000 bf1a 	b.w	59dc <eeprom_initialize>

00004ba8 <EventResponder::triggerEvent(int, void*)>:
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    4ba8:	f890 c01c 	ldrb.w	ip, [r0, #28]
		_status = status;
    4bac:	6041      	str	r1, [r0, #4]
		if (_type == EventTypeImmediate) {
    4bae:	f1bc 0f02 	cmp.w	ip, #2
		_data = data;
    4bb2:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    4bb4:	d101      	bne.n	4bba <EventResponder::triggerEvent(int, void*)+0x12>
			(*_function)(*this);
    4bb6:	6883      	ldr	r3, [r0, #8]
    4bb8:	4718      	bx	r3
		} else {
			triggerEventNotImmediate();
    4bba:	f000 b917 	b.w	4dec <EventResponder::triggerEventNotImmediate()>
    4bbe:	bf00      	nop

00004bc0 <_spi_dma_rxISR1()>:

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    4bc0:	4b32      	ldr	r3, [pc, #200]	; (4c8c <_spi_dma_rxISR1()+0xcc>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    4bc2:	4933      	ldr	r1, [pc, #204]	; (4c90 <_spi_dma_rxISR1()+0xd0>)
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4bc4:	b530      	push	{r4, r5, lr}
	_dmaTX->clearComplete();
    4bc6:	e9d3 5411 	ldrd	r5, r4, [r3, #68]	; 0x44
    4bca:	7920      	ldrb	r0, [r4, #4]
    4bcc:	77c8      	strb	r0, [r1, #31]
	_dmaRX->clearComplete();

	if (_dma_count_remaining) {
    4bce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    4bd0:	f895 c004 	ldrb.w	ip, [r5, #4]
    4bd4:	f881 c01c 	strb.w	ip, [r1, #28]
    4bd8:	7708      	strb	r0, [r1, #28]
    4bda:	b152      	cbz	r2, 4bf2 <_spi_dma_rxISR1()+0x32>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > MAX_DMA_COUNT) {
    4bdc:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    4be0:	d323      	bcc.n	4c2a <_spi_dma_rxISR1()+0x6a>
			_dma_count_remaining -= MAX_DMA_COUNT;
    4be2:	492c      	ldr	r1, [pc, #176]	; (4c94 <_spi_dma_rxISR1()+0xd4>)
    4be4:	4411      	add	r1, r2
		DMA_SERQ = channel;
    4be6:	4a2a      	ldr	r2, [pc, #168]	; (4c90 <_spi_dma_rxISR1()+0xd0>)
    4be8:	6419      	str	r1, [r3, #64]	; 0x40
    4bea:	76d0      	strb	r0, [r2, #27]
    4bec:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4bf0:	bd30      	pop	{r4, r5, pc}
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    4bf2:	6819      	ldr	r1, [r3, #0]
		}
		_dmaRX->enable();
		_dmaTX->enable();
	} else {

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4bf4:	240f      	movs	r4, #15

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    4bf6:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4bf8:	658c      	str	r4, [r1, #88]	; 0x58
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4bfa:	f240 3401 	movw	r4, #769	; 0x301
 		port().DER = 0;		// DMA no longer doing TX (or RX)
    4bfe:	61ca      	str	r2, [r1, #28]
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4c00:	610c      	str	r4, [r1, #16]
		port().SR = 0x3f00;	// clear out all of the other status...
    4c02:	f44f 547c 	mov.w	r4, #16128	; 0x3f00
    4c06:	614c      	str	r4, [r1, #20]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4c08:	2103      	movs	r1, #3
		_dma_event_responder->triggerEvent();
    4c0a:	6804      	ldr	r4, [r0, #0]
    4c0c:	6824      	ldr	r4, [r4, #0]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4c0e:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
		_dma_event_responder->triggerEvent();
    4c12:	4b21      	ldr	r3, [pc, #132]	; (4c98 <_spi_dma_rxISR1()+0xd8>)
    4c14:	429c      	cmp	r4, r3
    4c16:	d126      	bne.n	4c66 <_spi_dma_rxISR1()+0xa6>
		if (_type == EventTypeImmediate) {
    4c18:	7f03      	ldrb	r3, [r0, #28]
		_status = status;
    4c1a:	6042      	str	r2, [r0, #4]
		if (_type == EventTypeImmediate) {
    4c1c:	2b02      	cmp	r3, #2
		_data = data;
    4c1e:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    4c20:	d126      	bne.n	4c70 <_spi_dma_rxISR1()+0xb0>
			(*_function)(*this);
    4c22:	6883      	ldr	r3, [r0, #8]
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c24:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    4c28:	4718      	bx	r3
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
    4c2a:	682d      	ldr	r5, [r5, #0]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4c2c:	8be9      	ldrh	r1, [r5, #30]
    4c2e:	0409      	lsls	r1, r1, #16
    4c30:	d422      	bmi.n	4c78 <_spi_dma_rxISR1()+0xb8>
		tcd->BITER = len & 0x7fff;
    4c32:	b292      	uxth	r2, r2
    4c34:	83ea      	strh	r2, [r5, #30]
	tcd->CITER = tcd->BITER; 
    4c36:	6821      	ldr	r1, [r4, #0]
    4c38:	8bec      	ldrh	r4, [r5, #30]
    4c3a:	b2a4      	uxth	r4, r4
    4c3c:	82ec      	strh	r4, [r5, #22]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4c3e:	8bcc      	ldrh	r4, [r1, #30]
    4c40:	0424      	lsls	r4, r4, #16
    4c42:	d505      	bpl.n	4c50 <_spi_dma_rxISR1()+0x90>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4c44:	8bcc      	ldrh	r4, [r1, #30]
    4c46:	f3c2 0208 	ubfx	r2, r2, #0, #9
    4c4a:	f404 447e 	and.w	r4, r4, #65024	; 0xfe00
    4c4e:	4322      	orrs	r2, r4
    4c50:	83ca      	strh	r2, [r1, #30]
	tcd->CITER = tcd->BITER; 
    4c52:	8bca      	ldrh	r2, [r1, #30]
    4c54:	b292      	uxth	r2, r2
    4c56:	82ca      	strh	r2, [r1, #22]
    4c58:	2100      	movs	r1, #0
    4c5a:	4a0d      	ldr	r2, [pc, #52]	; (4c90 <_spi_dma_rxISR1()+0xd0>)
			_dma_count_remaining -= MAX_DMA_COUNT;
    4c5c:	6419      	str	r1, [r3, #64]	; 0x40
    4c5e:	76d0      	strb	r0, [r2, #27]
    4c60:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c64:	bd30      	pop	{r4, r5, pc}
		_dma_event_responder->triggerEvent();
    4c66:	4623      	mov	r3, r4
    4c68:	4611      	mov	r1, r2
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c6a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		_dma_event_responder->triggerEvent();
    4c6e:	4718      	bx	r3
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    4c70:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			triggerEventNotImmediate();
    4c74:	f000 b8ba 	b.w	4dec <EventResponder::triggerEventNotImmediate()>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4c78:	8be9      	ldrh	r1, [r5, #30]
    4c7a:	f3c2 0e08 	ubfx	lr, r2, #0, #9
    4c7e:	b292      	uxth	r2, r2
    4c80:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
    4c84:	ea41 010e 	orr.w	r1, r1, lr
    4c88:	83e9      	strh	r1, [r5, #30]
    4c8a:	e7d4      	b.n	4c36 <_spi_dma_rxISR1()+0x76>
    4c8c:	20006708 	.word	0x20006708
    4c90:	400e8000 	.word	0x400e8000
    4c94:	ffff8001 	.word	0xffff8001
    4c98:	00004ba9 	.word	0x00004ba9

00004c9c <_spi_dma_rxISR0()>:
	_dmaRX->clearInterrupt();
    4c9c:	4b32      	ldr	r3, [pc, #200]	; (4d68 <_spi_dma_rxISR0()+0xcc>)
		DMA_CINT = channel;
    4c9e:	4933      	ldr	r1, [pc, #204]	; (4d6c <_spi_dma_rxISR0()+0xd0>)
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4ca0:	b530      	push	{r4, r5, lr}
	_dmaTX->clearComplete();
    4ca2:	e9d3 5411 	ldrd	r5, r4, [r3, #68]	; 0x44
    4ca6:	7920      	ldrb	r0, [r4, #4]
    4ca8:	77c8      	strb	r0, [r1, #31]
	if (_dma_count_remaining) {
    4caa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
		DMA_CDNE = channel;
    4cac:	f895 c004 	ldrb.w	ip, [r5, #4]
    4cb0:	f881 c01c 	strb.w	ip, [r1, #28]
    4cb4:	7708      	strb	r0, [r1, #28]
    4cb6:	b152      	cbz	r2, 4cce <_spi_dma_rxISR0()+0x32>
		if (_dma_count_remaining > MAX_DMA_COUNT) {
    4cb8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    4cbc:	d323      	bcc.n	4d06 <_spi_dma_rxISR0()+0x6a>
			_dma_count_remaining -= MAX_DMA_COUNT;
    4cbe:	492c      	ldr	r1, [pc, #176]	; (4d70 <_spi_dma_rxISR0()+0xd4>)
    4cc0:	4411      	add	r1, r2
		DMA_SERQ = channel;
    4cc2:	4a2a      	ldr	r2, [pc, #168]	; (4d6c <_spi_dma_rxISR0()+0xd0>)
    4cc4:	6419      	str	r1, [r3, #64]	; 0x40
    4cc6:	76d0      	strb	r0, [r2, #27]
    4cc8:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4ccc:	bd30      	pop	{r4, r5, pc}
    4cce:	6819      	ldr	r1, [r3, #0]
		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4cd0:	240f      	movs	r4, #15
		_dma_event_responder->triggerEvent();
    4cd2:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
    4cd4:	658c      	str	r4, [r1, #88]	; 0x58
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4cd6:	f240 3401 	movw	r4, #769	; 0x301
 		port().DER = 0;		// DMA no longer doing TX (or RX)
    4cda:	61ca      	str	r2, [r1, #28]
		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
    4cdc:	610c      	str	r4, [r1, #16]
		port().SR = 0x3f00;	// clear out all of the other status...
    4cde:	f44f 547c 	mov.w	r4, #16128	; 0x3f00
    4ce2:	614c      	str	r4, [r1, #20]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4ce4:	2103      	movs	r1, #3
		_dma_event_responder->triggerEvent();
    4ce6:	6804      	ldr	r4, [r0, #0]
    4ce8:	6824      	ldr	r4, [r4, #0]
		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    4cea:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
		_dma_event_responder->triggerEvent();
    4cee:	4b21      	ldr	r3, [pc, #132]	; (4d74 <_spi_dma_rxISR0()+0xd8>)
    4cf0:	429c      	cmp	r4, r3
    4cf2:	d126      	bne.n	4d42 <_spi_dma_rxISR0()+0xa6>
		if (_type == EventTypeImmediate) {
    4cf4:	7f03      	ldrb	r3, [r0, #28]
		_status = status;
    4cf6:	6042      	str	r2, [r0, #4]
		if (_type == EventTypeImmediate) {
    4cf8:	2b02      	cmp	r3, #2
		_data = data;
    4cfa:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    4cfc:	d126      	bne.n	4d4c <_spi_dma_rxISR0()+0xb0>
			(*_function)(*this);
    4cfe:	6883      	ldr	r3, [r0, #8]
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d00:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    4d04:	4718      	bx	r3
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
    4d06:	682d      	ldr	r5, [r5, #0]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4d08:	8be9      	ldrh	r1, [r5, #30]
    4d0a:	0409      	lsls	r1, r1, #16
    4d0c:	d422      	bmi.n	4d54 <_spi_dma_rxISR0()+0xb8>
		tcd->BITER = len & 0x7fff;
    4d0e:	b292      	uxth	r2, r2
    4d10:	83ea      	strh	r2, [r5, #30]
	tcd->CITER = tcd->BITER; 
    4d12:	6821      	ldr	r1, [r4, #0]
    4d14:	8bec      	ldrh	r4, [r5, #30]
    4d16:	b2a4      	uxth	r4, r4
    4d18:	82ec      	strh	r4, [r5, #22]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    4d1a:	8bcc      	ldrh	r4, [r1, #30]
    4d1c:	0424      	lsls	r4, r4, #16
    4d1e:	d505      	bpl.n	4d2c <_spi_dma_rxISR0()+0x90>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4d20:	8bcc      	ldrh	r4, [r1, #30]
    4d22:	f3c2 0208 	ubfx	r2, r2, #0, #9
    4d26:	f404 447e 	and.w	r4, r4, #65024	; 0xfe00
    4d2a:	4322      	orrs	r2, r4
    4d2c:	83ca      	strh	r2, [r1, #30]
	tcd->CITER = tcd->BITER; 
    4d2e:	8bca      	ldrh	r2, [r1, #30]
    4d30:	b292      	uxth	r2, r2
    4d32:	82ca      	strh	r2, [r1, #22]
    4d34:	2100      	movs	r1, #0
    4d36:	4a0d      	ldr	r2, [pc, #52]	; (4d6c <_spi_dma_rxISR0()+0xd0>)
			_dma_count_remaining -= MAX_DMA_COUNT;
    4d38:	6419      	str	r1, [r3, #64]	; 0x40
    4d3a:	76d0      	strb	r0, [r2, #27]
    4d3c:	f882 c01b 	strb.w	ip, [r2, #27]
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d40:	bd30      	pop	{r4, r5, pc}
		_dma_event_responder->triggerEvent();
    4d42:	4623      	mov	r3, r4
    4d44:	4611      	mov	r1, r2
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d46:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		_dma_event_responder->triggerEvent();
    4d4a:	4718      	bx	r3
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    4d4c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			triggerEventNotImmediate();
    4d50:	f000 b84c 	b.w	4dec <EventResponder::triggerEventNotImmediate()>
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    4d54:	8be9      	ldrh	r1, [r5, #30]
    4d56:	f3c2 0e08 	ubfx	lr, r2, #0, #9
    4d5a:	b292      	uxth	r2, r2
    4d5c:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
    4d60:	ea41 010e 	orr.w	r1, r1, lr
    4d64:	83e9      	strh	r1, [r5, #30]
    4d66:	e7d4      	b.n	4d12 <_spi_dma_rxISR0()+0x76>
    4d68:	200066b8 	.word	0x200066b8
    4d6c:	400e8000 	.word	0x400e8000
    4d70:	ffff8001 	.word	0xffff8001
    4d74:	00004ba9 	.word	0x00004ba9

00004d78 <SPIClass::SPIClass(unsigned int, unsigned int)>:
		: port_addr(myport), hardware_addr(myhardware) {
    4d78:	2300      	movs	r3, #0
    4d7a:	e9c0 1200 	strd	r1, r2, [r0]
    4d7e:	e9c0 3302 	strd	r3, r3, [r0, #8]
    4d82:	e9c0 3304 	strd	r3, r3, [r0, #16]
    4d86:	e9c0 3306 	strd	r3, r3, [r0, #24]
    4d8a:	e9c0 3308 	strd	r3, r3, [r0, #32]
    4d8e:	e9c0 330a 	strd	r3, r3, [r0, #40]	; 0x28
    4d92:	e9c0 330c 	strd	r3, r3, [r0, #48]	; 0x30
    4d96:	6383      	str	r3, [r0, #56]	; 0x38
    4d98:	8783      	strh	r3, [r0, #60]	; 0x3c
    4d9a:	e9c0 3310 	strd	r3, r3, [r0, #64]	; 0x40
    4d9e:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
	}
    4da2:	4770      	bx	lr

00004da4 <_GLOBAL__sub_I__ZN8SPIClass5beginEv>:

	}
}
    4da4:	b508      	push	{r3, lr}
SPIClass SPI((uintptr_t)&IMXRT_LPSPI4_S, (uintptr_t)&SPIClass::spiclass_lpspi4_hardware);
    4da6:	4a08      	ldr	r2, [pc, #32]	; (4dc8 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x24>)
    4da8:	4908      	ldr	r1, [pc, #32]	; (4dcc <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x28>)
    4daa:	4809      	ldr	r0, [pc, #36]	; (4dd0 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x2c>)
    4dac:	f7ff ffe4 	bl	4d78 <SPIClass::SPIClass(unsigned int, unsigned int)>
SPIClass SPI1((uintptr_t)&IMXRT_LPSPI3_S, (uintptr_t)&SPIClass::spiclass_lpspi3_hardware);
    4db0:	4a08      	ldr	r2, [pc, #32]	; (4dd4 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x30>)
    4db2:	4909      	ldr	r1, [pc, #36]	; (4dd8 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x34>)
    4db4:	4809      	ldr	r0, [pc, #36]	; (4ddc <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x38>)
    4db6:	f7ff ffdf 	bl	4d78 <SPIClass::SPIClass(unsigned int, unsigned int)>
SPIClass SPI2((uintptr_t)&IMXRT_LPSPI1_S, (uintptr_t)&SPIClass::spiclass_lpspi1_hardware);
    4dba:	4a09      	ldr	r2, [pc, #36]	; (4de0 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x3c>)
    4dbc:	4909      	ldr	r1, [pc, #36]	; (4de4 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x40>)
    4dbe:	480a      	ldr	r0, [pc, #40]	; (4de8 <_GLOBAL__sub_I__ZN8SPIClass5beginEv+0x44>)
    4dc0:	f7ff ffda 	bl	4d78 <SPIClass::SPIClass(unsigned int, unsigned int)>
}
    4dc4:	bd08      	pop	{r3, pc}
    4dc6:	bf00      	nop
    4dc8:	200005d8 	.word	0x200005d8
    4dcc:	403a0000 	.word	0x403a0000
    4dd0:	200066b8 	.word	0x200066b8
    4dd4:	20000588 	.word	0x20000588
    4dd8:	4039c000 	.word	0x4039c000
    4ddc:	20006708 	.word	0x20006708
    4de0:	20000538 	.word	0x20000538
    4de4:	40394000 	.word	0x40394000
    4de8:	20006758 	.word	0x20006758

00004dec <EventResponder::triggerEventNotImmediate()>:
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4dec:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4df0:	b672      	cpsid	i
	if (_triggered == false) {
    4df2:	7f43      	ldrb	r3, [r0, #29]
    4df4:	b95b      	cbnz	r3, 4e0e <EventResponder::triggerEventNotImmediate()+0x22>
		if (_type == EventTypeYield) {
    4df6:	7f01      	ldrb	r1, [r0, #28]
    4df8:	2901      	cmp	r1, #1
{
    4dfa:	b430      	push	{r4, r5}
		if (_type == EventTypeYield) {
    4dfc:	d00b      	beq.n	4e16 <EventResponder::triggerEventNotImmediate()+0x2a>
		} else if (_type == EventTypeInterrupt) {
    4dfe:	2903      	cmp	r1, #3
    4e00:	d013      	beq.n	4e2a <EventResponder::triggerEventNotImmediate()+0x3e>
		_triggered = true;
    4e02:	2301      	movs	r3, #1
    4e04:	7743      	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4e06:	b902      	cbnz	r2, 4e0a <EventResponder::triggerEventNotImmediate()+0x1e>
    4e08:	b662      	cpsie	i
}
    4e0a:	bc30      	pop	{r4, r5}
    4e0c:	4770      	bx	lr
    4e0e:	b90a      	cbnz	r2, 4e14 <EventResponder::triggerEventNotImmediate()+0x28>
    4e10:	b662      	cpsie	i
    4e12:	4770      	bx	lr
    4e14:	4770      	bx	lr
			if (firstYield == nullptr) {
    4e16:	4c12      	ldr	r4, [pc, #72]	; (4e60 <EventResponder::triggerEventNotImmediate()+0x74>)
    4e18:	6821      	ldr	r1, [r4, #0]
    4e1a:	b1b1      	cbz	r1, 4e4a <EventResponder::triggerEventNotImmediate()+0x5e>
				_prev = lastYield;
    4e1c:	4911      	ldr	r1, [pc, #68]	; (4e64 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
    4e1e:	6143      	str	r3, [r0, #20]
				_prev = lastYield;
    4e20:	680b      	ldr	r3, [r1, #0]
				lastYield = this;
    4e22:	6008      	str	r0, [r1, #0]
				_prev = lastYield;
    4e24:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
    4e26:	6158      	str	r0, [r3, #20]
				lastYield = this;
    4e28:	e7eb      	b.n	4e02 <EventResponder::triggerEventNotImmediate()+0x16>
			if (firstInterrupt == nullptr) {
    4e2a:	4d0f      	ldr	r5, [pc, #60]	; (4e68 <EventResponder::triggerEventNotImmediate()+0x7c>)
    4e2c:	490f      	ldr	r1, [pc, #60]	; (4e6c <EventResponder::triggerEventNotImmediate()+0x80>)
    4e2e:	682c      	ldr	r4, [r5, #0]
    4e30:	b18c      	cbz	r4, 4e56 <EventResponder::triggerEventNotImmediate()+0x6a>
				_next = nullptr;
    4e32:	6143      	str	r3, [r0, #20]
				_prev = lastInterrupt;
    4e34:	680b      	ldr	r3, [r1, #0]
    4e36:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
    4e38:	6158      	str	r0, [r3, #20]
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    4e3a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    4e3e:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
				lastInterrupt = this;
    4e42:	6008      	str	r0, [r1, #0]
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    4e44:	f8c3 4d04 	str.w	r4, [r3, #3332]	; 0xd04
    4e48:	e7db      	b.n	4e02 <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
    4e4a:	4b06      	ldr	r3, [pc, #24]	; (4e64 <EventResponder::triggerEventNotImmediate()+0x78>)
				firstYield = this;
    4e4c:	6020      	str	r0, [r4, #0]
				lastYield = this;
    4e4e:	6018      	str	r0, [r3, #0]
				_prev = nullptr;
    4e50:	e9c0 1105 	strd	r1, r1, [r0, #20]
				lastYield = this;
    4e54:	e7d5      	b.n	4e02 <EventResponder::triggerEventNotImmediate()+0x16>
				_prev = nullptr;
    4e56:	e9c0 4405 	strd	r4, r4, [r0, #20]
				firstInterrupt = this;
    4e5a:	6028      	str	r0, [r5, #0]
				lastInterrupt = this;
    4e5c:	e7ed      	b.n	4e3a <EventResponder::triggerEventNotImmediate()+0x4e>
    4e5e:	bf00      	nop
    4e60:	20006878 	.word	0x20006878
    4e64:	20006884 	.word	0x20006884
    4e68:	20006880 	.word	0x20006880
    4e6c:	2000687c 	.word	0x2000687c

00004e70 <EventResponder::runFromInterrupt()>:
{
    4e70:	b570      	push	{r4, r5, r6, lr}
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4e72:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4e76:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    4e78:	4c0c      	ldr	r4, [pc, #48]	; (4eac <EventResponder::runFromInterrupt()+0x3c>)
    4e7a:	6820      	ldr	r0, [r4, #0]
		if (first) {
    4e7c:	b180      	cbz	r0, 4ea0 <EventResponder::runFromInterrupt()+0x30>
				lastInterrupt = nullptr;
    4e7e:	4e0c      	ldr	r6, [pc, #48]	; (4eb0 <EventResponder::runFromInterrupt()+0x40>)
				firstInterrupt->_prev = nullptr;
    4e80:	2500      	movs	r5, #0
			firstInterrupt = first->_next;
    4e82:	6943      	ldr	r3, [r0, #20]
    4e84:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    4e86:	b173      	cbz	r3, 4ea6 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    4e88:	619d      	str	r5, [r3, #24]
		if (doit) __enable_irq();
    4e8a:	b902      	cbnz	r2, 4e8e <EventResponder::runFromInterrupt()+0x1e>
    4e8c:	b662      	cpsie	i
			(*(first->_function))(*first);
    4e8e:	6883      	ldr	r3, [r0, #8]
			first->_triggered = false;
    4e90:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    4e92:	4798      	blx	r3
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4e94:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4e98:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    4e9a:	6820      	ldr	r0, [r4, #0]
		if (first) {
    4e9c:	2800      	cmp	r0, #0
    4e9e:	d1f0      	bne.n	4e82 <EventResponder::runFromInterrupt()+0x12>
		if (doit) __enable_irq();
    4ea0:	b902      	cbnz	r2, 4ea4 <EventResponder::runFromInterrupt()+0x34>
    4ea2:	b662      	cpsie	i
}
    4ea4:	bd70      	pop	{r4, r5, r6, pc}
				lastInterrupt = nullptr;
    4ea6:	6033      	str	r3, [r6, #0]
    4ea8:	e7ef      	b.n	4e8a <EventResponder::runFromInterrupt()+0x1a>
    4eaa:	bf00      	nop
    4eac:	20006880 	.word	0x20006880
    4eb0:	2000687c 	.word	0x2000687c

00004eb4 <pendablesrvreq_isr>:
	EventResponder::runFromInterrupt();
    4eb4:	f7ff bfdc 	b.w	4e70 <EventResponder::runFromInterrupt()>

00004eb8 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    4eb8:	4904      	ldr	r1, [pc, #16]	; (4ecc <systick_isr+0x14>)
	systick_millis_count++;
    4eba:	4a05      	ldr	r2, [pc, #20]	; (4ed0 <systick_isr+0x18>)
	systick_cycle_count = ARM_DWT_CYCCNT;
    4ebc:	6849      	ldr	r1, [r1, #4]
    4ebe:	4b05      	ldr	r3, [pc, #20]	; (4ed4 <systick_isr+0x1c>)
    4ec0:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    4ec2:	6813      	ldr	r3, [r2, #0]
    4ec4:	3301      	adds	r3, #1
    4ec6:	6013      	str	r3, [r2, #0]
}
    4ec8:	4770      	bx	lr
    4eca:	bf00      	nop
    4ecc:	e0001000 	.word	0xe0001000
    4ed0:	20006978 	.word	0x20006978
    4ed4:	20006974 	.word	0x20006974

00004ed8 <HardwareSerial::availableForWrite()>:

int HardwareSerial::availableForWrite(void)
{
	uint32_t head, tail;

	head = tx_buffer_head_;
    4ed8:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
	tail = tx_buffer_tail_;
    4edc:	f8b0 2048 	ldrh.w	r2, [r0, #72]	; 0x48
	head = tx_buffer_head_;
    4ee0:	b29b      	uxth	r3, r3
	tail = tx_buffer_tail_;
    4ee2:	b292      	uxth	r2, r2
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    4ee4:	4293      	cmp	r3, r2
    4ee6:	d202      	bcs.n	4eee <HardwareSerial::availableForWrite()+0x16>
	return tail - head - 1;
    4ee8:	3a01      	subs	r2, #1
    4eea:	1ad0      	subs	r0, r2, r3
}
    4eec:	4770      	bx	lr
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    4eee:	6b41      	ldr	r1, [r0, #52]	; 0x34
    4ef0:	3901      	subs	r1, #1
    4ef2:	440a      	add	r2, r1
    4ef4:	1ad0      	subs	r0, r2, r3
    4ef6:	4770      	bx	lr

00004ef8 <HardwareSerial::available()>:
int HardwareSerial::available(void)
{
	uint32_t head, tail;

	// WATER> 0 so IDLE involved may want to check if port has already has RX data to retrieve
	__disable_irq();
    4ef8:	b672      	cpsid	i
	head = rx_buffer_head_;
    4efa:	f8b0 204a 	ldrh.w	r2, [r0, #74]	; 0x4a
	tail = rx_buffer_tail_;
    4efe:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    4f02:	b292      	uxth	r2, r2
	tail = rx_buffer_tail_;
    4f04:	b29b      	uxth	r3, r3
	int avail;
	if (head >= tail) avail = head - tail;
    4f06:	429a      	cmp	r2, r3
	else avail = rx_buffer_total_size_ + head - tail;	
    4f08:	bf3c      	itt	cc
    4f0a:	6b81      	ldrcc	r1, [r0, #56]	; 0x38
    4f0c:	1852      	addcc	r2, r2, r1
    4f0e:	1ad3      	subs	r3, r2, r3
	avail += (port->WATER >> 24) & 0x7;
    4f10:	6902      	ldr	r2, [r0, #16]
    4f12:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
	__enable_irq();
    4f14:	b662      	cpsie	i
	avail += (port->WATER >> 24) & 0x7;
    4f16:	f3c0 6002 	ubfx	r0, r0, #24, #3
	return avail;
}
    4f1a:	4418      	add	r0, r3
    4f1c:	4770      	bx	lr
    4f1e:	bf00      	nop

00004f20 <HardwareSerial::peek()>:

int HardwareSerial::peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head_;
    4f20:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    4f24:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    4f26:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    4f2a:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    4f2c:	b29b      	uxth	r3, r3
	if (head == tail) {
    4f2e:	4299      	cmp	r1, r3
    4f30:	d010      	beq.n	4f54 <HardwareSerial::peek()+0x34>
			return c;
		}
		__enable_irq();

	} 
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4f32:	3301      	adds	r3, #1
    4f34:	6b90      	ldr	r0, [r2, #56]	; 0x38
	if (tail < rx_buffer_size_) {
    4f36:	6b11      	ldr	r1, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4f38:	4298      	cmp	r0, r3
    4f3a:	bf98      	it	ls
    4f3c:	2300      	movls	r3, #0
	if (tail < rx_buffer_size_) {
    4f3e:	4299      	cmp	r1, r3
    4f40:	d903      	bls.n	4f4a <HardwareSerial::peek()+0x2a>
		return rx_buffer_[tail];
    4f42:	6a12      	ldr	r2, [r2, #32]
    4f44:	5cd0      	ldrb	r0, [r2, r3]
    4f46:	b2c0      	uxtb	r0, r0
    4f48:	4770      	bx	lr
	} else {
		return rx_buffer_storage_[tail-rx_buffer_size_];
    4f4a:	1a5b      	subs	r3, r3, r1
    4f4c:	6a52      	ldr	r2, [r2, #36]	; 0x24
    4f4e:	5cd0      	ldrb	r0, [r2, r3]
    4f50:	b2c0      	uxtb	r0, r0
	}
}
    4f52:	4770      	bx	lr
		__disable_irq();
    4f54:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    4f56:	f8b0 004a 	ldrh.w	r0, [r0, #74]	; 0x4a
    4f5a:	b280      	uxth	r0, r0
		if (head == tail) {
    4f5c:	4281      	cmp	r1, r0
    4f5e:	d001      	beq.n	4f64 <HardwareSerial::peek()+0x44>
		__enable_irq();
    4f60:	b662      	cpsie	i
    4f62:	e7e6      	b.n	4f32 <HardwareSerial::peek()+0x12>
			if (port->WATER & 0x7000000) {
    4f64:	6913      	ldr	r3, [r2, #16]
    4f66:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    4f68:	f011 6fe0 	tst.w	r1, #117440512	; 0x7000000
    4f6c:	d103      	bne.n	4f76 <HardwareSerial::peek()+0x56>
			int c = -1;	// assume nothing to return
    4f6e:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    4f72:	b662      	cpsie	i
			return c;
    4f74:	4770      	bx	lr
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    4f76:	69db      	ldr	r3, [r3, #28]
				rx_buffer_head_ = 1;
    4f78:	2001      	movs	r0, #1
				rx_buffer_tail_ = 0; 
    4f7a:	f04f 0c00 	mov.w	ip, #0
				rx_buffer_[1] = c;
    4f7e:	6a11      	ldr	r1, [r2, #32]
				rx_buffer_head_ = 1;
    4f80:	f8a2 004a 	strh.w	r0, [r2, #74]	; 0x4a
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    4f84:	f3c3 0009 	ubfx	r0, r3, #0, #10
				rx_buffer_[1] = c;
    4f88:	b2db      	uxtb	r3, r3
				rx_buffer_tail_ = 0; 
    4f8a:	f8a2 c04c 	strh.w	ip, [r2, #76]	; 0x4c
				rx_buffer_[1] = c;
    4f8e:	704b      	strb	r3, [r1, #1]
    4f90:	e7ef      	b.n	4f72 <HardwareSerial::peek()+0x52>
    4f92:	bf00      	nop

00004f94 <HardwareSerial::read()>:
int HardwareSerial::read(void)
{
	uint32_t head, tail;
	int c;

	head = rx_buffer_head_;
    4f94:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    4f98:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    4f9a:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    4f9e:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    4fa0:	b29b      	uxth	r3, r3
	if (head == tail) {
    4fa2:	4299      	cmp	r1, r3
    4fa4:	d026      	beq.n	4ff4 <HardwareSerial::read()+0x60>
			return c;
		}
		__enable_irq();

	}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4fa6:	3301      	adds	r3, #1
{
    4fa8:	b430      	push	{r4, r5}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4faa:	6b94      	ldr	r4, [r2, #56]	; 0x38
    4fac:	429c      	cmp	r4, r3
    4fae:	d916      	bls.n	4fde <HardwareSerial::read()+0x4a>
	if (tail < rx_buffer_size_) {
    4fb0:	6b10      	ldr	r0, [r2, #48]	; 0x30
		c = rx_buffer_[tail];
	} else {
		c = rx_buffer_storage_[tail-rx_buffer_size_];
	}
	rx_buffer_tail_ = tail;
    4fb2:	fa1f fc83 	uxth.w	ip, r3
	if (tail < rx_buffer_size_) {
    4fb6:	4298      	cmp	r0, r3
    4fb8:	d917      	bls.n	4fea <HardwareSerial::read()+0x56>
		c = rx_buffer_[tail];
    4fba:	6a10      	ldr	r0, [r2, #32]
    4fbc:	5cc0      	ldrb	r0, [r0, r3]
    4fbe:	b2c0      	uxtb	r0, r0
	if (rts_pin_baseReg_) {
    4fc0:	6d95      	ldr	r5, [r2, #88]	; 0x58
	rx_buffer_tail_ = tail;
    4fc2:	f8a2 c04c 	strh.w	ip, [r2, #76]	; 0x4c
	if (rts_pin_baseReg_) {
    4fc6:	b145      	cbz	r5, 4fda <HardwareSerial::read()+0x46>
		uint32_t avail;
		if (head >= tail) avail = head - tail;
    4fc8:	4299      	cmp	r1, r3
    4fca:	d31c      	bcc.n	5006 <HardwareSerial::read()+0x72>
    4fcc:	1acb      	subs	r3, r1, r3
		else avail = rx_buffer_total_size_ + head - tail;

		if (avail <= rts_low_watermark_) rts_assert();
    4fce:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
    4fd0:	4299      	cmp	r1, r3
    4fd2:	d302      	bcc.n	4fda <HardwareSerial::read()+0x46>
	DIRECT_WRITE_LOW(rts_pin_baseReg_, rts_pin_bitmask_);
    4fd4:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    4fd6:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
	}
	return c;
}	
    4fda:	bc30      	pop	{r4, r5}
    4fdc:	4770      	bx	lr
    4fde:	f04f 0c00 	mov.w	ip, #0
	if (tail < rx_buffer_size_) {
    4fe2:	6b10      	ldr	r0, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    4fe4:	4663      	mov	r3, ip
	if (tail < rx_buffer_size_) {
    4fe6:	4298      	cmp	r0, r3
    4fe8:	d8e7      	bhi.n	4fba <HardwareSerial::read()+0x26>
		c = rx_buffer_storage_[tail-rx_buffer_size_];
    4fea:	1a18      	subs	r0, r3, r0
    4fec:	6a55      	ldr	r5, [r2, #36]	; 0x24
    4fee:	5c28      	ldrb	r0, [r5, r0]
    4ff0:	b2c0      	uxtb	r0, r0
    4ff2:	e7e5      	b.n	4fc0 <HardwareSerial::read()+0x2c>
    4ff4:	4608      	mov	r0, r1
		__disable_irq();
    4ff6:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    4ff8:	f8b2 104a 	ldrh.w	r1, [r2, #74]	; 0x4a
    4ffc:	b289      	uxth	r1, r1
		if (head == tail) {
    4ffe:	4288      	cmp	r0, r1
    5000:	d004      	beq.n	500c <HardwareSerial::read()+0x78>
		__enable_irq();
    5002:	b662      	cpsie	i
    5004:	e7cf      	b.n	4fa6 <HardwareSerial::read()+0x12>
		else avail = rx_buffer_total_size_ + head - tail;
    5006:	440c      	add	r4, r1
    5008:	1ae3      	subs	r3, r4, r3
    500a:	e7e0      	b.n	4fce <HardwareSerial::read()+0x3a>
			if (port->WATER & 0x7000000) {
    500c:	6913      	ldr	r3, [r2, #16]
    500e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    5010:	f012 6fe0 	tst.w	r2, #117440512	; 0x7000000
    5014:	d103      	bne.n	501e <HardwareSerial::read()+0x8a>
			c = -1;	// assume nothing to return
    5016:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    501a:	b662      	cpsie	i
}	
    501c:	4770      	bx	lr
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    501e:	69d8      	ldr	r0, [r3, #28]
    5020:	f3c0 0009 	ubfx	r0, r0, #0, #10
    5024:	e7f9      	b.n	501a <HardwareSerial::read()+0x86>
    5026:	bf00      	nop

00005028 <HardwareSerial::flush()>:

void HardwareSerial::flush(void)
{
	while (transmitting_) yield(); // wait
    5028:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
    502c:	b143      	cbz	r3, 5040 <HardwareSerial::flush()+0x18>
{
    502e:	b510      	push	{r4, lr}
    5030:	4604      	mov	r4, r0
	while (transmitting_) yield(); // wait
    5032:	f002 faa9 	bl	7588 <yield>
    5036:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    503a:	2b00      	cmp	r3, #0
    503c:	d1f9      	bne.n	5032 <HardwareSerial::flush()+0xa>
}
    503e:	bd10      	pop	{r4, pc}
    5040:	4770      	bx	lr
    5042:	bf00      	nop

00005044 <nvic_execution_priority()>:
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
    5044:	f3ef 8013 	mrs	r0, FAULTMASK
	if (faultmask) return -1;
    5048:	b9b8      	cbnz	r0, 507a <nvic_execution_priority()+0x36>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    504a:	f3ef 8310 	mrs	r3, PRIMASK
	if (primask) return 0;
    504e:	b94b      	cbnz	r3, 5064 <nvic_execution_priority()+0x20>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    5050:	f3ef 8205 	mrs	r2, IPSR
	if (ipsr) {
    5054:	b93a      	cbnz	r2, 5066 <nvic_execution_priority()+0x22>
	uint32_t priority=256;
    5056:	f44f 7380 	mov.w	r3, #256	; 0x100
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    505a:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    505e:	b150      	cbz	r0, 5076 <nvic_execution_priority()+0x32>
    5060:	4298      	cmp	r0, r3
    5062:	d208      	bcs.n	5076 <nvic_execution_priority()+0x32>
}
    5064:	4770      	bx	lr
		if (ipsr < 16) priority = 0; // could be non-zero
    5066:	2a0f      	cmp	r2, #15
    5068:	d9f7      	bls.n	505a <nvic_execution_priority()+0x16>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
    506a:	4b05      	ldr	r3, [pc, #20]	; (5080 <nvic_execution_priority()+0x3c>)
    506c:	5c9b      	ldrb	r3, [r3, r2]
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    506e:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    5072:	2800      	cmp	r0, #0
    5074:	d1f4      	bne.n	5060 <nvic_execution_priority()+0x1c>
    5076:	4618      	mov	r0, r3
	return priority;
    5078:	4770      	bx	lr
	if (faultmask) return -1;
    507a:	f04f 30ff 	mov.w	r0, #4294967295
    507e:	e7f1      	b.n	5064 <nvic_execution_priority()+0x20>
    5080:	e000e3f0 	.word	0xe000e3f0

00005084 <HardwareSerial::begin(unsigned long, unsigned short)>:
	float base = (float)UART_CLOCK / (float)baud;
    5084:	ee07 1a90 	vmov	s15, r1
    5088:	ed9f 7a91 	vldr	s14, [pc, #580]	; 52d0 <HardwareSerial::begin(unsigned long, unsigned short)+0x24c>
	for (int osr=4; osr <= 32; osr++) {
    508c:	2104      	movs	r1, #4
		int divint = (int)(div + 0.5f);
    508e:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
	float base = (float)UART_CLOCK / (float)baud;
    5092:	eef8 7a67 	vcvt.f32.u32	s15, s15
	float besterr = 1e20;
    5096:	ed9f 6a8f 	vldr	s12, [pc, #572]	; 52d4 <HardwareSerial::begin(unsigned long, unsigned short)+0x250>
    509a:	f641 7cff 	movw	ip, #8191	; 0x1fff
	float base = (float)UART_CLOCK / (float)baud;
    509e:	eec7 5a27 	vdiv.f32	s11, s14, s15
{
    50a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int bestosr = 4;
    50a6:	468e      	mov	lr, r1
	int bestdiv = 1;
    50a8:	2401      	movs	r4, #1
		float div = base / (float)osr;
    50aa:	ee07 1a90 	vmov	s15, r1
    50ae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    50b2:	ee85 7aa7 	vdiv.f32	s14, s11, s15
		int divint = (int)(div + 0.5f);
    50b6:	ee77 7a05 	vadd.f32	s15, s14, s10
    50ba:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    50be:	ee17 3a90 	vmov	r3, s15
    50c2:	4563      	cmp	r3, ip
    50c4:	bfa8      	it	ge
    50c6:	4663      	movge	r3, ip
    50c8:	2b01      	cmp	r3, #1
    50ca:	bfb8      	it	lt
    50cc:	2301      	movlt	r3, #1
		float err = ((float)divint - div) / div;
    50ce:	ee07 3a90 	vmov	s15, r3
    50d2:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    50d6:	ee76 6ac7 	vsub.f32	s13, s13, s14
    50da:	eec6 7a87 	vdiv.f32	s15, s13, s14
		if (err < 0.0f) err = -err;
    50de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    50e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    50e6:	bf48      	it	mi
    50e8:	eef1 7a67 	vnegmi.f32	s15, s15
		if (err <= besterr) {
    50ec:	eef4 7ac6 	vcmpe.f32	s15, s12
    50f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    50f4:	d803      	bhi.n	50fe <HardwareSerial::begin(unsigned long, unsigned short)+0x7a>
			besterr = err;
    50f6:	eeb0 6a67 	vmov.f32	s12, s15
		if (err <= besterr) {
    50fa:	468e      	mov	lr, r1
			bestdiv = divint;
    50fc:	461c      	mov	r4, r3
	for (int osr=4; osr <= 32; osr++) {
    50fe:	3101      	adds	r1, #1
    5100:	2921      	cmp	r1, #33	; 0x21
    5102:	d1d2      	bne.n	50aa <HardwareSerial::begin(unsigned long, unsigned short)+0x26>
	rx_buffer_head_ = 0;
    5104:	2100      	movs	r1, #0
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    5106:	6943      	ldr	r3, [r0, #20]
    5108:	f402 7500 	and.w	r5, r2, #512	; 0x200
	rx_buffer_head_ = 0;
    510c:	f8a0 104a 	strh.w	r1, [r0, #74]	; 0x4a
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    5110:	f8b3 c05e 	ldrh.w	ip, [r3, #94]	; 0x5e
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    5114:	428d      	cmp	r5, r1
	rx_buffer_tail_ = 0;
    5116:	f8a0 104c 	strh.w	r1, [r0, #76]	; 0x4c
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    511a:	f8b3 505c 	ldrh.w	r5, [r3, #92]	; 0x5c
	tx_buffer_head_ = 0;
    511e:	f8a0 1046 	strh.w	r1, [r0, #70]	; 0x46
	tx_buffer_tail_ = 0;
    5122:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	transmitting_ = 0;
    5126:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    512a:	6b81      	ldr	r1, [r0, #56]	; 0x38
	hardware->ccm_register |= hardware->ccm_value;
    512c:	691e      	ldr	r6, [r3, #16]
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    512e:	eba1 0505 	sub.w	r5, r1, r5
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    5132:	eba1 010c 	sub.w	r1, r1, ip
    5136:	e9c0 510f 	strd	r5, r1, [r0, #60]	; 0x3c
	hardware->ccm_register |= hardware->ccm_value;
    513a:	6831      	ldr	r1, [r6, #0]
    513c:	695d      	ldr	r5, [r3, #20]
    513e:	ea41 0105 	orr.w	r1, r1, r5
    5142:	6031      	str	r1, [r6, #0]
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    5144:	bf14      	ite	ne
    5146:	2101      	movne	r1, #1
    5148:	2100      	moveq	r1, #0
    514a:	7681      	strb	r1, [r0, #26]
	if (!half_duplex_mode_)  {
    514c:	f040 8091 	bne.w	5272 <HardwareSerial::begin(unsigned long, unsigned short)+0x1ee>
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5150:	7e05      	ldrb	r5, [r0, #24]
    5152:	f8df 8198 	ldr.w	r8, [pc, #408]	; 52ec <HardwareSerial::begin(unsigned long, unsigned short)+0x268>
    5156:	eb03 1c05 	add.w	ip, r3, r5, lsl #4
    515a:	4e5f      	ldr	r6, [pc, #380]	; (52d8 <HardwareSerial::begin(unsigned long, unsigned short)+0x254>)
    515c:	f89c 5018 	ldrb.w	r5, [ip, #24]
    5160:	eb08 1505 	add.w	r5, r8, r5, lsl #4
    5164:	68a9      	ldr	r1, [r5, #8]
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
    5166:	686d      	ldr	r5, [r5, #4]
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5168:	600e      	str	r6, [r1, #0]
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
    516a:	f8dc 601c 	ldr.w	r6, [ip, #28]
    516e:	602e      	str	r6, [r5, #0]
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
    5170:	f8dc 5020 	ldr.w	r5, [ip, #32]
    5174:	b115      	cbz	r5, 517c <HardwareSerial::begin(unsigned long, unsigned short)+0xf8>
		 	*(hardware->rx_pins[rx_pin_index_].select_input_register) =  hardware->rx_pins[rx_pin_index_].select_val;		
    5176:	f8dc 6024 	ldr.w	r6, [ip, #36]	; 0x24
    517a:	602e      	str	r6, [r5, #0]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
    517c:	7e45      	ldrb	r5, [r0, #25]
    517e:	27d9      	movs	r7, #217	; 0xd9
    5180:	eb03 1505 	add.w	r5, r3, r5, lsl #4
    5184:	f895 6038 	ldrb.w	r6, [r5, #56]	; 0x38
    5188:	eb08 1106 	add.w	r1, r8, r6, lsl #4
    518c:	688e      	ldr	r6, [r1, #8]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    518e:	6849      	ldr	r1, [r1, #4]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
    5190:	6037      	str	r7, [r6, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    5192:	6bed      	ldr	r5, [r5, #60]	; 0x3c
    5194:	600d      	str	r5, [r1, #0]
	if (hardware->tx_pins[tx_pin_index_].select_input_register) {
    5196:	7e41      	ldrb	r1, [r0, #25]
    5198:	eb03 1101 	add.w	r1, r3, r1, lsl #4
    519c:	6c0d      	ldr	r5, [r1, #64]	; 0x40
    519e:	b10d      	cbz	r5, 51a4 <HardwareSerial::begin(unsigned long, unsigned short)+0x120>
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
    51a0:	6c49      	ldr	r1, [r1, #68]	; 0x44
    51a2:	6029      	str	r1, [r5, #0]
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51a4:	f10e 31ff 	add.w	r1, lr, #4294967295
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51a8:	f1be 0f08 	cmp.w	lr, #8
	attachInterruptVector(hardware->irq, hardware->irq_handler);
    51ac:	685d      	ldr	r5, [r3, #4]
	port->PINCFG = 0;
    51ae:	f04f 0600 	mov.w	r6, #0
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51b2:	bfcc      	ite	gt
    51b4:	f04f 0e00 	movgt.w	lr, #0
    51b8:	f04f 0e01 	movle.w	lr, #1
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51bc:	0609      	lsls	r1, r1, #24
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51be:	ea44 444e 	orr.w	r4, r4, lr, lsl #17
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51c2:	f001 51f8 	and.w	r1, r1, #520093696	; 0x1f000000
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    51c6:	4321      	orrs	r1, r4
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    51c8:	785c      	ldrb	r4, [r3, #1]
    51ca:	f104 0310 	add.w	r3, r4, #16
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    51ce:	6904      	ldr	r4, [r0, #16]
    51d0:	6121      	str	r1, [r4, #16]
    51d2:	4942      	ldr	r1, [pc, #264]	; (52dc <HardwareSerial::begin(unsigned long, unsigned short)+0x258>)
	port->PINCFG = 0;
    51d4:	60e6      	str	r6, [r4, #12]
    51d6:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    51da:	6943      	ldr	r3, [r0, #20]
	NVIC_ENABLE_IRQ(hardware->irq);
    51dc:	f04f 0c01 	mov.w	ip, #1
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    51e0:	493f      	ldr	r1, [pc, #252]	; (52e0 <HardwareSerial::begin(unsigned long, unsigned short)+0x25c>)
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    51e2:	f002 0503 	and.w	r5, r2, #3
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    51e6:	785c      	ldrb	r4, [r3, #1]
    51e8:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
    51ec:	5463      	strb	r3, [r4, r1]
	NVIC_ENABLE_IRQ(hardware->irq);
    51ee:	6944      	ldr	r4, [r0, #20]
    51f0:	4b3c      	ldr	r3, [pc, #240]	; (52e4 <HardwareSerial::begin(unsigned long, unsigned short)+0x260>)
    51f2:	7861      	ldrb	r1, [r4, #1]
    51f4:	eb03 1351 	add.w	r3, r3, r1, lsr #5
    51f8:	f001 011f 	and.w	r1, r1, #31
    51fc:	009b      	lsls	r3, r3, #2
    51fe:	fa0c f101 	lsl.w	r1, ip, r1
    5202:	6019      	str	r1, [r3, #0]
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
    5204:	f04f 1102 	mov.w	r1, #131074	; 0x20002
    5208:	6903      	ldr	r3, [r0, #16]
    520a:	62d9      	str	r1, [r3, #44]	; 0x2c
	port->FIFO |= LPUART_FIFO_TXFE | LPUART_FIFO_RXFE;
    520c:	6a99      	ldr	r1, [r3, #40]	; 0x28
    520e:	f041 0188 	orr.w	r1, r1, #136	; 0x88
    5212:	6299      	str	r1, [r3, #40]	; 0x28
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    5214:	0751      	lsls	r1, r2, #29
    5216:	d429      	bmi.n	526c <HardwareSerial::begin(unsigned long, unsigned short)+0x1e8>
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    5218:	f445 1170 	orr.w	r1, r5, #3932160	; 0x3c0000
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
    521c:	f002 050f 	and.w	r5, r2, #15
    5220:	2d04      	cmp	r5, #4
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    5222:	7e85      	ldrb	r5, [r0, #26]
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
    5224:	bf08      	it	eq
    5226:	f041 4180 	orreq.w	r1, r1, #1073741824	; 0x40000000
	if (format & 0x20) ctrl |= LPUART_CTRL_TXINV;		// tx invert
    522a:	0697      	lsls	r7, r2, #26
    522c:	bf48      	it	mi
    522e:	f041 5180 	orrmi.w	r1, r1, #268435456	; 0x10000000
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    5232:	b10d      	cbz	r5, 5238 <HardwareSerial::begin(unsigned long, unsigned short)+0x1b4>
    5234:	f041 01a0 	orr.w	r1, r1, #160	; 0xa0
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    5238:	0716      	lsls	r6, r2, #28
	port->CTRL = ctrl;
    523a:	6199      	str	r1, [r3, #24]
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    523c:	d503      	bpl.n	5246 <HardwareSerial::begin(unsigned long, unsigned short)+0x1c2>
    523e:	6919      	ldr	r1, [r3, #16]
    5240:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
    5244:	6119      	str	r1, [r3, #16]
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    5246:	6959      	ldr	r1, [r3, #20]
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    5248:	06d5      	lsls	r5, r2, #27
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    524a:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    524e:	bf48      	it	mi
    5250:	f041 5180 	orrmi.w	r1, r1, #268435456	; 0x10000000
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
    5254:	05d2      	lsls	r2, r2, #23
	port->STAT = c;
    5256:	6159      	str	r1, [r3, #20]
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
    5258:	d503      	bpl.n	5262 <HardwareSerial::begin(unsigned long, unsigned short)+0x1de>
    525a:	691a      	ldr	r2, [r3, #16]
    525c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    5260:	611a      	str	r2, [r3, #16]
	if (!(*hardware->serial_event_handler_default)) addToSerialEventsList(); 		// Enable the processing of serialEvent for this object
    5262:	68e3      	ldr	r3, [r4, #12]
    5264:	781b      	ldrb	r3, [r3, #0]
    5266:	b1a3      	cbz	r3, 5292 <HardwareSerial::begin(unsigned long, unsigned short)+0x20e>
};
    5268:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    526c:	491e      	ldr	r1, [pc, #120]	; (52e8 <HardwareSerial::begin(unsigned long, unsigned short)+0x264>)
    526e:	4329      	orrs	r1, r5
    5270:	e7d4      	b.n	521c <HardwareSerial::begin(unsigned long, unsigned short)+0x198>
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    5272:	7e41      	ldrb	r1, [r0, #25]
    5274:	f24f 07d9 	movw	r7, #61657	; 0xf0d9
    5278:	4d1c      	ldr	r5, [pc, #112]	; (52ec <HardwareSerial::begin(unsigned long, unsigned short)+0x268>)
    527a:	eb03 1101 	add.w	r1, r3, r1, lsl #4
    527e:	f891 6038 	ldrb.w	r6, [r1, #56]	; 0x38
    5282:	eb05 1506 	add.w	r5, r5, r6, lsl #4
    5286:	68ae      	ldr	r6, [r5, #8]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    5288:	686d      	ldr	r5, [r5, #4]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    528a:	6037      	str	r7, [r6, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    528c:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
    528e:	6029      	str	r1, [r5, #0]
    5290:	e781      	b.n	5196 <HardwareSerial::begin(unsigned long, unsigned short)+0x112>
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    5292:	4e17      	ldr	r6, [pc, #92]	; (52f0 <HardwareSerial::begin(unsigned long, unsigned short)+0x26c>)
    5294:	7834      	ldrb	r4, [r6, #0]
    5296:	b1bc      	cbz	r4, 52c8 <HardwareSerial::begin(unsigned long, unsigned short)+0x244>
    5298:	1e61      	subs	r1, r4, #1
    529a:	4d16      	ldr	r5, [pc, #88]	; (52f4 <HardwareSerial::begin(unsigned long, unsigned short)+0x270>)
    529c:	b2c9      	uxtb	r1, r1
    529e:	1f2b      	subs	r3, r5, #4
    52a0:	eb05 0181 	add.w	r1, r5, r1, lsl #2
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
    52a4:	f853 2f04 	ldr.w	r2, [r3, #4]!
    52a8:	4290      	cmp	r0, r2
    52aa:	d0dd      	beq.n	5268 <HardwareSerial::begin(unsigned long, unsigned short)+0x1e4>
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    52ac:	4299      	cmp	r1, r3
    52ae:	d1f9      	bne.n	52a4 <HardwareSerial::begin(unsigned long, unsigned short)+0x220>
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    52b0:	1c63      	adds	r3, r4, #1
    52b2:	b2db      	uxtb	r3, r3
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    52b4:	4a10      	ldr	r2, [pc, #64]	; (52f8 <HardwareSerial::begin(unsigned long, unsigned short)+0x274>)
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    52b6:	7033      	strb	r3, [r6, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    52b8:	7813      	ldrb	r3, [r2, #0]
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    52ba:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    52be:	f043 0302 	orr.w	r3, r3, #2
    52c2:	7013      	strb	r3, [r2, #0]
};
    52c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    52c8:	2301      	movs	r3, #1
    52ca:	4d0a      	ldr	r5, [pc, #40]	; (52f4 <HardwareSerial::begin(unsigned long, unsigned short)+0x270>)
    52cc:	e7f2      	b.n	52b4 <HardwareSerial::begin(unsigned long, unsigned short)+0x230>
    52ce:	bf00      	nop
    52d0:	4bb71b00 	.word	0x4bb71b00
    52d4:	60ad78ec 	.word	0x60ad78ec
    52d8:	0001f038 	.word	0x0001f038
    52dc:	20001000 	.word	0x20001000
    52e0:	e000e400 	.word	0xe000e400
    52e4:	38003840 	.word	0x38003840
    52e8:	003c0010 	.word	0x003c0010
    52ec:	200006bc 	.word	0x200006bc
    52f0:	20006adb 	.word	0x20006adb
    52f4:	20006888 	.word	0x20006888
    52f8:	20000d47 	.word	0x20000d47

000052fc <HardwareSerial::end()>:
{
    52fc:	b538      	push	{r3, r4, r5, lr}
	if (!(hardware->ccm_register & hardware->ccm_value)) return;
    52fe:	6943      	ldr	r3, [r0, #20]
    5300:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
    5304:	6809      	ldr	r1, [r1, #0]
    5306:	4211      	tst	r1, r2
    5308:	d02a      	beq.n	5360 <HardwareSerial::end()+0x64>
	while (transmitting_) yield();  // wait for buffered data to send
    530a:	f890 2044 	ldrb.w	r2, [r0, #68]	; 0x44
    530e:	4604      	mov	r4, r0
    5310:	b132      	cbz	r2, 5320 <HardwareSerial::end()+0x24>
    5312:	f002 f939 	bl	7588 <yield>
    5316:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    531a:	2b00      	cmp	r3, #0
    531c:	d1f9      	bne.n	5312 <HardwareSerial::end()+0x16>
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    531e:	6963      	ldr	r3, [r4, #20]
	port->CTRL = 0;	// disable the TX and RX ...
    5320:	6920      	ldr	r0, [r4, #16]
    5322:	2100      	movs	r1, #0
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    5324:	4a0f      	ldr	r2, [pc, #60]	; (5364 <HardwareSerial::end()+0x68>)
	port->CTRL = 0;	// disable the TX and RX ...
    5326:	6181      	str	r1, [r0, #24]
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    5328:	7e20      	ldrb	r0, [r4, #24]
    532a:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    532e:	7e00      	ldrb	r0, [r0, #24]
    5330:	eb02 1000 	add.w	r0, r2, r0, lsl #4
    5334:	6845      	ldr	r5, [r0, #4]
    5336:	2005      	movs	r0, #5
    5338:	6028      	str	r0, [r5, #0]
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    533a:	f894 c019 	ldrb.w	ip, [r4, #25]
    533e:	eb03 130c 	add.w	r3, r3, ip, lsl #4
    5342:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    5346:	eb02 1203 	add.w	r2, r2, r3, lsl #4
	if (rts_pin_baseReg_) rts_deassert();
    534a:	6da3      	ldr	r3, [r4, #88]	; 0x58
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    534c:	6852      	ldr	r2, [r2, #4]
    534e:	6010      	str	r0, [r2, #0]
	rx_buffer_head_ = 0;
    5350:	f8a4 104a 	strh.w	r1, [r4, #74]	; 0x4a
	rx_buffer_tail_ = 0;
    5354:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
	if (rts_pin_baseReg_) rts_deassert();
    5358:	b113      	cbz	r3, 5360 <HardwareSerial::end()+0x64>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    535a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    535c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    5360:	bd38      	pop	{r3, r4, r5, pc}
    5362:	bf00      	nop
    5364:	200006bc 	.word	0x200006bc

00005368 <HardwareSerial::write9bit(unsigned long)>:
{
    5368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    536a:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    536c:	4604      	mov	r4, r0
    536e:	460e      	mov	r6, r1
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5370:	b113      	cbz	r3, 5378 <HardwareSerial::write9bit(unsigned long)+0x10>
    5372:	6d42      	ldr	r2, [r0, #84]	; 0x54
    5374:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	if(half_duplex_mode_) {		
    5378:	7ea3      	ldrb	r3, [r4, #26]
    537a:	b133      	cbz	r3, 538a <HardwareSerial::write9bit(unsigned long)+0x22>
		__disable_irq();
    537c:	b672      	cpsid	i
	    port->CTRL |= LPUART_CTRL_TXDIR;
    537e:	6922      	ldr	r2, [r4, #16]
    5380:	6993      	ldr	r3, [r2, #24]
    5382:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    5386:	6193      	str	r3, [r2, #24]
		__enable_irq();
    5388:	b662      	cpsie	i
	head = tx_buffer_head_;
    538a:	f8b4 5046 	ldrh.w	r5, [r4, #70]	; 0x46
	if (++head >= tx_buffer_total_size_) head = 0;
    538e:	6b63      	ldr	r3, [r4, #52]	; 0x34
	head = tx_buffer_head_;
    5390:	b2ad      	uxth	r5, r5
	if (++head >= tx_buffer_total_size_) head = 0;
    5392:	3501      	adds	r5, #1
    5394:	42ab      	cmp	r3, r5
    5396:	d84c      	bhi.n	5432 <HardwareSerial::write9bit(unsigned long)+0xca>
    5398:	2700      	movs	r7, #0
    539a:	463d      	mov	r5, r7
	while (tx_buffer_tail_ == head) {
    539c:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    53a0:	b29b      	uxth	r3, r3
    53a2:	429d      	cmp	r5, r3
    53a4:	d01a      	beq.n	53dc <HardwareSerial::write9bit(unsigned long)+0x74>
    53a6:	e029      	b.n	53fc <HardwareSerial::write9bit(unsigned long)+0x94>
			if ((port->STAT & LPUART_STAT_TDRE)) {
    53a8:	6921      	ldr	r1, [r4, #16]
    53aa:	694b      	ldr	r3, [r1, #20]
    53ac:	021b      	lsls	r3, r3, #8
    53ae:	d510      	bpl.n	53d2 <HardwareSerial::write9bit(unsigned long)+0x6a>
				uint32_t tail = tx_buffer_tail_;
    53b0:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
				if (++tail >= tx_buffer_total_size_) tail = 0;
    53b4:	6b62      	ldr	r2, [r4, #52]	; 0x34
				uint32_t tail = tx_buffer_tail_;
    53b6:	b29b      	uxth	r3, r3
				if (++tail >= tx_buffer_total_size_) tail = 0;
    53b8:	3301      	adds	r3, #1
    53ba:	429a      	cmp	r2, r3
    53bc:	d936      	bls.n	542c <HardwareSerial::write9bit(unsigned long)+0xc4>
				tx_buffer_tail_ = tail;
    53be:	b29a      	uxth	r2, r3
				if (tail < tx_buffer_size_) {
    53c0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    53c2:	4298      	cmp	r0, r3
    53c4:	d92d      	bls.n	5422 <HardwareSerial::write9bit(unsigned long)+0xba>
					n = tx_buffer_[tail];
    53c6:	69e0      	ldr	r0, [r4, #28]
    53c8:	5cc3      	ldrb	r3, [r0, r3]
    53ca:	b2db      	uxtb	r3, r3
				port->DATA  = n;
    53cc:	61cb      	str	r3, [r1, #28]
				tx_buffer_tail_ = tail;
    53ce:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
	while (tx_buffer_tail_ == head) {
    53d2:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    53d6:	b29b      	uxth	r3, r3
    53d8:	42ab      	cmp	r3, r5
    53da:	d10f      	bne.n	53fc <HardwareSerial::write9bit(unsigned long)+0x94>
		int priority = nvic_execution_priority();
    53dc:	f7ff fe32 	bl	5044 <nvic_execution_priority()>
		if (priority <= hardware->irq_priority) {
    53e0:	6963      	ldr	r3, [r4, #20]
    53e2:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
    53e6:	4283      	cmp	r3, r0
    53e8:	dade      	bge.n	53a8 <HardwareSerial::write9bit(unsigned long)+0x40>
		} else if (priority >= 256) 
    53ea:	28ff      	cmp	r0, #255	; 0xff
    53ec:	ddf1      	ble.n	53d2 <HardwareSerial::write9bit(unsigned long)+0x6a>
			yield(); // wait
    53ee:	f002 f8cb 	bl	7588 <yield>
	while (tx_buffer_tail_ == head) {
    53f2:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    53f6:	b29b      	uxth	r3, r3
    53f8:	42ab      	cmp	r3, r5
    53fa:	d0ef      	beq.n	53dc <HardwareSerial::write9bit(unsigned long)+0x74>
	if (head < tx_buffer_size_) {
    53fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    53fe:	42ab      	cmp	r3, r5
    5400:	d919      	bls.n	5436 <HardwareSerial::write9bit(unsigned long)+0xce>
		tx_buffer_[head] = c;
    5402:	69e3      	ldr	r3, [r4, #28]
    5404:	b2f6      	uxtb	r6, r6
    5406:	555e      	strb	r6, [r3, r5]
	__disable_irq();
    5408:	b672      	cpsid	i
	transmitting_ = 1;
    540a:	2001      	movs	r0, #1
	port->CTRL |= LPUART_CTRL_TIE; // (may need to handle this issue)BITBAND_SET_BIT(LPUART0_CTRL, TIE_BIT);
    540c:	6922      	ldr	r2, [r4, #16]
	transmitting_ = 1;
    540e:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
	tx_buffer_head_ = head;
    5412:	f8a4 7046 	strh.w	r7, [r4, #70]	; 0x46
	port->CTRL |= LPUART_CTRL_TIE; // (may need to handle this issue)BITBAND_SET_BIT(LPUART0_CTRL, TIE_BIT);
    5416:	6993      	ldr	r3, [r2, #24]
    5418:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    541c:	6193      	str	r3, [r2, #24]
	__enable_irq();
    541e:	b662      	cpsie	i
}
    5420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					n = tx_buffer_storage_[tail-tx_buffer_size_];
    5422:	1a1b      	subs	r3, r3, r0
    5424:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    5426:	5cc3      	ldrb	r3, [r0, r3]
    5428:	b2db      	uxtb	r3, r3
    542a:	e7cf      	b.n	53cc <HardwareSerial::write9bit(unsigned long)+0x64>
    542c:	2200      	movs	r2, #0
				if (++tail >= tx_buffer_total_size_) tail = 0;
    542e:	4613      	mov	r3, r2
    5430:	e7c6      	b.n	53c0 <HardwareSerial::write9bit(unsigned long)+0x58>
	tx_buffer_head_ = head;
    5432:	b2af      	uxth	r7, r5
    5434:	e7b2      	b.n	539c <HardwareSerial::write9bit(unsigned long)+0x34>
		tx_buffer_storage_[head - tx_buffer_size_] = c;
    5436:	1aed      	subs	r5, r5, r3
    5438:	b2f6      	uxtb	r6, r6
    543a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    543c:	555e      	strb	r6, [r3, r5]
    543e:	e7e3      	b.n	5408 <HardwareSerial::write9bit(unsigned long)+0xa0>

00005440 <HardwareSerial::write(unsigned char)>:
	return write9bit(c);
    5440:	f7ff bf92 	b.w	5368 <HardwareSerial::write9bit(unsigned long)>

00005444 <HardwareSerial::IRQHandler()>:
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    5444:	6902      	ldr	r2, [r0, #16]
    5446:	6953      	ldr	r3, [r2, #20]
    5448:	f413 1f40 	tst.w	r3, #3145728	; 0x300000
{
    544c:	b570      	push	{r4, r5, r6, lr}
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    544e:	4615      	mov	r5, r2
    5450:	d047      	beq.n	54e2 <HardwareSerial::IRQHandler()+0x9e>
		uint8_t avail = (port->WATER >> 24) & 0x7;
    5452:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
		if (avail) {
    5454:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
		uint8_t avail = (port->WATER >> 24) & 0x7;
    5458:	f3c3 6e02 	ubfx	lr, r3, #24, #3
		if (avail) {
    545c:	d03e      	beq.n	54dc <HardwareSerial::IRQHandler()+0x98>
			head = rx_buffer_head_;
    545e:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
			tail = rx_buffer_tail_;
    5462:	f8b0 504c 	ldrh.w	r5, [r0, #76]	; 0x4c
			head = rx_buffer_head_;
    5466:	b2a4      	uxth	r4, r4
			tail = rx_buffer_tail_;
    5468:	b2ad      	uxth	r5, r5
    546a:	e008      	b.n	547e <HardwareSerial::IRQHandler()+0x3a>
						rx_buffer_[head] = n;
    546c:	6a02      	ldr	r2, [r0, #32]
    546e:	f802 c003 	strb.w	ip, [r2, r3]
    5472:	6902      	ldr	r2, [r0, #16]
			} while (--avail > 0) ;
    5474:	f10e 33ff 	add.w	r3, lr, #4294967295
    5478:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    547c:	d01e      	beq.n	54bc <HardwareSerial::IRQHandler()+0x78>
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    547e:	69d1      	ldr	r1, [r2, #28]
				newhead = head + 1;
    5480:	1c63      	adds	r3, r4, #1
				if (newhead != rx_buffer_tail_) {
    5482:	f8b0 c04c 	ldrh.w	ip, [r0, #76]	; 0x4c
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    5486:	6b86      	ldr	r6, [r0, #56]	; 0x38
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5488:	f3c1 0109 	ubfx	r1, r1, #0, #10
				if (newhead != rx_buffer_tail_) {
    548c:	fa1f fc8c 	uxth.w	ip, ip
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    5490:	429e      	cmp	r6, r3
    5492:	bf98      	it	ls
    5494:	2300      	movls	r3, #0
				if (newhead != rx_buffer_tail_) {
    5496:	459c      	cmp	ip, r3
    5498:	d0ec      	beq.n	5474 <HardwareSerial::IRQHandler()+0x30>
					if (newhead < rx_buffer_size_) {
    549a:	6b02      	ldr	r2, [r0, #48]	; 0x30
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    549c:	fa5f fc81 	uxtb.w	ip, r1
    54a0:	461c      	mov	r4, r3
					if (newhead < rx_buffer_size_) {
    54a2:	429a      	cmp	r2, r3
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    54a4:	eba3 0602 	sub.w	r6, r3, r2
					if (newhead < rx_buffer_size_) {
    54a8:	d8e0      	bhi.n	546c <HardwareSerial::IRQHandler()+0x28>
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    54aa:	6a43      	ldr	r3, [r0, #36]	; 0x24
    54ac:	f803 c006 	strb.w	ip, [r3, r6]
			} while (--avail > 0) ;
    54b0:	f10e 33ff 	add.w	r3, lr, #4294967295
    54b4:	6902      	ldr	r2, [r0, #16]
    54b6:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    54ba:	d1e0      	bne.n	547e <HardwareSerial::IRQHandler()+0x3a>
			rx_buffer_head_ = head;
    54bc:	b2a3      	uxth	r3, r4
    54be:	f8a0 304a 	strh.w	r3, [r0, #74]	; 0x4a
			if (rts_pin_baseReg_) {
    54c2:	6d83      	ldr	r3, [r0, #88]	; 0x58
    54c4:	2b00      	cmp	r3, #0
    54c6:	d05a      	beq.n	557e <HardwareSerial::IRQHandler()+0x13a>
				if (head >= tail) avail = head - tail;
    54c8:	42ac      	cmp	r4, r5
    54ca:	d35d      	bcc.n	5588 <HardwareSerial::IRQHandler()+0x144>
    54cc:	1b64      	subs	r4, r4, r5
				if (avail >= rts_high_watermark_) rts_deassert();
    54ce:	6c01      	ldr	r1, [r0, #64]	; 0x40
    54d0:	42a1      	cmp	r1, r4
    54d2:	d854      	bhi.n	557e <HardwareSerial::IRQHandler()+0x13a>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    54d4:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
		if (port->STAT & LPUART_STAT_IDLE) {
    54d6:	4615      	mov	r5, r2
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    54d8:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
		if (port->STAT & LPUART_STAT_IDLE) {
    54dc:	6953      	ldr	r3, [r2, #20]
    54de:	02dc      	lsls	r4, r3, #11
    54e0:	d448      	bmi.n	5574 <HardwareSerial::IRQHandler()+0x130>
	ctrl = port->CTRL;
    54e2:	6996      	ldr	r6, [r2, #24]
	if ((ctrl & LPUART_CTRL_TIE) && (port->STAT & LPUART_STAT_TDRE))
    54e4:	0231      	lsls	r1, r6, #8
    54e6:	d529      	bpl.n	553c <HardwareSerial::IRQHandler()+0xf8>
    54e8:	6953      	ldr	r3, [r2, #20]
    54ea:	021b      	lsls	r3, r3, #8
    54ec:	d526      	bpl.n	553c <HardwareSerial::IRQHandler()+0xf8>
		head = tx_buffer_head_;
    54ee:	f8b0 c046 	ldrh.w	ip, [r0, #70]	; 0x46
		tail = tx_buffer_tail_;
    54f2:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
		head = tx_buffer_head_;
    54f6:	fa1f fc8c 	uxth.w	ip, ip
		tail = tx_buffer_tail_;
    54fa:	b29b      	uxth	r3, r3
    54fc:	e006      	b.n	550c <HardwareSerial::IRQHandler()+0xc8>
				n = tx_buffer_[tail];
    54fe:	69c1      	ldr	r1, [r0, #28]
    5500:	5cc9      	ldrb	r1, [r1, r3]
    5502:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    5504:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    5506:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    5508:	054c      	lsls	r4, r1, #21
    550a:	d412      	bmi.n	5532 <HardwareSerial::IRQHandler()+0xee>
			if (head == tail) break;
    550c:	4563      	cmp	r3, ip
    550e:	d03f      	beq.n	5590 <HardwareSerial::IRQHandler()+0x14c>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5510:	6b44      	ldr	r4, [r0, #52]	; 0x34
    5512:	3301      	adds	r3, #1
			if (tail < tx_buffer_size_) {
    5514:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5516:	429c      	cmp	r4, r3
    5518:	bf98      	it	ls
    551a:	2300      	movls	r3, #0
			if (tail < tx_buffer_size_) {
    551c:	4299      	cmp	r1, r3
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    551e:	eba3 0401 	sub.w	r4, r3, r1
			if (tail < tx_buffer_size_) {
    5522:	d8ec      	bhi.n	54fe <HardwareSerial::IRQHandler()+0xba>
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    5524:	6a81      	ldr	r1, [r0, #40]	; 0x28
    5526:	5d09      	ldrb	r1, [r1, r4]
    5528:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    552a:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    552c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    552e:	054c      	lsls	r4, r1, #21
    5530:	d5ec      	bpl.n	550c <HardwareSerial::IRQHandler()+0xc8>
		tx_buffer_tail_ = tail;
    5532:	b299      	uxth	r1, r3
		if (head == tail) {
    5534:	4563      	cmp	r3, ip
		tx_buffer_tail_ = tail;
    5536:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
		if (head == tail) {
    553a:	d02c      	beq.n	5596 <HardwareSerial::IRQHandler()+0x152>
	if ((ctrl & LPUART_CTRL_TCIE) && (port->STAT & LPUART_STAT_TC))
    553c:	0271      	lsls	r1, r6, #9
    553e:	d518      	bpl.n	5572 <HardwareSerial::IRQHandler()+0x12e>
    5540:	6953      	ldr	r3, [r2, #20]
    5542:	025b      	lsls	r3, r3, #9
    5544:	d515      	bpl.n	5572 <HardwareSerial::IRQHandler()+0x12e>
		transmitting_ = 0;
    5546:	2200      	movs	r2, #0
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5548:	6d03      	ldr	r3, [r0, #80]	; 0x50
		transmitting_ = 0;
    554a:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    554e:	b113      	cbz	r3, 5556 <HardwareSerial::IRQHandler()+0x112>
    5550:	6d42      	ldr	r2, [r0, #84]	; 0x54
    5552:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		if(half_duplex_mode_) {		
    5556:	7e83      	ldrb	r3, [r0, #26]
    5558:	b13b      	cbz	r3, 556a <HardwareSerial::IRQHandler()+0x126>
			__disable_irq();
    555a:	b672      	cpsid	i
		    port->CTRL &= ~LPUART_CTRL_TXDIR;
    555c:	6902      	ldr	r2, [r0, #16]
    555e:	6993      	ldr	r3, [r2, #24]
    5560:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
    5564:	6193      	str	r3, [r2, #24]
			__enable_irq();
    5566:	b662      	cpsie	i
		port->CTRL &= ~LPUART_CTRL_TCIE;
    5568:	6905      	ldr	r5, [r0, #16]
    556a:	69ab      	ldr	r3, [r5, #24]
    556c:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
    5570:	61ab      	str	r3, [r5, #24]
}
    5572:	bd70      	pop	{r4, r5, r6, pc}
			port->STAT |= LPUART_STAT_IDLE;	// writing a 1 to idle should clear it. 
    5574:	6953      	ldr	r3, [r2, #20]
    5576:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    557a:	6153      	str	r3, [r2, #20]
    557c:	e7b1      	b.n	54e2 <HardwareSerial::IRQHandler()+0x9e>
		if (port->STAT & LPUART_STAT_IDLE) {
    557e:	6953      	ldr	r3, [r2, #20]
    5580:	4615      	mov	r5, r2
    5582:	02dc      	lsls	r4, r3, #11
    5584:	d5ad      	bpl.n	54e2 <HardwareSerial::IRQHandler()+0x9e>
    5586:	e7f5      	b.n	5574 <HardwareSerial::IRQHandler()+0x130>
				else avail = rx_buffer_total_size_ + head - tail;
    5588:	6b81      	ldr	r1, [r0, #56]	; 0x38
    558a:	1b49      	subs	r1, r1, r5
    558c:	440c      	add	r4, r1
    558e:	e79e      	b.n	54ce <HardwareSerial::IRQHandler()+0x8a>
		tx_buffer_tail_ = tail;
    5590:	b29b      	uxth	r3, r3
    5592:	f8a0 3048 	strh.w	r3, [r0, #72]	; 0x48
			port->CTRL &= ~LPUART_CTRL_TIE; 
    5596:	6993      	ldr	r3, [r2, #24]
    5598:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    559c:	6193      	str	r3, [r2, #24]
  			port->CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
    559e:	6993      	ldr	r3, [r2, #24]
    55a0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    55a4:	6193      	str	r3, [r2, #24]
    55a6:	e7c9      	b.n	553c <HardwareSerial::IRQHandler()+0xf8>

000055a8 <IRQHandler_Serial2>:
#define IRQ_PRIORITY  64  // 0 = highest priority, 255 = lowest


void IRQHandler_Serial2()
{
	Serial2.IRQHandler();
    55a8:	4801      	ldr	r0, [pc, #4]	; (55b0 <IRQHandler_Serial2+0x8>)
    55aa:	f7ff bf4b 	b.w	5444 <HardwareSerial::IRQHandler()>
    55ae:	bf00      	nop
    55b0:	200067a8 	.word	0x200067a8

000055b4 <_GLOBAL__sub_I_IRQHandler_Serial2>:
	0, // No CTS
	IRQ_PRIORITY, 38, 24, // IRQ, rts_low_watermark, rts_high_watermark
	XBARA1_OUT_LPUART4_TRG_INPUT
};
HardwareSerial Serial2(&IMXRT_LPUART4, &UART4_Hardware, tx_buffer2, SERIAL2_TX_BUFFER_SIZE, 
	rx_buffer2,  SERIAL2_RX_BUFFER_SIZE);
    55b4:	b410      	push	{r4}
	constexpr Print() : write_error(0) {}
    55b6:	4b17      	ldr	r3, [pc, #92]	; (5614 <_GLOBAL__sub_I_IRQHandler_Serial2+0x60>)
	constexpr Stream() : _timeout(1000), read_error(0) {}
    55b8:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    55bc:	2200      	movs	r2, #0
public:
	constexpr HardwareSerial(IMXRT_LPUART_t *myport, const hardware_t *myhardware, 
		volatile BUFTYPE *_tx_buffer, size_t _tx_buffer_size, 
		volatile BUFTYPE *_rx_buffer, size_t _rx_buffer_size) :
		port(myport), hardware(myhardware),
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55be:	2028      	movs	r0, #40	; 0x28
    55c0:	609c      	str	r4, [r3, #8]
    55c2:	2140      	movs	r1, #64	; 0x40
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55c4:	4c14      	ldr	r4, [pc, #80]	; (5618 <_GLOBAL__sub_I_IRQHandler_Serial2+0x64>)
    55c6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    55ca:	601c      	str	r4, [r3, #0]
		port(myport), hardware(myhardware),
    55cc:	4c13      	ldr	r4, [pc, #76]	; (561c <_GLOBAL__sub_I_IRQHandler_Serial2+0x68>)
    55ce:	731a      	strb	r2, [r3, #12]
    55d0:	611c      	str	r4, [r3, #16]
    55d2:	4c13      	ldr	r4, [pc, #76]	; (5620 <_GLOBAL__sub_I_IRQHandler_Serial2+0x6c>)
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55d4:	831a      	strh	r2, [r3, #24]
		port(myport), hardware(myhardware),
    55d6:	615c      	str	r4, [r3, #20]
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55d8:	4c12      	ldr	r4, [pc, #72]	; (5624 <_GLOBAL__sub_I_IRQHandler_Serial2+0x70>)
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55da:	769a      	strb	r2, [r3, #26]
    55dc:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55e0:	61dc      	str	r4, [r3, #28]
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55e2:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
    55e6:	f85d 4b04 	ldr.w	r4, [sp], #4
    55ea:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
    55ee:	605a      	str	r2, [r3, #4]
    55f0:	625a      	str	r2, [r3, #36]	; 0x24
    55f2:	641a      	str	r2, [r3, #64]	; 0x40
    55f4:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    55f8:	e9c3 200a 	strd	r2, r0, [r3, #40]	; 0x28
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    55fc:	e9c3 100c 	strd	r1, r0, [r3, #48]	; 0x30
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    5600:	4809      	ldr	r0, [pc, #36]	; (5628 <_GLOBAL__sub_I_IRQHandler_Serial2+0x74>)
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    5602:	e9c3 120e 	strd	r1, r2, [r3, #56]	; 0x38
		tx_buffer_(_tx_buffer), rx_buffer_(_rx_buffer), tx_buffer_size_(_tx_buffer_size),  rx_buffer_size_(_rx_buffer_size),
    5606:	6218      	str	r0, [r3, #32]
		tx_buffer_total_size_(_tx_buffer_size), rx_buffer_total_size_(_rx_buffer_size) {
    5608:	e9c3 2214 	strd	r2, r2, [r3, #80]	; 0x50
    560c:	e9c3 2216 	strd	r2, r2, [r3, #88]	; 0x58
    5610:	4770      	bx	lr
    5612:	bf00      	nop
    5614:	200067a8 	.word	0x200067a8
    5618:	20000678 	.word	0x20000678
    561c:	40190000 	.word	0x40190000
    5620:	20000a78 	.word	0x20000a78
    5624:	20006848 	.word	0x20006848
    5628:	20006808 	.word	0x20006808

0000562c <usb_serial_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    562c:	4608      	mov	r0, r1
    562e:	f001 bf17 	b.w	7460 <usb_serial_putchar>
    5632:	bf00      	nop

00005634 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>:
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    5634:	2a01      	cmp	r2, #1
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    5636:	b570      	push	{r4, r5, r6, lr}
		base = 10;
    5638:	bf08      	it	eq
    563a:	220a      	moveq	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    563c:	b08a      	sub	sp, #40	; 0x28
	}


	if (n == 0) {
    563e:	b391      	cbz	r1, 56a6 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x72>
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
    5640:	f04f 0e21 	mov.w	lr, #33	; 0x21
    5644:	e001      	b.n	564a <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x16>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    5646:	fa5f fe86 	uxtb.w	lr, r6
    564a:	f10e 36ff 	add.w	r6, lr, #4294967295
			digit = n % base;
    564e:	fbb1 f5f2 	udiv	r5, r1, r2
    5652:	fb02 1415 	mls	r4, r2, r5, r1
    5656:	fa5f fc84 	uxtb.w	ip, r4
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    565a:	2c09      	cmp	r4, #9
    565c:	f10c 0437 	add.w	r4, ip, #55	; 0x37
    5660:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    5664:	bf98      	it	ls
    5666:	fa5f f48c 	uxtbls.w	r4, ip
    566a:	f10e 0c28 	add.w	ip, lr, #40	; 0x28
    566e:	bf88      	it	hi
    5670:	b2e4      	uxtbhi	r4, r4
			if (n == 0) break;
    5672:	4291      	cmp	r1, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5674:	44ec      	add	ip, sp
			n /= base;
    5676:	4629      	mov	r1, r5
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5678:	f80c 4c24 	strb.w	r4, [ip, #-36]
			if (n == 0) break;
    567c:	d2e3      	bcs.n	5646 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x12>
		}
	}
	if (sign) {
    567e:	b14b      	cbz	r3, 5694 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x60>
		i--;
    5680:	f10e 3eff 	add.w	lr, lr, #4294967295
		buf[i] = '-';
    5684:	222d      	movs	r2, #45	; 0x2d
		i--;
    5686:	fa5f fe8e 	uxtb.w	lr, lr
		buf[i] = '-';
    568a:	f10e 0328 	add.w	r3, lr, #40	; 0x28
    568e:	446b      	add	r3, sp
    5690:	f803 2c24 	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    5694:	6803      	ldr	r3, [r0, #0]
    5696:	a901      	add	r1, sp, #4
    5698:	f1ce 0222 	rsb	r2, lr, #34	; 0x22
    569c:	685b      	ldr	r3, [r3, #4]
    569e:	4471      	add	r1, lr
    56a0:	4798      	blx	r3
}
    56a2:	b00a      	add	sp, #40	; 0x28
    56a4:	bd70      	pop	{r4, r5, r6, pc}
		buf[sizeof(buf) - 1] = '0';
    56a6:	2230      	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    56a8:	f04f 0e21 	mov.w	lr, #33	; 0x21
		buf[sizeof(buf) - 1] = '0';
    56ac:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    56b0:	e7e5      	b.n	567e <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x4a>
    56b2:	bf00      	nop

000056b4 <Print::write(unsigned char const*, unsigned int)>:
{
    56b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buffer == nullptr) return 0;
    56b8:	460c      	mov	r4, r1
    56ba:	b1d1      	cbz	r1, 56f2 <Print::write(unsigned char const*, unsigned int)+0x3e>
	while (size--) count += write(*buffer++);
    56bc:	b1ea      	cbz	r2, 56fa <Print::write(unsigned char const*, unsigned int)+0x46>
    56be:	4680      	mov	r8, r0
    56c0:	188e      	adds	r6, r1, r2
	size_t count = 0;
    56c2:	2500      	movs	r5, #0
    56c4:	4f0e      	ldr	r7, [pc, #56]	; (5700 <Print::write(unsigned char const*, unsigned int)+0x4c>)
    56c6:	e004      	b.n	56d2 <Print::write(unsigned char const*, unsigned int)+0x1e>
    56c8:	f001 feca 	bl	7460 <usb_serial_putchar>
	while (size--) count += write(*buffer++);
    56cc:	42b4      	cmp	r4, r6
    56ce:	4405      	add	r5, r0
    56d0:	d00c      	beq.n	56ec <Print::write(unsigned char const*, unsigned int)+0x38>
    56d2:	f8d8 3000 	ldr.w	r3, [r8]
    56d6:	f814 0b01 	ldrb.w	r0, [r4], #1
    56da:	681b      	ldr	r3, [r3, #0]
    56dc:	42bb      	cmp	r3, r7
    56de:	d0f3      	beq.n	56c8 <Print::write(unsigned char const*, unsigned int)+0x14>
    56e0:	4601      	mov	r1, r0
    56e2:	4640      	mov	r0, r8
    56e4:	4798      	blx	r3
    56e6:	42b4      	cmp	r4, r6
    56e8:	4405      	add	r5, r0
    56ea:	d1f2      	bne.n	56d2 <Print::write(unsigned char const*, unsigned int)+0x1e>
}
    56ec:	4628      	mov	r0, r5
    56ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    56f2:	460d      	mov	r5, r1
}
    56f4:	4628      	mov	r0, r5
    56f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    56fa:	4615      	mov	r5, r2
    56fc:	e7f6      	b.n	56ec <Print::write(unsigned char const*, unsigned int)+0x38>
    56fe:	bf00      	nop
    5700:	0000562d 	.word	0x0000562d

00005704 <Print::print(long)>:
	if (n < 0) {
    5704:	2900      	cmp	r1, #0
    5706:	db03      	blt.n	5710 <Print::print(long)+0xc>
	uint8_t sign=0;
    5708:	2300      	movs	r3, #0
	if (base == 0) {
    570a:	220a      	movs	r2, #10
    570c:	f7ff bf92 	b.w	5634 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
		n = -n;
    5710:	4249      	negs	r1, r1
		sign = '-';
    5712:	232d      	movs	r3, #45	; 0x2d
	if (base == 0) {
    5714:	220a      	movs	r2, #10
    5716:	f7ff bf8d 	b.w	5634 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    571a:	bf00      	nop

0000571c <Print::println()>:
{
    571c:	b500      	push	{lr}
	return write(buf, 2);
    571e:	6803      	ldr	r3, [r0, #0]
{
    5720:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    5722:	f640 2c0d 	movw	ip, #2573	; 0xa0d
	return write(buf, 2);
    5726:	2202      	movs	r2, #2
    5728:	a901      	add	r1, sp, #4
    572a:	685b      	ldr	r3, [r3, #4]
	uint8_t buf[2]={'\r', '\n'};
    572c:	f8ad c004 	strh.w	ip, [sp, #4]
	return write(buf, 2);
    5730:	4798      	blx	r3
}
    5732:	b003      	add	sp, #12
    5734:	f85d fb04 	ldr.w	pc, [sp], #4

00005738 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	if (base == 0) {
    5738:	b95a      	cbnz	r2, 5752 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1a>
		return write((uint8_t)n);
    573a:	6803      	ldr	r3, [r0, #0]
    573c:	b2c9      	uxtb	r1, r1
    573e:	4a07      	ldr	r2, [pc, #28]	; (575c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x24>)
    5740:	681b      	ldr	r3, [r3, #0]
    5742:	4293      	cmp	r3, r2
{
    5744:	b500      	push	{lr}
    5746:	d106      	bne.n	5756 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    5748:	4608      	mov	r0, r1
}
    574a:	f85d eb04 	ldr.w	lr, [sp], #4
    574e:	f001 be87 	b.w	7460 <usb_serial_putchar>
    5752:	f7ff bf6f 	b.w	5634 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    5756:	f85d eb04 	ldr.w	lr, [sp], #4
		return write((uint8_t)n);
    575a:	4718      	bx	r3
    575c:	0000562d 	.word	0x0000562d

00005760 <usb_serial_class::read()>:
        virtual int read() { return usb_serial_getchar(); }
    5760:	f001 be6e 	b.w	7440 <usb_serial_getchar>

00005764 <usb_serial_class::peek()>:
        virtual int peek() { return usb_serial_peekchar(); }
    5764:	f001 be06 	b.w	7374 <usb_serial_peekchar>

00005768 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    5768:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
    576c:	b392      	cbz	r2, 57d4 <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
    576e:	4617      	mov	r7, r2
    5770:	fab3 f283 	clz	r2, r3
    5774:	0952      	lsrs	r2, r2, #5
    5776:	b36b      	cbz	r3, 57d4 <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
	length--;
	size_t index = 0;
	while (index < length) {
    5778:	f1b3 0801 	subs.w	r8, r3, #1
    577c:	d025      	beq.n	57ca <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    577e:	eb07 0a08 	add.w	sl, r7, r8
    5782:	4683      	mov	fp, r0
    5784:	4689      	mov	r9, r1
	size_t index = 0;
    5786:	4690      	mov	r8, r2
    5788:	4c17      	ldr	r4, [pc, #92]	; (57e8 <Stream::readBytesUntil(char, char*, unsigned int)+0x80>)
    578a:	4e18      	ldr	r6, [pc, #96]	; (57ec <Stream::readBytesUntil(char, char*, unsigned int)+0x84>)
    578c:	6825      	ldr	r5, [r4, #0]
    578e:	e00b      	b.n	57a8 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
        virtual int read() { return usb_serial_getchar(); }
    5790:	f001 fe56 	bl	7440 <usb_serial_getchar>
    if (c >= 0) return c;
    5794:	2800      	cmp	r0, #0
    5796:	da10      	bge.n	57ba <Stream::readBytesUntil(char, char*, unsigned int)+0x52>
    yield();
    5798:	f001 fef6 	bl	7588 <yield>
    579c:	6823      	ldr	r3, [r4, #0]
  } while(millis() - startMillis < _timeout);
    579e:	f8db 2008 	ldr.w	r2, [fp, #8]
    57a2:	1b5b      	subs	r3, r3, r5
    57a4:	4293      	cmp	r3, r2
    57a6:	d21a      	bcs.n	57de <Stream::readBytesUntil(char, char*, unsigned int)+0x76>
    c = read();
    57a8:	f8db 3000 	ldr.w	r3, [fp]
    57ac:	695b      	ldr	r3, [r3, #20]
    57ae:	42b3      	cmp	r3, r6
    57b0:	d0ee      	beq.n	5790 <Stream::readBytesUntil(char, char*, unsigned int)+0x28>
    57b2:	4658      	mov	r0, fp
    57b4:	4798      	blx	r3
    if (c >= 0) return c;
    57b6:	2800      	cmp	r0, #0
    57b8:	dbee      	blt.n	5798 <Stream::readBytesUntil(char, char*, unsigned int)+0x30>
		int c = timedRead();
		if (c == terminator) break;
    57ba:	4548      	cmp	r0, r9
    57bc:	d005      	beq.n	57ca <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
		if (c < 0) {
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    57be:	f807 0b01 	strb.w	r0, [r7], #1
	while (index < length) {
    57c2:	45ba      	cmp	sl, r7
		index++;
    57c4:	f108 0801 	add.w	r8, r8, #1
	while (index < length) {
    57c8:	d1e0      	bne.n	578c <Stream::readBytesUntil(char, char*, unsigned int)+0x24>
	}
	*buffer = 0;
    57ca:	2300      	movs	r3, #0
	return index; // return number of characters, not including null terminator
}
    57cc:	4640      	mov	r0, r8
	*buffer = 0;
    57ce:	703b      	strb	r3, [r7, #0]
}
    57d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (length < 1) return 0;
    57d4:	f04f 0800 	mov.w	r8, #0
}
    57d8:	4640      	mov	r0, r8
    57da:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	String readString(size_t max = 0 /* 0 means unlimited length */);
	String readStringUntil(char terminator, size_t max = 0 /* 0 means unlimited length */);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    57de:	2301      	movs	r3, #1
    57e0:	f88b 300c 	strb.w	r3, [fp, #12]
    57e4:	e7f1      	b.n	57ca <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    57e6:	bf00      	nop
    57e8:	20006978 	.word	0x20006978
    57ec:	00005761 	.word	0x00005761

000057f0 <delay>:
	if (msec == 0) return;
    57f0:	b900      	cbnz	r0, 57f4 <delay+0x4>
    57f2:	4770      	bx	lr
{
    57f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    57f8:	2101      	movs	r1, #1
    57fa:	4681      	mov	r9, r0
    57fc:	4c21      	ldr	r4, [pc, #132]	; (5884 <delay+0x94>)
    57fe:	4d22      	ldr	r5, [pc, #136]	; (5888 <delay+0x98>)
    5800:	4e22      	ldr	r6, [pc, #136]	; (588c <delay+0x9c>)
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    5802:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    5806:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5808:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    580a:	e844 1300 	strex	r3, r1, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    580e:	2b00      	cmp	r3, #0
    5810:	d1f7      	bne.n	5802 <delay+0x12>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    5812:	491f      	ldr	r1, [pc, #124]	; (5890 <delay+0xa0>)
    5814:	684b      	ldr	r3, [r1, #4]
	uint32_t usec = 1000*smc + frac;
    5816:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    581a:	f8df a078 	ldr.w	sl, [pc, #120]	; 5894 <delay+0xa4>
	uint32_t ccdelta = cyccnt - scc;
    581e:	1a1b      	subs	r3, r3, r0
    5820:	2701      	movs	r7, #1
	uint32_t usec = 1000*smc + frac;
    5822:	fb0b f802 	mul.w	r8, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5826:	f8da 2000 	ldr.w	r2, [sl]
    582a:	fba3 3202 	umull	r3, r2, r3, r2
	uint32_t usec = 1000*smc + frac;
    582e:	455a      	cmp	r2, fp
    5830:	bf94      	ite	ls
    5832:	4490      	addls	r8, r2
    5834:	44d8      	addhi	r8, fp
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    5836:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    583a:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    583c:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    583e:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    5842:	2b00      	cmp	r3, #0
    5844:	d1f7      	bne.n	5836 <delay+0x46>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    5846:	684b      	ldr	r3, [r1, #4]
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5848:	f8da c000 	ldr.w	ip, [sl]
	uint32_t ccdelta = cyccnt - scc;
    584c:	1a1b      	subs	r3, r3, r0
	uint32_t usec = 1000*smc + frac;
    584e:	fb0b f202 	mul.w	r2, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5852:	fba3 3c0c 	umull	r3, ip, r3, ip
	uint32_t usec = 1000*smc + frac;
    5856:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
    585a:	bf94      	ite	ls
    585c:	4462      	addls	r2, ip
    585e:	f502 727a 	addhi.w	r2, r2, #1000	; 0x3e8
		while ((micros() - start) >= 1000) {
    5862:	eba2 0208 	sub.w	r2, r2, r8
    5866:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
    586a:	d306      	bcc.n	587a <delay+0x8a>
			if (--msec == 0) return;
    586c:	f1b9 0901 	subs.w	r9, r9, #1
			start += 1000;
    5870:	f508 787a 	add.w	r8, r8, #1000	; 0x3e8
			if (--msec == 0) return;
    5874:	d1df      	bne.n	5836 <delay+0x46>
}
    5876:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		yield();
    587a:	f001 fe85 	bl	7588 <yield>
		while ((micros() - start) >= 1000) {
    587e:	4904      	ldr	r1, [pc, #16]	; (5890 <delay+0xa0>)
    5880:	e7d9      	b.n	5836 <delay+0x46>
    5882:	bf00      	nop
    5884:	2000697c 	.word	0x2000697c
    5888:	20006978 	.word	0x20006978
    588c:	20006974 	.word	0x20006974
    5890:	e0001000 	.word	0xe0001000
    5894:	2000692c 	.word	0x2000692c

00005898 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    5898:	2827      	cmp	r0, #39	; 0x27
    589a:	d816      	bhi.n	58ca <digitalWrite+0x32>
	p = digital_pin_to_info_PGM + pin;
    589c:	0102      	lsls	r2, r0, #4
    589e:	4b10      	ldr	r3, [pc, #64]	; (58e0 <digitalWrite+0x48>)
    58a0:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	pinmode = *(p->reg + 1);
    58a4:	589b      	ldr	r3, [r3, r2]
{
    58a6:	b410      	push	{r4}
	mask = p->mask;
    58a8:	68c2      	ldr	r2, [r0, #12]
	pinmode = *(p->reg + 1);
    58aa:	685c      	ldr	r4, [r3, #4]
	if (pinmode & mask) {
    58ac:	4214      	tst	r4, r2
    58ae:	d005      	beq.n	58bc <digitalWrite+0x24>
		// pin is configured for output mode
		if (val) {
    58b0:	b961      	cbnz	r1, 58cc <digitalWrite+0x34>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    58b2:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x22) = mask; // clear register
    58b6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
    58ba:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    58bc:	6883      	ldr	r3, [r0, #8]
		if (val) {
    58be:	b151      	cbz	r1, 58d6 <digitalWrite+0x3e>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    58c0:	4a08      	ldr	r2, [pc, #32]	; (58e4 <digitalWrite+0x4c>)
}
    58c2:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    58c6:	601a      	str	r2, [r3, #0]
}
    58c8:	4770      	bx	lr
    58ca:	4770      	bx	lr
    58cc:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x21) = mask; // set register
    58d0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    58d4:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    58d6:	4a04      	ldr	r2, [pc, #16]	; (58e8 <digitalWrite+0x50>)
}
    58d8:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    58dc:	601a      	str	r2, [r3, #0]
}
    58de:	4770      	bx	lr
    58e0:	200006bc 	.word	0x200006bc
    58e4:	0001f038 	.word	0x0001f038
    58e8:	00013038 	.word	0x00013038

000058ec <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    58ec:	2827      	cmp	r0, #39	; 0x27
    58ee:	d80b      	bhi.n	5908 <digitalRead+0x1c>
	p = digital_pin_to_info_PGM + pin;
    58f0:	4b06      	ldr	r3, [pc, #24]	; (590c <digitalRead+0x20>)
    58f2:	0102      	lsls	r2, r0, #4
    58f4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    58f8:	589a      	ldr	r2, [r3, r2]
    58fa:	68c3      	ldr	r3, [r0, #12]
    58fc:	6892      	ldr	r2, [r2, #8]
    58fe:	421a      	tst	r2, r3
    5900:	bf14      	ite	ne
    5902:	2001      	movne	r0, #1
    5904:	2000      	moveq	r0, #0
    5906:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return 0;
    5908:	2000      	movs	r0, #0
}
    590a:	4770      	bx	lr
    590c:	200006bc 	.word	0x200006bc

00005910 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    5910:	2827      	cmp	r0, #39	; 0x27
    5912:	d829      	bhi.n	5968 <pinMode+0x58>
	p = digital_pin_to_info_PGM + pin;
    5914:	4b16      	ldr	r3, [pc, #88]	; (5970 <pinMode+0x60>)
    5916:	0102      	lsls	r2, r0, #4
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5918:	2901      	cmp	r1, #1
	p = digital_pin_to_info_PGM + pin;
    591a:	eb03 1000 	add.w	r0, r3, r0, lsl #4
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    591e:	589a      	ldr	r2, [r3, r2]
{
    5920:	b410      	push	{r4}
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5922:	6853      	ldr	r3, [r2, #4]
    5924:	68c4      	ldr	r4, [r0, #12]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5926:	d00e      	beq.n	5946 <pinMode+0x36>
    5928:	2904      	cmp	r1, #4
    592a:	d00c      	beq.n	5946 <pinMode+0x36>
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    592c:	ea23 0304 	bic.w	r3, r3, r4
    5930:	6053      	str	r3, [r2, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5932:	6883      	ldr	r3, [r0, #8]
		if (mode == INPUT) {
    5934:	b1a9      	cbz	r1, 5962 <pinMode+0x52>
		} else if (mode == INPUT_PULLUP) {
    5936:	2902      	cmp	r1, #2
    5938:	d017      	beq.n	596a <pinMode+0x5a>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    593a:	2903      	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    593c:	bf0c      	ite	eq
    593e:	4a0d      	ldreq	r2, [pc, #52]	; (5974 <pinMode+0x64>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    5940:	4a0d      	ldrne	r2, [pc, #52]	; (5978 <pinMode+0x68>)
    5942:	601a      	str	r2, [r3, #0]
    5944:	e007      	b.n	5956 <pinMode+0x46>
		*(p->reg + 1) |= p->mask; // TODO: atomic
    5946:	4323      	orrs	r3, r4
		if (mode == OUTPUT) {
    5948:	2901      	cmp	r1, #1
		*(p->reg + 1) |= p->mask; // TODO: atomic
    594a:	6053      	str	r3, [r2, #4]
			*(p->pad) = IOMUXC_PAD_DSE(7);
    594c:	6883      	ldr	r3, [r0, #8]
		if (mode == OUTPUT) {
    594e:	d008      	beq.n	5962 <pinMode+0x52>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    5950:	f640 0238 	movw	r2, #2104	; 0x838
    5954:	601a      	str	r2, [r3, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    5956:	6843      	ldr	r3, [r0, #4]
    5958:	2215      	movs	r2, #21
}
    595a:	f85d 4b04 	ldr.w	r4, [sp], #4
	*(p->mux) = 5 | 0x10;
    595e:	601a      	str	r2, [r3, #0]
}
    5960:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5962:	2238      	movs	r2, #56	; 0x38
    5964:	601a      	str	r2, [r3, #0]
    5966:	e7f6      	b.n	5956 <pinMode+0x46>
    5968:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    596a:	4a04      	ldr	r2, [pc, #16]	; (597c <pinMode+0x6c>)
    596c:	601a      	str	r2, [r3, #0]
    596e:	e7f2      	b.n	5956 <pinMode+0x46>
    5970:	200006bc 	.word	0x200006bc
    5974:	00013038 	.word	0x00013038
    5978:	00010038 	.word	0x00010038
    597c:	0001f038 	.word	0x0001f038

00005980 <flash_wait>:
{
    5980:	b430      	push	{r4, r5}
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5982:	4a12      	ldr	r2, [pc, #72]	; (59cc <flash_wait+0x4c>)
	FLEXSPI_LUT61 = 0;
    5984:	2000      	movs	r0, #0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5986:	4b12      	ldr	r3, [pc, #72]	; (59d0 <flash_wait+0x50>)
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5988:	2101      	movs	r1, #1
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    598a:	4d12      	ldr	r5, [pc, #72]	; (59d4 <flash_wait+0x54>)
		status = *(uint8_t *)&FLEXSPI_RFDR0;
    598c:	4c12      	ldr	r4, [pc, #72]	; (59d8 <flash_wait+0x58>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    598e:	f8c2 32f0 	str.w	r3, [r2, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    5992:	f8c2 02f4 	str.w	r0, [r2, #756]	; 0x2f4
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5996:	f8c2 10b8 	str.w	r1, [r2, #184]	; 0xb8
		FLEXSPI_IPCR0 = 0;
    599a:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    599e:	f8c2 50a4 	str.w	r5, [r2, #164]	; 0xa4
		FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    59a2:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
		while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) {;}
    59a6:	6953      	ldr	r3, [r2, #20]
    59a8:	07db      	lsls	r3, r3, #31
    59aa:	d5fc      	bpl.n	59a6 <flash_wait+0x26>
		FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    59ac:	6151      	str	r1, [r2, #20]
	} while (status & 1);
    59ae:	7823      	ldrb	r3, [r4, #0]
    59b0:	07db      	lsls	r3, r3, #31
    59b2:	d4f0      	bmi.n	5996 <flash_wait+0x16>
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    59b4:	6813      	ldr	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    59b6:	4905      	ldr	r1, [pc, #20]	; (59cc <flash_wait+0x4c>)
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    59b8:	f043 0301 	orr.w	r3, r3, #1
    59bc:	6013      	str	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    59be:	680b      	ldr	r3, [r1, #0]
    59c0:	07db      	lsls	r3, r3, #31
    59c2:	d4fc      	bmi.n	59be <flash_wait+0x3e>
	__enable_irq();
    59c4:	b662      	cpsie	i
}
    59c6:	bc30      	pop	{r4, r5}
    59c8:	4770      	bx	lr
    59ca:	bf00      	nop
    59cc:	402a8000 	.word	0x402a8000
    59d0:	24010405 	.word	0x24010405
    59d4:	000f0001 	.word	0x000f0001
    59d8:	402a8100 	.word	0x402a8100

000059dc <eeprom_initialize>:
{
    59dc:	b570      	push	{r4, r5, r6, lr}
    59de:	4c0e      	ldr	r4, [pc, #56]	; (5a18 <eeprom_initialize+0x3c>)
			if (*p++ == 0xFFFF) break;
    59e0:	f64f 7eff 	movw	lr, #65535	; 0xffff
{
    59e4:	4e0d      	ldr	r6, [pc, #52]	; (5a1c <eeprom_initialize+0x40>)
    59e6:	f104 051e 	add.w	r5, r4, #30
		const uint16_t *p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    59ea:	f5a6 5380 	sub.w	r3, r6, #4096	; 0x1000
		uint16_t index = 0;
    59ee:	2100      	movs	r1, #0
    59f0:	e002      	b.n	59f8 <eeprom_initialize+0x1c>
		} while (p < end);
    59f2:	42b3      	cmp	r3, r6
			index++;
    59f4:	b281      	uxth	r1, r0
		} while (p < end);
    59f6:	d204      	bcs.n	5a02 <eeprom_initialize+0x26>
			if (*p++ == 0xFFFF) break;
    59f8:	881a      	ldrh	r2, [r3, #0]
			index++;
    59fa:	1c48      	adds	r0, r1, #1
			if (*p++ == 0xFFFF) break;
    59fc:	3302      	adds	r3, #2
    59fe:	4572      	cmp	r2, lr
    5a00:	d1f7      	bne.n	59f2 <eeprom_initialize+0x16>
		sector_index[sector] = index;
    5a02:	f824 1f02 	strh.w	r1, [r4, #2]!
	for (sector=0; sector < FLASH_SECTORS; sector++) {
    5a06:	42ac      	cmp	r4, r5
    5a08:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
    5a0c:	d1ed      	bne.n	59ea <eeprom_initialize+0xe>
	initialized = 1;
    5a0e:	4b04      	ldr	r3, [pc, #16]	; (5a20 <eeprom_initialize+0x44>)
    5a10:	2201      	movs	r2, #1
    5a12:	701a      	strb	r2, [r3, #0]
}
    5a14:	bd70      	pop	{r4, r5, r6, pc}
    5a16:	bf00      	nop
    5a18:	2000692e 	.word	0x2000692e
    5a1c:	601f1000 	.word	0x601f1000
    5a20:	20006ae0 	.word	0x20006ae0

00005a24 <eeprom_read_byte>:
	if (addr > E2END) return 0xFF;
    5a24:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    5a28:	d22c      	bcs.n	5a84 <eeprom_read_byte+0x60>
	if (!initialized) eeprom_initialize();
    5a2a:	4b17      	ldr	r3, [pc, #92]	; (5a88 <eeprom_read_byte+0x64>)
{
    5a2c:	b510      	push	{r4, lr}
	if (!initialized) eeprom_initialize();
    5a2e:	781b      	ldrb	r3, [r3, #0]
    5a30:	4604      	mov	r4, r0
    5a32:	b323      	cbz	r3, 5a7e <eeprom_read_byte+0x5a>
	sector = (addr >> 2) % FLASH_SECTORS;
    5a34:	08a0      	lsrs	r0, r4, #2
    5a36:	4b15      	ldr	r3, [pc, #84]	; (5a8c <eeprom_read_byte+0x68>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5a38:	f004 0103 	and.w	r1, r4, #3
	end = p + sector_index[sector];
    5a3c:	4c14      	ldr	r4, [pc, #80]	; (5a90 <eeprom_read_byte+0x6c>)
	sector = (addr >> 2) % FLASH_SECTORS;
    5a3e:	fba3 2300 	umull	r2, r3, r3, r0
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5a42:	4a14      	ldr	r2, [pc, #80]	; (5a94 <eeprom_read_byte+0x70>)
	sector = (addr >> 2) % FLASH_SECTORS;
    5a44:	08db      	lsrs	r3, r3, #3
    5a46:	ebc3 1e03 	rsb	lr, r3, r3, lsl #4
    5a4a:	469c      	mov	ip, r3
    5a4c:	eba0 030e 	sub.w	r3, r0, lr
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5a50:	ea41 018c 	orr.w	r1, r1, ip, lsl #2
	uint8_t data=0xFF;
    5a54:	20ff      	movs	r0, #255	; 0xff
	end = p + sector_index[sector];
    5a56:	f834 c013 	ldrh.w	ip, [r4, r3, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5a5a:	441a      	add	r2, r3
	end = p + sector_index[sector];
    5a5c:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5a60:	0313      	lsls	r3, r2, #12
	end = p + sector_index[sector];
    5a62:	eb0c 3c02 	add.w	ip, ip, r2, lsl #12
	while (p < end) {
    5a66:	ebbc 3f02 	cmp.w	ip, r2, lsl #12
    5a6a:	d907      	bls.n	5a7c <eeprom_read_byte+0x58>
		uint32_t val = *p++;
    5a6c:	881a      	ldrh	r2, [r3, #0]
    5a6e:	3302      	adds	r3, #2
		if ((val & 255) == offset) data = val >> 8;
    5a70:	b2d4      	uxtb	r4, r2
    5a72:	428c      	cmp	r4, r1
    5a74:	bf08      	it	eq
    5a76:	0a10      	lsreq	r0, r2, #8
	while (p < end) {
    5a78:	459c      	cmp	ip, r3
    5a7a:	d8f7      	bhi.n	5a6c <eeprom_read_byte+0x48>
}
    5a7c:	bd10      	pop	{r4, pc}
	if (!initialized) eeprom_initialize();
    5a7e:	f7ff ffad 	bl	59dc <eeprom_initialize>
    5a82:	e7d7      	b.n	5a34 <eeprom_read_byte+0x10>
	if (addr > E2END) return 0xFF;
    5a84:	20ff      	movs	r0, #255	; 0xff
}
    5a86:	4770      	bx	lr
    5a88:	20006ae0 	.word	0x20006ae0
    5a8c:	88888889 	.word	0x88888889
    5a90:	20006930 	.word	0x20006930
    5a94:	000601f0 	.word	0x000601f0

00005a98 <eepromemu_flash_write>:
{
    5a98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5a9a:	460f      	mov	r7, r1
    5a9c:	4616      	mov	r6, r2
	__disable_irq();
    5a9e:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5aa0:	4b34      	ldr	r3, [pc, #208]	; (5b74 <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5aa2:	f240 4106 	movw	r1, #1030	; 0x406
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5aa6:	4a34      	ldr	r2, [pc, #208]	; (5b78 <eepromemu_flash_write+0xe0>)
    5aa8:	619a      	str	r2, [r3, #24]
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5aaa:	2202      	movs	r2, #2
    5aac:	61da      	str	r2, [r3, #28]
	FLEXSPI_IPCR0 = 0;
    5aae:	2200      	movs	r2, #0
    5ab0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5ab4:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    5ab8:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    5abc:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    5ac0:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5ac4:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    5ac8:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5acc:	2201      	movs	r2, #1
    5ace:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    5ad2:	f020 031f 	bic.w	r3, r0, #31
	uint32_t end_addr = (uint32_t)addr + size;
    5ad6:	1982      	adds	r2, r0, r6
	asm volatile("": : :"memory");
	asm("dsb");
    5ad8:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    5adc:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
    5ae0:	f8c4 3f5c 	str.w	r3, [r4, #3932]	; 0xf5c
		location += 32;
    5ae4:	3320      	adds	r3, #32
	} while (location < end_addr);
    5ae6:	429a      	cmp	r2, r3
    5ae8:	d8fa      	bhi.n	5ae0 <eepromemu_flash_write+0x48>
	asm("dsb");
    5aea:	f3bf 8f4f 	dsb	sy
	asm("isb");
    5aee:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5af2:	4d20      	ldr	r5, [pc, #128]	; (5b74 <eepromemu_flash_write+0xdc>)
    5af4:	696b      	ldr	r3, [r5, #20]
    5af6:	07da      	lsls	r2, r3, #31
    5af8:	d5fc      	bpl.n	5af4 <eepromemu_flash_write+0x5c>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5afa:	2301      	movs	r3, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    5afc:	491f      	ldr	r1, [pc, #124]	; (5b7c <eepromemu_flash_write+0xe4>)
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5afe:	b2b2      	uxth	r2, r6
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    5b00:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5b04:	616b      	str	r3, [r5, #20]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5b06:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    5b0a:	f8c5 12f0 	str.w	r1, [r5, #752]	; 0x2f0
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    5b0e:	f242 2101 	movw	r1, #8705	; 0x2201
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5b12:	4c18      	ldr	r4, [pc, #96]	; (5b74 <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    5b14:	f8c5 12f4 	str.w	r1, [r5, #756]	; 0x2f4
	FLEXSPI_IPTXFCR = FLEXSPI_IPTXFCR_CLRIPTXF; // clear tx fifo
    5b18:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    5b1c:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5b20:	f8c5 20a4 	str.w	r2, [r5, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5b24:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b28:	4d15      	ldr	r5, [pc, #84]	; (5b80 <eepromemu_flash_write+0xe8>)
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5b2a:	e001      	b.n	5b30 <eepromemu_flash_write+0x98>
		if (n & FLEXSPI_INTR_IPTXWE) {
    5b2c:	065b      	lsls	r3, r3, #25
    5b2e:	d409      	bmi.n	5b44 <eepromemu_flash_write+0xac>
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5b30:	6963      	ldr	r3, [r4, #20]
    5b32:	f013 0001 	ands.w	r0, r3, #1
    5b36:	d0f9      	beq.n	5b2c <eepromemu_flash_write+0x94>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPTXWE;
    5b38:	2341      	movs	r3, #65	; 0x41
    5b3a:	6163      	str	r3, [r4, #20]
}
    5b3c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	flash_wait();
    5b40:	f7ff bf1e 	b.w	5980 <flash_wait>
			if (wrlen > 8) wrlen = 8;
    5b44:	2e08      	cmp	r6, #8
    5b46:	d80a      	bhi.n	5b5e <eepromemu_flash_write+0xc6>
			if (wrlen > 0) {
    5b48:	b136      	cbz	r6, 5b58 <eepromemu_flash_write+0xc0>
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b4a:	4632      	mov	r2, r6
    5b4c:	4639      	mov	r1, r7
				src += wrlen;
    5b4e:	4437      	add	r7, r6
				len -= wrlen;
    5b50:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b52:	4628      	mov	r0, r5
    5b54:	f000 f98e 	bl	5e74 <memcpy>
			FLEXSPI_INTR = FLEXSPI_INTR_IPTXWE;
    5b58:	2340      	movs	r3, #64	; 0x40
    5b5a:	6163      	str	r3, [r4, #20]
    5b5c:	e7e8      	b.n	5b30 <eepromemu_flash_write+0x98>
    5b5e:	f1a6 0008 	sub.w	r0, r6, #8
			if (wrlen > 8) wrlen = 8;
    5b62:	2608      	movs	r6, #8
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b64:	4639      	mov	r1, r7
    5b66:	4632      	mov	r2, r6
				src += wrlen;
    5b68:	4437      	add	r7, r6
				len -= wrlen;
    5b6a:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5b6c:	4628      	mov	r0, r5
    5b6e:	f000 f981 	bl	5e74 <memcpy>
				len -= wrlen;
    5b72:	e7f1      	b.n	5b58 <eepromemu_flash_write+0xc0>
    5b74:	402a8000 	.word	0x402a8000
    5b78:	5af05af0 	.word	0x5af05af0
    5b7c:	08180432 	.word	0x08180432
    5b80:	402a8180 	.word	0x402a8180

00005b84 <eepromemu_flash_erase_sector>:
{
    5b84:	b410      	push	{r4}
	__disable_irq();
    5b86:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5b88:	4b28      	ldr	r3, [pc, #160]	; (5c2c <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5b8a:	2102      	movs	r1, #2
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5b8c:	4c28      	ldr	r4, [pc, #160]	; (5c30 <eepromemu_flash_erase_sector+0xac>)
	FLEXSPI_LUT61 = 0;
    5b8e:	2200      	movs	r2, #0
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5b90:	619c      	str	r4, [r3, #24]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5b92:	f44f 2470 	mov.w	r4, #983040	; 0xf0000
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5b96:	61d9      	str	r1, [r3, #28]
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5b98:	f240 4106 	movw	r1, #1030	; 0x406
    5b9c:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5ba0:	2101      	movs	r1, #1
	FLEXSPI_LUT61 = 0;
    5ba2:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    5ba6:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    5baa:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR0 = 0;
    5bae:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    5bb2:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5bb6:	f8c3 40a4 	str.w	r4, [r3, #164]	; 0xa4
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    5bba:	4002      	ands	r2, r0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5bbc:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
	asm("dsb");
    5bc0:	f3bf 8f4f 	dsb	sy
	uint32_t end_addr = (uint32_t)addr + size;
    5bc4:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
    5bc8:	f102 0320 	add.w	r3, r2, #32
		SCB_CACHE_DCIMVAC = location;
    5bcc:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
    5bd0:	4299      	cmp	r1, r3
    5bd2:	bf34      	ite	cc
    5bd4:	2101      	movcc	r1, #1
    5bd6:	2180      	movcs	r1, #128	; 0x80
    5bd8:	eb02 1141 	add.w	r1, r2, r1, lsl #5
	} while (location < end_addr);
    5bdc:	428b      	cmp	r3, r1
		SCB_CACHE_DCIMVAC = location;
    5bde:	f8cc 2f5c 	str.w	r2, [ip, #3932]	; 0xf5c
		location += 32;
    5be2:	461a      	mov	r2, r3
	} while (location < end_addr);
    5be4:	f103 0320 	add.w	r3, r3, #32
    5be8:	d1f8      	bne.n	5bdc <eepromemu_flash_erase_sector+0x58>
	asm("dsb");
    5bea:	f3bf 8f4f 	dsb	sy
	asm("isb");
    5bee:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5bf2:	4a0e      	ldr	r2, [pc, #56]	; (5c2c <eepromemu_flash_erase_sector+0xa8>)
    5bf4:	6953      	ldr	r3, [r2, #20]
    5bf6:	07d9      	lsls	r1, r3, #31
    5bf8:	d5fc      	bpl.n	5bf4 <eepromemu_flash_erase_sector+0x70>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5bfa:	2401      	movs	r4, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    5bfc:	490d      	ldr	r1, [pc, #52]	; (5c34 <eepromemu_flash_erase_sector+0xb0>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    5bfe:	4b0e      	ldr	r3, [pc, #56]	; (5c38 <eepromemu_flash_erase_sector+0xb4>)
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5c00:	6154      	str	r4, [r2, #20]
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    5c02:	4003      	ands	r3, r0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    5c04:	f8c2 12f0 	str.w	r1, [r2, #752]	; 0x2f0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5c08:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5c0c:	4907      	ldr	r1, [pc, #28]	; (5c2c <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    5c0e:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5c12:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5c16:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5c1a:	694b      	ldr	r3, [r1, #20]
    5c1c:	07db      	lsls	r3, r3, #31
    5c1e:	d5fc      	bpl.n	5c1a <eepromemu_flash_erase_sector+0x96>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5c20:	2301      	movs	r3, #1
}
    5c22:	f85d 4b04 	ldr.w	r4, [sp], #4
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5c26:	614b      	str	r3, [r1, #20]
	flash_wait();
    5c28:	f7ff beaa 	b.w	5980 <flash_wait>
    5c2c:	402a8000 	.word	0x402a8000
    5c30:	5af05af0 	.word	0x5af05af0
    5c34:	08180420 	.word	0x08180420
    5c38:	00fff000 	.word	0x00fff000

00005c3c <eeprom_write_byte>:
	if (addr > E2END) return;
    5c3c:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    5c40:	f080 8086 	bcs.w	5d50 <eeprom_write_byte+0x114>
	if (!initialized) eeprom_initialize();
    5c44:	4b44      	ldr	r3, [pc, #272]	; (5d58 <eeprom_write_byte+0x11c>)
{
    5c46:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!initialized) eeprom_initialize();
    5c4a:	781b      	ldrb	r3, [r3, #0]
{
    5c4c:	b0c2      	sub	sp, #264	; 0x108
    5c4e:	4605      	mov	r5, r0
    5c50:	4689      	mov	r9, r1
	if (!initialized) eeprom_initialize();
    5c52:	2b00      	cmp	r3, #0
    5c54:	d079      	beq.n	5d4a <eeprom_write_byte+0x10e>
	sector = (addr >> 2) % FLASH_SECTORS; 
    5c56:	08ab      	lsrs	r3, r5, #2
    5c58:	4e40      	ldr	r6, [pc, #256]	; (5d5c <eeprom_write_byte+0x120>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5c5a:	f005 0503 	and.w	r5, r5, #3
	end = p + sector_index[sector];
    5c5e:	4f40      	ldr	r7, [pc, #256]	; (5d60 <eeprom_write_byte+0x124>)
	sector = (addr >> 2) % FLASH_SECTORS; 
    5c60:	fba6 2603 	umull	r2, r6, r6, r3
    5c64:	08f6      	lsrs	r6, r6, #3
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5c66:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
	sector = (addr >> 2) % FLASH_SECTORS; 
    5c6a:	ebc6 1606 	rsb	r6, r6, r6, lsl #4
    5c6e:	1b9e      	subs	r6, r3, r6
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5c70:	4b3c      	ldr	r3, [pc, #240]	; (5d64 <eeprom_write_byte+0x128>)
	end = p + sector_index[sector];
    5c72:	f837 4016 	ldrh.w	r4, [r7, r6, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5c76:	4433      	add	r3, r6
	end = p + sector_index[sector];
    5c78:	0060      	lsls	r0, r4, #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5c7a:	ea4f 3803 	mov.w	r8, r3, lsl #12
	end = p + sector_index[sector];
    5c7e:	eb00 3003 	add.w	r0, r0, r3, lsl #12
	while (p < end) {
    5c82:	ebb0 3f03 	cmp.w	r0, r3, lsl #12
    5c86:	d964      	bls.n	5d52 <eeprom_write_byte+0x116>
    5c88:	4643      	mov	r3, r8
	uint8_t olddata=0xFF;
    5c8a:	f04f 0cff 	mov.w	ip, #255	; 0xff
		uint16_t val = *p++;
    5c8e:	881a      	ldrh	r2, [r3, #0]
    5c90:	3302      	adds	r3, #2
		if ((val & 255) == offset) olddata = val >> 8;
    5c92:	b2d1      	uxtb	r1, r2
    5c94:	42a9      	cmp	r1, r5
    5c96:	bf08      	it	eq
    5c98:	ea4f 2c12 	moveq.w	ip, r2, lsr #8
	while (p < end) {
    5c9c:	4298      	cmp	r0, r3
    5c9e:	d8f6      	bhi.n	5c8e <eeprom_write_byte+0x52>
	if (data == olddata) return;
    5ca0:	45e1      	cmp	r9, ip
    5ca2:	d041      	beq.n	5d28 <eeprom_write_byte+0xec>
	if (sector_index[sector] < 2048) {
    5ca4:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
    5ca8:	d341      	bcc.n	5d2e <eeprom_write_byte+0xf2>
		memset(buf, 0xFF, sizeof(buf));
    5caa:	ac02      	add	r4, sp, #8
    5cac:	f44f 7280 	mov.w	r2, #256	; 0x100
    5cb0:	21ff      	movs	r1, #255	; 0xff
    5cb2:	4620      	mov	r0, r4
    5cb4:	f001 fee8 	bl	7a88 <memset>
		while (p < end) {
    5cb8:	f508 5080 	add.w	r0, r8, #4096	; 0x1000
    5cbc:	f108 0302 	add.w	r3, r8, #2
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5cc0:	4642      	mov	r2, r8
    5cc2:	4298      	cmp	r0, r3
    5cc4:	bf34      	ite	cc
    5cc6:	2001      	movcc	r0, #1
    5cc8:	f44f 6000 	movcs.w	r0, #2048	; 0x800
    5ccc:	eb08 0040 	add.w	r0, r8, r0, lsl #1
			uint16_t val = *p++;
    5cd0:	4613      	mov	r3, r2
    5cd2:	3202      	adds	r2, #2
    5cd4:	881b      	ldrh	r3, [r3, #0]
		while (p < end) {
    5cd6:	4282      	cmp	r2, r0
			buf[val & 255] = val >> 8;
    5cd8:	b2d9      	uxtb	r1, r3
    5cda:	ea4f 2313 	mov.w	r3, r3, lsr #8
    5cde:	5463      	strb	r3, [r4, r1]
		while (p < end) {
    5ce0:	d1f6      	bne.n	5cd0 <eeprom_write_byte+0x94>
		buf[offset] = data;
    5ce2:	f804 9005 	strb.w	r9, [r4, r5]
		eepromemu_flash_erase_sector(p);
    5ce6:	f10d 0907 	add.w	r9, sp, #7
    5cea:	f20d 1a07 	addw	sl, sp, #263	; 0x107
		index = 0;
    5cee:	2500      	movs	r5, #0
		eepromemu_flash_erase_sector(p);
    5cf0:	464c      	mov	r4, r9
    5cf2:	4640      	mov	r0, r8
    5cf4:	f7ff ff46 	bl	5b84 <eepromemu_flash_erase_sector>
			if (buf[i] != 0xFF) {
    5cf8:	f814 cf01 	ldrb.w	ip, [r4, #1]!
				eepromemu_flash_write(p + index, &newval, 2);
    5cfc:	eb08 0045 	add.w	r0, r8, r5, lsl #1
    5d00:	2202      	movs	r2, #2
    5d02:	f10d 0106 	add.w	r1, sp, #6
				uint16_t newval = i | (buf[i] << 8);
    5d06:	1e63      	subs	r3, r4, #1
			if (buf[i] != 0xFF) {
    5d08:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
				uint16_t newval = i | (buf[i] << 8);
    5d0c:	eba3 0309 	sub.w	r3, r3, r9
			if (buf[i] != 0xFF) {
    5d10:	d006      	beq.n	5d20 <eeprom_write_byte+0xe4>
				uint16_t newval = i | (buf[i] << 8);
    5d12:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
				index = index + 1;
    5d16:	3501      	adds	r5, #1
				uint16_t newval = i | (buf[i] << 8);
    5d18:	f8ad 3006 	strh.w	r3, [sp, #6]
				eepromemu_flash_write(p + index, &newval, 2);
    5d1c:	f7ff febc 	bl	5a98 <eepromemu_flash_write>
		for (i=0; i < 256; i++) {
    5d20:	45a2      	cmp	sl, r4
    5d22:	d1e9      	bne.n	5cf8 <eeprom_write_byte+0xbc>
		sector_index[sector] = index;
    5d24:	f827 5016 	strh.w	r5, [r7, r6, lsl #1]
}
    5d28:	b042      	add	sp, #264	; 0x108
    5d2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint16_t newdata = offset | (data << 8);
    5d2e:	ea45 2509 	orr.w	r5, r5, r9, lsl #8
		eepromemu_flash_write(end, &newdata, 2);
    5d32:	a902      	add	r1, sp, #8
    5d34:	2202      	movs	r2, #2
		sector_index[sector] = sector_index[sector] + 1;
    5d36:	3401      	adds	r4, #1
		uint16_t newdata = offset | (data << 8);
    5d38:	f8ad 5008 	strh.w	r5, [sp, #8]
		eepromemu_flash_write(end, &newdata, 2);
    5d3c:	f7ff feac 	bl	5a98 <eepromemu_flash_write>
		sector_index[sector] = sector_index[sector] + 1;
    5d40:	f827 4016 	strh.w	r4, [r7, r6, lsl #1]
}
    5d44:	b042      	add	sp, #264	; 0x108
    5d46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!initialized) eeprom_initialize();
    5d4a:	f7ff fe47 	bl	59dc <eeprom_initialize>
    5d4e:	e782      	b.n	5c56 <eeprom_write_byte+0x1a>
    5d50:	4770      	bx	lr
	uint8_t olddata=0xFF;
    5d52:	f04f 0cff 	mov.w	ip, #255	; 0xff
    5d56:	e7a3      	b.n	5ca0 <eeprom_write_byte+0x64>
    5d58:	20006ae0 	.word	0x20006ae0
    5d5c:	88888889 	.word	0x88888889
    5d60:	20006930 	.word	0x20006930
    5d64:	000601f0 	.word	0x000601f0

00005d68 <dummy_isr>:
static void dummy_isr() {};
    5d68:	4770      	bx	lr
    5d6a:	bf00      	nop

00005d6c <attachInterrupt>:

#endif

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    5d6c:	2827      	cmp	r0, #39	; 0x27
    5d6e:	d852      	bhi.n	5e16 <attachInterrupt+0xaa>
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
    5d70:	0100      	lsls	r0, r0, #4
{
    5d72:	b4f0      	push	{r4, r5, r6, r7}
	volatile uint32_t *gpio = portOutputRegister(pin);
    5d74:	4c31      	ldr	r4, [pc, #196]	; (5e3c <attachInterrupt+0xd0>)

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
    5d76:	4d32      	ldr	r5, [pc, #200]	; (5e40 <attachInterrupt+0xd4>)
	volatile uint32_t *gpio = portOutputRegister(pin);
    5d78:	5823      	ldr	r3, [r4, r0]
	switch((uint32_t)gpio) {
    5d7a:	42ab      	cmp	r3, r5
    5d7c:	d050      	beq.n	5e20 <attachInterrupt+0xb4>
    5d7e:	d843      	bhi.n	5e08 <attachInterrupt+0x9c>
    5d80:	f1b3 4f84 	cmp.w	r3, #1107296256	; 0x42000000
    5d84:	d045      	beq.n	5e12 <attachInterrupt+0xa6>
    5d86:	f5a5 4580 	sub.w	r5, r5, #16384	; 0x4000
    5d8a:	42ab      	cmp	r3, r5
    5d8c:	d13a      	bne.n	5e04 <attachInterrupt+0x98>
    5d8e:	4d2d      	ldr	r5, [pc, #180]	; (5e44 <attachInterrupt+0xd8>)
	volatile uint32_t *mux = portConfigRegister(pin);
    5d90:	4404      	add	r4, r0
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    5d92:	4e2d      	ldr	r6, [pc, #180]	; (5e48 <attachInterrupt+0xdc>)
    5d94:	482d      	ldr	r0, [pc, #180]	; (5e4c <attachInterrupt+0xe0>)
    5d96:	6867      	ldr	r7, [r4, #4]
    5d98:	f8c0 62b4 	str.w	r6, [r0, #692]	; 0x2b4
	uint32_t mask = digitalPinToBitMask(pin);
    5d9c:	68e0      	ldr	r0, [r4, #12]
		default:
			return;
	}

	attachInterruptVector(IRQ_GPIO6789, &irq_gpio6789);
	NVIC_ENABLE_IRQ(IRQ_GPIO6789);
    5d9e:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
    5da2:	f04f 5600 	mov.w	r6, #536870912	; 0x20000000
    5da6:	2a04      	cmp	r2, #4
    5da8:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110

#endif

	uint32_t icr;
	switch (mode) {
    5dac:	d82a      	bhi.n	5e04 <attachInterrupt+0x98>
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    5dae:	695c      	ldr	r4, [r3, #20]
    5db0:	ea24 0400 	bic.w	r4, r4, r0
    5db4:	615c      	str	r4, [r3, #20]
	*mux = 5;		// pin is GPIO
    5db6:	f04f 0405 	mov.w	r4, #5
    5dba:	603c      	str	r4, [r7, #0]
	gpio[GDIR_INDEX] &= ~mask;	// pin to input mode
    5dbc:	685c      	ldr	r4, [r3, #4]
    5dbe:	ea24 0400 	bic.w	r4, r4, r0
    5dc2:	605c      	str	r4, [r3, #4]
    5dc4:	4c22      	ldr	r4, [pc, #136]	; (5e50 <attachInterrupt+0xe4>)
    5dc6:	f854 4022 	ldr.w	r4, [r4, r2, lsl #2]
	uint32_t index = __builtin_ctz(mask);
    5dca:	fa90 f2a0 	rbit	r2, r0
    5dce:	fab2 f282 	clz	r2, r2
	table[index] = function;
    5dd2:	f845 1022 	str.w	r1, [r5, r2, lsl #2]
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    5dd6:	ea6f 0100 	mvn.w	r1, r0
	if (mode == CHANGE) {
    5dda:	d01d      	beq.n	5e18 <attachInterrupt+0xac>
		gpio[EDGE_INDEX] |= mask;
	} else {
		gpio[EDGE_INDEX] &= ~mask;
    5ddc:	69dd      	ldr	r5, [r3, #28]
		if (index < 16) {
    5dde:	2a0f      	cmp	r2, #15
		gpio[EDGE_INDEX] &= ~mask;
    5de0:	ea01 0105 	and.w	r1, r1, r5
    5de4:	61d9      	str	r1, [r3, #28]
		if (index < 16) {
    5de6:	dc1d      	bgt.n	5e24 <attachInterrupt+0xb8>
			uint32_t shift = index * 2;
    5de8:	0052      	lsls	r2, r2, #1
			gpio[ICR1_INDEX] = (gpio[ICR1_INDEX] & ~(3 << shift)) | (icr << shift);
    5dea:	2503      	movs	r5, #3
    5dec:	68d9      	ldr	r1, [r3, #12]
    5dee:	4094      	lsls	r4, r2
    5df0:	fa05 f202 	lsl.w	r2, r5, r2
    5df4:	ea21 0202 	bic.w	r2, r1, r2
    5df8:	4322      	orrs	r2, r4
    5dfa:	60da      	str	r2, [r3, #12]
		} else {
			uint32_t shift = (index - 16) * 2;
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
		}
	}
	gpio[ISR_INDEX] = mask;  // clear any prior pending interrupt
    5dfc:	6198      	str	r0, [r3, #24]
	gpio[IMR_INDEX] |= mask; // enable interrupt
    5dfe:	695a      	ldr	r2, [r3, #20]
    5e00:	4302      	orrs	r2, r0
    5e02:	615a      	str	r2, [r3, #20]
}
    5e04:	bcf0      	pop	{r4, r5, r6, r7}
    5e06:	4770      	bx	lr
	switch((uint32_t)gpio) {
    5e08:	4d12      	ldr	r5, [pc, #72]	; (5e54 <attachInterrupt+0xe8>)
    5e0a:	42ab      	cmp	r3, r5
    5e0c:	d1fa      	bne.n	5e04 <attachInterrupt+0x98>
			table = isr_table_gpio4;
    5e0e:	4d12      	ldr	r5, [pc, #72]	; (5e58 <attachInterrupt+0xec>)
    5e10:	e7be      	b.n	5d90 <attachInterrupt+0x24>
			table = isr_table_gpio1;
    5e12:	4d12      	ldr	r5, [pc, #72]	; (5e5c <attachInterrupt+0xf0>)
    5e14:	e7bc      	b.n	5d90 <attachInterrupt+0x24>
    5e16:	4770      	bx	lr
		gpio[EDGE_INDEX] |= mask;
    5e18:	69da      	ldr	r2, [r3, #28]
    5e1a:	4302      	orrs	r2, r0
    5e1c:	61da      	str	r2, [r3, #28]
    5e1e:	e7ed      	b.n	5dfc <attachInterrupt+0x90>
			table = isr_table_gpio3;
    5e20:	4d0f      	ldr	r5, [pc, #60]	; (5e60 <attachInterrupt+0xf4>)
    5e22:	e7b5      	b.n	5d90 <attachInterrupt+0x24>
			uint32_t shift = (index - 16) * 2;
    5e24:	3a10      	subs	r2, #16
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    5e26:	2503      	movs	r5, #3
    5e28:	6919      	ldr	r1, [r3, #16]
			uint32_t shift = (index - 16) * 2;
    5e2a:	0052      	lsls	r2, r2, #1
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    5e2c:	4094      	lsls	r4, r2
    5e2e:	fa05 f202 	lsl.w	r2, r5, r2
    5e32:	ea21 0202 	bic.w	r2, r1, r2
    5e36:	4322      	orrs	r2, r4
    5e38:	611a      	str	r2, [r3, #16]
    5e3a:	e7df      	b.n	5dfc <attachInterrupt+0x90>
    5e3c:	200006bc 	.word	0x200006bc
    5e40:	42008000 	.word	0x42008000
    5e44:	20000b70 	.word	0x20000b70
    5e48:	00000021 	.word	0x00000021
    5e4c:	20001000 	.word	0x20001000
    5e50:	200002d8 	.word	0x200002d8
    5e54:	4200c000 	.word	0x4200c000
    5e58:	20000c70 	.word	0x20000c70
    5e5c:	20000af0 	.word	0x20000af0
    5e60:	20000bf0 	.word	0x20000bf0

00005e64 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    5e64:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    5e66:	f7fa f95d 	bl	124 <setup>
	while (1) {
		loop();
    5e6a:	f7fa f9fb 	bl	264 <loop>
		yield();
    5e6e:	f001 fb8b 	bl	7588 <yield>
	while (1) {
    5e72:	e7fa      	b.n	5e6a <main+0x6>

00005e74 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    5e74:	4684      	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    5e76:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    5e7a:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    5e7e:	d16d      	bne.n	5f5c <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5e80:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    5e82:	d341      	bcc.n	5f08 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    5e84:	f851 3b04 	ldr.w	r3, [r1], #4
    5e88:	f840 3b04 	str.w	r3, [r0], #4
    5e8c:	f851 3b04 	ldr.w	r3, [r1], #4
    5e90:	f840 3b04 	str.w	r3, [r0], #4
    5e94:	f851 3b04 	ldr.w	r3, [r1], #4
    5e98:	f840 3b04 	str.w	r3, [r0], #4
    5e9c:	f851 3b04 	ldr.w	r3, [r1], #4
    5ea0:	f840 3b04 	str.w	r3, [r0], #4
    5ea4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ea8:	f840 3b04 	str.w	r3, [r0], #4
    5eac:	f851 3b04 	ldr.w	r3, [r1], #4
    5eb0:	f840 3b04 	str.w	r3, [r0], #4
    5eb4:	f851 3b04 	ldr.w	r3, [r1], #4
    5eb8:	f840 3b04 	str.w	r3, [r0], #4
    5ebc:	f851 3b04 	ldr.w	r3, [r1], #4
    5ec0:	f840 3b04 	str.w	r3, [r0], #4
    5ec4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ec8:	f840 3b04 	str.w	r3, [r0], #4
    5ecc:	f851 3b04 	ldr.w	r3, [r1], #4
    5ed0:	f840 3b04 	str.w	r3, [r0], #4
    5ed4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ed8:	f840 3b04 	str.w	r3, [r0], #4
    5edc:	f851 3b04 	ldr.w	r3, [r1], #4
    5ee0:	f840 3b04 	str.w	r3, [r0], #4
    5ee4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ee8:	f840 3b04 	str.w	r3, [r0], #4
    5eec:	f851 3b04 	ldr.w	r3, [r1], #4
    5ef0:	f840 3b04 	str.w	r3, [r0], #4
    5ef4:	f851 3b04 	ldr.w	r3, [r1], #4
    5ef8:	f840 3b04 	str.w	r3, [r0], #4
    5efc:	f851 3b04 	ldr.w	r3, [r1], #4
    5f00:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    5f04:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    5f06:	d2bd      	bcs.n	5e84 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    5f08:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    5f0a:	d311      	bcc.n	5f30 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    5f0c:	f851 3b04 	ldr.w	r3, [r1], #4
    5f10:	f840 3b04 	str.w	r3, [r0], #4
    5f14:	f851 3b04 	ldr.w	r3, [r1], #4
    5f18:	f840 3b04 	str.w	r3, [r0], #4
    5f1c:	f851 3b04 	ldr.w	r3, [r1], #4
    5f20:	f840 3b04 	str.w	r3, [r0], #4
    5f24:	f851 3b04 	ldr.w	r3, [r1], #4
    5f28:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    5f2c:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    5f2e:	d2ed      	bcs.n	5f0c <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    5f30:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    5f32:	d305      	bcc.n	5f40 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    5f34:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    5f38:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    5f3c:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    5f3e:	d2f9      	bcs.n	5f34 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    5f40:	3204      	adds	r2, #4
	beq	.Ldone
    5f42:	d008      	beq.n	5f56 <memcpy+0xe2>

	lsls	r2, r2, #31
    5f44:	07d2      	lsls	r2, r2, #31
	itt ne
    5f46:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5f48:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    5f4c:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    5f50:	d301      	bcc.n	5f56 <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    5f52:	880b      	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    5f54:	8003      	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    5f56:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    5f58:	4770      	bx	lr
    5f5a:	bf00      	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    5f5c:	2a08      	cmp	r2, #8
	blo	.Lbyte_copy
    5f5e:	d313      	bcc.n	5f88 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    5f60:	078b      	lsls	r3, r1, #30
	beq	.Ldst_aligned
    5f62:	d08d      	beq.n	5e80 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    5f64:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    5f68:	d08a      	beq.n	5e80 <memcpy+0xc>

	rsb	r3, #4
    5f6a:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    5f6e:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    5f70:	07db      	lsls	r3, r3, #31
	itt ne
    5f72:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    5f74:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    5f78:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    5f7c:	d380      	bcc.n	5e80 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    5f7e:	f831 3b02 	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    5f82:	f820 3b02 	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    5f86:	e77b      	b.n	5e80 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    5f88:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    5f8a:	d3d9      	bcc.n	5f40 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    5f8c:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    5f8e:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    5f92:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    5f96:	d2f9      	bcs.n	5f8c <memcpy+0x118>

	ldrb	r3, [r1]
    5f98:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    5f9a:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    5f9c:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    5f9e:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    5fa0:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    5fa2:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    5fa4:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    5fa6:	4770      	bx	lr

00005fa8 <ultoa>:


char * ultoa(unsigned long val, char *buf, int radix)
{
	unsigned digit;
	int i=0, j;
    5fa8:	f101 3cff 	add.w	ip, r1, #4294967295
{
    5fac:	b570      	push	{r4, r5, r6, lr}
	char t;

	while (1) {
		digit = val % radix;
    5fae:	4666      	mov	r6, ip
	int i=0, j;
    5fb0:	2400      	movs	r4, #0
    5fb2:	e000      	b.n	5fb6 <ultoa+0xe>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    5fb4:	3401      	adds	r4, #1
		digit = val % radix;
    5fb6:	fbb0 f5f2 	udiv	r5, r0, r2
    5fba:	fb02 0315 	mls	r3, r2, r5, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5fbe:	2b09      	cmp	r3, #9
    5fc0:	f103 0e37 	add.w	lr, r3, #55	; 0x37
    5fc4:	f103 0330 	add.w	r3, r3, #48	; 0x30
    5fc8:	fa5f fe8e 	uxtb.w	lr, lr
    5fcc:	bf98      	it	ls
    5fce:	fa5f fe83 	uxtbls.w	lr, r3
		if (val == 0) break;
    5fd2:	4290      	cmp	r0, r2
		val /= radix;
    5fd4:	4628      	mov	r0, r5
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5fd6:	f806 ef01 	strb.w	lr, [r6, #1]!
		if (val == 0) break;
    5fda:	d2eb      	bcs.n	5fb4 <ultoa+0xc>
	}
	buf[i + 1] = 0;
    5fdc:	1c63      	adds	r3, r4, #1
    5fde:	2200      	movs	r2, #0
    5fe0:	18c8      	adds	r0, r1, r3
    5fe2:	54ca      	strb	r2, [r1, r3]
	for (j=0; j < i; j++, i--) {
    5fe4:	b17c      	cbz	r4, 6006 <ultoa+0x5e>
		t = buf[j];
    5fe6:	4662      	mov	r2, ip
    5fe8:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
		buf[j] = buf[i];
    5fec:	f810 6d01 	ldrb.w	r6, [r0, #-1]!
	for (j=0; j < i; j++, i--) {
    5ff0:	eba1 030c 	sub.w	r3, r1, ip
    5ff4:	3202      	adds	r2, #2
		buf[j] = buf[i];
    5ff6:	f88c 6000 	strb.w	r6, [ip]
	for (j=0; j < i; j++, i--) {
    5ffa:	3b01      	subs	r3, #1
    5ffc:	1a52      	subs	r2, r2, r1
		buf[i] = t;
    5ffe:	7005      	strb	r5, [r0, #0]
	for (j=0; j < i; j++, i--) {
    6000:	4423      	add	r3, r4
    6002:	429a      	cmp	r2, r3
    6004:	dbef      	blt.n	5fe6 <ultoa+0x3e>
	}
	return buf;
}
    6006:	4608      	mov	r0, r1
    6008:	bd70      	pop	{r4, r5, r6, pc}
    600a:	bf00      	nop

0000600c <flexpwmWrite>:

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    600c:	f04f 0c01 	mov.w	ip, #1
    6010:	fa0c fc01 	lsl.w	ip, ip, r1
	uint32_t modulo = p->SM[submodule].VAL1;
    6014:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6018:	eb00 1141 	add.w	r1, r0, r1, lsl #5
{
    601c:	b570      	push	{r4, r5, r6, lr}
	uint32_t modulo = p->SM[submodule].VAL1;
    601e:	f8b1 e00e 	ldrh.w	lr, [r1, #14]
	uint16_t mask = 1 << submodule;
    6022:	fa1f f58c 	uxth.w	r5, ip
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6026:	4c25      	ldr	r4, [pc, #148]	; (60bc <flexpwmWrite+0xb0>)
	uint32_t modulo = p->SM[submodule].VAL1;
    6028:	fa1f fe8e 	uxth.w	lr, lr
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    602c:	7824      	ldrb	r4, [r4, #0]
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    602e:	012e      	lsls	r6, r5, #4
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6030:	fb0e 3303 	mla	r3, lr, r3, r3
    6034:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    6038:	40e3      	lsrs	r3, r4
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    603a:	f8b0 4188 	ldrh.w	r4, [r0, #392]	; 0x188
    603e:	4573      	cmp	r3, lr
    6040:	b2a4      	uxth	r4, r4
    6042:	bf28      	it	cs
    6044:	4673      	movcs	r3, lr
    6046:	4334      	orrs	r4, r6
	switch (channel) {
    6048:	2a01      	cmp	r2, #1
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    604a:	f8a0 4188 	strh.w	r4, [r0, #392]	; 0x188
	switch (channel) {
    604e:	d00d      	beq.n	606c <flexpwmWrite+0x60>
    6050:	2a02      	cmp	r2, #2
    6052:	d028      	beq.n	60a6 <flexpwmWrite+0x9a>
    6054:	b1c2      	cbz	r2, 6088 <flexpwmWrite+0x7c>
    6056:	f00c 020f 	and.w	r2, ip, #15
	  case 2: // B
		p->SM[submodule].VAL5 = cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
		//printf(" write channel B\n");
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    605a:	f8b0 c188 	ldrh.w	ip, [r0, #392]	; 0x188
    605e:	fa1f fc8c 	uxth.w	ip, ip
    6062:	ea4c 0c02 	orr.w	ip, ip, r2
    6066:	f8a0 c188 	strh.w	ip, [r0, #392]	; 0x188
}
    606a:	bd70      	pop	{r4, r5, r6, pc}
		p->SM[submodule].VAL3 = cval;
    606c:	b29b      	uxth	r3, r3
    606e:	f00c 020f 	and.w	r2, ip, #15
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    6072:	022d      	lsls	r5, r5, #8
		p->SM[submodule].VAL3 = cval;
    6074:	82cb      	strh	r3, [r1, #22]
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    6076:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    607a:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
    607e:	b29b      	uxth	r3, r3
    6080:	432b      	orrs	r3, r5
    6082:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    6086:	e7e8      	b.n	605a <flexpwmWrite+0x4e>
		p->SM[submodule].VAL0 = modulo - cval;
    6088:	ebae 0e03 	sub.w	lr, lr, r3
    608c:	f00c 020f 	and.w	r2, ip, #15
    6090:	fa1f fe8e 	uxth.w	lr, lr
    6094:	f8a1 e00a 	strh.w	lr, [r1, #10]
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
    6098:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    609c:	b29b      	uxth	r3, r3
    609e:	4313      	orrs	r3, r2
    60a0:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    60a4:	e7d9      	b.n	605a <flexpwmWrite+0x4e>
		p->SM[submodule].VAL5 = cval;
    60a6:	b29b      	uxth	r3, r3
    60a8:	f00c 020f 	and.w	r2, ip, #15
    60ac:	83cb      	strh	r3, [r1, #30]
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
    60ae:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    60b2:	b29b      	uxth	r3, r3
    60b4:	431e      	orrs	r6, r3
    60b6:	f8a0 6180 	strh.w	r6, [r0, #384]	; 0x180
    60ba:	e7ce      	b.n	605a <flexpwmWrite+0x4e>
    60bc:	20000d46 	.word	0x20000d46

000060c0 <analogWrite>:

void analogWrite(uint8_t pin, int val)
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
    60c0:	2827      	cmp	r0, #39	; 0x27
    60c2:	d84b      	bhi.n	615c <analogWrite+0x9c>
{
    60c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    60c6:	4d2a      	ldr	r5, [pc, #168]	; (6170 <analogWrite+0xb0>)
    60c8:	4604      	mov	r4, r0
	if (info->type == 1) {
    60ca:	f815 2020 	ldrb.w	r2, [r5, r0, lsl #2]
	info = pwm_pin_info + pin;
    60ce:	eb05 0580 	add.w	r5, r5, r0, lsl #2
	if (info->type == 1) {
    60d2:	2a01      	cmp	r2, #1
    60d4:	d02d      	beq.n	6132 <analogWrite+0x72>
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
    60d6:	2a02      	cmp	r2, #2
    60d8:	d13f      	bne.n	615a <analogWrite+0x9a>
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    60da:	786b      	ldrb	r3, [r5, #1]
    60dc:	f3c3 1001 	ubfx	r0, r3, #4, #2
    60e0:	2803      	cmp	r0, #3
    60e2:	d03e      	beq.n	6162 <analogWrite+0xa2>
    60e4:	4a23      	ldr	r2, [pc, #140]	; (6174 <analogWrite+0xb4>)
    60e6:	eb02 3280 	add.w	r2, r2, r0, lsl #14
		  case 0: qtimer = &IMXRT_TMR1; break;
		  case 1: qtimer = &IMXRT_TMR2; break;
		  case 2: qtimer = &IMXRT_TMR3; break;
		  default: qtimer = &IMXRT_TMR4;
		}
		quadtimerWrite(qtimer, info->module & 0x03, val);
    60ea:	f003 0c03 	and.w	ip, r3, #3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    60ee:	4822      	ldr	r0, [pc, #136]	; (6178 <analogWrite+0xb8>)
    60f0:	b289      	uxth	r1, r1
    60f2:	4663      	mov	r3, ip
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    60f4:	eb02 1c4c 	add.w	ip, r2, ip, lsl #5
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    60f8:	7806      	ldrb	r6, [r0, #0]
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    60fa:	f8bc e006 	ldrh.w	lr, [ip, #6]
    60fe:	0158      	lsls	r0, r3, #5
    6100:	f8bc 3010 	ldrh.w	r3, [ip, #16]
    6104:	fa1f fe8e 	uxth.w	lr, lr
    6108:	f1ce 1e01 	rsb	lr, lr, #65537	; 0x10001
    610c:	fa1e f383 	uxtah	r3, lr, r3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    6110:	f103 3eff 	add.w	lr, r3, #4294967295
    6114:	fb0e f101 	mul.w	r1, lr, r1
    6118:	40f1      	lsrs	r1, r6
	if (high >= modulo - 1) high = modulo - 2;
    611a:	458e      	cmp	lr, r1
    611c:	d923      	bls.n	6166 <analogWrite+0xa6>
	uint32_t low = modulo - high; // low must 2 or higher
    611e:	1a5b      	subs	r3, r3, r1
	p->CH[submodule].LOAD = 65537 - low;
    6120:	f1c3 0301 	rsb	r3, r3, #1
    6124:	b29b      	uxth	r3, r3
	p->CH[submodule].CMPLD1 = high;
    6126:	b289      	uxth	r1, r1
    6128:	4402      	add	r2, r0
	p->CH[submodule].LOAD = 65537 - low;
    612a:	f8ac 3006 	strh.w	r3, [ip, #6]
	p->CH[submodule].CMPLD1 = high;
    612e:	8211      	strh	r1, [r2, #16]
}
    6130:	e00d      	b.n	614e <analogWrite+0x8e>
		switch ((info->module >> 4) & 3) {
    6132:	786a      	ldrb	r2, [r5, #1]
    6134:	f3c2 1301 	ubfx	r3, r2, #4, #2
    6138:	2b03      	cmp	r3, #3
    613a:	d010      	beq.n	615e <analogWrite+0x9e>
    613c:	480f      	ldr	r0, [pc, #60]	; (617c <analogWrite+0xbc>)
    613e:	eb00 3083 	add.w	r0, r0, r3, lsl #14
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
    6142:	b28b      	uxth	r3, r1
    6144:	f002 0103 	and.w	r1, r2, #3
    6148:	78aa      	ldrb	r2, [r5, #2]
    614a:	f7ff ff5f 	bl	600c <flexpwmWrite>
	} else {
		return;
	}
	*(portConfigRegister(pin)) = info->muxval;
    614e:	4b0c      	ldr	r3, [pc, #48]	; (6180 <analogWrite+0xc0>)
    6150:	78ea      	ldrb	r2, [r5, #3]
    6152:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    6156:	685b      	ldr	r3, [r3, #4]
    6158:	601a      	str	r2, [r3, #0]
	// TODO: pad config register
}
    615a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    615c:	4770      	bx	lr
		switch ((info->module >> 4) & 3) {
    615e:	4809      	ldr	r0, [pc, #36]	; (6184 <analogWrite+0xc4>)
    6160:	e7ef      	b.n	6142 <analogWrite+0x82>
		switch ((info->module >> 4) & 3) {
    6162:	4a09      	ldr	r2, [pc, #36]	; (6188 <analogWrite+0xc8>)
    6164:	e7c1      	b.n	60ea <analogWrite+0x2a>
	if (high >= modulo - 1) high = modulo - 2;
    6166:	1e99      	subs	r1, r3, #2
    6168:	f64f 73ff 	movw	r3, #65535	; 0xffff
    616c:	e7db      	b.n	6126 <analogWrite+0x66>
    616e:	bf00      	nop
    6170:	2000093c 	.word	0x2000093c
    6174:	401dc000 	.word	0x401dc000
    6178:	20000d46 	.word	0x20000d46
    617c:	403dc000 	.word	0x403dc000
    6180:	200006bc 	.word	0x200006bc
    6184:	403e8000 	.word	0x403e8000
    6188:	401e8000 	.word	0x401e8000

0000618c <flexpwm_init>:
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    618c:	2300      	movs	r3, #0
	p->FSTS0 = 0x000F; // clear fault status
    618e:	220f      	movs	r2, #15
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    6190:	f248 2cb8 	movw	ip, #33464	; 0x82b8
	for (i=0; i < 4; i++) {
    6194:	4619      	mov	r1, r3
{
    6196:	b510      	push	{r4, lr}
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    6198:	f44f 4470 	mov.w	r4, #61440	; 0xf000
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    619c:	f44f 6e80 	mov.w	lr, #1024	; 0x400
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    61a0:	f8a0 418c 	strh.w	r4, [r0, #396]	; 0x18c
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    61a4:	f44f 4460 	mov.w	r4, #57344	; 0xe000
	p->FSTS0 = 0x000F; // clear fault status
    61a8:	f8a0 218e 	strh.w	r2, [r0, #398]	; 0x18e
		p->SM[i].OCTRL = 0;
    61ac:	460a      	mov	r2, r1
	p->FFILT0 = 0;
    61ae:	f8a0 3190 	strh.w	r3, [r0, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    61b2:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    61b6:	b29b      	uxth	r3, r3
    61b8:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    61bc:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    61c0:	eb01 0341 	add.w	r3, r1, r1, lsl #1
	for (i=0; i < 4; i++) {
    61c4:	3101      	adds	r1, #1
    61c6:	eb00 1343 	add.w	r3, r0, r3, lsl #5
    61ca:	2904      	cmp	r1, #4
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    61cc:	809c      	strh	r4, [r3, #4]
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    61ce:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    61d2:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    61d4:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    61d6:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    61d8:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    61da:	f8a3 c00e 	strh.w	ip, [r3, #14]
		p->SM[i].VAL2 = 0;
    61de:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    61e0:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    61e2:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    61e4:	83da      	strh	r2, [r3, #30]
	for (i=0; i < 4; i++) {
    61e6:	d1eb      	bne.n	61c0 <flexpwm_init+0x34>
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    61e8:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    61ec:	b29b      	uxth	r3, r3
    61ee:	f043 030f 	orr.w	r3, r3, #15
    61f2:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    61f6:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    61fa:	b29b      	uxth	r3, r3
    61fc:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    6200:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
}
    6204:	bd10      	pop	{r4, pc}
    6206:	bf00      	nop

00006208 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6208:	4b37      	ldr	r3, [pc, #220]	; (62e8 <pwm_init+0xe0>)
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    620a:	4a38      	ldr	r2, [pc, #224]	; (62ec <pwm_init+0xe4>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    620c:	6f99      	ldr	r1, [r3, #120]	; 0x78
		CCM_CCGR6_QTIMER3(CCM_CCGR_ON) | CCM_CCGR6_QTIMER4(CCM_CCGR_ON);
	flexpwm_init(&IMXRT_FLEXPWM1);
    620e:	4838      	ldr	r0, [pc, #224]	; (62f0 <pwm_init+0xe8>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6210:	f441 017f 	orr.w	r1, r1, #16711680	; 0xff0000
{
    6214:	b570      	push	{r4, r5, r6, lr}
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6216:	6799      	str	r1, [r3, #120]	; 0x78
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6218:	f241 0601 	movw	r6, #4097	; 0x1001
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    621c:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6220:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6224:	f243 0426 	movw	r4, #12326	; 0x3026
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6228:	430a      	orrs	r2, r1
    622a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	flexpwm_init(&IMXRT_FLEXPWM1);
    622e:	f7ff ffad 	bl	618c <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM2);
    6232:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    6236:	f7ff ffa9 	bl	618c <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM3);
    623a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    623e:	f7ff ffa5 	bl	618c <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM4);
    6242:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    6246:	f7ff ffa1 	bl	618c <flexpwm_init>
	for (i=0; i < 4; i++) {
    624a:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    624c:	f5a0 1003 	sub.w	r0, r0, #2146304	; 0x20c000
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6250:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CTRL = 0; // stop timer
    6254:	4611      	mov	r1, r2
    6256:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    625a:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    625e:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6260:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    6262:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    6264:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6266:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    626a:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    626c:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    626e:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    6272:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6274:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    6276:	d1ee      	bne.n	6256 <pwm_init+0x4e>
    6278:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    627a:	481e      	ldr	r0, [pc, #120]	; (62f4 <pwm_init+0xec>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    627c:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6280:	f241 0601 	movw	r6, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    6284:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6286:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    628a:	f243 0426 	movw	r4, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    628e:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    6292:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    6296:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6298:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    629a:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    629c:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    629e:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    62a2:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    62a4:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    62a6:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    62aa:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    62ac:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    62ae:	d1ee      	bne.n	628e <pwm_init+0x86>
    62b0:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    62b2:	4811      	ldr	r0, [pc, #68]	; (62f8 <pwm_init+0xf0>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    62b4:	260f      	movs	r6, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    62b6:	f241 0501 	movw	r5, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    62ba:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    62bc:	f645 54c0 	movw	r4, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    62c0:	f243 0e26 	movw	lr, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    62c4:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    62c8:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    62cc:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    62ce:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    62d0:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    62d2:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    62d4:	81de      	strh	r6, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    62d6:	829d      	strh	r5, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    62d8:	80dc      	strh	r4, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    62da:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    62de:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    62e0:	f8a3 e00c 	strh.w	lr, [r3, #12]
	for (i=0; i < 4; i++) {
    62e4:	d1ee      	bne.n	62c4 <pwm_init+0xbc>
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    62e6:	bd70      	pop	{r4, r5, r6, pc}
    62e8:	400fc000 	.word	0x400fc000
    62ec:	fc030000 	.word	0xfc030000
    62f0:	403dc000 	.word	0x403dc000
    62f4:	401e0000 	.word	0x401e0000
    62f8:	401e4000 	.word	0x401e4000

000062fc <serialEvent2()>:

#include <Arduino.h>
#include "HardwareSerial.h"
void serialEvent2() __attribute__((weak));
void serialEvent2() {}		// No use calling this so disable if called...
    62fc:	4770      	bx	lr
    62fe:	bf00      	nop

00006300 <unused_interrupt_vector>:
	__disable_irq();
    6300:	b672      	cpsid	i
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    6302:	f3ef 8305 	mrs	r3, IPSR
	info->ipsr = ipsr;
    6306:	4c4f      	ldr	r4, [pc, #316]	; (6444 <unused_interrupt_vector+0x144>)
    6308:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    630c:	f3ef 8208 	mrs	r2, MSP
	info->cfsr = SCB_CFSR;
    6310:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	p = (uint32_t *)info;
    6314:	4e4c      	ldr	r6, [pc, #304]	; (6448 <unused_interrupt_vector+0x148>)
	while (p < end) {
    6316:	4d4d      	ldr	r5, [pc, #308]	; (644c <unused_interrupt_vector+0x14c>)
	info->cfsr = SCB_CFSR;
    6318:	f8d3 0d28 	ldr.w	r0, [r3, #3368]	; 0xd28
	info->hfsr = SCB_HFSR;
    631c:	f8d3 1d2c 	ldr.w	r1, [r3, #3372]	; 0xd2c
    6320:	e9c4 0122 	strd	r0, r1, [r4, #136]	; 0x88
	info->mmfar = SCB_MMFAR;
    6324:	f8d3 1d34 	ldr.w	r1, [r3, #3380]	; 0xd34
	info->bfar = SCB_BFAR;
    6328:	f8d3 3d38 	ldr.w	r3, [r3, #3384]	; 0xd38
    632c:	e9c4 1324 	strd	r1, r3, [r4, #144]	; 0x90
	info->ret = stack[6];
    6330:	6993      	ldr	r3, [r2, #24]
    6332:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	info->xpsr = stack[7];
    6336:	69d3      	ldr	r3, [r2, #28]
    6338:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	info->temp = tempmonGetTemp();
    633c:	f000 f8a2 	bl	6484 <tempmonGetTemp>
    6340:	ed84 0a28 	vstr	s0, [r4, #160]	; 0xa0
	info->time = rtc_get();
    6344:	f001 fb10 	bl	7968 <rtc_get>
	info->len = sizeof(*info) / 4;
    6348:	210b      	movs	r1, #11
	crc = 0xFFFFFFFF;
    634a:	f04f 32ff 	mov.w	r2, #4294967295
	info->time = rtc_get();
    634e:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
	info->len = sizeof(*info) / 4;
    6352:	460b      	mov	r3, r1
    6354:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    6358:	493d      	ldr	r1, [pc, #244]	; (6450 <unused_interrupt_vector+0x150>)
		crc ^= *p++;
    635a:	1d30      	adds	r0, r6, #4
    635c:	405a      	eors	r2, r3
    635e:	2420      	movs	r4, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    6360:	f002 0301 	and.w	r3, r2, #1
    6364:	3c01      	subs	r4, #1
    6366:	fb01 f303 	mul.w	r3, r1, r3
    636a:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    636e:	d1f7      	bne.n	6360 <unused_interrupt_vector+0x60>
	while (p < end) {
    6370:	42a8      	cmp	r0, r5
    6372:	d002      	beq.n	637a <unused_interrupt_vector+0x7a>
		crc ^= *p++;
    6374:	6873      	ldr	r3, [r6, #4]
    6376:	4606      	mov	r6, r0
    6378:	e7ef      	b.n	635a <unused_interrupt_vector+0x5a>
	info->crc = crc;
    637a:	4b32      	ldr	r3, [pc, #200]	; (6444 <unused_interrupt_vector+0x144>)
    637c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    6380:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    6384:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6388:	492f      	ldr	r1, [pc, #188]	; (6448 <unused_interrupt_vector+0x148>)
    638a:	4a32      	ldr	r2, [pc, #200]	; (6454 <unused_interrupt_vector+0x154>)
    638c:	f8c3 1f70 	str.w	r1, [r3, #3952]	; 0xf70
    6390:	f8c3 2f70 	str.w	r2, [r3, #3952]	; 0xf70
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    6394:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6398:	f3bf 8f6f 	isb	sy
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    639c:	4a2e      	ldr	r2, [pc, #184]	; (6458 <unused_interrupt_vector+0x158>)
	PIT_MCR = PIT_MCR_MDIS;
    639e:	2502      	movs	r5, #2
    63a0:	482e      	ldr	r0, [pc, #184]	; (645c <unused_interrupt_vector+0x15c>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    63a2:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    63a4:	492e      	ldr	r1, [pc, #184]	; (6460 <unused_interrupt_vector+0x160>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    63a6:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
    63aa:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    63ac:	6005      	str	r5, [r0, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    63ae:	69d3      	ldr	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    63b0:	482c      	ldr	r0, [pc, #176]	; (6464 <unused_interrupt_vector+0x164>)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    63b2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    63b6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    63ba:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    63bc:	680b      	ldr	r3, [r1, #0]
    63be:	4283      	cmp	r3, r0
    63c0:	d83d      	bhi.n	643e <unused_interrupt_vector+0x13e>
	PIT_MCR = 0;
    63c2:	4d26      	ldr	r5, [pc, #152]	; (645c <unused_interrupt_vector+0x15c>)
    63c4:	2100      	movs	r1, #0
	NVIC_ICER0 = 0xFFFFFFFF;
    63c6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    63ca:	f04f 32ff 	mov.w	r2, #4294967295
	PIT_MCR = 0;
    63ce:	6029      	str	r1, [r5, #0]
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    63d0:	2601      	movs	r6, #1
	PIT_TCTRL0 = 0;
    63d2:	f8c5 1108 	str.w	r1, [r5, #264]	; 0x108
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    63d6:	4924      	ldr	r1, [pc, #144]	; (6468 <unused_interrupt_vector+0x168>)
    63d8:	f8c5 1100 	str.w	r1, [r5, #256]	; 0x100
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    63dc:	f8c5 6108 	str.w	r6, [r5, #264]	; 0x108
	NVIC_ICER0 = 0xFFFFFFFF;
    63e0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	NVIC_ICER1 = 0xFFFFFFFF;
    63e4:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
	NVIC_ICER2 = 0xFFFFFFFF;
    63e8:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
	NVIC_ICER3 = 0xFFFFFFFF;
    63ec:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	NVIC_ICER4 = 0xFFFFFFFF;
    63f0:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
	count = 0;
    63f4:	e001      	b.n	63fa <unused_interrupt_vector+0xfa>
		usb_isr();
    63f6:	f000 f937 	bl	6668 <usb_isr>
		if (PIT_TFLG0) {
    63fa:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    63fe:	2b00      	cmp	r3, #0
    6400:	d0f9      	beq.n	63f6 <unused_interrupt_vector+0xf6>
			if (++count >= 80) break;  // reboot after 8 seconds
    6402:	3401      	adds	r4, #1
			PIT_TFLG0 = 1;
    6404:	f8c5 610c 	str.w	r6, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    6408:	2c4f      	cmp	r4, #79	; 0x4f
    640a:	d9f4      	bls.n	63f6 <unused_interrupt_vector+0xf6>
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    640c:	4b17      	ldr	r3, [pc, #92]	; (646c <unused_interrupt_vector+0x16c>)
	USB1_USBCMD = USB_USBCMD_RST;
    640e:	2002      	movs	r0, #2
    6410:	4917      	ldr	r1, [pc, #92]	; (6470 <unused_interrupt_vector+0x170>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6412:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	USB1_USBCMD = USB_USBCMD_RST;
    6416:	f8c1 0140 	str.w	r0, [r1, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    641a:	635a      	str	r2, [r3, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    641c:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    6420:	b93b      	cbnz	r3, 6432 <unused_interrupt_vector+0x132>
	SRC_GPR5 = 0x0BAD00F1;
    6422:	4814      	ldr	r0, [pc, #80]	; (6474 <unused_interrupt_vector+0x174>)
    6424:	4914      	ldr	r1, [pc, #80]	; (6478 <unused_interrupt_vector+0x178>)
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6426:	4a0d      	ldr	r2, [pc, #52]	; (645c <unused_interrupt_vector+0x15c>)
	SRC_GPR5 = 0x0BAD00F1;
    6428:	6301      	str	r1, [r0, #48]	; 0x30
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    642a:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    642e:	2b00      	cmp	r3, #0
    6430:	d0fa      	beq.n	6428 <unused_interrupt_vector+0x128>
	SCB_AIRCR = 0x05FA0004;
    6432:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6436:	4a11      	ldr	r2, [pc, #68]	; (647c <unused_interrupt_vector+0x17c>)
    6438:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c
	while (1) ;
    643c:	e7fe      	b.n	643c <unused_interrupt_vector+0x13c>
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    643e:	f001 f91b 	bl	7678 <set_arm_clock>
    6442:	e7be      	b.n	63c2 <unused_interrupt_vector+0xc2>
    6444:	2027ff00 	.word	0x2027ff00
    6448:	2027ff80 	.word	0x2027ff80
    644c:	2027ffa8 	.word	0x2027ffa8
    6450:	edb88320 	.word	0xedb88320
    6454:	2027ffa0 	.word	0x2027ffa0
    6458:	400fc000 	.word	0x400fc000
    645c:	40084000 	.word	0x40084000
    6460:	20000a64 	.word	0x20000a64
    6464:	0bcd3d80 	.word	0x0bcd3d80
    6468:	00249f00 	.word	0x00249f00
    646c:	400d9000 	.word	0x400d9000
    6470:	402e0000 	.word	0x402e0000
    6474:	400f8000 	.word	0x400f8000
    6478:	0bad00f1 	.word	0x0bad00f1
    647c:	05fa0004 	.word	0x05fa0004

00006480 <Panic_Temp_isr>:
  unused_interrupt_vector();
    6480:	f7ff bf3e 	b.w	6300 <unused_interrupt_vector>

00006484 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    6484:	4a12      	ldr	r2, [pc, #72]	; (64d0 <tempmonGetTemp+0x4c>)
    6486:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    648a:	075b      	lsls	r3, r3, #29
    648c:	d5fb      	bpl.n	6486 <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    648e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6492:	4810      	ldr	r0, [pc, #64]	; (64d4 <tempmonGetTemp+0x50>)
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6494:	f3c3 230b 	ubfx	r3, r3, #8, #12
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6498:	490f      	ldr	r1, [pc, #60]	; (64d8 <tempmonGetTemp+0x54>)
    649a:	ed90 7a00 	vldr	s14, [r0]
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    649e:	ee07 3a90 	vmov	s15, r3
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    64a2:	ed91 6a00 	vldr	s12, [r1]
    64a6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    64aa:	4a0c      	ldr	r2, [pc, #48]	; (64dc <tempmonGetTemp+0x58>)
    64ac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    64b0:	4b0b      	ldr	r3, [pc, #44]	; (64e0 <tempmonGetTemp+0x5c>)
    64b2:	edd2 6a00 	vldr	s13, [r2]
    64b6:	ee77 7ac7 	vsub.f32	s15, s15, s14
    64ba:	ed93 7a00 	vldr	s14, [r3]
    64be:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    64c2:	ee67 7a86 	vmul.f32	s15, s15, s12
    64c6:	ee87 0aa6 	vdiv.f32	s0, s15, s13

    return tmeas;
}
    64ca:	ee37 0a40 	vsub.f32	s0, s14, s0
    64ce:	4770      	bx	lr
    64d0:	400d8100 	.word	0x400d8100
    64d4:	2000691c 	.word	0x2000691c
    64d8:	20006924 	.word	0x20006924
    64dc:	20006928 	.word	0x20006928
    64e0:	20006920 	.word	0x20006920

000064e4 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    64e4:	6b83      	ldr	r3, [r0, #56]	; 0x38
{
    64e6:	b4f0      	push	{r4, r5, r6, r7}
	if (endpoint->callback_function) {
    64e8:	b11b      	cbz	r3, 64f2 <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    64ea:	6853      	ldr	r3, [r2, #4]
    64ec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    64f0:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    64f2:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    64f4:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    64f6:	b33c      	cbz	r4, 6548 <schedule_transfer+0x64>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    64f8:	4b1a      	ldr	r3, [pc, #104]	; (6564 <schedule_transfer+0x80>)
		last->next = (uint32_t)transfer;
    64fa:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    64fc:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    6500:	420c      	tst	r4, r1
    6502:	d11d      	bne.n	6540 <schedule_transfer+0x5c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    6504:	4e18      	ldr	r6, [pc, #96]	; (6568 <schedule_transfer+0x84>)
    6506:	6877      	ldr	r7, [r6, #4]
    6508:	e004      	b.n	6514 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    650a:	6874      	ldr	r4, [r6, #4]
    650c:	1be4      	subs	r4, r4, r7
    650e:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    6512:	d20b      	bcs.n	652c <schedule_transfer+0x48>
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    6514:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    6518:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    651c:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    6520:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    6524:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    6528:	0464      	lsls	r4, r4, #17
    652a:	d5ee      	bpl.n	650a <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    652c:	400d      	ands	r5, r1
    652e:	d107      	bne.n	6540 <schedule_transfer+0x5c>
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    6530:	4c0c      	ldr	r4, [pc, #48]	; (6564 <schedule_transfer+0x80>)
		endpoint->status = 0;
    6532:	e9c0 2502 	strd	r2, r5, [r0, #8]
		USB1_ENDPTPRIME |= epmask;
    6536:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    653a:	430b      	orrs	r3, r1
    653c:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    6540:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    6542:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    6544:	bcf0      	pop	{r4, r5, r6, r7}
    6546:	4770      	bx	lr
	USB1_ENDPTPRIME |= epmask;
    6548:	4d06      	ldr	r5, [pc, #24]	; (6564 <schedule_transfer+0x80>)
	endpoint->status = 0;
    654a:	e9c0 2402 	strd	r2, r4, [r0, #8]
	USB1_ENDPTPRIME |= epmask;
    654e:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    6552:	430b      	orrs	r3, r1
    6554:	f8c5 31b0 	str.w	r3, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    6558:	6302      	str	r2, [r0, #48]	; 0x30
	endpoint->last_transfer = transfer;
    655a:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    655c:	b662      	cpsie	i
}
    655e:	bcf0      	pop	{r4, r5, r6, r7}
    6560:	4770      	bx	lr
    6562:	bf00      	nop
    6564:	402e0000 	.word	0x402e0000
    6568:	e0001000 	.word	0xe0001000

0000656c <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    656c:	b570      	push	{r4, r5, r6, lr}
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    656e:	6b05      	ldr	r5, [r0, #48]	; 0x30
	if (first == NULL) return;
    6570:	b19d      	cbz	r5, 659a <run_callbacks+0x2e>
    6572:	4606      	mov	r6, r0
    6574:	462a      	mov	r2, r5

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
    6576:	2400      	movs	r4, #0
    6578:	e003      	b.n	6582 <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    657a:	6812      	ldr	r2, [r2, #0]
		count++;
    657c:	3401      	adds	r4, #1
		if ((uint32_t)t == 1) {
    657e:	2a01      	cmp	r2, #1
    6580:	d00c      	beq.n	659c <run_callbacks+0x30>
		if (t->status & (1<<7)) {
    6582:	6853      	ldr	r3, [r2, #4]
    6584:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    6588:	d0f7      	beq.n	657a <run_callbacks+0xe>
			ep->first_transfer = t;
    658a:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    658c:	b12c      	cbz	r4, 659a <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
    658e:	4628      	mov	r0, r5
		ep->callback_function(first);
    6590:	6bb3      	ldr	r3, [r6, #56]	; 0x38
		transfer_t *next = (transfer_t *)first->next;
    6592:	682d      	ldr	r5, [r5, #0]
		ep->callback_function(first);
    6594:	4798      	blx	r3
	while (count) {
    6596:	3c01      	subs	r4, #1
    6598:	d1f9      	bne.n	658e <run_callbacks+0x22>
		first = next;
		count--;
	}
}
    659a:	bd70      	pop	{r4, r5, r6, pc}
			ep->last_transfer = NULL;
    659c:	e9c6 330c 	strd	r3, r3, [r6, #48]	; 0x30
			break;
    65a0:	e7f4      	b.n	658c <run_callbacks+0x20>
    65a2:	bf00      	nop

000065a4 <endpoint0_transmit.constprop.0>:
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    65a4:	b430      	push	{r4, r5}
	if (len > 0) {
    65a6:	b9d9      	cbnz	r1, 65e0 <endpoint0_transmit.constprop.0+0x3c>
    65a8:	4c1f      	ldr	r4, [pc, #124]	; (6628 <endpoint0_transmit.constprop.0+0x84>)
	endpoint0_transfer_ack.next = 1;
    65aa:	4b20      	ldr	r3, [pc, #128]	; (662c <endpoint0_transmit.constprop.0+0x88>)
	endpoint0_transfer_ack.pointer0 = 0;
    65ac:	2100      	movs	r1, #0
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    65ae:	4a20      	ldr	r2, [pc, #128]	; (6630 <endpoint0_transmit.constprop.0+0x8c>)
	endpoint0_transfer_ack.next = 1;
    65b0:	2501      	movs	r5, #1
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    65b2:	f04f 1001 	mov.w	r0, #65537	; 0x10001
	endpoint0_transfer_ack.pointer0 = 0;
    65b6:	6099      	str	r1, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    65b8:	601d      	str	r5, [r3, #0]
	endpoint_queue_head[0].status = 0;
    65ba:	e9c4 3102 	strd	r3, r1, [r4, #8]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    65be:	2480      	movs	r4, #128	; 0x80
    65c0:	605c      	str	r4, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    65c2:	f8c2 01bc 	str.w	r0, [r2, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    65c6:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    65ca:	481a      	ldr	r0, [pc, #104]	; (6634 <endpoint0_transmit.constprop.0+0x90>)
	USB1_ENDPTPRIME |= (1<<0);
    65cc:	432b      	orrs	r3, r5
    65ce:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    65d2:	6001      	str	r1, [r0, #0]
	while (USB1_ENDPTPRIME) ;
    65d4:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    65d8:	2b00      	cmp	r3, #0
    65da:	d1fb      	bne.n	65d4 <endpoint0_transmit.constprop.0+0x30>
}
    65dc:	bc30      	pop	{r4, r5}
    65de:	4770      	bx	lr
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    65e0:	0409      	lsls	r1, r1, #16
		endpoint0_transfer_data.next = 1;
    65e2:	4b15      	ldr	r3, [pc, #84]	; (6638 <endpoint0_transmit.constprop.0+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    65e4:	4c10      	ldr	r4, [pc, #64]	; (6628 <endpoint0_transmit.constprop.0+0x84>)
		endpoint0_transfer_data.next = 1;
    65e6:	2501      	movs	r5, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    65e8:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    65ec:	6098      	str	r0, [r3, #8]
		USB1_ENDPTPRIME |= (1<<16);
    65ee:	4a10      	ldr	r2, [pc, #64]	; (6630 <endpoint0_transmit.constprop.0+0x8c>)
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    65f0:	6059      	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    65f2:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
		endpoint0_transfer_data.next = 1;
    65f6:	601d      	str	r5, [r3, #0]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    65f8:	60d9      	str	r1, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    65fa:	f500 5100 	add.w	r1, r0, #8192	; 0x2000
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    65fe:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6600:	6119      	str	r1, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6602:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6606:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    660a:	6159      	str	r1, [r3, #20]
		endpoint_queue_head[1].status = 0;
    660c:	2100      	movs	r1, #0
		endpoint0_transfer_data.pointer4 = addr + 16384;
    660e:	6198      	str	r0, [r3, #24]
		endpoint_queue_head[1].status = 0;
    6610:	64e1      	str	r1, [r4, #76]	; 0x4c
		USB1_ENDPTPRIME |= (1<<16);
    6612:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6616:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    661a:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    661e:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6622:	2b00      	cmp	r3, #0
    6624:	d1fb      	bne.n	661e <endpoint0_transmit.constprop.0+0x7a>
    6626:	e7c0      	b.n	65aa <endpoint0_transmit.constprop.0+0x6>
    6628:	20000000 	.word	0x20000000
    662c:	200012c0 	.word	0x200012c0
    6630:	402e0000 	.word	0x402e0000
    6634:	200068b8 	.word	0x200068b8
    6638:	200012e0 	.word	0x200012e0

0000663c <usb_stop_sof_interrupts>:
	sof_usage &= ~(1 << interface);
    663c:	4908      	ldr	r1, [pc, #32]	; (6660 <usb_stop_sof_interrupts+0x24>)
    663e:	2201      	movs	r2, #1
    6640:	780b      	ldrb	r3, [r1, #0]
    6642:	fa02 f000 	lsl.w	r0, r2, r0
    6646:	ea23 0000 	bic.w	r0, r3, r0
    664a:	7008      	strb	r0, [r1, #0]
	if (sof_usage == 0) {
    664c:	b930      	cbnz	r0, 665c <usb_stop_sof_interrupts+0x20>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    664e:	4a05      	ldr	r2, [pc, #20]	; (6664 <usb_stop_sof_interrupts+0x28>)
    6650:	f8d2 3148 	ldr.w	r3, [r2, #328]	; 0x148
    6654:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    6658:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
}
    665c:	4770      	bx	lr
    665e:	bf00      	nop
    6660:	20006ae6 	.word	0x20006ae6
    6664:	402e0000 	.word	0x402e0000

00006668 <usb_isr>:
{
    6668:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t status = USB1_USBSTS;
    666c:	4c97      	ldr	r4, [pc, #604]	; (68cc <usb_isr+0x264>)
{
    666e:	b083      	sub	sp, #12
	uint32_t status = USB1_USBSTS;
    6670:	f8d4 7144 	ldr.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    6674:	07fb      	lsls	r3, r7, #31
	USB1_USBSTS = status;
    6676:	f8c4 7144 	str.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    667a:	d553      	bpl.n	6724 <usb_isr+0xbc>
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    667c:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6680:	2a00      	cmp	r2, #0
    6682:	d04a      	beq.n	671a <usb_isr+0xb2>
    6684:	4e92      	ldr	r6, [pc, #584]	; (68d0 <usb_isr+0x268>)
    6686:	f8df a260 	ldr.w	sl, [pc, #608]	; 68e8 <usb_isr+0x280>
		uint32_t addr = (uint32_t)data;
    668a:	f8df 9274 	ldr.w	r9, [pc, #628]	; 6900 <usb_isr+0x298>
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    668e:	f8df b274 	ldr.w	fp, [pc, #628]	; 6904 <usb_isr+0x29c>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    6692:	f8df 8274 	ldr.w	r8, [pc, #628]	; 6908 <usb_isr+0x2a0>
			USB1_ENDPTSETUPSTAT = setupstatus;
    6696:	f8c4 21ac 	str.w	r2, [r4, #428]	; 0x1ac
				s.word2 = endpoint_queue_head[0].setup1;
    669a:	e9d6 200a 	ldrd	r2, r0, [r6, #40]	; 0x28
				USB1_USBCMD |= USB_USBCMD_SUTW;
    669e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    66a2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    66a6:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    66aa:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    66ae:	049d      	lsls	r5, r3, #18
    66b0:	d5f5      	bpl.n	669e <usb_isr+0x36>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    66b2:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    66b6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    66ba:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    66be:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    66c2:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    66c6:	f8d4 51b4 	ldr.w	r5, [r4, #436]	; 0x1b4
    66ca:	f015 1501 	ands.w	r5, r5, #65537	; 0x10001
    66ce:	d1fa      	bne.n	66c6 <usb_isr+0x5e>
			endpoint0_notify_mask = 0;
    66d0:	b293      	uxth	r3, r2
	setup.bothwords = setupdata;
    66d2:	4684      	mov	ip, r0
			endpoint0_notify_mask = 0;
    66d4:	f8ca 5000 	str.w	r5, [sl]
	switch (setup.wRequestAndType) {
    66d8:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    66dc:	f000 81cf 	beq.w	6a7e <usb_isr+0x416>
    66e0:	f200 80db 	bhi.w	689a <usb_isr+0x232>
    66e4:	f240 3102 	movw	r1, #770	; 0x302
    66e8:	428b      	cmp	r3, r1
    66ea:	f000 81e7 	beq.w	6abc <usb_isr+0x454>
    66ee:	f200 809a 	bhi.w	6826 <usb_isr+0x1be>
    66f2:	2b82      	cmp	r3, #130	; 0x82
    66f4:	f000 81cb 	beq.w	6a8e <usb_isr+0x426>
    66f8:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    66fc:	f040 808a 	bne.w	6814 <usb_isr+0x1ac>
		if (endpoint > 7) break;
    6700:	f010 0f78 	tst.w	r0, #120	; 0x78
    6704:	b283      	uxth	r3, r0
    6706:	f000 8203 	beq.w	6b10 <usb_isr+0x4a8>
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    670a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    670e:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    6712:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6716:	2a00      	cmp	r2, #0
    6718:	d1bd      	bne.n	6696 <usb_isr+0x2e>
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    671a:	4a6c      	ldr	r2, [pc, #432]	; (68cc <usb_isr+0x264>)
    671c:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    6720:	2b00      	cmp	r3, #0
    6722:	d142      	bne.n	67aa <usb_isr+0x142>
	if (status & USB_USBSTS_URI) { // page 3164
    6724:	067e      	lsls	r6, r7, #25
    6726:	d516      	bpl.n	6756 <usb_isr+0xee>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    6728:	4b68      	ldr	r3, [pc, #416]	; (68cc <usb_isr+0x264>)
    672a:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
    672e:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    6732:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    6736:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    673a:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    673e:	2c00      	cmp	r4, #0
    6740:	d1fb      	bne.n	673a <usb_isr+0xd2>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    6742:	f04f 32ff 	mov.w	r2, #4294967295
    6746:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    674a:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
		usb_serial_reset();
    674e:	f000 fd29 	bl	71a4 <usb_serial_reset>
		endpointN_notify_mask = 0;
    6752:	4b60      	ldr	r3, [pc, #384]	; (68d4 <usb_isr+0x26c>)
    6754:	601c      	str	r4, [r3, #0]
	if (status & USB_USBSTS_TI0) {
    6756:	01fc      	lsls	r4, r7, #7
    6758:	d503      	bpl.n	6762 <usb_isr+0xfa>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    675a:	4b5f      	ldr	r3, [pc, #380]	; (68d8 <usb_isr+0x270>)
    675c:	681b      	ldr	r3, [r3, #0]
    675e:	b103      	cbz	r3, 6762 <usb_isr+0xfa>
    6760:	4798      	blx	r3
	if (status & USB_USBSTS_TI1) {
    6762:	01b8      	lsls	r0, r7, #6
    6764:	d503      	bpl.n	676e <usb_isr+0x106>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    6766:	4b5d      	ldr	r3, [pc, #372]	; (68dc <usb_isr+0x274>)
    6768:	681b      	ldr	r3, [r3, #0]
    676a:	b103      	cbz	r3, 676e <usb_isr+0x106>
    676c:	4798      	blx	r3
	if (status & USB_USBSTS_PCI) {
    676e:	0779      	lsls	r1, r7, #29
    6770:	d508      	bpl.n	6784 <usb_isr+0x11c>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    6772:	4b56      	ldr	r3, [pc, #344]	; (68cc <usb_isr+0x264>)
    6774:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    6778:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    677c:	d047      	beq.n	680e <usb_isr+0x1a6>
			usb_high_speed = 1;
    677e:	4b58      	ldr	r3, [pc, #352]	; (68e0 <usb_isr+0x278>)
    6780:	2201      	movs	r2, #1
    6782:	701a      	strb	r2, [r3, #0]
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    6784:	4b51      	ldr	r3, [pc, #324]	; (68cc <usb_isr+0x264>)
    6786:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
    678a:	061a      	lsls	r2, r3, #24
    678c:	d50a      	bpl.n	67a4 <usb_isr+0x13c>
    678e:	063b      	lsls	r3, r7, #24
    6790:	d508      	bpl.n	67a4 <usb_isr+0x13c>
		if (usb_reboot_timer) {
    6792:	4a54      	ldr	r2, [pc, #336]	; (68e4 <usb_isr+0x27c>)
    6794:	7813      	ldrb	r3, [r2, #0]
    6796:	b12b      	cbz	r3, 67a4 <usb_isr+0x13c>
			if (--usb_reboot_timer == 0) {
    6798:	3b01      	subs	r3, #1
    679a:	b2db      	uxtb	r3, r3
    679c:	7013      	strb	r3, [r2, #0]
    679e:	2b00      	cmp	r3, #0
    67a0:	f000 8272 	beq.w	6c88 <usb_isr+0x620>
}
    67a4:	b003      	add	sp, #12
    67a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (completestatus & endpoint0_notify_mask) {
    67aa:	494f      	ldr	r1, [pc, #316]	; (68e8 <usb_isr+0x280>)
			USB1_ENDPTCOMPLETE = completestatus;
    67ac:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			if (completestatus & endpoint0_notify_mask) {
    67b0:	6808      	ldr	r0, [r1, #0]
    67b2:	4203      	tst	r3, r0
    67b4:	f040 81d1 	bne.w	6b5a <usb_isr+0x4f2>
			completestatus &= endpointN_notify_mask;
    67b8:	4a46      	ldr	r2, [pc, #280]	; (68d4 <usb_isr+0x26c>)
    67ba:	6814      	ldr	r4, [r2, #0]
			if (completestatus) {
    67bc:	401c      	ands	r4, r3
    67be:	d0b1      	beq.n	6724 <usb_isr+0xbc>
				while (tx) {
    67c0:	ea5f 4814 	movs.w	r8, r4, lsr #16
    67c4:	d010      	beq.n	67e8 <usb_isr+0x180>
    67c6:	4e42      	ldr	r6, [pc, #264]	; (68d0 <usb_isr+0x268>)
					tx &= ~(1<<p);
    67c8:	f04f 0901 	mov.w	r9, #1
					int p=__builtin_ctz(tx);
    67cc:	fa98 f5a8 	rbit	r5, r8
    67d0:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    67d4:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					tx &= ~(1<<p);
    67d8:	fa09 f505 	lsl.w	r5, r9, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    67dc:	3040      	adds	r0, #64	; 0x40
    67de:	f7ff fec5 	bl	656c <run_callbacks>
				while (tx) {
    67e2:	ea38 0805 	bics.w	r8, r8, r5
    67e6:	d1f1      	bne.n	67cc <usb_isr+0x164>
				uint32_t rx = completestatus & 0xffff;
    67e8:	b2a4      	uxth	r4, r4
				while(rx) {
    67ea:	2c00      	cmp	r4, #0
    67ec:	d09a      	beq.n	6724 <usb_isr+0xbc>
    67ee:	4e38      	ldr	r6, [pc, #224]	; (68d0 <usb_isr+0x268>)
					rx &= ~(1<<p);
    67f0:	f04f 0801 	mov.w	r8, #1
					int p=__builtin_ctz(rx);
    67f4:	fa94 f5a4 	rbit	r5, r4
    67f8:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2);
    67fc:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					rx &= ~(1<<p);
    6800:	fa08 f505 	lsl.w	r5, r8, r5
					run_callbacks(endpoint_queue_head + p * 2);
    6804:	f7ff feb2 	bl	656c <run_callbacks>
				while(rx) {
    6808:	43ac      	bics	r4, r5
    680a:	d1f3      	bne.n	67f4 <usb_isr+0x18c>
    680c:	e78a      	b.n	6724 <usb_isr+0xbc>
			usb_high_speed = 0;
    680e:	4a34      	ldr	r2, [pc, #208]	; (68e0 <usb_isr+0x278>)
    6810:	7013      	strb	r3, [r2, #0]
    6812:	e7b7      	b.n	6784 <usb_isr+0x11c>
	switch (setup.wRequestAndType) {
    6814:	2b80      	cmp	r3, #128	; 0x80
    6816:	f47f af78 	bne.w	670a <usb_isr+0xa2>
		reply_buffer[0] = 0;
    681a:	4834      	ldr	r0, [pc, #208]	; (68ec <usb_isr+0x284>)
		endpoint0_transmit(reply_buffer, 2, 0);
    681c:	2102      	movs	r1, #2
		reply_buffer[0] = 0;
    681e:	8005      	strh	r5, [r0, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6820:	f7ff fec0 	bl	65a4 <endpoint0_transmit.constprop.0>
		return;
    6824:	e775      	b.n	6712 <usb_isr+0xaa>
	switch (setup.wRequestAndType) {
    6826:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    682a:	f000 810b 	beq.w	6a44 <usb_isr+0x3dc>
    682e:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    6832:	2b01      	cmp	r3, #1
    6834:	f63f af69 	bhi.w	670a <usb_isr+0xa2>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6838:	4b2d      	ldr	r3, [pc, #180]	; (68f0 <usb_isr+0x288>)
    683a:	685d      	ldr	r5, [r3, #4]
    683c:	2d00      	cmp	r5, #0
    683e:	f43f af64 	beq.w	670a <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6842:	fa1f fc8c 	uxth.w	ip, ip
    6846:	ea4f 4e12 	mov.w	lr, r2, lsr #16
    684a:	e004      	b.n	6856 <usb_isr+0x1ee>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    684c:	691d      	ldr	r5, [r3, #16]
    684e:	330c      	adds	r3, #12
    6850:	2d00      	cmp	r5, #0
    6852:	f43f af5a 	beq.w	670a <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6856:	881a      	ldrh	r2, [r3, #0]
    6858:	4572      	cmp	r2, lr
    685a:	d1f7      	bne.n	684c <usb_isr+0x1e4>
    685c:	885a      	ldrh	r2, [r3, #2]
    685e:	4562      	cmp	r2, ip
    6860:	d1f4      	bne.n	684c <usb_isr+0x1e4>
				if ((setup.wValue >> 8) == 3) {
    6862:	ea4f 221e 	mov.w	r2, lr, lsr #8
    6866:	2a03      	cmp	r2, #3
    6868:	f000 81a5 	beq.w	6bb6 <usb_isr+0x54e>
					datalen = list->length;
    686c:	891a      	ldrh	r2, [r3, #8]
				if (datalen > setup.wLength) datalen = setup.wLength;
    686e:	0c00      	lsrs	r0, r0, #16
    6870:	4282      	cmp	r2, r0
    6872:	bf28      	it	cs
    6874:	4602      	movcs	r2, r0
				if (setup.wValue == 0x200) {
    6876:	f5be 7f00 	cmp.w	lr, #512	; 0x200
    687a:	f040 81a1 	bne.w	6bc0 <usb_isr+0x558>
					if (usb_high_speed) src = usb_config_descriptor_480;
    687e:	4b18      	ldr	r3, [pc, #96]	; (68e0 <usb_isr+0x278>)
    6880:	491c      	ldr	r1, [pc, #112]	; (68f4 <usb_isr+0x28c>)
    6882:	7818      	ldrb	r0, [r3, #0]
    6884:	4b1c      	ldr	r3, [pc, #112]	; (68f8 <usb_isr+0x290>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6886:	9201      	str	r2, [sp, #4]
    6888:	2800      	cmp	r0, #0
    688a:	bf18      	it	ne
    688c:	4619      	movne	r1, r3
    688e:	481b      	ldr	r0, [pc, #108]	; (68fc <usb_isr+0x294>)
    6890:	f7ff faf0 	bl	5e74 <memcpy>
    6894:	4d19      	ldr	r5, [pc, #100]	; (68fc <usb_isr+0x294>)
    6896:	9a01      	ldr	r2, [sp, #4]
    6898:	e1e1      	b.n	6c5e <usb_isr+0x5f6>
	switch (setup.wRequestAndType) {
    689a:	f242 2121 	movw	r1, #8737	; 0x2221
    689e:	428b      	cmp	r3, r1
    68a0:	d07c      	beq.n	699c <usb_isr+0x334>
    68a2:	d933      	bls.n	690c <usb_isr+0x2a4>
    68a4:	f242 3121 	movw	r1, #8993	; 0x2321
    68a8:	428b      	cmp	r3, r1
    68aa:	f000 8081 	beq.w	69b0 <usb_isr+0x348>
    68ae:	f64f 01c0 	movw	r1, #63680	; 0xf8c0
    68b2:	428b      	cmp	r3, r1
    68b4:	f47f af29 	bne.w	670a <usb_isr+0xa2>
		if ((setup.wIndex & 0xFF00) != 0) break; // 1=Genre, 4=Compat ID, 5=Properties
    68b8:	f410 4f7f 	tst.w	r0, #65280	; 0xff00
    68bc:	b283      	uxth	r3, r0
    68be:	f47f af24 	bne.w	670a <usb_isr+0xa2>
		setup.wIndex |= 0xEE00; // alter wIndex and treat as normal USB descriptor
    68c2:	f443 436e 	orr.w	r3, r3, #60928	; 0xee00
    68c6:	f363 0c0f 	bfi	ip, r3, #0, #16
    68ca:	e7b5      	b.n	6838 <usb_isr+0x1d0>
    68cc:	402e0000 	.word	0x402e0000
    68d0:	20000000 	.word	0x20000000
    68d4:	200068bc 	.word	0x200068bc
    68d8:	20006acc 	.word	0x20006acc
    68dc:	20006ad0 	.word	0x20006ad0
    68e0:	20006aec 	.word	0x20006aec
    68e4:	20006aed 	.word	0x20006aed
    68e8:	200068b8 	.word	0x200068b8
    68ec:	200068e4 	.word	0x200068e4
    68f0:	200009dc 	.word	0x200009dc
    68f4:	60001b14 	.word	0x60001b14
    68f8:	60001b78 	.word	0x60001b78
    68fc:	20200000 	.word	0x20200000
    6900:	200068b0 	.word	0x200068b0
    6904:	b8c6cf5d 	.word	0xb8c6cf5d
    6908:	402e01c0 	.word	0x402e01c0
	switch (setup.wRequestAndType) {
    690c:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    6910:	d066      	beq.n	69e0 <usb_isr+0x378>
    6912:	f242 0121 	movw	r1, #8225	; 0x2021
    6916:	428b      	cmp	r3, r1
    6918:	f47f aef7 	bne.w	670a <usb_isr+0xa2>
		if (setup.wLength != 7) break;
    691c:	0c03      	lsrs	r3, r0, #16
    691e:	2b07      	cmp	r3, #7
    6920:	f47f aef3 	bne.w	670a <usb_isr+0xa2>
		endpoint0_transfer_data.next = 1;
    6924:	4bb2      	ldr	r3, [pc, #712]	; (6bf0 <usb_isr+0x588>)
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6926:	49b3      	ldr	r1, [pc, #716]	; (6bf4 <usb_isr+0x58c>)
		endpoint_queue_head[0].status = 0;
    6928:	60f5      	str	r5, [r6, #12]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    692a:	60d9      	str	r1, [r3, #12]
		endpoint0_setupdata.bothwords = setupdata;
    692c:	49b2      	ldr	r1, [pc, #712]	; (6bf8 <usb_isr+0x590>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    692e:	60b3      	str	r3, [r6, #8]
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    6930:	f8c3 9008 	str.w	r9, [r3, #8]
		endpoint0_setupdata.bothwords = setupdata;
    6934:	e9c1 2000 	strd	r2, r0, [r1]
		endpoint0_transfer_data.next = 1;
    6938:	2201      	movs	r2, #1
    693a:	601a      	str	r2, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    693c:	4aaf      	ldr	r2, [pc, #700]	; (6bfc <usb_isr+0x594>)
    693e:	605a      	str	r2, [r3, #4]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6940:	4aaf      	ldr	r2, [pc, #700]	; (6c00 <usb_isr+0x598>)
    6942:	611a      	str	r2, [r3, #16]
		USB1_ENDPTPRIME |= (1<<0);
    6944:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
    6948:	f041 0101 	orr.w	r1, r1, #1
    694c:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6950:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6954:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6958:	6159      	str	r1, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    695a:	619a      	str	r2, [r3, #24]
		while (USB1_ENDPTPRIME) ;
    695c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6960:	2b00      	cmp	r3, #0
    6962:	d1fb      	bne.n	695c <usb_isr+0x2f4>
	endpoint0_transfer_ack.next = 1;
    6964:	4aa7      	ldr	r2, [pc, #668]	; (6c04 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6966:	64f3      	str	r3, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6968:	6093      	str	r3, [r2, #8]
	endpoint0_transfer_ack.next = 1;
    696a:	2301      	movs	r3, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    696c:	64b2      	str	r2, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    696e:	6013      	str	r3, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6970:	f248 0380 	movw	r3, #32896	; 0x8080
    6974:	6053      	str	r3, [r2, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6976:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    697a:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    697e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6982:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6986:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    698a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    698e:	f8ca 3000 	str.w	r3, [sl]
	while (USB1_ENDPTPRIME) ;
    6992:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6996:	2b00      	cmp	r3, #0
    6998:	d1fb      	bne.n	6992 <usb_isr+0x32a>
    699a:	e6ba      	b.n	6712 <usb_isr+0xaa>
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
    699c:	b280      	uxth	r0, r0
    699e:	b938      	cbnz	r0, 69b0 <usb_isr+0x348>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    69a0:	4b99      	ldr	r3, [pc, #612]	; (6c08 <usb_isr+0x5a0>)
			usb_cdc_line_rtsdtr = setup.wValue;
    69a2:	f3c2 4207 	ubfx	r2, r2, #16, #8
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    69a6:	6819      	ldr	r1, [r3, #0]
    69a8:	4b98      	ldr	r3, [pc, #608]	; (6c0c <usb_isr+0x5a4>)
    69aa:	6019      	str	r1, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    69ac:	4b98      	ldr	r3, [pc, #608]	; (6c10 <usb_isr+0x5a8>)
    69ae:	701a      	strb	r2, [r3, #0]
	endpoint0_transfer_ack.next = 1;
    69b0:	4b94      	ldr	r3, [pc, #592]	; (6c04 <usb_isr+0x59c>)
	endpoint0_transfer_ack.pointer0 = 0;
    69b2:	2200      	movs	r2, #0
    69b4:	609a      	str	r2, [r3, #8]
	endpoint_queue_head[1].status = 0;
    69b6:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    69b8:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    69ba:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    69bc:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    69be:	2280      	movs	r2, #128	; 0x80
    69c0:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    69c2:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    69c6:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    69ca:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    69ce:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    69d2:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    69d6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    69da:	2b00      	cmp	r3, #0
    69dc:	d1fb      	bne.n	69d6 <usb_isr+0x36e>
    69de:	e698      	b.n	6712 <usb_isr+0xaa>
		usb_configuration = setup.wValue;
    69e0:	f3c2 4207 	ubfx	r2, r2, #16, #8
    69e4:	4b8b      	ldr	r3, [pc, #556]	; (6c14 <usb_isr+0x5ac>)
    69e6:	701a      	strb	r2, [r3, #0]
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    69e8:	4b8b      	ldr	r3, [pc, #556]	; (6c18 <usb_isr+0x5b0>)
    69ea:	f8c4 31c8 	str.w	r3, [r4, #456]	; 0x1c8
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    69ee:	4b8b      	ldr	r3, [pc, #556]	; (6c1c <usb_isr+0x5b4>)
    69f0:	f8c4 31cc 	str.w	r3, [r4, #460]	; 0x1cc
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    69f4:	4b8a      	ldr	r3, [pc, #552]	; (6c20 <usb_isr+0x5b8>)
    69f6:	f8c4 31d0 	str.w	r3, [r4, #464]	; 0x1d0
		usb_serial_configure();
    69fa:	f000 fbd5 	bl	71a8 <usb_serial_configure>
		memset(endpoint_queue_head + 2, 0, sizeof(endpoint_t) * 2);
    69fe:	2280      	movs	r2, #128	; 0x80
    6a00:	4629      	mov	r1, r5
    6a02:	4888      	ldr	r0, [pc, #544]	; (6c24 <usb_isr+0x5bc>)
    6a04:	f001 f840 	bl	7a88 <memset>
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    6a08:	4b87      	ldr	r3, [pc, #540]	; (6c28 <usb_isr+0x5c0>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a0a:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    6a0c:	f8c6 b0a0 	str.w	fp, [r6, #160]	; 0xa0
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    6a10:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
	endpoint0_transfer_ack.next = 1;
    6a14:	4b7b      	ldr	r3, [pc, #492]	; (6c04 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6a16:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a18:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.next = 1;
    6a1a:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6a1c:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.pointer0 = 0;
    6a1e:	609d      	str	r5, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6a20:	601a      	str	r2, [r3, #0]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a22:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6a26:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6a2a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6a32:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    6a36:	f8ca 5000 	str.w	r5, [sl]
	while (USB1_ENDPTPRIME) ;
    6a3a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a3e:	2b00      	cmp	r3, #0
    6a40:	d1fb      	bne.n	6a3a <usb_isr+0x3d2>
    6a42:	e666      	b.n	6712 <usb_isr+0xaa>
	endpoint0_transfer_ack.next = 1;
    6a44:	4b6f      	ldr	r3, [pc, #444]	; (6c04 <usb_isr+0x59c>)
    6a46:	2101      	movs	r1, #1
	endpoint_queue_head[1].status = 0;
    6a48:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    6a4a:	6019      	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a4c:	2180      	movs	r1, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
    6a4e:	609d      	str	r5, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6a50:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a52:	6059      	str	r1, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a54:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6a58:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6a5c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a60:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6a64:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6a68:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6a6c:	2b00      	cmp	r3, #0
    6a6e:	d1fb      	bne.n	6a68 <usb_isr+0x400>
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    6a70:	0c13      	lsrs	r3, r2, #16
    6a72:	065b      	lsls	r3, r3, #25
    6a74:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    6a78:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
		return;
    6a7c:	e649      	b.n	6712 <usb_isr+0xaa>
		reply_buffer[0] = usb_configuration;
    6a7e:	4b65      	ldr	r3, [pc, #404]	; (6c14 <usb_isr+0x5ac>)
		endpoint0_transmit(reply_buffer, 1, 0);
    6a80:	2101      	movs	r1, #1
		reply_buffer[0] = usb_configuration;
    6a82:	486a      	ldr	r0, [pc, #424]	; (6c2c <usb_isr+0x5c4>)
    6a84:	781b      	ldrb	r3, [r3, #0]
    6a86:	7003      	strb	r3, [r0, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    6a88:	f7ff fd8c 	bl	65a4 <endpoint0_transmit.constprop.0>
		return;
    6a8c:	e641      	b.n	6712 <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    6a8e:	b283      	uxth	r3, r0
		if (endpoint > 7) break;
    6a90:	f010 0078 	ands.w	r0, r0, #120	; 0x78
    6a94:	f47f ae39 	bne.w	670a <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    6a98:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    6a9c:	f858 1022 	ldr.w	r1, [r8, r2, lsl #2]
		reply_buffer[0] = 0;
    6aa0:	4a62      	ldr	r2, [pc, #392]	; (6c2c <usb_isr+0x5c4>)
    6aa2:	8010      	strh	r0, [r2, #0]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    6aa4:	0618      	lsls	r0, r3, #24
    6aa6:	f100 809e 	bmi.w	6be6 <usb_isr+0x57e>
    6aaa:	07cb      	lsls	r3, r1, #31
    6aac:	d501      	bpl.n	6ab2 <usb_isr+0x44a>
			reply_buffer[0] = 1;
    6aae:	2301      	movs	r3, #1
    6ab0:	7013      	strb	r3, [r2, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6ab2:	2102      	movs	r1, #2
    6ab4:	485d      	ldr	r0, [pc, #372]	; (6c2c <usb_isr+0x5c4>)
    6ab6:	f7ff fd75 	bl	65a4 <endpoint0_transmit.constprop.0>
		return;
    6aba:	e62a      	b.n	6712 <usb_isr+0xaa>
		if (endpoint > 7) break;
    6abc:	f010 0f78 	tst.w	r0, #120	; 0x78
    6ac0:	b283      	uxth	r3, r0
    6ac2:	f47f ae22 	bne.w	670a <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    6ac6:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    6aca:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    6ace:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    6ad2:	bf14      	ite	ne
    6ad4:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    6ad8:	f043 0301 	orreq.w	r3, r3, #1
    6adc:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    6ae0:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    6ae2:	4b48      	ldr	r3, [pc, #288]	; (6c04 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6ae4:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6ae6:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6ae8:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6aea:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6aec:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6aee:	2280      	movs	r2, #128	; 0x80
    6af0:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6af2:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6af6:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6afa:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6afe:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6b02:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6b06:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b0a:	2b00      	cmp	r3, #0
    6b0c:	d1fb      	bne.n	6b06 <usb_isr+0x49e>
    6b0e:	e600      	b.n	6712 <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    6b10:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    6b14:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    6b18:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    6b1c:	bf14      	ite	ne
    6b1e:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    6b22:	f023 0301 	biceq.w	r3, r3, #1
    6b26:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    6b2a:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    6b2c:	4b35      	ldr	r3, [pc, #212]	; (6c04 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6b2e:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6b30:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6b32:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6b34:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6b36:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6b38:	2280      	movs	r2, #128	; 0x80
    6b3a:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6b3c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6b40:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6b44:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b48:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6b4c:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6b50:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b54:	2b00      	cmp	r3, #0
    6b56:	d1fb      	bne.n	6b50 <usb_isr+0x4e8>
    6b58:	e5db      	b.n	6712 <usb_isr+0xaa>
				endpoint0_notify_mask = 0;
    6b5a:	2000      	movs	r0, #0
    6b5c:	6008      	str	r0, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    6b5e:	4926      	ldr	r1, [pc, #152]	; (6bf8 <usb_isr+0x590>)
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    6b60:	880c      	ldrh	r4, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    6b62:	6848      	ldr	r0, [r1, #4]
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    6b64:	f242 0121 	movw	r1, #8225	; 0x2021
    6b68:	428c      	cmp	r4, r1
    6b6a:	f47f ae25 	bne.w	67b8 <usb_isr+0x150>
    6b6e:	b280      	uxth	r0, r0
    6b70:	2800      	cmp	r0, #0
    6b72:	f47f ae21 	bne.w	67b8 <usb_isr+0x150>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    6b76:	492e      	ldr	r1, [pc, #184]	; (6c30 <usb_isr+0x5c8>)
    6b78:	4c2e      	ldr	r4, [pc, #184]	; (6c34 <usb_isr+0x5cc>)
    6b7a:	c903      	ldmia	r1, {r0, r1}
    6b7c:	80a1      	strh	r1, [r4, #4]
		if (usb_cdc_line_coding[0] == 134) {
    6b7e:	2886      	cmp	r0, #134	; 0x86
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    6b80:	ea4f 4111 	mov.w	r1, r1, lsr #16
    6b84:	6020      	str	r0, [r4, #0]
    6b86:	71a1      	strb	r1, [r4, #6]
		if (usb_cdc_line_coding[0] == 134) {
    6b88:	f47f ae16 	bne.w	67b8 <usb_isr+0x150>
	__disable_irq();
    6b8c:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    6b8e:	482a      	ldr	r0, [pc, #168]	; (6c38 <usb_isr+0x5d0>)
    6b90:	7801      	ldrb	r1, [r0, #0]
    6b92:	f041 0108 	orr.w	r1, r1, #8
    6b96:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    6b98:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    6b9c:	060d      	lsls	r5, r1, #24
    6b9e:	d405      	bmi.n	6bac <usb_isr+0x544>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    6ba0:	2080      	movs	r0, #128	; 0x80
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    6ba2:	4301      	orrs	r1, r0
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    6ba4:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    6ba8:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	__enable_irq();
    6bac:	b662      	cpsie	i
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    6bae:	4a23      	ldr	r2, [pc, #140]	; (6c3c <usb_isr+0x5d4>)
    6bb0:	2150      	movs	r1, #80	; 0x50
    6bb2:	7011      	strb	r1, [r2, #0]
    6bb4:	e600      	b.n	67b8 <usb_isr+0x150>
				if (datalen > setup.wLength) datalen = setup.wLength;
    6bb6:	0c00      	lsrs	r0, r0, #16
					datalen = *(list->addr);
    6bb8:	782a      	ldrb	r2, [r5, #0]
    6bba:	4282      	cmp	r2, r0
    6bbc:	bf28      	it	cs
    6bbe:	4602      	movcs	r2, r0
				} else if (setup.wValue == 0x700) {
    6bc0:	f5be 6fe0 	cmp.w	lr, #1792	; 0x700
    6bc4:	d144      	bne.n	6c50 <usb_isr+0x5e8>
					if (usb_high_speed) src = usb_config_descriptor_12;
    6bc6:	4b1e      	ldr	r3, [pc, #120]	; (6c40 <usb_isr+0x5d8>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6bc8:	4d1e      	ldr	r5, [pc, #120]	; (6c44 <usb_isr+0x5dc>)
					if (usb_high_speed) src = usb_config_descriptor_12;
    6bca:	7818      	ldrb	r0, [r3, #0]
    6bcc:	491e      	ldr	r1, [pc, #120]	; (6c48 <usb_isr+0x5e0>)
    6bce:	4b1f      	ldr	r3, [pc, #124]	; (6c4c <usb_isr+0x5e4>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6bd0:	9201      	str	r2, [sp, #4]
    6bd2:	2800      	cmp	r0, #0
    6bd4:	bf18      	it	ne
    6bd6:	4619      	movne	r1, r3
    6bd8:	4628      	mov	r0, r5
    6bda:	f7ff f94b 	bl	5e74 <memcpy>
					usb_descriptor_buffer[1] = 7;
    6bde:	2307      	movs	r3, #7
    6be0:	706b      	strb	r3, [r5, #1]
    6be2:	9a01      	ldr	r2, [sp, #4]
    6be4:	e03b      	b.n	6c5e <usb_isr+0x5f6>
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    6be6:	03c9      	lsls	r1, r1, #15
    6be8:	f53f af61 	bmi.w	6aae <usb_isr+0x446>
    6bec:	e761      	b.n	6ab2 <usb_isr+0x44a>
    6bee:	bf00      	nop
    6bf0:	200012e0 	.word	0x200012e0
    6bf4:	200078b0 	.word	0x200078b0
    6bf8:	20001480 	.word	0x20001480
    6bfc:	00070080 	.word	0x00070080
    6c00:	200088b0 	.word	0x200088b0
    6c04:	200012c0 	.word	0x200012c0
    6c08:	20006978 	.word	0x20006978
    6c0c:	20006ac8 	.word	0x20006ac8
    6c10:	20006aea 	.word	0x20006aea
    6c14:	20006aeb 	.word	0x20006aeb
    6c18:	00cc0002 	.word	0x00cc0002
    6c1c:	000200c8 	.word	0x000200c8
    6c20:	00c80002 	.word	0x00c80002
    6c24:	20000080 	.word	0x20000080
    6c28:	74d59319 	.word	0x74d59319
    6c2c:	200068e4 	.word	0x200068e4
    6c30:	200068b0 	.word	0x200068b0
    6c34:	20006ac0 	.word	0x20006ac0
    6c38:	20006ae6 	.word	0x20006ae6
    6c3c:	20006aed 	.word	0x20006aed
    6c40:	20006aec 	.word	0x20006aec
    6c44:	20200000 	.word	0x20200000
    6c48:	60001b78 	.word	0x60001b78
    6c4c:	60001b14 	.word	0x60001b14
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    6c50:	4629      	mov	r1, r5
    6c52:	4d10      	ldr	r5, [pc, #64]	; (6c94 <usb_isr+0x62c>)
    6c54:	9201      	str	r2, [sp, #4]
    6c56:	4628      	mov	r0, r5
    6c58:	f7ff f90c 	bl	5e74 <memcpy>
    6c5c:	9a01      	ldr	r2, [sp, #4]
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    6c5e:	f025 031f 	bic.w	r3, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    6c62:	4415      	add	r5, r2
	asm("dsb");
    6c64:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    6c68:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    6c6c:	f8c1 3f70 	str.w	r3, [r1, #3952]	; 0xf70
		location += 32;
    6c70:	3320      	adds	r3, #32
	} while (location < end_addr);
    6c72:	429d      	cmp	r5, r3
    6c74:	d8fa      	bhi.n	6c6c <usb_isr+0x604>
	asm("dsb");
    6c76:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6c7a:	f3bf 8f6f 	isb	sy
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    6c7e:	4805      	ldr	r0, [pc, #20]	; (6c94 <usb_isr+0x62c>)
    6c80:	4611      	mov	r1, r2
    6c82:	f7ff fc8f 	bl	65a4 <endpoint0_transmit.constprop.0>
				return;
    6c86:	e544      	b.n	6712 <usb_isr+0xaa>
				usb_stop_sof_interrupts(NUM_INTERFACE);
    6c88:	2003      	movs	r0, #3
    6c8a:	f7ff fcd7 	bl	663c <usb_stop_sof_interrupts>
				_reboot_Teensyduino_();
    6c8e:	f000 ff77 	bl	7b80 <___reboot_Teensyduino__veneer>
    6c92:	bf00      	nop
    6c94:	20200000 	.word	0x20200000

00006c98 <usb_config_rx>:
{
    6c98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6c9c:	461f      	mov	r7, r3
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    6c9e:	1e83      	subs	r3, r0, #2
    6ca0:	2b02      	cmp	r3, #2
    6ca2:	d901      	bls.n	6ca8 <usb_config_rx+0x10>
}
    6ca4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    6ca8:	f8df 904c 	ldr.w	r9, [pc, #76]	; 6cf8 <usb_config_rx+0x60>
    6cac:	4615      	mov	r5, r2
    6cae:	460c      	mov	r4, r1
	memset(qh, 0, sizeof(endpoint_t));
    6cb0:	223c      	movs	r2, #60	; 0x3c
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    6cb2:	eb09 18c0 	add.w	r8, r9, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    6cb6:	4606      	mov	r6, r0
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    6cb8:	ea4f 1ac0 	mov.w	sl, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    6cbc:	2100      	movs	r1, #0
    6cbe:	f108 0004 	add.w	r0, r8, #4
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6cc2:	0424      	lsls	r4, r4, #16
	memset(qh, 0, sizeof(endpoint_t));
    6cc4:	f000 fee0 	bl	7a88 <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6cc8:	fab5 f285 	clz	r2, r5
	qh->next = 1; // Terminate bit = 1
    6ccc:	2301      	movs	r3, #1
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6cce:	0952      	lsrs	r2, r2, #5
    6cd0:	ea44 7442 	orr.w	r4, r4, r2, lsl #29
	qh->config = config;
    6cd4:	f849 400a 	str.w	r4, [r9, sl]
	qh->callback_function = callback;
    6cd8:	f8c8 7038 	str.w	r7, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    6cdc:	f8c8 3008 	str.w	r3, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << ep);
    6ce0:	2f00      	cmp	r7, #0
    6ce2:	d0df      	beq.n	6ca4 <usb_config_rx+0xc>
    6ce4:	4a03      	ldr	r2, [pc, #12]	; (6cf4 <usb_config_rx+0x5c>)
    6ce6:	40b3      	lsls	r3, r6
    6ce8:	6811      	ldr	r1, [r2, #0]
    6cea:	430b      	orrs	r3, r1
    6cec:	6013      	str	r3, [r2, #0]
}
    6cee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6cf2:	bf00      	nop
    6cf4:	200068bc 	.word	0x200068bc
    6cf8:	20000000 	.word	0x20000000

00006cfc <usb_config_tx>:
{
    6cfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6d00:	460d      	mov	r5, r1
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    6d02:	1e81      	subs	r1, r0, #2
    6d04:	2902      	cmp	r1, #2
    6d06:	d901      	bls.n	6d0c <usb_config_tx+0x10>
}
    6d08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    6d0c:	01c7      	lsls	r7, r0, #7
    6d0e:	f8df 904c 	ldr.w	r9, [pc, #76]	; 6d5c <usb_config_tx+0x60>
    6d12:	4692      	mov	sl, r2
    6d14:	4604      	mov	r4, r0
    6d16:	3740      	adds	r7, #64	; 0x40
	memset(qh, 0, sizeof(endpoint_t));
    6d18:	223c      	movs	r2, #60	; 0x3c
    6d1a:	2100      	movs	r1, #0
    6d1c:	461e      	mov	r6, r3
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    6d1e:	eb09 0807 	add.w	r8, r9, r7
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6d22:	042d      	lsls	r5, r5, #16
	memset(qh, 0, sizeof(endpoint_t));
    6d24:	f108 0004 	add.w	r0, r8, #4
    6d28:	f000 feae 	bl	7a88 <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    6d2c:	faba f28a 	clz	r2, sl
    6d30:	0952      	lsrs	r2, r2, #5
    6d32:	ea45 7242 	orr.w	r2, r5, r2, lsl #29
	qh->config = config;
    6d36:	f849 2007 	str.w	r2, [r9, r7]
	qh->next = 1; // Terminate bit = 1
    6d3a:	2201      	movs	r2, #1
	qh->callback_function = callback;
    6d3c:	f8c8 6038 	str.w	r6, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    6d40:	f8c8 2008 	str.w	r2, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    6d44:	2e00      	cmp	r6, #0
    6d46:	d0df      	beq.n	6d08 <usb_config_tx+0xc>
    6d48:	4b03      	ldr	r3, [pc, #12]	; (6d58 <usb_config_tx+0x5c>)
    6d4a:	3410      	adds	r4, #16
    6d4c:	6819      	ldr	r1, [r3, #0]
    6d4e:	40a2      	lsls	r2, r4
    6d50:	430a      	orrs	r2, r1
    6d52:	601a      	str	r2, [r3, #0]
}
    6d54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6d58:	200068bc 	.word	0x200068bc
    6d5c:	20000000 	.word	0x20000000

00006d60 <usb_prepare_transfer>:
	transfer->status = (len << 16) | (1<<7);
    6d60:	0412      	lsls	r2, r2, #16
	transfer->pointer0 = addr;
    6d62:	6081      	str	r1, [r0, #8]
	transfer->callback_param = param;
    6d64:	61c3      	str	r3, [r0, #28]
	transfer->pointer3 = addr + 12288;
    6d66:	f501 5340 	add.w	r3, r1, #12288	; 0x3000
	transfer->status = (len << 16) | (1<<7);
    6d6a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
{
    6d6e:	b410      	push	{r4}
	transfer->next = 1;
    6d70:	2401      	movs	r4, #1
	transfer->status = (len << 16) | (1<<7);
    6d72:	6042      	str	r2, [r0, #4]
	transfer->pointer2 = addr + 8192;
    6d74:	f501 5200 	add.w	r2, r1, #8192	; 0x2000
	transfer->next = 1;
    6d78:	6004      	str	r4, [r0, #0]
	transfer->pointer1 = addr + 4096;
    6d7a:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
	transfer->pointer4 = addr + 16384;
    6d7e:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
	transfer->pointer1 = addr + 4096;
    6d82:	60c4      	str	r4, [r0, #12]
	transfer->pointer4 = addr + 16384;
    6d84:	6181      	str	r1, [r0, #24]
}
    6d86:	f85d 4b04 	ldr.w	r4, [sp], #4
	transfer->pointer3 = addr + 12288;
    6d8a:	e9c0 2304 	strd	r2, r3, [r0, #16]
}
    6d8e:	4770      	bx	lr

00006d90 <usb_transmit>:

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6d90:	1e83      	subs	r3, r0, #2
{
    6d92:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6d94:	2b02      	cmp	r3, #2
    6d96:	d900      	bls.n	6d9a <usb_transmit+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}
    6d98:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    6d9a:	4b06      	ldr	r3, [pc, #24]	; (6db4 <usb_transmit+0x24>)
	uint32_t mask = 1 << (endpoint_number + 16);
    6d9c:	f100 0110 	add.w	r1, r0, #16
    6da0:	f04f 0c01 	mov.w	ip, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    6da4:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
	schedule_transfer(endpoint, mask, transfer);
    6da8:	fa0c f101 	lsl.w	r1, ip, r1
    6dac:	3040      	adds	r0, #64	; 0x40
    6dae:	f7ff bb99 	b.w	64e4 <schedule_transfer>
    6db2:	bf00      	nop
    6db4:	20000000 	.word	0x20000000

00006db8 <usb_receive>:

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6db8:	1e83      	subs	r3, r0, #2
{
    6dba:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    6dbc:	2b02      	cmp	r3, #2
    6dbe:	d900      	bls.n	6dc2 <usb_receive+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
}
    6dc0:	4770      	bx	lr
	uint32_t mask = 1 << endpoint_number;
    6dc2:	2101      	movs	r1, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
    6dc4:	4b02      	ldr	r3, [pc, #8]	; (6dd0 <usb_receive+0x18>)
	schedule_transfer(endpoint, mask, transfer);
    6dc6:	4081      	lsls	r1, r0
    6dc8:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    6dcc:	f7ff bb8a 	b.w	64e4 <schedule_transfer>
    6dd0:	20000000 	.word	0x20000000

00006dd4 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    6dd4:	6840      	ldr	r0, [r0, #4]
#endif
}
    6dd6:	4770      	bx	lr

00006dd8 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    6dd8:	4a12      	ldr	r2, [pc, #72]	; (6e24 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    6dda:	4b13      	ldr	r3, [pc, #76]	; (6e28 <usb_init_serialnumber+0x50>)
	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    6ddc:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    6de0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	if (num < 10000000) num = num * 10;
    6de4:	4298      	cmp	r0, r3
{
    6de6:	b510      	push	{r4, lr}
    6de8:	b084      	sub	sp, #16
	if (num < 10000000) num = num * 10;
    6dea:	d202      	bcs.n	6df2 <usb_init_serialnumber+0x1a>
    6dec:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    6df0:	0040      	lsls	r0, r0, #1
	ultoa(num, buf, 10);
    6df2:	4c0e      	ldr	r4, [pc, #56]	; (6e2c <usb_init_serialnumber+0x54>)
    6df4:	a901      	add	r1, sp, #4
    6df6:	220a      	movs	r2, #10
    6df8:	f7ff f8d6 	bl	5fa8 <ultoa>
	for (i=0; i<10; i++) {
    6dfc:	a901      	add	r1, sp, #4
    6dfe:	2300      	movs	r3, #0
    6e00:	4620      	mov	r0, r4
		char c = buf[i];
    6e02:	f811 2b01 	ldrb.w	r2, [r1], #1
	for (i=0; i<10; i++) {
    6e06:	3301      	adds	r3, #1
		if (!c) break;
    6e08:	b13a      	cbz	r2, 6e1a <usb_init_serialnumber+0x42>
	for (i=0; i<10; i++) {
    6e0a:	2b0a      	cmp	r3, #10
		usb_string_serial_number_default.wString[i] = c;
    6e0c:	f820 2f02 	strh.w	r2, [r0, #2]!
	for (i=0; i<10; i++) {
    6e10:	d1f7      	bne.n	6e02 <usb_init_serialnumber+0x2a>
    6e12:	2316      	movs	r3, #22
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    6e14:	7023      	strb	r3, [r4, #0]
}
    6e16:	b004      	add	sp, #16
    6e18:	bd10      	pop	{r4, pc}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    6e1a:	005b      	lsls	r3, r3, #1
    6e1c:	b2db      	uxtb	r3, r3
    6e1e:	7023      	strb	r3, [r4, #0]
}
    6e20:	b004      	add	sp, #16
    6e22:	bd10      	pop	{r4, pc}
    6e24:	401f4400 	.word	0x401f4400
    6e28:	00989680 	.word	0x00989680
    6e2c:	20000d30 	.word	0x20000d30

00006e30 <usb_serial_class::clear()>:
        virtual void clear(void) { usb_serial_flush_input(); }
    6e30:	f000 bace 	b.w	73d0 <usb_serial_flush_input>

00006e34 <usb_serial_class::available()>:
        virtual int available() { return usb_serial_available(); }
    6e34:	f000 bac0 	b.w	73b8 <usb_serial_available>

00006e38 <usb_serial_class::flush()>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6e38:	f000 bb5c 	b.w	74f4 <usb_serial_flush_output>

00006e3c <usb_serial_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    6e3c:	f000 bb32 	b.w	74a4 <usb_serial_write_buffer_free>

00006e40 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    6e40:	4608      	mov	r0, r1
    6e42:	4611      	mov	r1, r2
    6e44:	f000 bb22 	b.w	748c <usb_serial_write>

00006e48 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    6e48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    6e4a:	4c14      	ldr	r4, [pc, #80]	; (6e9c <rx_queue_transfer+0x54>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    6e4c:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    6e50:	4e13      	ldr	r6, [pc, #76]	; (6ea0 <rx_queue_transfer+0x58>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    6e52:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    6e56:	eb04 2440 	add.w	r4, r4, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    6e5a:	4f12      	ldr	r7, [pc, #72]	; (6ea4 <rx_queue_transfer+0x5c>)
    6e5c:	eb06 1640 	add.w	r6, r6, r0, lsl #5
{
    6e60:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
    6e62:	f8c5 218c 	str.w	r2, [r5, #396]	; 0x18c
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    6e66:	4621      	mov	r1, r4
    6e68:	883a      	ldrh	r2, [r7, #0]
    6e6a:	4630      	mov	r0, r6
    6e6c:	f7ff ff78 	bl	6d60 <usb_prepare_transfer>
	arm_dcache_delete(buffer, rx_packet_size);
    6e70:	883b      	ldrh	r3, [r7, #0]
	uint32_t end_addr = (uint32_t)addr + size;
    6e72:	4423      	add	r3, r4
	asm("dsb");
    6e74:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCIMVAC = location;
    6e78:	f8c5 4f5c 	str.w	r4, [r5, #3932]	; 0xf5c
		location += 32;
    6e7c:	3420      	adds	r4, #32
	} while (location < end_addr);
    6e7e:	42a3      	cmp	r3, r4
    6e80:	d8fa      	bhi.n	6e78 <rx_queue_transfer+0x30>
	asm("dsb");
    6e82:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6e86:	f3bf 8f6f 	isb	sy
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    6e8a:	2003      	movs	r0, #3
    6e8c:	4631      	mov	r1, r6
    6e8e:	f7ff ff93 	bl	6db8 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    6e92:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    6e96:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
}
    6e9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6e9c:	20200080 	.word	0x20200080
    6ea0:	20001300 	.word	0x20001300
    6ea4:	20006ad4 	.word	0x20006ad4

00006ea8 <rx_event>:

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    6ea8:	4b24      	ldr	r3, [pc, #144]	; (6f3c <rx_event+0x94>)
{
    6eaa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    6eae:	881c      	ldrh	r4, [r3, #0]
    6eb0:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    6eb2:	69c5      	ldr	r5, [r0, #28]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    6eb4:	f3c3 430e 	ubfx	r3, r3, #16, #15
    6eb8:	1ae4      	subs	r4, r4, r3
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    6eba:	2c00      	cmp	r4, #0
    6ebc:	dd24      	ble.n	6f08 <rx_event+0x60>
		// received a packet with data
		uint32_t head = rx_head;
    6ebe:	4920      	ldr	r1, [pc, #128]	; (6f40 <rx_event+0x98>)
		if (head != rx_tail) {
    6ec0:	4820      	ldr	r0, [pc, #128]	; (6f44 <rx_event+0x9c>)
		uint32_t head = rx_head;
    6ec2:	780a      	ldrb	r2, [r1, #0]
		if (head != rx_tail) {
    6ec4:	7800      	ldrb	r0, [r0, #0]
		uint32_t head = rx_head;
    6ec6:	b2d3      	uxtb	r3, r2
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
    6ec8:	4e1f      	ldr	r6, [pc, #124]	; (6f48 <rx_event+0xa0>)
		if (head != rx_tail) {
    6eca:	4282      	cmp	r2, r0
			uint32_t ii = rx_list[head];
    6ecc:	481f      	ldr	r0, [pc, #124]	; (6f4c <rx_event+0xa4>)
		if (head != rx_tail) {
    6ece:	d007      	beq.n	6ee0 <rx_event+0x38>
			uint32_t ii = rx_list[head];
    6ed0:	f810 8003 	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    6ed4:	f836 7018 	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    6ed8:	f5c7 7200 	rsb	r2, r7, #512	; 0x200
    6edc:	4294      	cmp	r4, r2
    6ede:	d918      	bls.n	6f12 <rx_event+0x6a>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    6ee0:	3301      	adds	r3, #1
		rx_index[i] = 0;
    6ee2:	2200      	movs	r2, #0
		rx_count[i] = len;
    6ee4:	f826 4015 	strh.w	r4, [r6, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
    6ee8:	2b08      	cmp	r3, #8
		rx_index[i] = 0;
    6eea:	4e19      	ldr	r6, [pc, #100]	; (6f50 <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    6eec:	bf88      	it	hi
    6eee:	4613      	movhi	r3, r2
		rx_index[i] = 0;
    6ef0:	f826 2015 	strh.w	r2, [r6, r5, lsl #1]
		rx_list[head] = i;
		rx_head = head;
    6ef4:	bf98      	it	ls
    6ef6:	b2da      	uxtbls	r2, r3
		rx_list[head] = i;
    6ef8:	54c5      	strb	r5, [r0, r3]
		rx_available += len;
    6efa:	4b16      	ldr	r3, [pc, #88]	; (6f54 <rx_event+0xac>)
		rx_head = head;
    6efc:	700a      	strb	r2, [r1, #0]
		rx_available += len;
    6efe:	681a      	ldr	r2, [r3, #0]
    6f00:	4414      	add	r4, r2
    6f02:	601c      	str	r4, [r3, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    6f04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx_queue_transfer(i);
    6f08:	4628      	mov	r0, r5
}
    6f0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_queue_transfer(i);
    6f0e:	f7ff bf9b 	b.w	6e48 <rx_queue_transfer>
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    6f12:	eb07 2048 	add.w	r0, r7, r8, lsl #9
    6f16:	4910      	ldr	r1, [pc, #64]	; (6f58 <rx_event+0xb0>)
    6f18:	4622      	mov	r2, r4
				rx_count[ii] = count + len;
    6f1a:	4427      	add	r7, r4
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    6f1c:	4408      	add	r0, r1
    6f1e:	eb01 2145 	add.w	r1, r1, r5, lsl #9
    6f22:	f7fe ffa7 	bl	5e74 <memcpy>
				rx_available += len;
    6f26:	4a0b      	ldr	r2, [pc, #44]	; (6f54 <rx_event+0xac>)
				rx_queue_transfer(i);
    6f28:	4628      	mov	r0, r5
				rx_count[ii] = count + len;
    6f2a:	f826 7018 	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    6f2e:	6813      	ldr	r3, [r2, #0]
    6f30:	4423      	add	r3, r4
}
    6f32:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				rx_available += len;
    6f36:	6013      	str	r3, [r2, #0]
				rx_queue_transfer(i);
    6f38:	f7ff bf86 	b.w	6e48 <rx_queue_transfer>
    6f3c:	20006ad4 	.word	0x20006ad4
    6f40:	20006ae4 	.word	0x20006ae4
    6f44:	20006ae5 	.word	0x20006ae5
    6f48:	200068f0 	.word	0x200068f0
    6f4c:	20006910 	.word	0x20006910
    6f50:	20006900 	.word	0x20006900
    6f54:	200068ec 	.word	0x200068ec
    6f58:	20200080 	.word	0x20200080

00006f5c <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    6f5c:	4b1d      	ldr	r3, [pc, #116]	; (6fd4 <usb_serial_flush_callback+0x78>)
    6f5e:	781a      	ldrb	r2, [r3, #0]
    6f60:	2a00      	cmp	r2, #0
    6f62:	d136      	bne.n	6fd2 <usb_serial_flush_callback+0x76>
	if (!usb_configuration) return;
    6f64:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    6f68:	4a1b      	ldr	r2, [pc, #108]	; (6fd8 <usb_serial_flush_callback+0x7c>)
    6f6a:	7812      	ldrb	r2, [r2, #0]
    6f6c:	b38a      	cbz	r2, 6fd2 <usb_serial_flush_callback+0x76>
{
    6f6e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_available == 0) return;
    6f72:	4d1a      	ldr	r5, [pc, #104]	; (6fdc <usb_serial_flush_callback+0x80>)
    6f74:	882a      	ldrh	r2, [r5, #0]
    6f76:	b352      	cbz	r2, 6fce <usb_serial_flush_callback+0x72>
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    6f78:	4e19      	ldr	r6, [pc, #100]	; (6fe0 <usb_serial_flush_callback+0x84>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    6f7a:	f5c2 6800 	rsb	r8, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    6f7e:	4f19      	ldr	r7, [pc, #100]	; (6fe4 <usb_serial_flush_callback+0x88>)
    6f80:	7832      	ldrb	r2, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    6f82:	4c19      	ldr	r4, [pc, #100]	; (6fe8 <usb_serial_flush_callback+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    6f84:	eb07 1742 	add.w	r7, r7, r2, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    6f88:	eb04 24c2 	add.w	r4, r4, r2, lsl #11
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    6f8c:	4642      	mov	r2, r8
    6f8e:	4638      	mov	r0, r7
    6f90:	4621      	mov	r1, r4
    6f92:	f7ff fee5 	bl	6d60 <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    6f96:	eb04 0208 	add.w	r2, r4, r8
	asm("dsb");
    6f9a:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    6f9e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6fa2:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    6fa6:	3420      	adds	r4, #32
	} while (location < end_addr);
    6fa8:	42a2      	cmp	r2, r4
    6faa:	d8fa      	bhi.n	6fa2 <usb_serial_flush_callback+0x46>
	asm("dsb");
    6fac:	f3bf 8f4f 	dsb	sy
	asm("isb");
    6fb0:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    6fb4:	2004      	movs	r0, #4
    6fb6:	4639      	mov	r1, r7
    6fb8:	f7ff feea 	bl	6d90 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    6fbc:	7833      	ldrb	r3, [r6, #0]
    6fbe:	3301      	adds	r3, #1
    6fc0:	b2db      	uxtb	r3, r3
    6fc2:	2b03      	cmp	r3, #3
    6fc4:	bf88      	it	hi
    6fc6:	2300      	movhi	r3, #0
    6fc8:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    6fca:	2300      	movs	r3, #0
    6fcc:	802b      	strh	r3, [r5, #0]
}
    6fce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6fd2:	4770      	bx	lr
    6fd4:	20006ae9 	.word	0x20006ae9
    6fd8:	20006aeb 	.word	0x20006aeb
    6fdc:	20006ad6 	.word	0x20006ad6
    6fe0:	20006ae8 	.word	0x20006ae8
    6fe4:	20001400 	.word	0x20001400
    6fe8:	20201080 	.word	0x20201080

00006fec <usb_serial_write.part.0>:
int usb_serial_write(const void *buffer, uint32_t size)
    6fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ff0:	b085      	sub	sp, #20
	while (size > 0) {
    6ff2:	e9cd 1001 	strd	r1, r0, [sp, #4]
    6ff6:	2900      	cmp	r1, #0
    6ff8:	f000 80bf 	beq.w	717a <usb_serial_write.part.0+0x18e>
	uint32_t sent=0;
    6ffc:	2300      	movs	r3, #0
    6ffe:	4c60      	ldr	r4, [pc, #384]	; (7180 <usb_serial_write.part.0+0x194>)
    7000:	f8df 8198 	ldr.w	r8, [pc, #408]	; 719c <usb_serial_write.part.0+0x1b0>
    7004:	f8df a198 	ldr.w	sl, [pc, #408]	; 71a0 <usb_serial_write.part.0+0x1b4>
				wait_begin_at = systick_millis_count;
    7008:	4f5e      	ldr	r7, [pc, #376]	; (7184 <usb_serial_write.part.0+0x198>)
	uint32_t sent=0;
    700a:	9300      	str	r3, [sp, #0]
		tx_noautoflush = 1;
    700c:	2301      	movs	r3, #1
		transfer_t *xfer = tx_transfer + tx_head;
    700e:	4a5e      	ldr	r2, [pc, #376]	; (7188 <usb_serial_write.part.0+0x19c>)
		tx_noautoflush = 1;
    7010:	7023      	strb	r3, [r4, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    7012:	4b5e      	ldr	r3, [pc, #376]	; (718c <usb_serial_write.part.0+0x1a0>)
    7014:	7819      	ldrb	r1, [r3, #0]
		while (!tx_available) {
    7016:	f8b8 3000 	ldrh.w	r3, [r8]
		transfer_t *xfer = tx_transfer + tx_head;
    701a:	eb02 1941 	add.w	r9, r2, r1, lsl #5
		while (!tx_available) {
    701e:	2b00      	cmp	r3, #0
    7020:	f040 80a7 	bne.w	7172 <usb_serial_write.part.0+0x186>
		uint32_t wait_begin_at=0;
    7024:	461e      	mov	r6, r3
		int waiting=0;
    7026:	461d      	mov	r5, r3
			tx_noautoflush = 0;
    7028:	469b      	mov	fp, r3
			uint32_t status = usb_transfer_status(xfer);
    702a:	4648      	mov	r0, r9
    702c:	f7ff fed2 	bl	6dd4 <usb_transfer_status>
			if (!(status & 0x80)) {
    7030:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    7034:	f000 808c 	beq.w	7150 <usb_serial_write.part.0+0x164>
			asm("dsb" ::: "memory");
    7038:	f3bf 8f4f 	dsb	sy
			if (transmit_previous_timeout) return sent;
    703c:	f89a 3000 	ldrb.w	r3, [sl]
			tx_noautoflush = 0;
    7040:	f884 b000 	strb.w	fp, [r4]
			if (!waiting) {
    7044:	b905      	cbnz	r5, 7048 <usb_serial_write.part.0+0x5c>
				wait_begin_at = systick_millis_count;
    7046:	683e      	ldr	r6, [r7, #0]
			if (transmit_previous_timeout) return sent;
    7048:	2b00      	cmp	r3, #0
    704a:	d17d      	bne.n	7148 <usb_serial_write.part.0+0x15c>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    704c:	683b      	ldr	r3, [r7, #0]
    704e:	1b9b      	subs	r3, r3, r6
    7050:	2b78      	cmp	r3, #120	; 0x78
    7052:	f200 8087 	bhi.w	7164 <usb_serial_write.part.0+0x178>
			if (!usb_configuration) return sent;
    7056:	4b4e      	ldr	r3, [pc, #312]	; (7190 <usb_serial_write.part.0+0x1a4>)
    7058:	781b      	ldrb	r3, [r3, #0]
    705a:	2b00      	cmp	r3, #0
    705c:	d074      	beq.n	7148 <usb_serial_write.part.0+0x15c>
			yield();
    705e:	f000 fa93 	bl	7588 <yield>
			tx_noautoflush = 1;
    7062:	2201      	movs	r2, #1
		while (!tx_available) {
    7064:	f8b8 3000 	ldrh.w	r3, [r8]
    7068:	4615      	mov	r5, r2
			tx_noautoflush = 1;
    706a:	7022      	strb	r2, [r4, #0]
		while (!tx_available) {
    706c:	2b00      	cmp	r3, #0
    706e:	d0dc      	beq.n	702a <usb_serial_write.part.0+0x3e>
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7070:	4a46      	ldr	r2, [pc, #280]	; (718c <usb_serial_write.part.0+0x1a0>)
    7072:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    7076:	7811      	ldrb	r1, [r2, #0]
    7078:	461a      	mov	r2, r3
    707a:	eb00 20c1 	add.w	r0, r0, r1, lsl #11
    707e:	4d45      	ldr	r5, [pc, #276]	; (7194 <usb_serial_write.part.0+0x1a8>)
    7080:	02c9      	lsls	r1, r1, #11
    7082:	4428      	add	r0, r5
		if (size >= tx_available) {
    7084:	9d01      	ldr	r5, [sp, #4]
    7086:	4295      	cmp	r5, r2
    7088:	d217      	bcs.n	70ba <usb_serial_write.part.0+0xce>
			memcpy(txdata, data, size);
    708a:	9303      	str	r3, [sp, #12]
    708c:	e9dd 5101 	ldrd	r5, r1, [sp, #4]
    7090:	462a      	mov	r2, r5
    7092:	f7fe feef 	bl	5e74 <memcpy>
			tx_available -= size;
    7096:	9b03      	ldr	r3, [sp, #12]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    7098:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
			tx_available -= size;
    709c:	1b5b      	subs	r3, r3, r5
    709e:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    70a2:	4b3d      	ldr	r3, [pc, #244]	; (7198 <usb_serial_write.part.0+0x1ac>)
    70a4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		asm("dsb" ::: "memory");
    70a8:	f3bf 8f4f 	dsb	sy
			sent += size;
    70ac:	9800      	ldr	r0, [sp, #0]
		tx_noautoflush = 0;
    70ae:	2300      	movs	r3, #0
			sent += size;
    70b0:	4428      	add	r0, r5
		tx_noautoflush = 0;
    70b2:	7023      	strb	r3, [r4, #0]
}
    70b4:	b005      	add	sp, #20
    70b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    70ba:	4b36      	ldr	r3, [pc, #216]	; (7194 <usb_serial_write.part.0+0x1a8>)
    70bc:	18cd      	adds	r5, r1, r3
			memcpy(txdata, data, tx_available);
    70be:	9902      	ldr	r1, [sp, #8]
    70c0:	f7fe fed8 	bl	5e74 <memcpy>
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    70c4:	2300      	movs	r3, #0
    70c6:	f44f 6200 	mov.w	r2, #2048	; 0x800
    70ca:	4629      	mov	r1, r5
    70cc:	4648      	mov	r0, r9
    70ce:	f7ff fe47 	bl	6d60 <usb_prepare_transfer>
	asm("dsb");
    70d2:	f3bf 8f4f 	dsb	sy
    70d6:	f105 0220 	add.w	r2, r5, #32
	uint32_t end_addr = (uint32_t)addr + size;
    70da:	f505 6300 	add.w	r3, r5, #2048	; 0x800
    70de:	4293      	cmp	r3, r2
    70e0:	bf34      	ite	cc
    70e2:	2301      	movcc	r3, #1
    70e4:	2340      	movcs	r3, #64	; 0x40
		SCB_CACHE_DCCIMVAC = location;
    70e6:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    70ea:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    70ee:	f8c2 5f70 	str.w	r5, [r2, #3952]	; 0xf70
		location += 32;
    70f2:	3520      	adds	r5, #32
	} while (location < end_addr);
    70f4:	42ab      	cmp	r3, r5
    70f6:	d1fa      	bne.n	70ee <usb_serial_write.part.0+0x102>
	asm("dsb");
    70f8:	f3bf 8f4f 	dsb	sy
	asm("isb");
    70fc:	f3bf 8f6f 	isb	sy
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    7100:	2004      	movs	r0, #4
    7102:	4649      	mov	r1, r9
    7104:	f7ff fe44 	bl	6d90 <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    7108:	4a20      	ldr	r2, [pc, #128]	; (718c <usb_serial_write.part.0+0x1a0>)
    710a:	7813      	ldrb	r3, [r2, #0]
    710c:	3301      	adds	r3, #1
    710e:	b2db      	uxtb	r3, r3
    7110:	2b03      	cmp	r3, #3
    7112:	bf84      	itt	hi
    7114:	2300      	movhi	r3, #0
    7116:	4a1d      	ldrhi	r2, [pc, #116]	; (718c <usb_serial_write.part.0+0x1a0>)
    7118:	7013      	strb	r3, [r2, #0]
			size -= tx_available;
    711a:	f8b8 3000 	ldrh.w	r3, [r8]
    711e:	9a01      	ldr	r2, [sp, #4]
    7120:	1ad1      	subs	r1, r2, r3
			sent += tx_available;
    7122:	9a00      	ldr	r2, [sp, #0]
    7124:	441a      	add	r2, r3
			size -= tx_available;
    7126:	9101      	str	r1, [sp, #4]
			sent += tx_available;
    7128:	9200      	str	r2, [sp, #0]
			data += tx_available;
    712a:	9a02      	ldr	r2, [sp, #8]
    712c:	441a      	add	r2, r3
			tx_available = 0;
    712e:	2300      	movs	r3, #0
			data += tx_available;
    7130:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = 0;
    7132:	4a19      	ldr	r2, [pc, #100]	; (7198 <usb_serial_write.part.0+0x1ac>)
			tx_available = 0;
    7134:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = 0;
    7138:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
		asm("dsb" ::: "memory");
    713c:	f3bf 8f4f 	dsb	sy
		tx_noautoflush = 0;
    7140:	7023      	strb	r3, [r4, #0]
	while (size > 0) {
    7142:	2900      	cmp	r1, #0
    7144:	f47f af62 	bne.w	700c <usb_serial_write.part.0+0x20>
	return sent;
    7148:	9800      	ldr	r0, [sp, #0]
}
    714a:	b005      	add	sp, #20
    714c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tx_available = TX_SIZE;
    7150:	f44f 6200 	mov.w	r2, #2048	; 0x800
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7154:	4b0d      	ldr	r3, [pc, #52]	; (718c <usb_serial_write.part.0+0x1a0>)
				transmit_previous_timeout = 0;
    7156:	f88a 0000 	strb.w	r0, [sl]
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    715a:	7819      	ldrb	r1, [r3, #0]
				break;
    715c:	4613      	mov	r3, r2
				tx_available = TX_SIZE;
    715e:	f8a8 2000 	strh.w	r2, [r8]
				break;
    7162:	e78a      	b.n	707a <usb_serial_write.part.0+0x8e>
				transmit_previous_timeout = 1;
    7164:	2301      	movs	r3, #1
				return sent;
    7166:	9800      	ldr	r0, [sp, #0]
				transmit_previous_timeout = 1;
    7168:	f88a 3000 	strb.w	r3, [sl]
}
    716c:	b005      	add	sp, #20
    716e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7172:	461a      	mov	r2, r3
    7174:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    7178:	e77f      	b.n	707a <usb_serial_write.part.0+0x8e>
	while (size > 0) {
    717a:	9801      	ldr	r0, [sp, #4]
	return sent;
    717c:	e7e5      	b.n	714a <usb_serial_write.part.0+0x15e>
    717e:	bf00      	nop
    7180:	20006ae9 	.word	0x20006ae9
    7184:	20006978 	.word	0x20006978
    7188:	20001400 	.word	0x20001400
    718c:	20006ae8 	.word	0x20006ae8
    7190:	20006aeb 	.word	0x20006aeb
    7194:	20201080 	.word	0x20201080
    7198:	402e0000 	.word	0x402e0000
    719c:	20006ad6 	.word	0x20006ad6
    71a0:	20006ae7 	.word	0x20006ae7

000071a4 <usb_serial_reset>:
}
    71a4:	4770      	bx	lr
    71a6:	bf00      	nop

000071a8 <usb_serial_configure>:
	if (usb_high_speed) {
    71a8:	4b2a      	ldr	r3, [pc, #168]	; (7254 <usb_serial_configure+0xac>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
    71aa:	2100      	movs	r1, #0
    71ac:	2280      	movs	r2, #128	; 0x80
    71ae:	482a      	ldr	r0, [pc, #168]	; (7258 <usb_serial_configure+0xb0>)
{
    71b0:	b570      	push	{r4, r5, r6, lr}
	if (usb_high_speed) {
    71b2:	781b      	ldrb	r3, [r3, #0]
	tx_head = 0;
    71b4:	2400      	movs	r4, #0
		tx_packet_size = CDC_TX_SIZE_480;
    71b6:	4d29      	ldr	r5, [pc, #164]	; (725c <usb_serial_configure+0xb4>)
	if (usb_high_speed) {
    71b8:	428b      	cmp	r3, r1
		rx_packet_size = CDC_RX_SIZE_480;
    71ba:	4e29      	ldr	r6, [pc, #164]	; (7260 <usb_serial_configure+0xb8>)
	if (usb_high_speed) {
    71bc:	bf0c      	ite	eq
    71be:	2340      	moveq	r3, #64	; 0x40
    71c0:	f44f 7300 	movne.w	r3, #512	; 0x200
		tx_packet_size = CDC_TX_SIZE_480;
    71c4:	802b      	strh	r3, [r5, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    71c6:	8033      	strh	r3, [r6, #0]
	memset(tx_transfer, 0, sizeof(tx_transfer));
    71c8:	f000 fc5e 	bl	7a88 <memset>
	tx_head = 0;
    71cc:	4a25      	ldr	r2, [pc, #148]	; (7264 <usb_serial_configure+0xbc>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    71ce:	4621      	mov	r1, r4
	tx_available = 0;
    71d0:	4b25      	ldr	r3, [pc, #148]	; (7268 <usb_serial_configure+0xc0>)
	tx_head = 0;
    71d2:	7014      	strb	r4, [r2, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    71d4:	f44f 7280 	mov.w	r2, #256	; 0x100
    71d8:	4824      	ldr	r0, [pc, #144]	; (726c <usb_serial_configure+0xc4>)
	tx_available = 0;
    71da:	801c      	strh	r4, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    71dc:	f000 fc54 	bl	7a88 <memset>
	memset(rx_count, 0, sizeof(rx_count));
    71e0:	4a23      	ldr	r2, [pc, #140]	; (7270 <usb_serial_configure+0xc8>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    71e2:	2110      	movs	r1, #16
	memset(rx_index, 0, sizeof(rx_index));
    71e4:	4b23      	ldr	r3, [pc, #140]	; (7274 <usb_serial_configure+0xcc>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    71e6:	2002      	movs	r0, #2
	memset(rx_count, 0, sizeof(rx_count));
    71e8:	e9c2 4400 	strd	r4, r4, [r2]
    71ec:	e9c2 4402 	strd	r4, r4, [r2, #8]
	rx_head = 0;
    71f0:	4a21      	ldr	r2, [pc, #132]	; (7278 <usb_serial_configure+0xd0>)
	memset(rx_index, 0, sizeof(rx_index));
    71f2:	e9c3 4400 	strd	r4, r4, [r3]
	rx_head = 0;
    71f6:	7014      	strb	r4, [r2, #0]
	rx_available = 0;
    71f8:	4a20      	ldr	r2, [pc, #128]	; (727c <usb_serial_configure+0xd4>)
	memset(rx_index, 0, sizeof(rx_index));
    71fa:	e9c3 4402 	strd	r4, r4, [r3, #8]
	rx_tail = 0;
    71fe:	4b20      	ldr	r3, [pc, #128]	; (7280 <usb_serial_configure+0xd8>)
    7200:	701c      	strb	r4, [r3, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    7202:	4623      	mov	r3, r4
	rx_available = 0;
    7204:	6014      	str	r4, [r2, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    7206:	4622      	mov	r2, r4
    7208:	f7ff fd78 	bl	6cfc <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    720c:	4622      	mov	r2, r4
    720e:	8831      	ldrh	r1, [r6, #0]
    7210:	2003      	movs	r0, #3
    7212:	4b1c      	ldr	r3, [pc, #112]	; (7284 <usb_serial_configure+0xdc>)
    7214:	f7ff fd40 	bl	6c98 <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    7218:	4623      	mov	r3, r4
    721a:	2201      	movs	r2, #1
    721c:	8829      	ldrh	r1, [r5, #0]
    721e:	2004      	movs	r0, #4
    7220:	f7ff fd6c 	bl	6cfc <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    7224:	4620      	mov	r0, r4
    7226:	3401      	adds	r4, #1
    7228:	f7ff fe0e 	bl	6e48 <rx_queue_transfer>
    722c:	2c08      	cmp	r4, #8
    722e:	d1f9      	bne.n	7224 <usb_serial_configure+0x7c>
	USB1_GPTIMER0CTRL = 0;
    7230:	4b15      	ldr	r3, [pc, #84]	; (7288 <usb_serial_configure+0xe0>)
	USB1_GPTIMER0LD = microseconds - 1;
    7232:	224a      	movs	r2, #74	; 0x4a
	usb_timer0_callback = callback;
    7234:	4815      	ldr	r0, [pc, #84]	; (728c <usb_serial_configure+0xe4>)
	USB1_GPTIMER0CTRL = 0;
    7236:	2100      	movs	r1, #0
	usb_timer0_callback = callback;
    7238:	4c15      	ldr	r4, [pc, #84]	; (7290 <usb_serial_configure+0xe8>)
    723a:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    723c:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    7240:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    7244:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    7248:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    724c:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
}
    7250:	bd70      	pop	{r4, r5, r6, pc}
    7252:	bf00      	nop
    7254:	20006aec 	.word	0x20006aec
    7258:	20001400 	.word	0x20001400
    725c:	20006ad8 	.word	0x20006ad8
    7260:	20006ad4 	.word	0x20006ad4
    7264:	20006ae8 	.word	0x20006ae8
    7268:	20006ad6 	.word	0x20006ad6
    726c:	20001300 	.word	0x20001300
    7270:	200068f0 	.word	0x200068f0
    7274:	20006900 	.word	0x20006900
    7278:	20006ae4 	.word	0x20006ae4
    727c:	200068ec 	.word	0x200068ec
    7280:	20006ae5 	.word	0x20006ae5
    7284:	00006ea9 	.word	0x00006ea9
    7288:	402e0000 	.word	0x402e0000
    728c:	20006acc 	.word	0x20006acc
    7290:	00006f5d 	.word	0x00006f5d

00007294 <usb_serial_read>:
{
    7294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
    7298:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    729c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	uint32_t tail = rx_tail;
    72a0:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 736c <usb_serial_read+0xd8>
{
    72a4:	b083      	sub	sp, #12
	NVIC_DISABLE_IRQ(IRQ_USB1);
    72a6:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	while (count < size && tail != rx_head) {
    72aa:	468b      	mov	fp, r1
	uint32_t tail = rx_tail;
    72ac:	f89a 4000 	ldrb.w	r4, [sl]
	while (count < size && tail != rx_head) {
    72b0:	2900      	cmp	r1, #0
    72b2:	d04f      	beq.n	7354 <usb_serial_read+0xc0>
    72b4:	4680      	mov	r8, r0
    72b6:	b2e4      	uxtb	r4, r4
	uint32_t count=0;
    72b8:	2700      	movs	r7, #0
		uint32_t avail = rx_count[i] - rx_index[i];
    72ba:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 7370 <usb_serial_read+0xdc>
	while (count < size && tail != rx_head) {
    72be:	4b26      	ldr	r3, [pc, #152]	; (7358 <usb_serial_read+0xc4>)
		uint32_t len = size - count;
    72c0:	ebab 0207 	sub.w	r2, fp, r7
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    72c4:	4925      	ldr	r1, [pc, #148]	; (735c <usb_serial_read+0xc8>)
	while (count < size && tail != rx_head) {
    72c6:	781b      	ldrb	r3, [r3, #0]
    72c8:	42a3      	cmp	r3, r4
		if (++tail > RX_NUM) tail = 0;
    72ca:	f104 0401 	add.w	r4, r4, #1
	while (count < size && tail != rx_head) {
    72ce:	d03f      	beq.n	7350 <usb_serial_read+0xbc>
		if (++tail > RX_NUM) tail = 0;
    72d0:	2c09      	cmp	r4, #9
		uint32_t i = rx_list[tail];
    72d2:	4b23      	ldr	r3, [pc, #140]	; (7360 <usb_serial_read+0xcc>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    72d4:	4640      	mov	r0, r8
		if (++tail > RX_NUM) tail = 0;
    72d6:	bf28      	it	cs
    72d8:	2400      	movcs	r4, #0
		uint32_t i = rx_list[tail];
    72da:	5d1e      	ldrb	r6, [r3, r4]
		uint32_t avail = rx_count[i] - rx_index[i];
    72dc:	f839 c016 	ldrh.w	ip, [r9, r6, lsl #1]
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    72e0:	eb0c 2346 	add.w	r3, ip, r6, lsl #9
    72e4:	4419      	add	r1, r3
		uint32_t avail = rx_count[i] - rx_index[i];
    72e6:	4b1f      	ldr	r3, [pc, #124]	; (7364 <usb_serial_read+0xd0>)
    72e8:	f833 5016 	ldrh.w	r5, [r3, r6, lsl #1]
    72ec:	eba5 050c 	sub.w	r5, r5, ip
		if (avail > len) {
    72f0:	42aa      	cmp	r2, r5
    72f2:	d21c      	bcs.n	732e <usb_serial_read+0x9a>
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    72f4:	eb0c 2c46 	add.w	ip, ip, r6, lsl #9
    72f8:	4918      	ldr	r1, [pc, #96]	; (735c <usb_serial_read+0xc8>)
			rx_available -= len;
    72fa:	4c1b      	ldr	r4, [pc, #108]	; (7368 <usb_serial_read+0xd4>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    72fc:	4461      	add	r1, ip
    72fe:	9201      	str	r2, [sp, #4]
    7300:	f7fe fdb8 	bl	5e74 <memcpy>
			rx_available -= len;
    7304:	6821      	ldr	r1, [r4, #0]
			rx_index[i] += len;
    7306:	f839 5016 	ldrh.w	r5, [r9, r6, lsl #1]
	return count;
    730a:	4658      	mov	r0, fp
			rx_index[i] += len;
    730c:	9a01      	ldr	r2, [sp, #4]
			rx_available -= len;
    730e:	eba1 010b 	sub.w	r1, r1, fp
			rx_index[i] += len;
    7312:	442a      	add	r2, r5
			rx_available -= len;
    7314:	4439      	add	r1, r7
			rx_index[i] += len;
    7316:	f829 2016 	strh.w	r2, [r9, r6, lsl #1]
			rx_available -= len;
    731a:	6021      	str	r1, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
    731c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7320:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    7324:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
}
    7328:	b003      	add	sp, #12
    732a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    732e:	462a      	mov	r2, r5
			count += avail;
    7330:	442f      	add	r7, r5
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    7332:	f7fe fd9f 	bl	5e74 <memcpy>
			rx_available -= avail;
    7336:	490c      	ldr	r1, [pc, #48]	; (7368 <usb_serial_read+0xd4>)
			rx_tail = tail;
    7338:	b2e3      	uxtb	r3, r4
			rx_queue_transfer(i);
    733a:	4630      	mov	r0, r6
			rx_available -= avail;
    733c:	680a      	ldr	r2, [r1, #0]
			p += avail;
    733e:	44a8      	add	r8, r5
			rx_available -= avail;
    7340:	1b52      	subs	r2, r2, r5
    7342:	600a      	str	r2, [r1, #0]
			rx_tail = tail;
    7344:	f88a 3000 	strb.w	r3, [sl]
			rx_queue_transfer(i);
    7348:	f7ff fd7e 	bl	6e48 <rx_queue_transfer>
	while (count < size && tail != rx_head) {
    734c:	45bb      	cmp	fp, r7
    734e:	d8b6      	bhi.n	72be <usb_serial_read+0x2a>
	return count;
    7350:	4638      	mov	r0, r7
    7352:	e7e3      	b.n	731c <usb_serial_read+0x88>
	while (count < size && tail != rx_head) {
    7354:	4608      	mov	r0, r1
    7356:	e7e1      	b.n	731c <usb_serial_read+0x88>
    7358:	20006ae4 	.word	0x20006ae4
    735c:	20200080 	.word	0x20200080
    7360:	20006910 	.word	0x20006910
    7364:	200068f0 	.word	0x200068f0
    7368:	200068ec 	.word	0x200068ec
    736c:	20006ae5 	.word	0x20006ae5
    7370:	20006900 	.word	0x20006900

00007374 <usb_serial_peekchar>:
	if (tail == rx_head) return -1;
    7374:	4b0b      	ldr	r3, [pc, #44]	; (73a4 <usb_serial_peekchar+0x30>)
	uint32_t tail = rx_tail;
    7376:	4a0c      	ldr	r2, [pc, #48]	; (73a8 <usb_serial_peekchar+0x34>)
    7378:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) return -1;
    737a:	7819      	ldrb	r1, [r3, #0]
	uint32_t tail = rx_tail;
    737c:	b2d3      	uxtb	r3, r2
	if (tail == rx_head) return -1;
    737e:	428a      	cmp	r2, r1
    7380:	d00d      	beq.n	739e <usb_serial_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    7382:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    7384:	4809      	ldr	r0, [pc, #36]	; (73ac <usb_serial_peekchar+0x38>)
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7386:	4a0a      	ldr	r2, [pc, #40]	; (73b0 <usb_serial_peekchar+0x3c>)
	if (++tail > RX_NUM) tail = 0;
    7388:	2b09      	cmp	r3, #9
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    738a:	490a      	ldr	r1, [pc, #40]	; (73b4 <usb_serial_peekchar+0x40>)
	if (++tail > RX_NUM) tail = 0;
    738c:	bf28      	it	cs
    738e:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    7390:	5cc3      	ldrb	r3, [r0, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7392:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
    7396:	eb02 2343 	add.w	r3, r2, r3, lsl #9
    739a:	5c58      	ldrb	r0, [r3, r1]
    739c:	4770      	bx	lr
	if (tail == rx_head) return -1;
    739e:	f04f 30ff 	mov.w	r0, #4294967295
}
    73a2:	4770      	bx	lr
    73a4:	20006ae4 	.word	0x20006ae4
    73a8:	20006ae5 	.word	0x20006ae5
    73ac:	20006910 	.word	0x20006910
    73b0:	20200080 	.word	0x20200080
    73b4:	20006900 	.word	0x20006900

000073b8 <usb_serial_available>:
	uint32_t n = rx_available;
    73b8:	4b04      	ldr	r3, [pc, #16]	; (73cc <usb_serial_available+0x14>)
{
    73ba:	b510      	push	{r4, lr}
	uint32_t n = rx_available;
    73bc:	681c      	ldr	r4, [r3, #0]
	if (n == 0) yield();
    73be:	b10c      	cbz	r4, 73c4 <usb_serial_available+0xc>
}
    73c0:	4620      	mov	r0, r4
    73c2:	bd10      	pop	{r4, pc}
	if (n == 0) yield();
    73c4:	f000 f8e0 	bl	7588 <yield>
}
    73c8:	4620      	mov	r0, r4
    73ca:	bd10      	pop	{r4, pc}
    73cc:	200068ec 	.word	0x200068ec

000073d0 <usb_serial_flush_input>:
{
    73d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t tail = rx_tail;
    73d4:	4e14      	ldr	r6, [pc, #80]	; (7428 <usb_serial_flush_input+0x58>)
	while (tail != rx_head) {
    73d6:	4d15      	ldr	r5, [pc, #84]	; (742c <usb_serial_flush_input+0x5c>)
	uint32_t tail = rx_tail;
    73d8:	7833      	ldrb	r3, [r6, #0]
	while (tail != rx_head) {
    73da:	782a      	ldrb	r2, [r5, #0]
    73dc:	4293      	cmp	r3, r2
    73de:	d021      	beq.n	7424 <usb_serial_flush_input+0x54>
    73e0:	b2dc      	uxtb	r4, r3
    73e2:	f8df 9050 	ldr.w	r9, [pc, #80]	; 7434 <usb_serial_flush_input+0x64>
    73e6:	f8df b050 	ldr.w	fp, [pc, #80]	; 7438 <usb_serial_flush_input+0x68>
    73ea:	f8df 8050 	ldr.w	r8, [pc, #80]	; 743c <usb_serial_flush_input+0x6c>
    73ee:	4f10      	ldr	r7, [pc, #64]	; (7430 <usb_serial_flush_input+0x60>)
		if (++tail > RX_NUM) tail = 0;
    73f0:	3401      	adds	r4, #1
    73f2:	2c08      	cmp	r4, #8
		rx_tail = tail;
    73f4:	fa5f fa84 	uxtb.w	sl, r4
		if (++tail > RX_NUM) tail = 0;
    73f8:	d901      	bls.n	73fe <usb_serial_flush_input+0x2e>
    73fa:	2400      	movs	r4, #0
    73fc:	46a2      	mov	sl, r4
		uint32_t i = rx_list[tail];
    73fe:	f819 0004 	ldrb.w	r0, [r9, r4]
		rx_available -= rx_count[i] - rx_index[i];
    7402:	f8db 3000 	ldr.w	r3, [fp]
    7406:	f838 2010 	ldrh.w	r2, [r8, r0, lsl #1]
    740a:	f837 1010 	ldrh.w	r1, [r7, r0, lsl #1]
    740e:	1a52      	subs	r2, r2, r1
    7410:	1a9b      	subs	r3, r3, r2
    7412:	f8cb 3000 	str.w	r3, [fp]
		rx_queue_transfer(i);
    7416:	f7ff fd17 	bl	6e48 <rx_queue_transfer>
		rx_tail = tail;
    741a:	f886 a000 	strb.w	sl, [r6]
	while (tail != rx_head) {
    741e:	782b      	ldrb	r3, [r5, #0]
    7420:	42a3      	cmp	r3, r4
    7422:	d1e5      	bne.n	73f0 <usb_serial_flush_input+0x20>
}
    7424:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7428:	20006ae5 	.word	0x20006ae5
    742c:	20006ae4 	.word	0x20006ae4
    7430:	20006900 	.word	0x20006900
    7434:	20006910 	.word	0x20006910
    7438:	200068ec 	.word	0x200068ec
    743c:	200068f0 	.word	0x200068f0

00007440 <usb_serial_getchar>:
{
    7440:	b500      	push	{lr}
    7442:	b083      	sub	sp, #12
	if (usb_serial_read(&c, 1)) return c;
    7444:	2101      	movs	r1, #1
    7446:	f10d 0007 	add.w	r0, sp, #7
    744a:	f7ff ff23 	bl	7294 <usb_serial_read>
    744e:	b120      	cbz	r0, 745a <usb_serial_getchar+0x1a>
    7450:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
    7454:	b003      	add	sp, #12
    7456:	f85d fb04 	ldr.w	pc, [sp], #4
	return -1;
    745a:	f04f 30ff 	mov.w	r0, #4294967295
    745e:	e7f9      	b.n	7454 <usb_serial_getchar+0x14>

00007460 <usb_serial_putchar>:
	if (!usb_configuration) return 0;
    7460:	4b09      	ldr	r3, [pc, #36]	; (7488 <usb_serial_putchar+0x28>)
{
    7462:	b500      	push	{lr}
    7464:	b083      	sub	sp, #12
	if (!usb_configuration) return 0;
    7466:	781b      	ldrb	r3, [r3, #0]
{
    7468:	f88d 0007 	strb.w	r0, [sp, #7]
	if (!usb_configuration) return 0;
    746c:	b13b      	cbz	r3, 747e <usb_serial_putchar+0x1e>
    746e:	2101      	movs	r1, #1
    7470:	f10d 0007 	add.w	r0, sp, #7
    7474:	f7ff fdba 	bl	6fec <usb_serial_write.part.0>
}
    7478:	b003      	add	sp, #12
    747a:	f85d fb04 	ldr.w	pc, [sp], #4
    747e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    7482:	b003      	add	sp, #12
    7484:	f85d fb04 	ldr.w	pc, [sp], #4
    7488:	20006aeb 	.word	0x20006aeb

0000748c <usb_serial_write>:
	if (!usb_configuration) return 0;
    748c:	4b04      	ldr	r3, [pc, #16]	; (74a0 <usb_serial_write+0x14>)
    748e:	781b      	ldrb	r3, [r3, #0]
    7490:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    7494:	b10b      	cbz	r3, 749a <usb_serial_write+0xe>
    7496:	f7ff bda9 	b.w	6fec <usb_serial_write.part.0>
}
    749a:	4610      	mov	r0, r2
    749c:	4770      	bx	lr
    749e:	bf00      	nop
    74a0:	20006aeb 	.word	0x20006aeb

000074a4 <usb_serial_write_buffer_free>:
{
    74a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (uint32_t i=0; i < TX_NUM; i++) {
    74a8:	2400      	movs	r4, #0
	tx_noautoflush = 1;
    74aa:	f8df 8044 	ldr.w	r8, [pc, #68]	; 74f0 <usb_serial_write_buffer_free+0x4c>
    74ae:	2301      	movs	r3, #1
    74b0:	4d0d      	ldr	r5, [pc, #52]	; (74e8 <usb_serial_write_buffer_free+0x44>)
	uint32_t sum = 0;
    74b2:	4627      	mov	r7, r4
    74b4:	4e0d      	ldr	r6, [pc, #52]	; (74ec <usb_serial_write_buffer_free+0x48>)
	tx_noautoflush = 1;
    74b6:	f888 3000 	strb.w	r3, [r8]
		if (i == tx_head) continue;
    74ba:	7833      	ldrb	r3, [r6, #0]
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    74bc:	4628      	mov	r0, r5
	for (uint32_t i=0; i < TX_NUM; i++) {
    74be:	3520      	adds	r5, #32
		if (i == tx_head) continue;
    74c0:	42a3      	cmp	r3, r4
	for (uint32_t i=0; i < TX_NUM; i++) {
    74c2:	f104 0401 	add.w	r4, r4, #1
		if (i == tx_head) continue;
    74c6:	d005      	beq.n	74d4 <usb_serial_write_buffer_free+0x30>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    74c8:	f7ff fc84 	bl	6dd4 <usb_transfer_status>
    74cc:	0603      	lsls	r3, r0, #24
    74ce:	bf58      	it	pl
    74d0:	f507 6700 	addpl.w	r7, r7, #2048	; 0x800
	for (uint32_t i=0; i < TX_NUM; i++) {
    74d4:	2c04      	cmp	r4, #4
    74d6:	d1f0      	bne.n	74ba <usb_serial_write_buffer_free+0x16>
	asm("dsb" ::: "memory");
    74d8:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    74dc:	2300      	movs	r3, #0
}
    74de:	4638      	mov	r0, r7
	tx_noautoflush = 0;
    74e0:	f888 3000 	strb.w	r3, [r8]
}
    74e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    74e8:	20001400 	.word	0x20001400
    74ec:	20006ae8 	.word	0x20006ae8
    74f0:	20006ae9 	.word	0x20006ae9

000074f4 <usb_serial_flush_output>:
{
    74f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!usb_configuration) return;
    74f8:	4b1d      	ldr	r3, [pc, #116]	; (7570 <usb_serial_flush_output+0x7c>)
    74fa:	781b      	ldrb	r3, [r3, #0]
    74fc:	b113      	cbz	r3, 7504 <usb_serial_flush_output+0x10>
	if (tx_available == 0) return;
    74fe:	4d1d      	ldr	r5, [pc, #116]	; (7574 <usb_serial_flush_output+0x80>)
    7500:	882a      	ldrh	r2, [r5, #0]
    7502:	b90a      	cbnz	r2, 7508 <usb_serial_flush_output+0x14>
}
    7504:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	transfer_t *xfer = tx_transfer + tx_head;
    7508:	4e1b      	ldr	r6, [pc, #108]	; (7578 <usb_serial_flush_output+0x84>)
	uint32_t txnum = TX_SIZE - tx_available;
    750a:	f5c2 6900 	rsb	r9, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    750e:	491b      	ldr	r1, [pc, #108]	; (757c <usb_serial_flush_output+0x88>)
    7510:	7833      	ldrb	r3, [r6, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7512:	464a      	mov	r2, r9
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    7514:	4c1a      	ldr	r4, [pc, #104]	; (7580 <usb_serial_flush_output+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    7516:	eb01 1843 	add.w	r8, r1, r3, lsl #5
	tx_noautoflush = 1;
    751a:	4f1a      	ldr	r7, [pc, #104]	; (7584 <usb_serial_flush_output+0x90>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    751c:	eb04 24c3 	add.w	r4, r4, r3, lsl #11
	tx_noautoflush = 1;
    7520:	2301      	movs	r3, #1
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7522:	4640      	mov	r0, r8
	tx_noautoflush = 1;
    7524:	703b      	strb	r3, [r7, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7526:	4621      	mov	r1, r4
    7528:	2300      	movs	r3, #0
    752a:	f7ff fc19 	bl	6d60 <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    752e:	eb04 0209 	add.w	r2, r4, r9
	asm("dsb");
    7532:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    7536:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    753a:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    753e:	3420      	adds	r4, #32
	} while (location < end_addr);
    7540:	42a2      	cmp	r2, r4
    7542:	d8fa      	bhi.n	753a <usb_serial_flush_output+0x46>
	asm("dsb");
    7544:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7548:	f3bf 8f6f 	isb	sy
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    754c:	2004      	movs	r0, #4
    754e:	4641      	mov	r1, r8
    7550:	f7ff fc1e 	bl	6d90 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    7554:	7833      	ldrb	r3, [r6, #0]
    7556:	3301      	adds	r3, #1
    7558:	b2db      	uxtb	r3, r3
    755a:	2b03      	cmp	r3, #3
    755c:	bf88      	it	hi
    755e:	2300      	movhi	r3, #0
    7560:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    7562:	2300      	movs	r3, #0
    7564:	802b      	strh	r3, [r5, #0]
	asm("dsb" ::: "memory");
    7566:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    756a:	703b      	strb	r3, [r7, #0]
}
    756c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7570:	20006aeb 	.word	0x20006aeb
    7574:	20006ad6 	.word	0x20006ad6
    7578:	20006ae8 	.word	0x20006ae8
    757c:	20001400 	.word	0x20001400
    7580:	20201080 	.word	0x20201080
    7584:	20006ae9 	.word	0x20006ae9

00007588 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    7588:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    758c:	4e32      	ldr	r6, [pc, #200]	; (7658 <yield+0xd0>)
    758e:	7833      	ldrb	r3, [r6, #0]
    7590:	b163      	cbz	r3, 75ac <yield+0x24>
	if (running) return; // TODO: does this need to be atomic?
    7592:	4f32      	ldr	r7, [pc, #200]	; (765c <yield+0xd4>)
    7594:	783a      	ldrb	r2, [r7, #0]
    7596:	b94a      	cbnz	r2, 75ac <yield+0x24>
	running = 1;
    7598:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    759a:	07d9      	lsls	r1, r3, #31
	running = 1;
    759c:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    759e:	d444      	bmi.n	762a <yield+0xa2>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    75a0:	079a      	lsls	r2, r3, #30
    75a2:	d426      	bmi.n	75f2 <yield+0x6a>

	running = 0;
    75a4:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    75a6:	075b      	lsls	r3, r3, #29
	running = 0;
    75a8:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    75aa:	d401      	bmi.n	75b0 <yield+0x28>
	
};
    75ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (!firstYield) return;  
    75b0:	4b2b      	ldr	r3, [pc, #172]	; (7660 <yield+0xd8>)
    75b2:	681a      	ldr	r2, [r3, #0]
    75b4:	2a00      	cmp	r2, #0
    75b6:	d0f9      	beq.n	75ac <yield+0x24>
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    75b8:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    75bc:	2a00      	cmp	r2, #0
    75be:	d1f5      	bne.n	75ac <yield+0x24>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    75c0:	f3ef 8510 	mrs	r5, PRIMASK
		__disable_irq();
    75c4:	b672      	cpsid	i
		EventResponder *first = firstYield;
    75c6:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    75c8:	2800      	cmp	r0, #0
    75ca:	d03b      	beq.n	7644 <yield+0xbc>
		if (runningFromYield) {
    75cc:	4c25      	ldr	r4, [pc, #148]	; (7664 <yield+0xdc>)
    75ce:	7821      	ldrb	r1, [r4, #0]
    75d0:	2900      	cmp	r1, #0
    75d2:	d137      	bne.n	7644 <yield+0xbc>
		runningFromYield = true;
    75d4:	2201      	movs	r2, #1
    75d6:	7022      	strb	r2, [r4, #0]
		firstYield = first->_next;
    75d8:	6942      	ldr	r2, [r0, #20]
    75da:	601a      	str	r2, [r3, #0]
		if (firstYield) {
    75dc:	2a00      	cmp	r2, #0
    75de:	d038      	beq.n	7652 <yield+0xca>
			firstYield->_prev = nullptr;
    75e0:	6191      	str	r1, [r2, #24]
		if (doit) __enable_irq();
    75e2:	b905      	cbnz	r5, 75e6 <yield+0x5e>
    75e4:	b662      	cpsie	i
		first->_triggered = false;
    75e6:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    75e8:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
    75ea:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    75ec:	4798      	blx	r3
		runningFromYield = false;
    75ee:	7025      	strb	r5, [r4, #0]
    75f0:	e7dc      	b.n	75ac <yield+0x24>
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    75f2:	f8df 807c 	ldr.w	r8, [pc, #124]	; 7670 <yield+0xe8>
    75f6:	f898 2000 	ldrb.w	r2, [r8]
    75fa:	2a00      	cmp	r2, #0
    75fc:	d0d2      	beq.n	75a4 <yield+0x1c>
    75fe:	2500      	movs	r5, #0
    7600:	f8df 9070 	ldr.w	r9, [pc, #112]	; 7674 <yield+0xec>
    7604:	462b      	mov	r3, r5
			s_serials_with_serial_events[i]->doYieldCode();
    7606:	f859 4023 	ldr.w	r4, [r9, r3, lsl #2]
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    760a:	3501      	adds	r5, #1
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    760c:	6823      	ldr	r3, [r4, #0]
    760e:	4620      	mov	r0, r4
    7610:	691b      	ldr	r3, [r3, #16]
    7612:	4798      	blx	r3
    7614:	b110      	cbz	r0, 761c <yield+0x94>
    7616:	6963      	ldr	r3, [r4, #20]
    7618:	689b      	ldr	r3, [r3, #8]
    761a:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    761c:	f898 2000 	ldrb.w	r2, [r8]
    7620:	b2eb      	uxtb	r3, r5
    7622:	429a      	cmp	r2, r3
    7624:	d8ef      	bhi.n	7606 <yield+0x7e>
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    7626:	7833      	ldrb	r3, [r6, #0]
    7628:	e7bc      	b.n	75a4 <yield+0x1c>
        virtual int available() { return usb_serial_available(); }
    762a:	f7ff fec5 	bl	73b8 <usb_serial_available>
		if (Serial.available()) serialEvent();
    762e:	b968      	cbnz	r0, 764c <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    7630:	4b0d      	ldr	r3, [pc, #52]	; (7668 <yield+0xe0>)
    7632:	781b      	ldrb	r3, [r3, #0]
    7634:	b90b      	cbnz	r3, 763a <yield+0xb2>
    7636:	7833      	ldrb	r3, [r6, #0]
    7638:	e7b2      	b.n	75a0 <yield+0x18>
    763a:	7833      	ldrb	r3, [r6, #0]
    763c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    7640:	7033      	strb	r3, [r6, #0]
    7642:	e7ad      	b.n	75a0 <yield+0x18>
		if (doit) __enable_irq();
    7644:	2d00      	cmp	r5, #0
    7646:	d1b1      	bne.n	75ac <yield+0x24>
    7648:	b662      	cpsie	i
    764a:	e7af      	b.n	75ac <yield+0x24>
		if (Serial.available()) serialEvent();
    764c:	f000 f99e 	bl	798c <serialEvent()>
    7650:	e7ee      	b.n	7630 <yield+0xa8>
			lastYield = nullptr;
    7652:	4b06      	ldr	r3, [pc, #24]	; (766c <yield+0xe4>)
    7654:	601a      	str	r2, [r3, #0]
    7656:	e7c4      	b.n	75e2 <yield+0x5a>
    7658:	20000d47 	.word	0x20000d47
    765c:	20006adc 	.word	0x20006adc
    7660:	20006878 	.word	0x20006878
    7664:	20006ada 	.word	0x20006ada
    7668:	60001ade 	.word	0x60001ade
    766c:	20006884 	.word	0x20006884
    7670:	20006adb 	.word	0x20006adb
    7674:	20006888 	.word	0x20006888

00007678 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    7678:	49a2      	ldr	r1, [pc, #648]	; (7904 <set_arm_clock+0x28c>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    767a:	4ba3      	ldr	r3, [pc, #652]	; (7908 <set_arm_clock+0x290>)
	if (frequency > 528000000) {
    767c:	4288      	cmp	r0, r1
{
    767e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t dcdc = DCDC_REG3;
    7682:	4ca2      	ldr	r4, [pc, #648]	; (790c <set_arm_clock+0x294>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    7684:	695e      	ldr	r6, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    7686:	699a      	ldr	r2, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    7688:	f8d4 800c 	ldr.w	r8, [r4, #12]
	if (frequency > 528000000) {
    768c:	d91b      	bls.n	76c6 <set_arm_clock+0x4e>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    768e:	4ba0      	ldr	r3, [pc, #640]	; (7910 <set_arm_clock+0x298>)
    7690:	4298      	cmp	r0, r3
    7692:	f240 8102 	bls.w	789a <set_arm_clock+0x222>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    7696:	1ac3      	subs	r3, r0, r3
    7698:	499e      	ldr	r1, [pc, #632]	; (7914 <set_arm_clock+0x29c>)
    769a:	0a1b      	lsrs	r3, r3, #8
    769c:	fba1 1303 	umull	r1, r3, r1, r3
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76a0:	f240 6127 	movw	r1, #1575	; 0x627
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    76a4:	09db      	lsrs	r3, r3, #7
    76a6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    76aa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    76ae:	f203 43e2 	addw	r3, r3, #1250	; 0x4e2
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76b2:	428b      	cmp	r3, r1
    76b4:	bf28      	it	cs
    76b6:	460b      	movcs	r3, r1
    76b8:	f5a3 7748 	sub.w	r7, r3, #800	; 0x320
    76bc:	4b96      	ldr	r3, [pc, #600]	; (7918 <set_arm_clock+0x2a0>)
    76be:	fba3 3707 	umull	r3, r7, r3, r7
    76c2:	08ff      	lsrs	r7, r7, #3
    76c4:	e004      	b.n	76d0 <set_arm_clock+0x58>
	} else if (frequency <= 24000000) {
    76c6:	4f95      	ldr	r7, [pc, #596]	; (791c <set_arm_clock+0x2a4>)
    76c8:	42b8      	cmp	r0, r7
    76ca:	bf8c      	ite	hi
    76cc:	270e      	movhi	r7, #14
    76ce:	2706      	movls	r7, #6
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    76d0:	498d      	ldr	r1, [pc, #564]	; (7908 <set_arm_clock+0x290>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76d2:	f008 091f 	and.w	r9, r8, #31
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    76d6:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76da:	45b9      	cmp	r9, r7
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    76dc:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    76e0:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    76e4:	d20c      	bcs.n	7700 <set_arm_clock+0x88>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    76e6:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    76ea:	f5a1 21f8 	sub.w	r1, r1, #507904	; 0x7c000
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    76ee:	ea48 0807 	orr.w	r8, r8, r7
		DCDC_REG3 = dcdc;
    76f2:	f8c1 800c 	str.w	r8, [r1, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    76f6:	680b      	ldr	r3, [r1, #0]
    76f8:	2b00      	cmp	r3, #0
    76fa:	dafc      	bge.n	76f6 <set_arm_clock+0x7e>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    76fc:	f008 091f 	and.w	r9, r8, #31
	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    7700:	f016 7300 	ands.w	r3, r6, #33554432	; 0x2000000
    7704:	d124      	bne.n	7750 <set_arm_clock+0xd8>
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    7706:	4986      	ldr	r1, [pc, #536]	; (7920 <set_arm_clock+0x2a8>)
    7708:	690c      	ldr	r4, [r1, #16]
    770a:	4986      	ldr	r1, [pc, #536]	; (7924 <set_arm_clock+0x2ac>)
    770c:	43a1      	bics	r1, r4
    770e:	f000 80ea 	beq.w	78e6 <set_arm_clock+0x26e>
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    7712:	f482 5180 	eor.w	r1, r2, #4096	; 0x1000
    7716:	4634      	mov	r4, r6
    7718:	f44f 5580 	mov.w	r5, #4096	; 0x1000
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    771c:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    7720:	d004      	beq.n	772c <set_arm_clock+0xb4>
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    7722:	f026 5660 	bic.w	r6, r6, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    7726:	431e      	orrs	r6, r3
			CCM_CBCDR = cbcdr;
    7728:	4b77      	ldr	r3, [pc, #476]	; (7908 <set_arm_clock+0x290>)
    772a:	615e      	str	r6, [r3, #20]
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    772c:	f411 5f40 	tst.w	r1, #12288	; 0x3000
    7730:	d007      	beq.n	7742 <set_arm_clock+0xca>
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    7732:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
			CCM_CBCMR = cbcmr;
    7736:	4974      	ldr	r1, [pc, #464]	; (7908 <set_arm_clock+0x290>)
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    7738:	432a      	orrs	r2, r5
			CCM_CBCMR = cbcmr;
    773a:	618a      	str	r2, [r1, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    773c:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    773e:	071a      	lsls	r2, r3, #28
    7740:	d4fc      	bmi.n	773c <set_arm_clock+0xc4>
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    7742:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    7746:	4a70      	ldr	r2, [pc, #448]	; (7908 <set_arm_clock+0x290>)
    7748:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    774a:	6c93      	ldr	r3, [r2, #72]	; 0x48
    774c:	069b      	lsls	r3, r3, #26
    774e:	d4fc      	bmi.n	774a <set_arm_clock+0xd2>
	while (frequency * div_arm * div_ahb < 648000000) {
    7750:	4c75      	ldr	r4, [pc, #468]	; (7928 <set_arm_clock+0x2b0>)
    7752:	42a0      	cmp	r0, r4
    7754:	f200 80ce 	bhi.w	78f4 <set_arm_clock+0x27c>
	uint32_t div_ahb = 1;
    7758:	f04f 0c01 	mov.w	ip, #1
    775c:	4601      	mov	r1, r0
	uint32_t div_arm = 1;
    775e:	4663      	mov	r3, ip
	while (frequency * div_arm * div_ahb < 648000000) {
    7760:	fb03 1201 	mla	r2, r3, r1, r1
			div_arm = div_arm + 1;
    7764:	f103 0e01 	add.w	lr, r3, #1
				div_ahb = div_ahb + 1;
    7768:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    776c:	42a2      	cmp	r2, r4
    776e:	d818      	bhi.n	77a2 <set_arm_clock+0x12a>
		if (div_arm < 8) {
    7770:	f1be 0f08 	cmp.w	lr, #8
				div_arm = 1;
    7774:	f04f 0301 	mov.w	r3, #1
		if (div_arm < 8) {
    7778:	f040 808d 	bne.w	7896 <set_arm_clock+0x21e>
			if (div_ahb < 5) {
    777c:	f1bc 0f04 	cmp.w	ip, #4
    7780:	f200 8091 	bhi.w	78a6 <set_arm_clock+0x22e>
	while (frequency * div_arm * div_ahb < 648000000) {
    7784:	180a      	adds	r2, r1, r0
    7786:	42a2      	cmp	r2, r4
    7788:	f200 80a4 	bhi.w	78d4 <set_arm_clock+0x25c>
    778c:	fb05 f100 	mul.w	r1, r5, r0
				div_ahb = div_ahb + 1;
    7790:	46ac      	mov	ip, r5
			div_arm = div_arm + 1;
    7792:	f103 0e01 	add.w	lr, r3, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    7796:	fb03 1201 	mla	r2, r3, r1, r1
				div_ahb = div_ahb + 1;
    779a:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    779e:	42a2      	cmp	r2, r4
    77a0:	d9e6      	bls.n	7770 <set_arm_clock+0xf8>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    77a2:	f10c 31ff 	add.w	r1, ip, #4294967295
    77a6:	028c      	lsls	r4, r1, #10
    77a8:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    77ac:	485f      	ldr	r0, [pc, #380]	; (792c <set_arm_clock+0x2b4>)
    77ae:	4410      	add	r0, r2
	if (mult > 108) mult = 108;
    77b0:	4a5f      	ldr	r2, [pc, #380]	; (7930 <set_arm_clock+0x2b8>)
    77b2:	4290      	cmp	r0, r2
    77b4:	d97f      	bls.n	78b6 <set_arm_clock+0x23e>
    77b6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 795c <set_arm_clock+0x2e4>
    77ba:	226c      	movs	r2, #108	; 0x6c
    77bc:	485d      	ldr	r0, [pc, #372]	; (7934 <set_arm_clock+0x2bc>)
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    77be:	4d58      	ldr	r5, [pc, #352]	; (7920 <set_arm_clock+0x2a8>)
	frequency = mult * 12000000 / div_arm / div_ahb;
    77c0:	fbb0 f0fe 	udiv	r0, r0, lr
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    77c4:	f8d5 e000 	ldr.w	lr, [r5]
	frequency = mult * 12000000 / div_arm / div_ahb;
    77c8:	fbb0 f0fc 	udiv	r0, r0, ip
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    77cc:	f8df c190 	ldr.w	ip, [pc, #400]	; 7960 <set_arm_clock+0x2e8>
    77d0:	ea0e 0c0c 	and.w	ip, lr, ip
    77d4:	45d4      	cmp	ip, sl
    77d6:	d009      	beq.n	77ec <set_arm_clock+0x174>
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    77d8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    77dc:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    77e0:	f8c5 c000 	str.w	ip, [r5]
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    77e4:	602a      	str	r2, [r5, #0]
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    77e6:	682a      	ldr	r2, [r5, #0]
    77e8:	2a00      	cmp	r2, #0
    77ea:	dafc      	bge.n	77e6 <set_arm_clock+0x16e>
	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    77ec:	4a46      	ldr	r2, [pc, #280]	; (7908 <set_arm_clock+0x290>)
    77ee:	6915      	ldr	r5, [r2, #16]
    77f0:	f005 0507 	and.w	r5, r5, #7
    77f4:	429d      	cmp	r5, r3
    77f6:	d003      	beq.n	7800 <set_arm_clock+0x188>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    77f8:	6113      	str	r3, [r2, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    77fa:	6c93      	ldr	r3, [r2, #72]	; 0x48
    77fc:	03dd      	lsls	r5, r3, #15
    77fe:	d4fc      	bmi.n	77fa <set_arm_clock+0x182>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    7800:	f411 5fe0 	tst.w	r1, #7168	; 0x1c00
    7804:	d009      	beq.n	781a <set_arm_clock+0x1a2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    7806:	f426 56e0 	bic.w	r6, r6, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    780a:	f404 54e0 	and.w	r4, r4, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
    780e:	4a3e      	ldr	r2, [pc, #248]	; (7908 <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    7810:	4326      	orrs	r6, r4
		CCM_CBCDR = cbcdr;
    7812:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    7814:	6c93      	ldr	r3, [r2, #72]	; 0x48
    7816:	0799      	lsls	r1, r3, #30
    7818:	d4fc      	bmi.n	7814 <set_arm_clock+0x19c>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    781a:	4947      	ldr	r1, [pc, #284]	; (7938 <set_arm_clock+0x2c0>)
	if (div_ipg > 4) div_ipg = 4;
    781c:	4a47      	ldr	r2, [pc, #284]	; (793c <set_arm_clock+0x2c4>)
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    781e:	4401      	add	r1, r0
	if (div_ipg > 4) div_ipg = 4;
    7820:	4291      	cmp	r1, r2
    7822:	d83c      	bhi.n	789e <set_arm_clock+0x226>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    7824:	4b46      	ldr	r3, [pc, #280]	; (7940 <set_arm_clock+0x2c8>)
    7826:	09c9      	lsrs	r1, r1, #7
    7828:	fba3 3101 	umull	r3, r1, r3, r1
    782c:	0b09      	lsrs	r1, r1, #12
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    782e:	1e4b      	subs	r3, r1, #1
    7830:	021b      	lsls	r3, r3, #8
    7832:	ea86 0203 	eor.w	r2, r6, r3
    7836:	f412 7f40 	tst.w	r2, #768	; 0x300
    783a:	d006      	beq.n	784a <set_arm_clock+0x1d2>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    783c:	f426 7640 	bic.w	r6, r6, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    7840:	f403 7340 	and.w	r3, r3, #768	; 0x300
		CCM_CBCDR = cbcdr;
    7844:	4a30      	ldr	r2, [pc, #192]	; (7908 <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    7846:	4333      	orrs	r3, r6
		CCM_CBCDR = cbcdr;
    7848:	6153      	str	r3, [r2, #20]
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    784a:	4a2f      	ldr	r2, [pc, #188]	; (7908 <set_arm_clock+0x290>)
    784c:	6953      	ldr	r3, [r2, #20]
    784e:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
    7852:	6153      	str	r3, [r2, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    7854:	6c93      	ldr	r3, [r2, #72]	; 0x48
    7856:	069b      	lsls	r3, r3, #26
    7858:	d4fc      	bmi.n	7854 <set_arm_clock+0x1dc>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    785a:	4b3a      	ldr	r3, [pc, #232]	; (7944 <set_arm_clock+0x2cc>)
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    785c:	454f      	cmp	r7, r9
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    785e:	fba3 2300 	umull	r2, r3, r3, r0
    7862:	f04f 32ff 	mov.w	r2, #4294967295
    7866:	ea4f 4393 	mov.w	r3, r3, lsr #18
	F_BUS_ACTUAL = frequency / div_ipg;
    786a:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    786e:	fbb2 f3f3 	udiv	r3, r2, r3
	F_CPU_ACTUAL = frequency;
    7872:	4a35      	ldr	r2, [pc, #212]	; (7948 <set_arm_clock+0x2d0>)
    7874:	6010      	str	r0, [r2, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
    7876:	4a35      	ldr	r2, [pc, #212]	; (794c <set_arm_clock+0x2d4>)
    7878:	6011      	str	r1, [r2, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    787a:	4a35      	ldr	r2, [pc, #212]	; (7950 <set_arm_clock+0x2d8>)
    787c:	6013      	str	r3, [r2, #0]
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    787e:	d208      	bcs.n	7892 <set_arm_clock+0x21a>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    7880:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    7884:	4a21      	ldr	r2, [pc, #132]	; (790c <set_arm_clock+0x294>)
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    7886:	ea48 0707 	orr.w	r7, r8, r7
		DCDC_REG3 = dcdc;
    788a:	60d7      	str	r7, [r2, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    788c:	6813      	ldr	r3, [r2, #0]
    788e:	2b00      	cmp	r3, #0
    7890:	dafc      	bge.n	788c <set_arm_clock+0x214>
	}

	return frequency;
}
    7892:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7896:	4673      	mov	r3, lr
    7898:	e762      	b.n	7760 <set_arm_clock+0xe8>
    789a:	2712      	movs	r7, #18
    789c:	e718      	b.n	76d0 <set_arm_clock+0x58>
    789e:	f44f 7340 	mov.w	r3, #768	; 0x300
	if (div_ipg > 4) div_ipg = 4;
    78a2:	2104      	movs	r1, #4
    78a4:	e7c5      	b.n	7832 <set_arm_clock+0x1ba>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78a6:	f10c 31ff 	add.w	r1, ip, #4294967295
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78aa:	4820      	ldr	r0, [pc, #128]	; (792c <set_arm_clock+0x2b4>)
    78ac:	2307      	movs	r3, #7
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78ae:	028c      	lsls	r4, r1, #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78b0:	4410      	add	r0, r2
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78b2:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78b6:	4a27      	ldr	r2, [pc, #156]	; (7954 <set_arm_clock+0x2dc>)
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    78b8:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 7964 <set_arm_clock+0x2ec>
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    78bc:	fba2 2000 	umull	r2, r0, r2, r0
    78c0:	0d02      	lsrs	r2, r0, #20
	frequency = mult * 12000000 / div_arm / div_ahb;
    78c2:	4825      	ldr	r0, [pc, #148]	; (7958 <set_arm_clock+0x2e0>)
    78c4:	2a36      	cmp	r2, #54	; 0x36
    78c6:	bf38      	it	cc
    78c8:	2236      	movcc	r2, #54	; 0x36
    78ca:	fb02 f000 	mul.w	r0, r2, r0
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    78ce:	ea42 0a0a 	orr.w	sl, r2, sl
    78d2:	e774      	b.n	77be <set_arm_clock+0x146>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    78d4:	ea4f 248c 	mov.w	r4, ip, lsl #10
    78d8:	2300      	movs	r3, #0
    78da:	ea86 218c 	eor.w	r1, r6, ip, lsl #10
				div_arm = 1;
    78de:	f04f 0e01 	mov.w	lr, #1
				div_ahb = div_ahb + 1;
    78e2:	46ac      	mov	ip, r5
    78e4:	e762      	b.n	77ac <set_arm_clock+0x134>
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    78e6:	461d      	mov	r5, r3
    78e8:	f086 54c0 	eor.w	r4, r6, #402653184	; 0x18000000
    78ec:	4611      	mov	r1, r2
    78ee:	f04f 53c0 	mov.w	r3, #402653184	; 0x18000000
    78f2:	e713      	b.n	771c <set_arm_clock+0xa4>
	while (frequency * div_arm * div_ahb < 648000000) {
    78f4:	2400      	movs	r4, #0
	uint32_t div_ahb = 1;
    78f6:	f04f 0c01 	mov.w	ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    78fa:	4602      	mov	r2, r0
    78fc:	4631      	mov	r1, r6
    78fe:	4623      	mov	r3, r4
	uint32_t div_arm = 1;
    7900:	46e6      	mov	lr, ip
    7902:	e753      	b.n	77ac <set_arm_clock+0x134>
    7904:	1f78a400 	.word	0x1f78a400
    7908:	400fc000 	.word	0x400fc000
    790c:	40080000 	.word	0x40080000
    7910:	23c34600 	.word	0x23c34600
    7914:	004cb223 	.word	0x004cb223
    7918:	51eb851f 	.word	0x51eb851f
    791c:	016e3600 	.word	0x016e3600
    7920:	400d8000 	.word	0x400d8000
    7924:	80003040 	.word	0x80003040
    7928:	269fb1ff 	.word	0x269fb1ff
    792c:	005b8d80 	.word	0x005b8d80
    7930:	4df67eff 	.word	0x4df67eff
    7934:	4d3f6400 	.word	0x4d3f6400
    7938:	08f0d17f 	.word	0x08f0d17f
    793c:	2cb4177f 	.word	0x2cb4177f
    7940:	00e5109f 	.word	0x00e5109f
    7944:	431bde83 	.word	0x431bde83
    7948:	20000a64 	.word	0x20000a64
    794c:	20000a60 	.word	0x20000a60
    7950:	2000692c 	.word	0x2000692c
    7954:	165e9f81 	.word	0x165e9f81
    7958:	00b71b00 	.word	0x00b71b00
    795c:	8000206c 	.word	0x8000206c
    7960:	8001307f 	.word	0x8001307f
    7964:	80002000 	.word	0x80002000

00007968 <rtc_get>:
	uint32_t hi1 = SNVS_HPRTCMR;
    7968:	4a07      	ldr	r2, [pc, #28]	; (7988 <rtc_get+0x20>)
    796a:	6a50      	ldr	r0, [r2, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
    796c:	6a93      	ldr	r3, [r2, #40]	; 0x28
		uint32_t hi2 = SNVS_HPRTCMR;
    796e:	4619      	mov	r1, r3
    7970:	4684      	mov	ip, r0
    7972:	6a50      	ldr	r0, [r2, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    7974:	6a93      	ldr	r3, [r2, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    7976:	4299      	cmp	r1, r3
    7978:	d1f9      	bne.n	796e <rtc_get+0x6>
    797a:	4584      	cmp	ip, r0
    797c:	d1f7      	bne.n	796e <rtc_get+0x6>
			return (hi2 << 17) | (lo2 >> 15);
    797e:	0bdb      	lsrs	r3, r3, #15
}
    7980:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
    7984:	4770      	bx	lr
    7986:	bf00      	nop
    7988:	400d4000 	.word	0x400d4000

0000798c <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
}
    798c:	4770      	bx	lr
    798e:	bf00      	nop

00007990 <memmove>:
    7990:	4288      	cmp	r0, r1
    7992:	d90d      	bls.n	79b0 <memmove+0x20>
    7994:	188b      	adds	r3, r1, r2
    7996:	4283      	cmp	r3, r0
    7998:	d90a      	bls.n	79b0 <memmove+0x20>
    799a:	eb00 0c02 	add.w	ip, r0, r2
    799e:	b1ba      	cbz	r2, 79d0 <memmove+0x40>
    79a0:	4662      	mov	r2, ip
    79a2:	f813 cd01 	ldrb.w	ip, [r3, #-1]!
    79a6:	f802 cd01 	strb.w	ip, [r2, #-1]!
    79aa:	4299      	cmp	r1, r3
    79ac:	d1f9      	bne.n	79a2 <memmove+0x12>
    79ae:	4770      	bx	lr
    79b0:	2a0f      	cmp	r2, #15
    79b2:	d80e      	bhi.n	79d2 <memmove+0x42>
    79b4:	4603      	mov	r3, r0
    79b6:	f102 3cff 	add.w	ip, r2, #4294967295
    79ba:	b14a      	cbz	r2, 79d0 <memmove+0x40>
    79bc:	f10c 0c01 	add.w	ip, ip, #1
    79c0:	3b01      	subs	r3, #1
    79c2:	448c      	add	ip, r1
    79c4:	f811 2b01 	ldrb.w	r2, [r1], #1
    79c8:	f803 2f01 	strb.w	r2, [r3, #1]!
    79cc:	4561      	cmp	r1, ip
    79ce:	d1f9      	bne.n	79c4 <memmove+0x34>
    79d0:	4770      	bx	lr
    79d2:	ea40 0301 	orr.w	r3, r0, r1
    79d6:	079b      	lsls	r3, r3, #30
    79d8:	d150      	bne.n	7a7c <memmove+0xec>
    79da:	f1a2 0310 	sub.w	r3, r2, #16
    79de:	b570      	push	{r4, r5, r6, lr}
    79e0:	f101 0c20 	add.w	ip, r1, #32
    79e4:	f023 050f 	bic.w	r5, r3, #15
    79e8:	f101 0e10 	add.w	lr, r1, #16
    79ec:	f100 0410 	add.w	r4, r0, #16
    79f0:	44ac      	add	ip, r5
    79f2:	091b      	lsrs	r3, r3, #4
    79f4:	f85e 5c10 	ldr.w	r5, [lr, #-16]
    79f8:	f844 5c10 	str.w	r5, [r4, #-16]
    79fc:	f85e 5c0c 	ldr.w	r5, [lr, #-12]
    7a00:	f844 5c0c 	str.w	r5, [r4, #-12]
    7a04:	f85e 5c08 	ldr.w	r5, [lr, #-8]
    7a08:	f844 5c08 	str.w	r5, [r4, #-8]
    7a0c:	f85e 5c04 	ldr.w	r5, [lr, #-4]
    7a10:	f844 5c04 	str.w	r5, [r4, #-4]
    7a14:	f10e 0e10 	add.w	lr, lr, #16
    7a18:	45e6      	cmp	lr, ip
    7a1a:	f104 0410 	add.w	r4, r4, #16
    7a1e:	d1e9      	bne.n	79f4 <memmove+0x64>
    7a20:	3301      	adds	r3, #1
    7a22:	f012 0f0c 	tst.w	r2, #12
    7a26:	eb01 1103 	add.w	r1, r1, r3, lsl #4
    7a2a:	f002 040f 	and.w	r4, r2, #15
    7a2e:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    7a32:	d027      	beq.n	7a84 <memmove+0xf4>
    7a34:	3c04      	subs	r4, #4
    7a36:	f024 0603 	bic.w	r6, r4, #3
    7a3a:	ea4f 0c94 	mov.w	ip, r4, lsr #2
    7a3e:	441e      	add	r6, r3
    7a40:	1f1c      	subs	r4, r3, #4
    7a42:	468e      	mov	lr, r1
    7a44:	f85e 5b04 	ldr.w	r5, [lr], #4
    7a48:	f844 5f04 	str.w	r5, [r4, #4]!
    7a4c:	42b4      	cmp	r4, r6
    7a4e:	d1f9      	bne.n	7a44 <memmove+0xb4>
    7a50:	f10c 0401 	add.w	r4, ip, #1
    7a54:	f002 0203 	and.w	r2, r2, #3
    7a58:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    7a5c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    7a60:	f102 3cff 	add.w	ip, r2, #4294967295
    7a64:	b14a      	cbz	r2, 7a7a <memmove+0xea>
    7a66:	f10c 0c01 	add.w	ip, ip, #1
    7a6a:	3b01      	subs	r3, #1
    7a6c:	448c      	add	ip, r1
    7a6e:	f811 2b01 	ldrb.w	r2, [r1], #1
    7a72:	f803 2f01 	strb.w	r2, [r3, #1]!
    7a76:	4561      	cmp	r1, ip
    7a78:	d1f9      	bne.n	7a6e <memmove+0xde>
    7a7a:	bd70      	pop	{r4, r5, r6, pc}
    7a7c:	f102 3cff 	add.w	ip, r2, #4294967295
    7a80:	4603      	mov	r3, r0
    7a82:	e79b      	b.n	79bc <memmove+0x2c>
    7a84:	4622      	mov	r2, r4
    7a86:	e7eb      	b.n	7a60 <memmove+0xd0>

00007a88 <memset>:
    7a88:	0783      	lsls	r3, r0, #30
    7a8a:	b530      	push	{r4, r5, lr}
    7a8c:	d048      	beq.n	7b20 <memset+0x98>
    7a8e:	1e54      	subs	r4, r2, #1
    7a90:	2a00      	cmp	r2, #0
    7a92:	d03f      	beq.n	7b14 <memset+0x8c>
    7a94:	b2ca      	uxtb	r2, r1
    7a96:	4603      	mov	r3, r0
    7a98:	e001      	b.n	7a9e <memset+0x16>
    7a9a:	3c01      	subs	r4, #1
    7a9c:	d33a      	bcc.n	7b14 <memset+0x8c>
    7a9e:	f803 2b01 	strb.w	r2, [r3], #1
    7aa2:	079d      	lsls	r5, r3, #30
    7aa4:	d1f9      	bne.n	7a9a <memset+0x12>
    7aa6:	2c03      	cmp	r4, #3
    7aa8:	d92d      	bls.n	7b06 <memset+0x7e>
    7aaa:	b2cd      	uxtb	r5, r1
    7aac:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    7ab0:	2c0f      	cmp	r4, #15
    7ab2:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    7ab6:	d936      	bls.n	7b26 <memset+0x9e>
    7ab8:	f1a4 0210 	sub.w	r2, r4, #16
    7abc:	f022 0c0f 	bic.w	ip, r2, #15
    7ac0:	f103 0e20 	add.w	lr, r3, #32
    7ac4:	44e6      	add	lr, ip
    7ac6:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    7aca:	f103 0210 	add.w	r2, r3, #16
    7ace:	e942 5504 	strd	r5, r5, [r2, #-16]
    7ad2:	e942 5502 	strd	r5, r5, [r2, #-8]
    7ad6:	3210      	adds	r2, #16
    7ad8:	4572      	cmp	r2, lr
    7ada:	d1f8      	bne.n	7ace <memset+0x46>
    7adc:	f10c 0201 	add.w	r2, ip, #1
    7ae0:	f014 0f0c 	tst.w	r4, #12
    7ae4:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    7ae8:	f004 0c0f 	and.w	ip, r4, #15
    7aec:	d013      	beq.n	7b16 <memset+0x8e>
    7aee:	f1ac 0304 	sub.w	r3, ip, #4
    7af2:	f023 0303 	bic.w	r3, r3, #3
    7af6:	3304      	adds	r3, #4
    7af8:	4413      	add	r3, r2
    7afa:	f842 5b04 	str.w	r5, [r2], #4
    7afe:	4293      	cmp	r3, r2
    7b00:	d1fb      	bne.n	7afa <memset+0x72>
    7b02:	f00c 0403 	and.w	r4, ip, #3
    7b06:	b12c      	cbz	r4, 7b14 <memset+0x8c>
    7b08:	b2c9      	uxtb	r1, r1
    7b0a:	441c      	add	r4, r3
    7b0c:	f803 1b01 	strb.w	r1, [r3], #1
    7b10:	429c      	cmp	r4, r3
    7b12:	d1fb      	bne.n	7b0c <memset+0x84>
    7b14:	bd30      	pop	{r4, r5, pc}
    7b16:	4664      	mov	r4, ip
    7b18:	4613      	mov	r3, r2
    7b1a:	2c00      	cmp	r4, #0
    7b1c:	d1f4      	bne.n	7b08 <memset+0x80>
    7b1e:	e7f9      	b.n	7b14 <memset+0x8c>
    7b20:	4603      	mov	r3, r0
    7b22:	4614      	mov	r4, r2
    7b24:	e7bf      	b.n	7aa6 <memset+0x1e>
    7b26:	461a      	mov	r2, r3
    7b28:	46a4      	mov	ip, r4
    7b2a:	e7e0      	b.n	7aee <memset+0x66>

00007b2c <__libc_init_array>:
    7b2c:	b570      	push	{r4, r5, r6, lr}
    7b2e:	4e0d      	ldr	r6, [pc, #52]	; (7b64 <__libc_init_array+0x38>)
    7b30:	4d0d      	ldr	r5, [pc, #52]	; (7b68 <__libc_init_array+0x3c>)
    7b32:	1b76      	subs	r6, r6, r5
    7b34:	10b6      	asrs	r6, r6, #2
    7b36:	d006      	beq.n	7b46 <__libc_init_array+0x1a>
    7b38:	2400      	movs	r4, #0
    7b3a:	f855 3b04 	ldr.w	r3, [r5], #4
    7b3e:	3401      	adds	r4, #1
    7b40:	4798      	blx	r3
    7b42:	42a6      	cmp	r6, r4
    7b44:	d1f9      	bne.n	7b3a <__libc_init_array+0xe>
    7b46:	4e09      	ldr	r6, [pc, #36]	; (7b6c <__libc_init_array+0x40>)
    7b48:	4d09      	ldr	r5, [pc, #36]	; (7b70 <__libc_init_array+0x44>)
    7b4a:	1b76      	subs	r6, r6, r5
    7b4c:	f000 f814 	bl	7b78 <___init_veneer>
    7b50:	10b6      	asrs	r6, r6, #2
    7b52:	d006      	beq.n	7b62 <__libc_init_array+0x36>
    7b54:	2400      	movs	r4, #0
    7b56:	f855 3b04 	ldr.w	r3, [r5], #4
    7b5a:	3401      	adds	r4, #1
    7b5c:	4798      	blx	r3
    7b5e:	42a6      	cmp	r6, r4
    7b60:	d1f9      	bne.n	7b56 <__libc_init_array+0x2a>
    7b62:	bd70      	pop	{r4, r5, r6, pc}
    7b64:	60001ab8 	.word	0x60001ab8
    7b68:	60001ab8 	.word	0x60001ab8
    7b6c:	60001adc 	.word	0x60001adc
    7b70:	60001ab8 	.word	0x60001ab8
    7b74:	00000000 	.word	0x00000000

00007b78 <___init_veneer>:
    7b78:	f85f f000 	ldr.w	pc, [pc]	; 7b7c <___init_veneer+0x4>
    7b7c:	60001a75 	.word	0x60001a75

00007b80 <___reboot_Teensyduino__veneer>:
    7b80:	f85f f000 	ldr.w	pc, [pc]	; 7b84 <___reboot_Teensyduino__veneer+0x4>
    7b84:	600019cd 	.word	0x600019cd
	...

Disassembly of section .fini:

00007b90 <_fini>:
    7b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7b92:	bf00      	nop
