
C:\Users\Adam\AppData\Local\Temp\arduino\sketches\1E3EBD161CF261E6D284F0D719605E18/main.ino.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
	if (dest == src) return;
	do {
		*dest++ = *src++;
	} while (dest < dest_end);
#else
	asm volatile(
60001400:	4281      	cmp	r1, r0
60001402:	d005      	beq.n	60001410 <memory_copy+0x10>
60001404:	f851 3b04 	ldr.w	r3, [r1], #4
60001408:	f840 3b04 	str.w	r3, [r0], #4
6000140c:	4282      	cmp	r2, r0
6000140e:	d8f9      	bhi.n	60001404 <memory_copy+0x4>
	"	cmp	%[end], %[dest]		\n"
	"	bhi.n	1b			\n"
	"2:					\n"
	: [dest] "+r" (dest), [src] "+r" (src) : [end] "r" (dest_end) : "r3", "memory");
#endif
}
60001410:	4770      	bx	lr
60001412:	bf00      	nop

60001414 <memory_clear.constprop.0>:
#if 0
	while (dest < dest_end) {
		*dest++ = 0;
	}
#else
	asm volatile(
60001414:	4a04      	ldr	r2, [pc, #16]	; (60001428 <memory_clear.constprop.0+0x14>)
60001416:	4905      	ldr	r1, [pc, #20]	; (6000142c <memory_clear.constprop.0+0x18>)
60001418:	f04f 0300 	mov.w	r3, #0
6000141c:	f842 3b04 	str.w	r3, [r2], #4
60001420:	4291      	cmp	r1, r2
60001422:	d8fb      	bhi.n	6000141c <memory_clear.constprop.0+0x8>
	"1:	str.w	r3, [%[dest]], #4	\n"
	"	cmp	%[end], %[dest]		\n"
	"	bhi.n	1b			\n"
	: [dest] "+r" (dest) : [end] "r" (dest_end) : "r3", "memory");
#endif
}
60001424:	4770      	bx	lr
60001426:	bf00      	nop
60001428:	20001ec0 	.word	0x20001ec0
6000142c:	20007760 	.word	0x20007760

60001430 <ResetHandler2>:
{
60001430:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
	__asm__ volatile("dsb":::"memory");
60001434:	f3bf 8f4f 	dsb	sy
	asm volatile("nop");
60001438:	bf00      	nop
	asm volatile("nop");
6000143a:	bf00      	nop
	asm volatile("nop");
6000143c:	bf00      	nop
	asm volatile("nop");
6000143e:	bf00      	nop
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001440:	f000 f916 	bl	60001670 <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001444:	4b67      	ldr	r3, [pc, #412]	; (600015e4 <ResetHandler2+0x1b4>)
60001446:	2208      	movs	r2, #8
60001448:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
	asm volatile("nop");
6000144c:	bf00      	nop
	asm volatile("nop");
6000144e:	bf00      	nop
	asm volatile("nop");
60001450:	bf00      	nop
	asm volatile("nop");
60001452:	bf00      	nop
	asm volatile("nop");
60001454:	bf00      	nop
	asm volatile("nop");
60001456:	bf00      	nop
	asm volatile("nop");
60001458:	bf00      	nop
	asm volatile("nop");
6000145a:	bf00      	nop
	asm volatile("nop");
6000145c:	bf00      	nop
	asm volatile("nop");
6000145e:	bf00      	nop
	asm volatile("nop");
60001460:	bf00      	nop
	asm volatile("nop");
60001462:	bf00      	nop
	asm volatile("nop");
60001464:	bf00      	nop
	asm volatile("nop");
60001466:	bf00      	nop
	asm volatile("nop");
60001468:	bf00      	nop
	asm volatile("nop");
6000146a:	bf00      	nop
	memory_copy(&_stext, &_stextload, &_etext);
6000146c:	4a5e      	ldr	r2, [pc, #376]	; (600015e8 <ResetHandler2+0x1b8>)
6000146e:	495f      	ldr	r1, [pc, #380]	; (600015ec <ResetHandler2+0x1bc>)
60001470:	485f      	ldr	r0, [pc, #380]	; (600015f0 <ResetHandler2+0x1c0>)
60001472:	f7ff ffc5 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
60001476:	4a5f      	ldr	r2, [pc, #380]	; (600015f4 <ResetHandler2+0x1c4>)
60001478:	495f      	ldr	r1, [pc, #380]	; (600015f8 <ResetHandler2+0x1c8>)
6000147a:	4860      	ldr	r0, [pc, #384]	; (600015fc <ResetHandler2+0x1cc>)
6000147c:	f7ff ffc0 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001480:	4c5f      	ldr	r4, [pc, #380]	; (60001600 <ResetHandler2+0x1d0>)
60001482:	f7ff ffc7 	bl	60001414 <memory_clear.constprop.0>
	SCB_CPACR = 0x00F00000;
60001486:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000
6000148a:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000148e:	2300      	movs	r3, #0
60001490:	4a5c      	ldr	r2, [pc, #368]	; (60001604 <ResetHandler2+0x1d4>)
	SCB_CPACR = 0x00F00000;
60001492:	f8c1 0d88 	str.w	r0, [r1, #3464]	; 0xd88
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001496:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
6000149a:	3301      	adds	r3, #1
6000149c:	2bb0      	cmp	r3, #176	; 0xb0
6000149e:	d1fa      	bne.n	60001496 <ResetHandler2+0x66>
600014a0:	4b59      	ldr	r3, [pc, #356]	; (60001608 <ResetHandler2+0x1d8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600014a2:	2180      	movs	r1, #128	; 0x80
600014a4:	4a59      	ldr	r2, [pc, #356]	; (6000160c <ResetHandler2+0x1dc>)
600014a6:	f803 1b01 	strb.w	r1, [r3], #1
600014aa:	4293      	cmp	r3, r2
600014ac:	d1fb      	bne.n	600014a6 <ResetHandler2+0x76>
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b2:	4e4c      	ldr	r6, [pc, #304]	; (600015e4 <ResetHandler2+0x1b4>)
600014b4:	f04f 3980 	mov.w	r9, #2155905152	; 0x80808080
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b8:	f8df b180 	ldr.w	fp, [pc, #384]	; 6000163c <ResetHandler2+0x20c>
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8df a180 	ldr.w	sl, [pc, #384]	; 60001640 <ResetHandler2+0x210>
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014c0:	f04f 31ff 	mov.w	r1, #4294967295
	SCB_VTOR = (uint32_t)_VectorsRam;
600014c4:	f8c5 4d08 	str.w	r4, [r5, #3336]	; 0xd08
	SYST_CVR = 0;
600014c8:	2700      	movs	r7, #0
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014ca:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014ce:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014d2:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014d6:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014da:	f8d5 3d24 	ldr.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014de:	f8df 8164 	ldr.w	r8, [pc, #356]	; 60001644 <ResetHandler2+0x214>
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014e2:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e6:	4a4a      	ldr	r2, [pc, #296]	; (60001610 <ResetHandler2+0x1e0>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014e8:	f8c5 3d24 	str.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ec:	f8d8 301c 	ldr.w	r3, [r8, #28]
600014f0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014f4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014f8:	f8c8 301c 	str.w	r3, [r8, #28]
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014fc:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
60001500:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
60001504:	f043 0340 	orr.w	r3, r3, #64	; 0x40
60001508:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000150c:	6691      	str	r1, [r2, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
6000150e:	66d1      	str	r1, [r2, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
60001510:	6711      	str	r1, [r2, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
60001512:	6751      	str	r1, [r2, #116]	; 0x74
	configure_cache();
60001514:	f000 f8b4 	bl	60001680 <configure_cache>
	_VectorsRam[14] = pendablesrvreq_isr;
60001518:	4b3e      	ldr	r3, [pc, #248]	; (60001614 <ResetHandler2+0x1e4>)
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000151a:	493f      	ldr	r1, [pc, #252]	; (60001618 <ResetHandler2+0x1e8>)
	_VectorsRam[14] = pendablesrvreq_isr;
6000151c:	63a3      	str	r3, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
6000151e:	4b3f      	ldr	r3, [pc, #252]	; (6000161c <ResetHandler2+0x1ec>)
60001520:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001522:	2363      	movs	r3, #99	; 0x63
60001524:	616b      	str	r3, [r5, #20]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001526:	2303      	movs	r3, #3
	SYST_CVR = 0;
60001528:	61af      	str	r7, [r5, #24]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000152a:	612b      	str	r3, [r5, #16]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
6000152c:	4b3c      	ldr	r3, [pc, #240]	; (60001620 <ResetHandler2+0x1f0>)
6000152e:	f8c5 3d20 	str.w	r3, [r5, #3360]	; 0xd20
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001532:	f8d5 3dfc 	ldr.w	r3, [r5, #3580]	; 0xdfc
60001536:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
6000153a:	f8c5 3dfc 	str.w	r3, [r5, #3580]	; 0xdfc
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000153e:	4b39      	ldr	r3, [pc, #228]	; (60001624 <ResetHandler2+0x1f4>)
60001540:	681a      	ldr	r2, [r3, #0]
60001542:	f042 0201 	orr.w	r2, r2, #1
60001546:	601a      	str	r2, [r3, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001548:	685b      	ldr	r3, [r3, #4]
6000154a:	600b      	str	r3, [r1, #0]
	usb_pll_start();	
6000154c:	f000 f920 	bl	60001790 <usb_pll_start>
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001550:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	set_arm_clock(F_CPU);
60001554:	4834      	ldr	r0, [pc, #208]	; (60001628 <ResetHandler2+0x1f8>)
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001556:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000155a:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000155e:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	set_arm_clock(F_CPU);
60001562:	f000 faa9 	bl	60001ab8 <__set_arm_clock_veneer>
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001566:	f8d8 106c 	ldr.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
6000156a:	4b30      	ldr	r3, [pc, #192]	; (6000162c <ResetHandler2+0x1fc>)
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000156c:	4a30      	ldr	r2, [pc, #192]	; (60001630 <ResetHandler2+0x200>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000156e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
60001572:	f8c8 106c 	str.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
60001576:	601f      	str	r7, [r3, #0]
	PIT_TCTRL0 = 0;
60001578:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000157c:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001580:	f8c3 7128 	str.w	r7, [r3, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001584:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001588:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000158a:	07db      	lsls	r3, r3, #31
6000158c:	d408      	bmi.n	600015a0 <ResetHandler2+0x170>
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000158e:	f642 6315 	movw	r3, #11797	; 0x2e15
		SNVS_LPSRTCLR = 1546300800u << 15;
60001592:	4928      	ldr	r1, [pc, #160]	; (60001634 <ResetHandler2+0x204>)
60001594:	6551      	str	r1, [r2, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001596:	6513      	str	r3, [r2, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001598:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000159a:	f043 0301 	orr.w	r3, r3, #1
6000159e:	6393      	str	r3, [r2, #56]	; 0x38
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600015a0:	4a23      	ldr	r2, [pc, #140]	; (60001630 <ResetHandler2+0x200>)
600015a2:	4c25      	ldr	r4, [pc, #148]	; (60001638 <ResetHandler2+0x208>)
600015a4:	6893      	ldr	r3, [r2, #8]
600015a6:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
600015aa:	6093      	str	r3, [r2, #8]
	analog_init();
600015ac:	f000 fa54 	bl	60001a58 <analog_init>
	pwm_init();
600015b0:	f000 fa8e 	bl	60001ad0 <__pwm_init_veneer>
	tempmon_init();
600015b4:	f000 f91a 	bl	600017ec <tempmon_init>
	startup_middle_hook();
600015b8:	f000 f85c 	bl	60001674 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015bc:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015be:	2b13      	cmp	r3, #19
600015c0:	d9fc      	bls.n	600015bc <ResetHandler2+0x18c>
	usb_init();
600015c2:	f000 f9ab 	bl	6000191c <usb_init>
600015c6:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015c8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015cc:	d3fb      	bcc.n	600015c6 <ResetHandler2+0x196>
	startup_debug_reset();
600015ce:	f000 f855 	bl	6000167c <startup_debug_reset>
	startup_late_hook();
600015d2:	f000 f851 	bl	60001678 <startup_default_late_hook>
	__libc_init_array();
600015d6:	f000 fa87 	bl	60001ae8 <____libc_init_array_veneer>
	main();
600015da:	f000 fa71 	bl	60001ac0 <__main_veneer>
	while (1) asm("WFI");
600015de:	bf30      	wfi
600015e0:	e7fd      	b.n	600015de <ResetHandler2+0x1ae>
600015e2:	bf00      	nop
600015e4:	400d8000 	.word	0x400d8000
600015e8:	0000ddc0 	.word	0x0000ddc0
600015ec:	60001c14 	.word	0x60001c14
600015f0:	00000000 	.word	0x00000000
600015f4:	20001ec0 	.word	0x20001ec0
600015f8:	6000f9d8 	.word	0x6000f9d8
600015fc:	20000000 	.word	0x20000000
60001600:	20001c00 	.word	0x20001c00
60001604:	00006745 	.word	0x00006745
60001608:	e000e400 	.word	0xe000e400
6000160c:	e000e4a0 	.word	0xe000e4a0
60001610:	400ac000 	.word	0x400ac000
60001614:	00005029 	.word	0x00005029
60001618:	200075a4 	.word	0x200075a4
6000161c:	0000502d 	.word	0x0000502d
60001620:	20200000 	.word	0x20200000
60001624:	e0001000 	.word	0xe0001000
60001628:	08f0d180 	.word	0x08f0d180
6000162c:	40084000 	.word	0x40084000
60001630:	400d4000 	.word	0x400d4000
60001634:	56c00000 	.word	0x56c00000
60001638:	200075a8 	.word	0x200075a8
6000163c:	2018101b 	.word	0x2018101b
60001640:	13110d0c 	.word	0x13110d0c
60001644:	400fc000 	.word	0x400fc000

60001648 <ResetHandler>:
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001648:	4b05      	ldr	r3, [pc, #20]	; (60001660 <ResetHandler+0x18>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000164a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000164e:	4a05      	ldr	r2, [pc, #20]	; (60001664 <ResetHandler+0x1c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001650:	4805      	ldr	r0, [pc, #20]	; (60001668 <ResetHandler+0x20>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001652:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001654:	6418      	str	r0, [r3, #64]	; 0x40
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : "memory");
60001656:	4a05      	ldr	r2, [pc, #20]	; (6000166c <ResetHandler+0x24>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001658:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : "memory");
6000165a:	4695      	mov	sp, r2
	ResetHandler2();
6000165c:	f7ff fee8 	bl	60001430 <ResetHandler2>
60001660:	400ac000 	.word	0x400ac000
60001664:	aaaaaaaf 	.word	0xaaaaaaaf
60001668:	00200007 	.word	0x00200007
6000166c:	20070000 	.word	0x20070000

60001670 <startup_default_early_hook>:
FLASHMEM void startup_default_early_hook(void) {}
60001670:	4770      	bx	lr
60001672:	bf00      	nop

60001674 <startup_default_middle_hook>:
60001674:	4770      	bx	lr
60001676:	bf00      	nop

60001678 <startup_default_late_hook>:
60001678:	4770      	bx	lr
6000167a:	bf00      	nop

6000167c <startup_debug_reset>:
FLASHMEM void startup_debug_reset(void) { __asm__ volatile("nop"); }
6000167c:	bf00      	nop
6000167e:	4770      	bx	lr

60001680 <configure_cache>:
{
60001680:	b410      	push	{r4}
	SCB_MPU_CTRL = 0; // turn off MPU
60001682:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60001686:	2100      	movs	r1, #0
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001688:	2410      	movs	r4, #16
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
6000168a:	4831      	ldr	r0, [pc, #196]	; (60001750 <configure_cache+0xd0>)
	SCB_MPU_CTRL = 0; // turn off MPU
6000168c:	f8c3 1d94 	str.w	r1, [r3, #3476]	; 0xd94
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001690:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001694:	2411      	movs	r4, #17
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001696:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_NOCACHE | READONLY | SIZE_512K;
6000169a:	482e      	ldr	r0, [pc, #184]	; (60001754 <configure_cache+0xd4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
6000169c:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016a0:	2412      	movs	r4, #18
	SCB_MPU_RASR = MEM_NOCACHE | READONLY | SIZE_512K;
600016a2:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016a6:	482c      	ldr	r0, [pc, #176]	; (60001758 <configure_cache+0xd8>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016a8:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ac:	4a2b      	ldr	r2, [pc, #172]	; (6000175c <configure_cache+0xdc>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ae:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016b2:	4c2b      	ldr	r4, [pc, #172]	; (60001760 <configure_cache+0xe0>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016b4:	f042 0215 	orr.w	r2, r2, #21
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016b8:	482a      	ldr	r0, [pc, #168]	; (60001764 <configure_cache+0xe4>)
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016ba:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016be:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016c2:	4c29      	ldr	r4, [pc, #164]	; (60001768 <configure_cache+0xe8>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016c4:	4829      	ldr	r0, [pc, #164]	; (6000176c <configure_cache+0xec>)
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016c6:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016ca:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016ce:	4c28      	ldr	r4, [pc, #160]	; (60001770 <configure_cache+0xf0>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016d0:	f8c3 2d9c 	str.w	r2, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016d4:	4827      	ldr	r0, [pc, #156]	; (60001774 <configure_cache+0xf4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016d6:	4a28      	ldr	r2, [pc, #160]	; (60001778 <configure_cache+0xf8>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016d8:	f8c3 4da0 	str.w	r4, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016dc:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016e0:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016e4:	f502 22a0 	add.w	r2, r2, #327680	; 0x50000
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016e8:	4c24      	ldr	r4, [pc, #144]	; (6000177c <configure_cache+0xfc>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016ea:	320c      	adds	r2, #12
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016ec:	4824      	ldr	r0, [pc, #144]	; (60001780 <configure_cache+0x100>)
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016ee:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016f2:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016f6:	4a23      	ldr	r2, [pc, #140]	; (60001784 <configure_cache+0x104>)
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016f8:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600016fc:	4c22      	ldr	r4, [pc, #136]	; (60001788 <configure_cache+0x108>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016fe:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001702:	f102 6240 	add.w	r2, r2, #201326592	; 0xc000000
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001706:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x80000000 | REGION(i++); // SEMC: SDRAM, NAND, SRAM, etc
6000170a:	4820      	ldr	r0, [pc, #128]	; (6000178c <configure_cache+0x10c>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000170c:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1G;
60001710:	320c      	adds	r2, #12
	SCB_MPU_RBAR = 0x80000000 | REGION(i++); // SEMC: SDRAM, NAND, SRAM, etc
60001712:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1G;
60001716:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	asm("nop"); // allow a few cycles for bus writes before enable MPU
6000171a:	bf00      	nop
	asm("nop");
6000171c:	bf00      	nop
	asm("nop");
6000171e:	bf00      	nop
	asm("nop");
60001720:	bf00      	nop
	asm("nop");
60001722:	bf00      	nop
	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001724:	2201      	movs	r2, #1
60001726:	f8c3 2d94 	str.w	r2, [r3, #3476]	; 0xd94
	asm("dsb");
6000172a:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172e:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001732:	f8c3 1f50 	str.w	r1, [r3, #3920]	; 0xf50
	asm("dsb");
60001736:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000173a:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173e:	f8d3 2d14 	ldr.w	r2, [r3, #3348]	; 0xd14
}
60001742:	f85d 4b04 	ldr.w	r4, [sp], #4
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
60001746:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
6000174a:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
}
6000174e:	4770      	bx	lr
60001750:	1000003f 	.word	0x1000003f
60001754:	07080025 	.word	0x07080025
60001758:	00100009 	.word	0x00100009
6000175c:	20007760 	.word	0x20007760
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	60000018 	.word	0x60000018
60001784:	070b002f 	.word	0x070b002f
60001788:	70000019 	.word	0x70000019
6000178c:	8000001a 	.word	0x8000001a

60001790 <usb_pll_start>:
{
60001790:	b4f0      	push	{r4, r5, r6, r7}
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001792:	4a15      	ldr	r2, [pc, #84]	; (600017e8 <usb_pll_start+0x58>)
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001794:	2740      	movs	r7, #64	; 0x40
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001796:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000179a:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000179e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
600017a2:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
600017a6:	f243 0042 	movw	r0, #12354	; 0x3042
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
600017aa:	6913      	ldr	r3, [r2, #16]
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
600017ac:	f013 0f02 	tst.w	r3, #2
600017b0:	d10e      	bne.n	600017d0 <usb_pll_start+0x40>
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
600017b2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
600017b6:	d00f      	beq.n	600017d8 <usb_pll_start+0x48>
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
600017b8:	f413 5f80 	tst.w	r3, #4096	; 0x1000
600017bc:	d00e      	beq.n	600017dc <usb_pll_start+0x4c>
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
600017be:	2b00      	cmp	r3, #0
600017c0:	daf3      	bge.n	600017aa <usb_pll_start+0x1a>
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
600017c2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
600017c6:	d10b      	bne.n	600017e0 <usb_pll_start+0x50>
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
600017c8:	065b      	lsls	r3, r3, #25
600017ca:	d50b      	bpl.n	600017e4 <usb_pll_start+0x54>
}
600017cc:	bcf0      	pop	{r4, r5, r6, r7}
600017ce:	4770      	bx	lr
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
600017d0:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
600017d2:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
600017d4:	6190      	str	r0, [r2, #24]
			continue;
600017d6:	e7e8      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
600017d8:	6155      	str	r5, [r2, #20]
			continue;
600017da:	e7e6      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
600017dc:	6156      	str	r6, [r2, #20]
			continue;
600017de:	e7e4      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600017e0:	6191      	str	r1, [r2, #24]
			continue;
600017e2:	e7e2      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600017e4:	6157      	str	r7, [r2, #20]
			continue;
600017e6:	e7e0      	b.n	600017aa <usb_pll_start+0x1a>
600017e8:	400d8000 	.word	0x400d8000

600017ec <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017ec:	4a3f      	ldr	r2, [pc, #252]	; (600018ec <tempmon_init+0x100>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600017ee:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600017f0:	493f      	ldr	r1, [pc, #252]	; (600018f0 <tempmon_init+0x104>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017f2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017f6:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600017fa:	f04f 0c00 	mov.w	ip, #0
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600017fe:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 600018f4 <tempmon_init+0x108>
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001802:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001806:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 600018f8 <tempmon_init+0x10c>
{
6000180a:	b430      	push	{r4, r5}
  TEMPMON_TEMPSENSE0 &= ~0x1U;
6000180c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001810:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  calibrationData = HW_OCOTP_ANA1;
60001814:	f8d1 10e0 	ldr.w	r1, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001818:	4d38      	ldr	r5, [pc, #224]	; (600018fc <tempmon_init+0x110>)
6000181a:	b2cb      	uxtb	r3, r1
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
6000181c:	4c38      	ldr	r4, [pc, #224]	; (60001900 <tempmon_init+0x114>)
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000181e:	4839      	ldr	r0, [pc, #228]	; (60001904 <tempmon_init+0x118>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001820:	602b      	str	r3, [r5, #0]
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001822:	ee07 3a90 	vmov	s15, r3
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
60001826:	0d0b      	lsrs	r3, r1, #20
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001828:	f3c1 210b 	ubfx	r1, r1, #8, #12
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000182c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
60001830:	ee06 3a90 	vmov	s13, r3
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001834:	ee07 1a10 	vmov	s14, r1
60001838:	4b33      	ldr	r3, [pc, #204]	; (60001908 <tempmon_init+0x11c>)
6000183a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
6000183e:	6021      	str	r1, [r4, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001840:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001844:	4931      	ldr	r1, [pc, #196]	; (6000190c <tempmon_init+0x120>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001846:	ee37 6ac6 	vsub.f32	s12, s15, s12
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000184a:	ee37 5ac5 	vsub.f32	s10, s15, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
6000184e:	ee76 6ac7 	vsub.f32	s13, s13, s14
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001852:	ee77 7ae5 	vsub.f32	s15, s15, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001856:	ee26 6a26 	vmul.f32	s12, s12, s13
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
6000185a:	edc3 6a00 	vstr	s13, [r3]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000185e:	ee25 5a26 	vmul.f32	s10, s10, s13
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001862:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001866:	ee67 4aa6 	vmul.f32	s9, s15, s13
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000186a:	edc0 7a00 	vstr	s15, [r0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000186e:	eec6 5a27 	vdiv.f32	s11, s12, s15
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001872:	4827      	ldr	r0, [pc, #156]	; (60001910 <tempmon_init+0x124>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001874:	ee85 6a27 	vdiv.f32	s12, s10, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001878:	eec4 6aa7 	vdiv.f32	s13, s9, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000187c:	ee75 5a87 	vadd.f32	s11, s11, s14
60001880:	eefc 5ae5 	vcvt.u32.f32	s11, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001884:	ee36 6a07 	vadd.f32	s12, s12, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001888:	ee15 4a90 	vmov	r4, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000188c:	eebc 6ac6 	vcvt.u32.f32	s12, s12
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001890:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001894:	ee76 7a87 	vadd.f32	s15, s13, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001898:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000189c:	ee16 3a10 	vmov	r3, s12
600018a0:	f8d2 4190 	ldr.w	r4, [r2, #400]	; 0x190
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018a4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600018a8:	ea01 4103 	and.w	r1, r1, r3, lsl #16
600018ac:	4321      	orrs	r1, r4
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018ae:	ee17 3a90 	vmov	r3, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600018b2:	f8c2 1190 	str.w	r1, [r2, #400]	; 0x190
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600018b6:	f3c3 030b 	ubfx	r3, r3, #0, #12
600018ba:	f8d2 1190 	ldr.w	r1, [r2, #400]	; 0x190
600018be:	430b      	orrs	r3, r1
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
600018c0:	4914      	ldr	r1, [pc, #80]	; (60001914 <tempmon_init+0x128>)
600018c2:	f8c2 3190 	str.w	r3, [r2, #400]	; 0x190
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
600018c6:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
600018ca:	f043 0302 	orr.w	r3, r3, #2
600018ce:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
600018d2:	4b11      	ldr	r3, [pc, #68]	; (60001918 <tempmon_init+0x12c>)
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600018d4:	f880 c040 	strb.w	ip, [r0, #64]	; 0x40
600018d8:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018dc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
600018e0:	2201      	movs	r2, #1
}
600018e2:	bc30      	pop	{r4, r5}
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018e4:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
}
600018e8:	4770      	bx	lr
600018ea:	bf00      	nop
600018ec:	400d8100 	.word	0x400d8100
600018f0:	401f4400 	.word	0x401f4400
600018f4:	42aa0000 	.word	0x42aa0000
600018f8:	42b40000 	.word	0x42b40000
600018fc:	20007550 	.word	0x20007550
60001900:	2000754c 	.word	0x2000754c
60001904:	20007554 	.word	0x20007554
60001908:	20007558 	.word	0x20007558
6000190c:	0fff0000 	.word	0x0fff0000
60001910:	e000e400 	.word	0xe000e400
60001914:	20001c00 	.word	0x20001c00
60001918:	0000692d 	.word	0x0000692d

6000191c <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
6000191c:	4b31      	ldr	r3, [pc, #196]	; (600019e4 <usb_init+0xc8>)
6000191e:	f640 7261 	movw	r2, #3937	; 0xf61
{
60001922:	b510      	push	{r4, lr}
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001924:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001928:	f240 4404 	movw	r4, #1028	; 0x404
	usb_init_serialnumber();
6000192c:	f000 f8cc 	bl	60001ac8 <__usb_init_serialnumber_veneer>
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001930:	4a2d      	ldr	r2, [pc, #180]	; (600019e8 <usb_init+0xcc>)
	USB1_BURSTSIZE = 0x0404;
60001932:	492e      	ldr	r1, [pc, #184]	; (600019ec <usb_init+0xd0>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001934:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001938:	482d      	ldr	r0, [pc, #180]	; (600019f0 <usb_init+0xd4>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
6000193a:	f043 0303 	orr.w	r3, r3, #3
6000193e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001942:	4b2c      	ldr	r3, [pc, #176]	; (600019f4 <usb_init+0xd8>)
	USB1_BURSTSIZE = 0x0404;
60001944:	f8c1 4160 	str.w	r4, [r1, #352]	; 0x160
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001948:	6802      	ldr	r2, [r0, #0]
6000194a:	421a      	tst	r2, r3
6000194c:	d103      	bne.n	60001956 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
6000194e:	f8d1 31a8 	ldr.w	r3, [r1, #424]	; 0x1a8
60001952:	079a      	lsls	r2, r3, #30
60001954:	d01b      	beq.n	6000198e <usb_init+0x72>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001956:	4a25      	ldr	r2, [pc, #148]	; (600019ec <usb_init+0xd0>)
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001958:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
6000195c:	4b24      	ldr	r3, [pc, #144]	; (600019f0 <usb_init+0xd4>)
6000195e:	6359      	str	r1, [r3, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001960:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001964:	f043 0302 	orr.w	r3, r3, #2
60001968:	f8c2 3140 	str.w	r3, [r2, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
6000196c:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001970:	079b      	lsls	r3, r3, #30
60001972:	d4fb      	bmi.n	6000196c <usb_init+0x50>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001974:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001978:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
6000197c:	4b1c      	ldr	r3, [pc, #112]	; (600019f0 <usb_init+0xd4>)
6000197e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001982:	f8c1 028c 	str.w	r0, [r1, #652]	; 0x28c
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001986:	2019      	movs	r0, #25
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001988:	639a      	str	r2, [r3, #56]	; 0x38
		delay(25);
6000198a:	f000 f8a9 	bl	60001ae0 <__delay_veneer>
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000198e:	4a18      	ldr	r2, [pc, #96]	; (600019f0 <usb_init+0xd4>)
60001990:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001994:	4c15      	ldr	r4, [pc, #84]	; (600019ec <usb_init+0xd0>)
	USBPHY1_PWD = 0;
60001996:	2100      	movs	r1, #0
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001998:	6390      	str	r0, [r2, #56]	; 0x38
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000199a:	200a      	movs	r0, #10
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000199c:	4b16      	ldr	r3, [pc, #88]	; (600019f8 <usb_init+0xdc>)
	USBPHY1_PWD = 0;
6000199e:	6011      	str	r1, [r2, #0]
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
600019a0:	f44f 7220 	mov.w	r2, #640	; 0x280
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
600019a4:	f8c4 01a8 	str.w	r0, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
600019a8:	4618      	mov	r0, r3
600019aa:	f000 f895 	bl	60001ad8 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
600019ae:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
600019b2:	4603      	mov	r3, r0
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
600019b4:	f44f 0081 	mov.w	r0, #4227072	; 0x408000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
600019b8:	f240 1143 	movw	r1, #323	; 0x143
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
600019bc:	6018      	str	r0, [r3, #0]
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
600019be:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
	endpoint_queue_head[1].config = (64 << 16);
600019c2:	641a      	str	r2, [r3, #64]	; 0x40
600019c4:	4b0d      	ldr	r3, [pc, #52]	; (600019fc <usb_init+0xe0>)
600019c6:	4a0e      	ldr	r2, [pc, #56]	; (60001a00 <usb_init+0xe4>)
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
600019c8:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
600019cc:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
600019d0:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
600019d4:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600019d8:	2301      	movs	r3, #1
	NVIC_ENABLE_IRQ(IRQ_USB1);
600019da:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
	USB1_USBCMD = USB_USBCMD_RS;
600019de:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	//transfer_log_head = 0;
	//transfer_log_count = 0;
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}
600019e2:	bd10      	pop	{r4, pc}
600019e4:	400d8000 	.word	0x400d8000
600019e8:	400fc000 	.word	0x400fc000
600019ec:	402e0000 	.word	0x402e0000
600019f0:	400d9000 	.word	0x400d9000
600019f4:	001e1c00 	.word	0x001e1c00
600019f8:	20000000 	.word	0x20000000
600019fc:	20001c00 	.word	0x20001c00
60001a00:	00006b15 	.word	0x00006b15

60001a04 <_reboot_Teensyduino_>:


FLASHMEM __attribute__((noinline)) void _reboot_Teensyduino_(void)
{
60001a04:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001a06:	4b0e      	ldr	r3, [pc, #56]	; (60001a40 <_reboot_Teensyduino_+0x3c>)
60001a08:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001a0a:	079b      	lsls	r3, r3, #30
60001a0c:	d400      	bmi.n	60001a10 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001a0e:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001a10:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001a12:	4b0c      	ldr	r3, [pc, #48]	; (60001a44 <_reboot_Teensyduino_+0x40>)
60001a14:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001a16:	4a0c      	ldr	r2, [pc, #48]	; (60001a48 <_reboot_Teensyduino_+0x44>)
		USB1_USBCMD = 0;
60001a18:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001a1c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
		IOMUXC_GPR_GPR16 = 0x00200003;
60001a20:	490a      	ldr	r1, [pc, #40]	; (60001a4c <_reboot_Teensyduino_+0x48>)
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001a22:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
		IOMUXC_GPR_GPR16 = 0x00200003;
60001a26:	6411      	str	r1, [r2, #64]	; 0x40
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001a28:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001a2a:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a2e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
		*p = 0xEB120000;
60001a32:	4807      	ldr	r0, [pc, #28]	; (60001a50 <_reboot_Teensyduino_+0x4c>)
60001a34:	4a07      	ldr	r2, [pc, #28]	; (60001a54 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a36:	69db      	ldr	r3, [r3, #28]
		*p = 0xEB120000;
60001a38:	6002      	str	r2, [r0, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a3a:	689b      	ldr	r3, [r3, #8]
60001a3c:	4798      	blx	r3
	}
	__builtin_unreachable();
60001a3e:	bf00      	nop
60001a40:	401f4400 	.word	0x401f4400
60001a44:	402e0000 	.word	0x402e0000
60001a48:	400ac000 	.word	0x400ac000
60001a4c:	00200003 	.word	0x00200003
60001a50:	20208000 	.word	0x20208000
60001a54:	eb120000 	.word	0xeb120000

60001a58 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a58:	4b10      	ldr	r3, [pc, #64]	; (60001a9c <analog_init+0x44>)
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a5a:	20a0      	movs	r0, #160	; 0xa0
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a5c:	4a10      	ldr	r2, [pc, #64]	; (60001aa0 <analog_init+0x48>)
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a5e:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a60:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
{
60001a64:	b410      	push	{r4}
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a66:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a68:	f240 6437 	movw	r4, #1591	; 0x637
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001a6c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a6e:	f441 7140 	orr.w	r1, r1, #768	; 0x300
60001a72:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a74:	6454      	str	r4, [r2, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a76:	6490      	str	r0, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001a78:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a7a:	061b      	lsls	r3, r3, #24
60001a7c:	d4fc      	bmi.n	60001a78 <analog_init+0x20>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a7e:	4a09      	ldr	r2, [pc, #36]	; (60001aa4 <analog_init+0x4c>)
60001a80:	f240 6137 	movw	r1, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a84:	23a0      	movs	r3, #160	; 0xa0
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a86:	6451      	str	r1, [r2, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a88:	6493      	str	r3, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001a8a:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a8c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001a90:	d1fb      	bne.n	60001a8a <analog_init+0x32>
		//yield();
	}
	calibrating = 0;
60001a92:	4a05      	ldr	r2, [pc, #20]	; (60001aa8 <analog_init+0x50>)
60001a94:	7013      	strb	r3, [r2, #0]
}
60001a96:	f85d 4b04 	ldr.w	r4, [sp], #4
60001a9a:	4770      	bx	lr
60001a9c:	400fc000 	.word	0x400fc000
60001aa0:	400c4000 	.word	0x400c4000
60001aa4:	400c8000 	.word	0x400c8000
60001aa8:	2000770e 	.word	0x2000770e

60001aac <_init>:
60001aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60001aae:	bf00      	nop
60001ab0:	bcf8      	pop	{r3, r4, r5, r6, r7}
60001ab2:	bc08      	pop	{r3}
60001ab4:	469e      	mov	lr, r3
60001ab6:	4770      	bx	lr

60001ab8 <__set_arm_clock_veneer>:
60001ab8:	f85f f000 	ldr.w	pc, [pc]	; 60001abc <__set_arm_clock_veneer+0x4>
60001abc:	0000593d 	.word	0x0000593d

60001ac0 <__main_veneer>:
60001ac0:	f85f f000 	ldr.w	pc, [pc]	; 60001ac4 <__main_veneer+0x4>
60001ac4:	000062ad 	.word	0x000062ad

60001ac8 <__usb_init_serialnumber_veneer>:
60001ac8:	f85f f000 	ldr.w	pc, [pc]	; 60001acc <__usb_init_serialnumber_veneer+0x4>
60001acc:	00007285 	.word	0x00007285

60001ad0 <__pwm_init_veneer>:
60001ad0:	f85f f000 	ldr.w	pc, [pc]	; 60001ad4 <__pwm_init_veneer+0x4>
60001ad4:	00006651 	.word	0x00006651

60001ad8 <__memset_veneer>:
60001ad8:	f85f f000 	ldr.w	pc, [pc]	; 60001adc <__memset_veneer+0x4>
60001adc:	000088ad 	.word	0x000088ad

60001ae0 <__delay_veneer>:
60001ae0:	f85f f000 	ldr.w	pc, [pc]	; 60001ae4 <__delay_veneer+0x4>
60001ae4:	00005c2d 	.word	0x00005c2d

60001ae8 <____libc_init_array_veneer>:
60001ae8:	f85f f000 	ldr.w	pc, [pc]	; 60001aec <____libc_init_array_veneer+0x4>
60001aec:	00008a99 	.word	0x00008a99

60001af0 <__frame_dummy_init_array_entry>:
60001af0:	00000105 00000149 00000409 00000bf5     ....I...........
60001b00:	00000e99 00004ccd 00004fe1              .....L...O..

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <irq_gpio6789>:
	while (SNVS_HPCR & SNVS_HPCR_RTC_EN); // wait
	// stop the SRTC
	SNVS_LPCR &= ~SNVS_LPCR_SRTC_ENV;
	while (SNVS_LPCR & SNVS_LPCR_SRTC_ENV); // wait
	// set the SRTC
	SNVS_LPSRTCLR = t << 15;
      20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SNVS_LPSRTCMR = t >> 17;
	// start the SRTC
	SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
	while (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)); // wait
      22:	f04f 4384 	mov.w	r3, #1107296256	; 0x42000000
	SNVS_LPSRTCLR = t << 15;
      26:	699d      	ldr	r5, [r3, #24]
	SNVS_LPSRTCMR = t >> 17;
      28:	695a      	ldr	r2, [r3, #20]
	SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
      2a:	4015      	ands	r5, r2
      2c:	d00d      	beq.n	4a <_teensy_model_identifier+0x26>
      2e:	4f25      	ldr	r7, [pc, #148]	; (c4 <_teensy_model_identifier+0xa0>)
      30:	2601      	movs	r6, #1
	while (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)); // wait
      32:	619d      	str	r5, [r3, #24]
      34:	fa95 f4a5 	rbit	r4, r5
	// start the RTC and sync it to the SRTC
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
      38:	fab4 f484 	clz	r4, r4
      3c:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
}
      40:	fa06 f404 	lsl.w	r4, r6, r4
      44:	4798      	blx	r3
      46:	43a5      	bics	r5, r4
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
	return usec;
}
      48:	d1f4      	bne.n	34 <_teensy_model_identifier+0x10>
      4a:	4b1f      	ldr	r3, [pc, #124]	; (c8 <_teensy_model_identifier+0xa4>)
      4c:	699d      	ldr	r5, [r3, #24]
      4e:	695a      	ldr	r2, [r3, #20]
      50:	4015      	ands	r5, r2
      52:	d00d      	beq.n	70 <_teensy_model_identifier+0x4c>
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      54:	4f1d      	ldr	r7, [pc, #116]	; (cc <_teensy_model_identifier+0xa8>)
      56:	2601      	movs	r6, #1
      58:	619d      	str	r5, [r3, #24]
      5a:	fa95 f4a5 	rbit	r4, r5
}
      5e:	fab4 f484 	clz	r4, r4
      62:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      66:	fa06 f404 	lsl.w	r4, r6, r4
      6a:	4798      	blx	r3
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
		MillisTimer *next = waiting->_next;
      6c:	43a5      	bics	r5, r4
		waiting->addToActiveList();
      6e:	d1f4      	bne.n	5a <_teensy_model_identifier+0x36>
      70:	4b17      	ldr	r3, [pc, #92]	; (d0 <_teensy_model_identifier+0xac>)
	while (waiting) {
      72:	699d      	ldr	r5, [r3, #24]
      74:	695a      	ldr	r2, [r3, #20]
		waiting = next;
	}
}
      76:	4015      	ands	r5, r2
			event.triggerEvent(0, timer);
      78:	d00d      	beq.n	96 <_teensy_model_identifier+0x72>
      7a:	4f16      	ldr	r7, [pc, #88]	; (d4 <_teensy_model_identifier+0xb0>)
      7c:	2601      	movs	r6, #1
      7e:	619d      	str	r5, [r3, #24]
			timer->_ms--;
      80:	fa95 f4a5 	rbit	r4, r5
			break;
      84:	fab4 f484 	clz	r4, r4
      88:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      8c:	fa06 f404 	lsl.w	r4, r6, r4
      90:	4798      	blx	r3
      92:	43a5      	bics	r5, r4
	if(!(ch & 0x80)) {
      94:	d1f4      	bne.n	80 <_teensy_model_identifier+0x5c>
      96:	4b10      	ldr	r3, [pc, #64]	; (d8 <_teensy_model_identifier+0xb4>)
	if (pin > sizeof(pin_to_channel)) return 0;
      98:	699d      	ldr	r5, [r3, #24]
}
      9a:	695a      	ldr	r2, [r3, #20]
      9c:	4015      	ands	r5, r2
      9e:	d00d      	beq.n	bc <_teensy_model_identifier+0x98>
      a0:	4f0e      	ldr	r7, [pc, #56]	; (dc <_teensy_model_identifier+0xb8>)
      a2:	2601      	movs	r6, #1
      a4:	619d      	str	r5, [r3, #24]
      a6:	fa95 f4a5 	rbit	r4, r5
      aa:	fab4 f484 	clz	r4, r4
      ae:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FF8000;
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
	flash_wait();
      b2:	fa06 f404 	lsl.w	r4, r6, r4
      b6:	4798      	blx	r3
      b8:	43a5      	bics	r5, r4
      ba:	d1f4      	bne.n	a6 <_teensy_model_identifier+0x82>
{
	irq_anyport(&GPIO6_DR, isr_table_gpio1);
	irq_anyport(&GPIO7_DR, isr_table_gpio2);
	irq_anyport(&GPIO8_DR, isr_table_gpio3);
	irq_anyport(&GPIO9_DR, isr_table_gpio4);
	asm volatile ("dsb":::"memory");
      bc:	f3bf 8f4f 	dsb	sy
}
      c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      c2:	bf00      	nop
      c4:	20001784 	.word	0x20001784
      c8:	42004000 	.word	0x42004000
      cc:	20001804 	.word	0x20001804
      d0:	42008000 	.word	0x42008000
      d4:	20001884 	.word	0x20001884
      d8:	4200c000 	.word	0x4200c000
      dc:	20001904 	.word	0x20001904

000000e0 <register_tm_clones>:

  CAN_message_t brakes3;
  brakes3.id = BRAKES3_ID;
  brakes3.len = 8;
  brakes3.buf[0] = 0x0;   // low byte, LEFT Front
  brakes3.buf[1] = 0xA;   // high byte, LEFT Front
      e0:	4805      	ldr	r0, [pc, #20]	; (f8 <register_tm_clones+0x18>)
      e2:	4b06      	ldr	r3, [pc, #24]	; (fc <register_tm_clones+0x1c>)

  brakes3.buf[2] = 0x0;   // low byte, RIGHT Front
  brakes3.buf[3] = 0xA;   // high byte, RIGHT Front
      e4:	1a1b      	subs	r3, r3, r0
      e6:	0fd9      	lsrs	r1, r3, #31
  CAN_message_t brakes3;
      e8:	eb01 01a3 	add.w	r1, r1, r3, asr #2
  brakes3.buf[4] = 0x0;   // low byte, LEFT Rear
  brakes3.buf[5] = 0x04;  // high byte, LEFT Rear // 254+10? (5050 returns 0xA)

  brakes3.buf[6] = 0x0;   // low byte, RIGHT Rear
  brakes3.buf[7] = 0x04;  // low byte, RIGHT Rear  // 254+10?
  HaldexCAN.write(brakes3);
      ec:	1049      	asrs	r1, r1, #1
      ee:	d002      	beq.n	f6 <register_tm_clones+0x16>
  brakes3.buf[5] = 0x04;  // high byte, LEFT Rear // 254+10? (5050 returns 0xA)
      f0:	4b03      	ldr	r3, [pc, #12]	; (100 <register_tm_clones+0x20>)
      f2:	b103      	cbz	r3, f6 <register_tm_clones+0x16>
  brakes3.buf[7] = 0x04;  // low byte, RIGHT Rear  // 254+10?
      f4:	4718      	bx	r3
      f6:	4770      	bx	lr
  HaldexCAN.write(brakes3);
      f8:	20001ec0 	.word	0x20001ec0
}
      fc:	20001ec0 	.word	0x20001ec0
     100:	00000000 	.word	0x00000000

00000104 <frame_dummy>:
     104:	b508      	push	{r3, lr}
     106:	4b05      	ldr	r3, [pc, #20]	; (11c <frame_dummy+0x18>)
     108:	b11b      	cbz	r3, 112 <frame_dummy+0xe>
     10a:	4905      	ldr	r1, [pc, #20]	; (120 <frame_dummy+0x1c>)
     10c:	4805      	ldr	r0, [pc, #20]	; (124 <frame_dummy+0x20>)
     10e:	f3af 8000 	nop.w
     112:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    value = -value;
  if(isFraction)
    return value * fraction;
  else
    return value;
}
     116:	f7ff bfe3 	b.w	e0 <register_tm_clones>
     11a:	bf00      	nop
     11c:	00000000 	.word	0x00000000
     120:	200074f8 	.word	0x200074f8
     124:	60012800 	.word	0x60012800

00000128 <printMode(void*)>:
uint32_t lastTransmission = 0;
bool btConnected = false;

auto timer = timer_create_default();

bool printMode(void *params) {
     128:	b508      	push	{r3, lr}
  Serial.printf("OpenHaldex mode=%d\n", state.mode);
     12a:	4b04      	ldr	r3, [pc, #16]	; (13c <printMode(void*)+0x14>)
     12c:	4904      	ldr	r1, [pc, #16]	; (140 <printMode(void*)+0x18>)
     12e:	781a      	ldrb	r2, [r3, #0]
     130:	4804      	ldr	r0, [pc, #16]	; (144 <printMode(void*)+0x1c>)
     132:	f005 fb99 	bl	5868 <Print::printf(char const*, ...)>
  return true;
}
     136:	2001      	movs	r0, #1
     138:	bd08      	pop	{r3, pc}
     13a:	bf00      	nop
     13c:	20007580 	.word	0x20007580
     140:	20000690 	.word	0x20000690
     144:	20001110 	.word	0x20001110

00000148 <_GLOBAL__sub_I_state>:
    btInit();  // can't have BT_Conf as an interrupt and change the pin state...
  }

  // light up the LED as per the 'state.mode'
  LED();
}
     148:	b508      	push	{r3, lr}
***/

struct EEPROMClass{

#if defined(__arm__) && defined(TEENSYDUINO)
    EEPROMClass()                        { eeprom_initialize(); }
     14a:	f005 fe65 	bl	5e18 <eeprom_initialize>
        }

        return true;
    }

    Timer() : tasks{} {}
     14e:	f44f 72a0 	mov.w	r2, #320	; 0x140
     152:	2100      	movs	r1, #0
     154:	4801      	ldr	r0, [pc, #4]	; (15c <_GLOBAL__sub_I_state+0x14>)
     156:	f008 fba9 	bl	88ac <memset>
     15a:	bd08      	pop	{r3, pc}
     15c:	200075b0 	.word	0x200075b0

00000160 <setup>:
			remainder -= n; 
		}
		count += write(buf, count);
	}
	return count;
}
     160:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	// is always initialized early during startup.  The baud rate setting
	// is not used.  Communication occurs at USB native speed.  For
	// compatibility with Arduino code, Serial.begin waits up to 2 seconds
	// for your PC to open the virtual serial port.
        void begin(long baud_unused __attribute__((unused))) {
		uint32_t millis_begin = systick_millis_count;
     164:	4d55      	ldr	r5, [pc, #340]	; (2bc <setup+0x15c>)
				// Wait up to 2 seconds for Arduino Serial Monitor
				if (elapsed > 2000) break;
			} else {
				// But wait only 3/4 second if there is no sign the
				// USB host has begun the USB enumeration process.
				if (elapsed > 750) break;
     166:	f240 28ee 	movw	r8, #750	; 0x2ee
     16a:	4c55      	ldr	r4, [pc, #340]	; (2c0 <setup+0x160>)
	// Testing Serial as a boolean indicates whether USB is active and a program
	// running on your PC has raised the DTR signal, which typically means it has
	// opened the port and is ready to communicate.
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     16c:	4f55      	ldr	r7, [pc, #340]	; (2c4 <setup+0x164>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     16e:	f8df 918c 	ldr.w	r9, [pc, #396]	; 2fc <setup+0x19c>
		uint32_t millis_begin = systick_millis_count;
     172:	682e      	ldr	r6, [r5, #0]
		yield();
     174:	f007 fc68 	bl	7a48 <yield>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     178:	7823      	ldrb	r3, [r4, #0]
     17a:	2b00      	cmp	r3, #0
     17c:	d073      	beq.n	266 <setup+0x106>
     17e:	783b      	ldrb	r3, [r7, #0]
     180:	07db      	lsls	r3, r3, #31
     182:	d570      	bpl.n	266 <setup+0x106>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     184:	682b      	ldr	r3, [r5, #0]
     186:	f8d9 2000 	ldr.w	r2, [r9]
     18a:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     18c:	2b0e      	cmp	r3, #14
     18e:	d96a      	bls.n	266 <setup+0x106>
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     190:	2124      	movs	r1, #36	; 0x24
     192:	484d      	ldr	r0, [pc, #308]	; (2c8 <setup+0x168>)
     194:	f007 fbda 	bl	794c <usb_serial_write>
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
	// Print a string and newline
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     198:	484c      	ldr	r0, [pc, #304]	; (2cc <setup+0x16c>)
     19a:	f005 fb49 	bl	5830 <Print::println()>
  Serial.printf("Running at %dMHz\r\n", F_CPU_ACTUAL / (1000 * 1000));
     19e:	4a4c      	ldr	r2, [pc, #304]	; (2d0 <setup+0x170>)
     1a0:	4b4c      	ldr	r3, [pc, #304]	; (2d4 <setup+0x174>)
     1a2:	6812      	ldr	r2, [r2, #0]
     1a4:	494c      	ldr	r1, [pc, #304]	; (2d8 <setup+0x178>)
     1a6:	fba3 3202 	umull	r3, r2, r3, r2
     1aa:	4848      	ldr	r0, [pc, #288]	; (2cc <setup+0x16c>)
     1ac:	0c92      	lsrs	r2, r2, #18
     1ae:	f005 fb5b 	bl	5868 <Print::printf(char const*, ...)>
  Serial2.begin(baudBT);
     1b2:	2200      	movs	r2, #0
     1b4:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     1b8:	4848      	ldr	r0, [pc, #288]	; (2dc <setup+0x17c>)
     1ba:	f005 f837 	bl	522c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>
     1be:	2117      	movs	r1, #23
     1c0:	4847      	ldr	r0, [pc, #284]	; (2e0 <setup+0x180>)
     1c2:	f007 fbc3 	bl	794c <usb_serial_write>
     1c6:	4841      	ldr	r0, [pc, #260]	; (2cc <setup+0x16c>)
     1c8:	f005 fb32 	bl	5830 <Print::println()>
  pinMode(LED_BUILTIN, OUTPUT);
     1cc:	2101      	movs	r1, #1
     1ce:	200d      	movs	r0, #13
     1d0:	f005 fdbc 	bl	5d4c <pinMode>
  canInit();
     1d4:	f002 fbd8 	bl	2988 <canInit()>
  readEEP();
     1d8:	f004 fdda 	bl	4d90 <readEEP()>
  pinMode(pinLED_R, OUTPUT);
     1dc:	2101      	movs	r1, #1
     1de:	200c      	movs	r0, #12
     1e0:	f005 fdb4 	bl	5d4c <pinMode>
  pinMode(pinLED_G, OUTPUT);
     1e4:	2101      	movs	r1, #1
     1e6:	200a      	movs	r0, #10
     1e8:	f005 fdb0 	bl	5d4c <pinMode>
  pinMode(pinLED_B, OUTPUT);
     1ec:	2101      	movs	r1, #1
     1ee:	200b      	movs	r0, #11
     1f0:	f005 fdac 	bl	5d4c <pinMode>
  attachInterrupt(pinSwitchMode, checkSwitchMode, HIGH);
     1f4:	2201      	movs	r2, #1
     1f6:	493b      	ldr	r1, [pc, #236]	; (2e4 <setup+0x184>)
     1f8:	2011      	movs	r0, #17
     1fa:	f005 ffd5 	bl	61a8 <attachInterrupt>
  pinMode(pinBT_Conf, INPUT);
     1fe:	2100      	movs	r1, #0
     200:	2004      	movs	r0, #4
     202:	f005 fda3 	bl	5d4c <pinMode>

    inline
    struct task *
    next_task_slot()
    {
        timer_foreach_task(slot) {
     206:	4b38      	ldr	r3, [pc, #224]	; (2e8 <setup+0x188>)
     208:	6828      	ldr	r0, [r5, #0]
     20a:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     20e:	681a      	ldr	r2, [r3, #0]
     210:	2a00      	cmp	r2, #0
     212:	d035      	beq.n	280 <setup+0x120>
        timer_foreach_task(slot) {
     214:	3314      	adds	r3, #20
     216:	428b      	cmp	r3, r1
     218:	d1f9      	bne.n	20e <setup+0xae>
     21a:	4b33      	ldr	r3, [pc, #204]	; (2e8 <setup+0x188>)
     21c:	6828      	ldr	r0, [r5, #0]
     21e:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     222:	681a      	ldr	r2, [r3, #0]
     224:	2a00      	cmp	r2, #0
     226:	d03f      	beq.n	2a8 <setup+0x148>
        timer_foreach_task(slot) {
     228:	3314      	adds	r3, #20
     22a:	428b      	cmp	r3, r1
     22c:	d1f9      	bne.n	222 <setup+0xc2>
     22e:	4b2e      	ldr	r3, [pc, #184]	; (2e8 <setup+0x188>)
     230:	6828      	ldr	r0, [r5, #0]
     232:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     236:	681a      	ldr	r2, [r3, #0]
     238:	b362      	cbz	r2, 294 <setup+0x134>
        timer_foreach_task(slot) {
     23a:	3314      	adds	r3, #20
     23c:	428b      	cmp	r3, r1
     23e:	d1fa      	bne.n	236 <setup+0xd6>
  CCM_ANALOG_PLL_AUDIO |= CCM_ANALOG_PLL_AUDIO_POWERDOWN;
     240:	4b2a      	ldr	r3, [pc, #168]	; (2ec <setup+0x18c>)
     242:	6f1a      	ldr	r2, [r3, #112]	; 0x70
     244:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     248:	671a      	str	r2, [r3, #112]	; 0x70
  CCM_ANALOG_PLL_VIDEO |= CCM_ANALOG_PLL_VIDEO_POWERDOWN;
     24a:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
     24e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     252:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  CCM_ANALOG_PLL_ENET |= CCM_ANALOG_PLL_ENET_POWERDOWN;
     256:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
     25a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     25e:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
}
     262:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			uint32_t elapsed = systick_millis_count - millis_begin;
     266:	682b      	ldr	r3, [r5, #0]
			if (usb_configuration) {
     268:	7822      	ldrb	r2, [r4, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
     26a:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
     26c:	b12a      	cbz	r2, 27a <setup+0x11a>
				if (elapsed > 2000) break;
     26e:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
     272:	d88d      	bhi.n	190 <setup+0x30>
			yield();
     274:	f007 fbe8 	bl	7a48 <yield>
     278:	e77c      	b.n	174 <setup+0x14>
				if (elapsed > 750) break;
     27a:	4543      	cmp	r3, r8
     27c:	d9fa      	bls.n	274 <setup+0x114>
     27e:	e787      	b.n	190 <setup+0x30>
    {
        struct task * const slot = next_task_slot();

        if (!slot) return NULL;

        slot->handler = h;
     280:	4c1b      	ldr	r4, [pc, #108]	; (2f0 <setup+0x190>)
        slot->opaque = opaque;
        slot->start = start;
        slot->expires = expires;
     282:	f640 31b8 	movw	r1, #3000	; 0xbb8
        slot->opaque = opaque;
     286:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     288:	2201      	movs	r2, #1
        slot->start = start;
     28a:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     28c:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     28e:	e9c3 1203 	strd	r1, r2, [r3, #12]

        return slot;
     292:	e7c2      	b.n	21a <setup+0xba>
        slot->handler = h;
     294:	4c17      	ldr	r4, [pc, #92]	; (2f4 <setup+0x194>)
        slot->expires = expires;
     296:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
        slot->start = start;
     29a:	e9c3 2001 	strd	r2, r0, [r3, #4]
        slot->repeat = repeat;
     29e:	2201      	movs	r2, #1
        slot->handler = h;
     2a0:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     2a2:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     2a6:	e7cb      	b.n	240 <setup+0xe0>
        slot->handler = h;
     2a8:	4c13      	ldr	r4, [pc, #76]	; (2f8 <setup+0x198>)
        slot->expires = expires;
     2aa:	f241 3188 	movw	r1, #5000	; 0x1388
        slot->opaque = opaque;
     2ae:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     2b0:	2201      	movs	r2, #1
        slot->start = start;
     2b2:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     2b4:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     2b6:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     2ba:	e7b8      	b.n	22e <setup+0xce>
     2bc:	200075a8 	.word	0x200075a8
     2c0:	2000771d 	.word	0x2000771d
     2c4:	2000771c 	.word	0x2000771c
     2c8:	20000ea8 	.word	0x20000ea8
     2cc:	20001110 	.word	0x20001110
     2d0:	2000110c 	.word	0x2000110c
     2d4:	431bde83 	.word	0x431bde83
     2d8:	20000ed0 	.word	0x20000ed0
     2dc:	20001120 	.word	0x20001120
     2e0:	20000ee4 	.word	0x20000ee4
     2e4:	00000919 	.word	0x00000919
     2e8:	200075b0 	.word	0x200075b0
     2ec:	400d8000 	.word	0x400d8000
     2f0:	0000040d 	.word	0x0000040d
     2f4:	00000129 	.word	0x00000129
     2f8:	00004ea1 	.word	0x00004ea1
     2fc:	200076f8 	.word	0x200076f8

00000300 <loop>:
void loop() {
     300:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     304:	4d3b      	ldr	r5, [pc, #236]	; (3f4 <loop+0xf4>)
     306:	b084      	sub	sp, #16
     308:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 404 <loop+0x104>
        task->handler = NULL;
     30c:	2700      	movs	r7, #0
                    task->repeat = task->handler(task->opaque) && task->repeat;
     30e:	f04f 0a01 	mov.w	sl, #1
     312:	f505 76a0 	add.w	r6, r5, #320	; 0x140
     316:	462c      	mov	r4, r5
     318:	e009      	b.n	32e <loop+0x2e>
     31a:	f854 3c04 	ldr.w	r3, [r4, #-4]
     31e:	b1bb      	cbz	r3, 350 <loop+0x50>
     320:	f844 ac04 	str.w	sl, [r4, #-4]
                    if (task->repeat) task->start = t;
     324:	f844 9c0c 	str.w	r9, [r4, #-12]
        timer_foreach_task(task) {
     328:	3414      	adds	r4, #20
     32a:	42b4      	cmp	r4, r6
     32c:	d019      	beq.n	362 <loop+0x62>
            if (task->handler) {
     32e:	f854 2c14 	ldr.w	r2, [r4, #-20]
     332:	2a00      	cmp	r2, #0
     334:	d0f8      	beq.n	328 <loop+0x28>
     336:	f8d8 9000 	ldr.w	r9, [r8]
                if (duration >= task->expires) {
     33a:	e954 3103 	ldrd	r3, r1, [r4, #-12]
                const unsigned long duration = t - task->start;
     33e:	eba9 0303 	sub.w	r3, r9, r3
                if (duration >= task->expires) {
     342:	428b      	cmp	r3, r1
     344:	d3f0      	bcc.n	328 <loop+0x28>
                    task->repeat = task->handler(task->opaque) && task->repeat;
     346:	f854 0c10 	ldr.w	r0, [r4, #-16]
     34a:	4790      	blx	r2
     34c:	2800      	cmp	r0, #0
     34e:	d1e4      	bne.n	31a <loop+0x1a>
        task->repeat = 0;
     350:	f844 7c04 	str.w	r7, [r4, #-4]
        task->opaque = T();
     354:	e944 7705 	strd	r7, r7, [r4, #-20]
        task->expires = 0;
     358:	e944 7703 	strd	r7, r7, [r4, #-12]
        timer_foreach_task(task) {
     35c:	3414      	adds	r4, #20
     35e:	42b4      	cmp	r4, r6
     360:	d1e5      	bne.n	32e <loop+0x2e>
     362:	f8d8 3000 	ldr.w	r3, [r8]
            if (task->handler) {
     366:	f855 3c14 	ldr.w	r3, [r5, #-20]
     36a:	b133      	cbz	r3, 37a <loop+0x7a>
     36c:	f8d8 3000 	ldr.w	r3, [r8]
                if (duration >= task->expires) {
     370:	e955 1203 	ldrd	r1, r2, [r5, #-12]
                const unsigned long duration = t - task->start;
     374:	1a5b      	subs	r3, r3, r1
                if (duration >= task->expires) {
     376:	4293      	cmp	r3, r2
     378:	d202      	bcs.n	380 <loop+0x80>
        timer_foreach_const_task(task) {
     37a:	3514      	adds	r5, #20
     37c:	42b5      	cmp	r5, r6
     37e:	d1f2      	bne.n	366 <loop+0x66>
  if (millis() - lastTransmission >= btTimeout) {
     380:	491d      	ldr	r1, [pc, #116]	; (3f8 <loop+0xf8>)
    bt_packet rx_packet = { 0 };
     382:	2400      	movs	r4, #0
     384:	f8d8 3000 	ldr.w	r3, [r8]
  if (millis() - lastTransmission >= btTimeout) {
     388:	6809      	ldr	r1, [r1, #0]
     38a:	f8d8 3000 	ldr.w	r3, [r8]
     38e:	4a1b      	ldr	r2, [pc, #108]	; (3fc <loop+0xfc>)
     390:	1a5b      	subs	r3, r3, r1
  while (Serial2.available()) {
     392:	4d1b      	ldr	r5, [pc, #108]	; (400 <loop+0x100>)
  if (millis() - lastTransmission >= btTimeout) {
     394:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
     398:	bf2c      	ite	cs
     39a:	2300      	movcs	r3, #0
     39c:	2301      	movcc	r3, #1
     39e:	7013      	strb	r3, [r2, #0]
     3a0:	e00c      	b.n	3bc <loop+0xbc>
    bt_packet rx_packet = { 0 };
     3a2:	e9cd 4400 	strd	r4, r4, [sp]
     3a6:	9402      	str	r4, [sp, #8]
     3a8:	f88d 400c 	strb.w	r4, [sp, #12]
	long parseInt(LookaheadMode lookahead = SKIP_ALL, char ignore = '\x01');
	float parseFloat(LookaheadMode lookahead = SKIP_ALL, char ignore = '\x01');
	size_t readBytes(char *buffer, size_t length);
	size_t readBytes(uint8_t *buffer, size_t length) { return readBytes((char *)buffer, length); }
	size_t readBytesUntil(char terminator, char *buffer, size_t length);
	size_t readBytesUntil(char terminator, uint8_t *buffer, size_t length) { return readBytesUntil(terminator, (char *)buffer, length); }
     3ac:	f005 fa82 	bl	58b4 <Stream::readBytesUntil(char, char*, unsigned int)>
     3b0:	4603      	mov	r3, r0
    btProcess(&rx_packet);
     3b2:	4668      	mov	r0, sp
    rx_packet.len = Serial2.readBytesUntil(SERIAL_PACKET_END, rx_packet.data, ARRAY_SIZE(rx_packet.data));
     3b4:	f88d 3000 	strb.w	r3, [sp]
    btProcess(&rx_packet);
     3b8:	f000 f8b4 	bl	524 <btProcess(bt_packet*)>
  while (Serial2.available()) {
     3bc:	4628      	mov	r0, r5
     3be:	f004 fe57 	bl	5070 <HardwareSerialIMXRT::available()>
     3c2:	4606      	mov	r6, r0
     3c4:	230c      	movs	r3, #12
     3c6:	f10d 0201 	add.w	r2, sp, #1
     3ca:	21ff      	movs	r1, #255	; 0xff
     3cc:	4628      	mov	r0, r5
     3ce:	2e00      	cmp	r6, #0
     3d0:	d1e7      	bne.n	3a2 <loop+0xa2>
  if (digitalRead(pinBT_Conf)) {
     3d2:	2004      	movs	r0, #4
     3d4:	f005 fca8 	bl	5d28 <digitalRead>
     3d8:	b920      	cbnz	r0, 3e4 <loop+0xe4>
}
     3da:	b004      	add	sp, #16
     3dc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     3e0:	f000 bb9e 	b.w	b20 <LED()>
    btInit();  // can't have BT_Conf as an interrupt and change the pin state...
     3e4:	f000 f964 	bl	6b0 <btInit()>
}
     3e8:	b004      	add	sp, #16
     3ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     3ee:	f000 bb97 	b.w	b20 <LED()>
     3f2:	bf00      	nop
     3f4:	200075c4 	.word	0x200075c4
     3f8:	200074f0 	.word	0x200074f0
     3fc:	2000770d 	.word	0x2000770d
     400:	20001120 	.word	0x20001120
     404:	200075a8 	.word	0x200075a8

00000408 <_GLOBAL__sub_I__Z12btSendStatusPv>:
     408:	f005 bd06 	b.w	5e18 <eeprom_initialize>

0000040c <btSendStatus(void*)>:
#include "openhaldex.h"

bool btSendStatus(void *params) {
     40c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bt_packet packet;
  if (!isScreen) {
     410:	4c3c      	ldr	r4, [pc, #240]	; (504 <btSendStatus(void*)+0xf8>)
bool btSendStatus(void *params) {
     412:	b084      	sub	sp, #16
  if (!isScreen) {
     414:	7823      	ldrb	r3, [r4, #0]
     416:	2b00      	cmp	r3, #0
     418:	d03c      	beq.n	494 <btSendStatus(void*)+0x88>
     41a:	f8df 8104 	ldr.w	r8, [pc, #260]	; 520 <btSendStatus(void*)+0x114>
     41e:	f10d 0501 	add.w	r5, sp, #1
     422:	4f39      	ldr	r7, [pc, #228]	; (508 <btSendStatus(void*)+0xfc>)
     424:	4e39      	ldr	r6, [pc, #228]	; (50c <btSendStatus(void*)+0x100>)

  if (isScreen) {
    packet.data[0] = APP_MSG_STATUS;
    packet.data[1] = 0;  // was haldexStatus
    packet.data[2] = haldexEngagement;
    packet.data[3] = int(lockTarget);
     426:	edd7 7a00 	vldr	s15, [r7]
    packet.data[7] = int(pedValue);
    packet.data[8] = softwareVersion;
    packet.data[9] = SERIAL_PACKET_END;
    packet.len = 10;

    Serial2.write(packet.data, packet.len);
     42a:	4629      	mov	r1, r5
    packet.data[7] = int(pedValue);
     42c:	4b38      	ldr	r3, [pc, #224]	; (510 <btSendStatus(void*)+0x104>)
    packet.data[3] = int(lockTarget);
     42e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    packet.data[2] = haldexEngagement;
     432:	f898 4000 	ldrb.w	r4, [r8]
    packet.data[7] = int(pedValue);
     436:	ed93 7a00 	vldr	s14, [r3]
    packet.data[5] = state.mode_override;
     43a:	4836      	ldr	r0, [pc, #216]	; (514 <btSendStatus(void*)+0x108>)
    packet.data[3] = int(lockTarget);
     43c:	ee17 3a90 	vmov	r3, s15
    packet.data[7] = int(pedValue);
     440:	eefd 7ac7 	vcvt.s32.f32	s15, s14
    packet.data[2] = haldexEngagement;
     444:	f88d 4003 	strb.w	r4, [sp, #3]
    packet.data[3] = int(lockTarget);
     448:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[8] = softwareVersion;
     44c:	4b32      	ldr	r3, [pc, #200]	; (518 <btSendStatus(void*)+0x10c>)
    packet.data[7] = int(pedValue);
     44e:	ee17 2a90 	vmov	r2, s15
    packet.data[5] = state.mode_override;
     452:	f890 4023 	ldrb.w	r4, [r0, #35]	; 0x23
    packet.data[8] = softwareVersion;
     456:	681b      	ldr	r3, [r3, #0]
    packet.data[7] = int(pedValue);
     458:	f88d 2008 	strb.w	r2, [sp, #8]
    packet.data[6] = state.mode;
     45c:	7802      	ldrb	r2, [r0, #0]
    packet.len = 10;
     45e:	f44f 7085 	mov.w	r0, #266	; 0x10a
    packet.data[4] = vehicleSpeed;
     462:	7836      	ldrb	r6, [r6, #0]
    packet.data[5] = state.mode_override;
     464:	f88d 4006 	strb.w	r4, [sp, #6]
    packet.data[9] = SERIAL_PACKET_END;
     468:	24ff      	movs	r4, #255	; 0xff
    packet.data[8] = softwareVersion;
     46a:	f88d 3009 	strb.w	r3, [sp, #9]
    packet.data[1] = 0;  // was haldexStatus
     46e:	2300      	movs	r3, #0
    packet.data[6] = state.mode;
     470:	f88d 2007 	strb.w	r2, [sp, #7]
    Serial2.write(packet.data, packet.len);
     474:	220a      	movs	r2, #10
    packet.len = 10;
     476:	f8ad 0000 	strh.w	r0, [sp]
    Serial2.write(packet.data, packet.len);
     47a:	4828      	ldr	r0, [pc, #160]	; (51c <btSendStatus(void*)+0x110>)
    packet.data[4] = vehicleSpeed;
     47c:	f88d 6005 	strb.w	r6, [sp, #5]
    packet.data[9] = SERIAL_PACKET_END;
     480:	f88d 400a 	strb.w	r4, [sp, #10]
    packet.data[1] = 0;  // was haldexStatus
     484:	f88d 3002 	strb.w	r3, [sp, #2]
    Serial2.write(packet.data, packet.len);
     488:	f005 f99e 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
  }
  return true;
}
     48c:	2001      	movs	r0, #1
     48e:	b004      	add	sp, #16
     490:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    packet.data[3] = lockTarget;  //lockTarget;
     494:	4f1c      	ldr	r7, [pc, #112]	; (508 <btSendStatus(void*)+0xfc>)
     496:	f10d 0501 	add.w	r5, sp, #1
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     49a:	f8df 8084 	ldr.w	r8, [pc, #132]	; 520 <btSendStatus(void*)+0x114>
     49e:	f10d 0005 	add.w	r0, sp, #5
    packet.data[3] = lockTarget;  //lockTarget;
     4a2:	edd7 7a00 	vldr	s15, [r7]
        packet.data[i] = SERIAL_PACKET_END - 1;
     4a6:	21fe      	movs	r1, #254	; 0xfe
    packet.data[1] = 0;  // was haldexStatus
     4a8:	f88d 3002 	strb.w	r3, [sp, #2]
    packet.data[3] = lockTarget;  //lockTarget;
     4ac:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     4b0:	f898 3000 	ldrb.w	r3, [r8]
    packet.data[4] = vehicleSpeed;  //vehicleSpeed;
     4b4:	4e15      	ldr	r6, [pc, #84]	; (50c <btSendStatus(void*)+0x100>)
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     4b6:	f88d 3003 	strb.w	r3, [sp, #3]
    packet.data[3] = lockTarget;  //lockTarget;
     4ba:	ee17 3a90 	vmov	r3, s15
     4be:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[4] = vehicleSpeed;  //vehicleSpeed;
     4c2:	7833      	ldrb	r3, [r6, #0]
     4c4:	f88d 3005 	strb.w	r3, [sp, #5]
    packet.data[5] = SERIAL_PACKET_END;
     4c8:	23ff      	movs	r3, #255	; 0xff
     4ca:	f88d 3006 	strb.w	r3, [sp, #6]
    packet.len = 6;
     4ce:	f44f 7383 	mov.w	r3, #262	; 0x106
     4d2:	f8ad 3000 	strh.w	r3, [sp]
     4d6:	462b      	mov	r3, r5
    for (int i = 0; i < packet.len - 1; i++) {
     4d8:	4298      	cmp	r0, r3
     4da:	d006      	beq.n	4ea <btSendStatus(void*)+0xde>
      if (packet.data[i] == SERIAL_PACKET_END) {
     4dc:	f813 2f01 	ldrb.w	r2, [r3, #1]!
     4e0:	2aff      	cmp	r2, #255	; 0xff
        packet.data[i] = SERIAL_PACKET_END - 1;
     4e2:	bf08      	it	eq
     4e4:	7019      	strbeq	r1, [r3, #0]
    for (int i = 0; i < packet.len - 1; i++) {
     4e6:	4298      	cmp	r0, r3
     4e8:	d1f8      	bne.n	4dc <btSendStatus(void*)+0xd0>
    Serial2.write(packet.data, packet.len);
     4ea:	2206      	movs	r2, #6
     4ec:	4629      	mov	r1, r5
     4ee:	480b      	ldr	r0, [pc, #44]	; (51c <btSendStatus(void*)+0x110>)
     4f0:	f005 f96a 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
  if (isScreen) {
     4f4:	7823      	ldrb	r3, [r4, #0]
     4f6:	2b00      	cmp	r3, #0
     4f8:	d195      	bne.n	426 <btSendStatus(void*)+0x1a>
}
     4fa:	2001      	movs	r0, #1
     4fc:	b004      	add	sp, #16
     4fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     502:	bf00      	nop
     504:	20007714 	.word	0x20007714
     508:	200074f4 	.word	0x200074f4
     50c:	20007720 	.word	0x20007720
     510:	20007510 	.word	0x20007510
     514:	20007580 	.word	0x20007580
     518:	200019c0 	.word	0x200019c0
     51c:	20001120 	.word	0x20001120
     520:	20007710 	.word	0x20007710

00000524 <btProcess(bt_packet*)>:
     524:	4a57      	ldr	r2, [pc, #348]	; (684 <btProcess(bt_packet*)+0x160>)

void btProcess(bt_packet *rx_packet) {
  byte lockpoint_index;
  bt_packet tx_packet;

  lastTransmission = millis();
     526:	4b58      	ldr	r3, [pc, #352]	; (688 <btProcess(bt_packet*)+0x164>)
     528:	6812      	ldr	r2, [r2, #0]
void btProcess(bt_packet *rx_packet) {
     52a:	b510      	push	{r4, lr}
  lastTransmission = millis();
     52c:	601a      	str	r2, [r3, #0]
void btProcess(bt_packet *rx_packet) {
     52e:	b086      	sub	sp, #24

  switch (rx_packet->data[0]) {
     530:	7843      	ldrb	r3, [r0, #1]
     532:	2b04      	cmp	r3, #4
     534:	d80b      	bhi.n	54e <btProcess(bt_packet*)+0x2a>
     536:	e8df f003 	tbb	[pc, r3]
     53a:	0a39      	.short	0x0a39
     53c:	0c13      	.short	0x0c13
     53e:	03          	.byte	0x03
     53f:	00          	.byte	0x00
          Serial.println("App assumed control of override");
          break;
      }
      break;
    case APP_MSG_IS_SCREEN:
      isScreen = true;
     540:	4952      	ldr	r1, [pc, #328]	; (68c <btProcess(bt_packet*)+0x168>)
     542:	2001      	movs	r0, #1
      state.mode_override = false;
     544:	4b52      	ldr	r3, [pc, #328]	; (690 <btProcess(bt_packet*)+0x16c>)
     546:	2200      	movs	r2, #0
      isScreen = true;
     548:	7008      	strb	r0, [r1, #0]
      state.mode_override = false;
     54a:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
      break;
  }
}
     54e:	b006      	add	sp, #24
     550:	bd10      	pop	{r4, pc}
      switch (rx_packet->data[1]) {
     552:	7883      	ldrb	r3, [r0, #2]
     554:	2b03      	cmp	r3, #3
     556:	d8fa      	bhi.n	54e <btProcess(bt_packet*)+0x2a>
     558:	e8df f003 	tbb	[pc, r3]
     55c:	5664867d 	.word	0x5664867d
      lockpoint_index = rx_packet->data[1];
     560:	7882      	ldrb	r2, [r0, #2]
      if (lockpoint_index < NUM_LOCK_POINTS) {
     562:	2a09      	cmp	r2, #9
     564:	d8f3      	bhi.n	54e <btProcess(bt_packet*)+0x2a>
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     566:	4c4a      	ldr	r4, [pc, #296]	; (690 <btProcess(bt_packet*)+0x16c>)
     568:	eb02 0342 	add.w	r3, r2, r2, lsl #1
     56c:	78c1      	ldrb	r1, [r0, #3]
        if (lockpoint_index > 6) {
     56e:	2a06      	cmp	r2, #6
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     570:	4423      	add	r3, r4
     572:	7059      	strb	r1, [r3, #1]
        state.custom_mode.lockpoints[lockpoint_index].lock = rx_packet->data[3];
     574:	7901      	ldrb	r1, [r0, #4]
     576:	7099      	strb	r1, [r3, #2]
        state.custom_mode.lockpoints[lockpoint_index].intensity = rx_packet->data[4];
     578:	7941      	ldrb	r1, [r0, #5]
     57a:	70d9      	strb	r1, [r3, #3]
        if (lockpoint_index > 6) {
     57c:	d93a      	bls.n	5f4 <btProcess(bt_packet*)+0xd0>
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     57e:	1fd0      	subs	r0, r2, #7
     580:	2101      	movs	r1, #1
     582:	7fe3      	ldrb	r3, [r4, #31]
     584:	4081      	lsls	r1, r0
     586:	4319      	orrs	r1, r3
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     588:	f894 3020 	ldrb.w	r3, [r4, #32]
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     58c:	b2c9      	uxtb	r1, r1
     58e:	77e1      	strb	r1, [r4, #31]
        state.custom_mode.lockpoint_count++;
     590:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     594:	9100      	str	r1, [sp, #0]
        state.custom_mode.lockpoint_count++;
     596:	3001      	adds	r0, #1
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     598:	493e      	ldr	r1, [pc, #248]	; (694 <btProcess(bt_packet*)+0x170>)
        state.custom_mode.lockpoint_count++;
     59a:	b2c0      	uxtb	r0, r0
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     59c:	9001      	str	r0, [sp, #4]
        state.custom_mode.lockpoint_count++;
     59e:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     5a2:	483d      	ldr	r0, [pc, #244]	; (698 <btProcess(bt_packet*)+0x174>)
     5a4:	f005 f960 	bl	5868 <Print::printf(char const*, ...)>
}
     5a8:	b006      	add	sp, #24
     5aa:	bd10      	pop	{r4, pc}
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     5ac:	7883      	ldrb	r3, [r0, #2]
     5ae:	2b03      	cmp	r3, #3
     5b0:	d80a      	bhi.n	5c8 <btProcess(bt_packet*)+0xa4>
     5b2:	4a37      	ldr	r2, [pc, #220]	; (690 <btProcess(bt_packet*)+0x16c>)
      if (state.mode == MODE_FWD) {
     5b4:	2b01      	cmp	r3, #1
      state.ped_threshold = rx_packet->data[2];
     5b6:	78c1      	ldrb	r1, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     5b8:	7013      	strb	r3, [r2, #0]
      state.ped_threshold = rx_packet->data[2];
     5ba:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
      if (state.mode == MODE_FWD) {
     5be:	d109      	bne.n	5d4 <btProcess(bt_packet*)+0xb0>
        lockTarget = 0;
     5c0:	4b36      	ldr	r3, [pc, #216]	; (69c <btProcess(bt_packet*)+0x178>)
     5c2:	2200      	movs	r2, #0
     5c4:	601a      	str	r2, [r3, #0]
     5c6:	e005      	b.n	5d4 <btProcess(bt_packet*)+0xb0>
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     5c8:	4b31      	ldr	r3, [pc, #196]	; (690 <btProcess(bt_packet*)+0x16c>)
     5ca:	2100      	movs	r1, #0
      state.ped_threshold = rx_packet->data[2];
     5cc:	78c2      	ldrb	r2, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     5ce:	7019      	strb	r1, [r3, #0]
      state.ped_threshold = rx_packet->data[2];
     5d0:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      if (rx_packet->data[1] == MODE_CUSTOM) {
     5d4:	7882      	ldrb	r2, [r0, #2]
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     5d6:	78c3      	ldrb	r3, [r0, #3]
      if (rx_packet->data[1] == MODE_CUSTOM) {
     5d8:	f1a2 0003 	sub.w	r0, r2, #3
     5dc:	4c30      	ldr	r4, [pc, #192]	; (6a0 <btProcess(bt_packet*)+0x17c>)
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     5de:	4931      	ldr	r1, [pc, #196]	; (6a4 <btProcess(bt_packet*)+0x180>)
      if (rx_packet->data[1] == MODE_CUSTOM) {
     5e0:	fab0 f080 	clz	r0, r0
     5e4:	0940      	lsrs	r0, r0, #5
     5e6:	7020      	strb	r0, [r4, #0]
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     5e8:	482b      	ldr	r0, [pc, #172]	; (698 <btProcess(bt_packet*)+0x174>)
}
     5ea:	b006      	add	sp, #24
     5ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     5f0:	f005 b93a 	b.w	5868 <Print::printf(char const*, ...)>
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     5f4:	2001      	movs	r0, #1
     5f6:	f894 3020 	ldrb.w	r3, [r4, #32]
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     5fa:	7fe1      	ldrb	r1, [r4, #31]
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     5fc:	4090      	lsls	r0, r2
     5fe:	4303      	orrs	r3, r0
     600:	b2db      	uxtb	r3, r3
     602:	f884 3020 	strb.w	r3, [r4, #32]
     606:	e7c3      	b.n	590 <btProcess(bt_packet*)+0x6c>
          state.mode_override = false;
     608:	4b21      	ldr	r3, [pc, #132]	; (690 <btProcess(bt_packet*)+0x16c>)
     60a:	2200      	movs	r2, #0
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     60c:	211f      	movs	r1, #31
     60e:	4826      	ldr	r0, [pc, #152]	; (6a8 <btProcess(bt_packet*)+0x184>)
     610:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
     614:	f007 f99a 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
     618:	481f      	ldr	r0, [pc, #124]	; (698 <btProcess(bt_packet*)+0x174>)
}
     61a:	b006      	add	sp, #24
     61c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     620:	f005 b906 	b.w	5830 <Print::println()>
          tx_packet.data[2] = state.mode;
     624:	4b1a      	ldr	r3, [pc, #104]	; (690 <btProcess(bt_packet*)+0x16c>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     626:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     628:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     62c:	2402      	movs	r4, #2
          tx_packet.data[2] = state.mode;
     62e:	7818      	ldrb	r0, [r3, #0]
          tx_packet.data[3] = state.ped_threshold;
     630:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
          tx_packet.data[4] = SERIAL_PACKET_END;
     634:	f88d 200d 	strb.w	r2, [sp, #13]
          Serial2.write(tx_packet.data, tx_packet.len);
     638:	2205      	movs	r2, #5
          tx_packet.data[2] = state.mode;
     63a:	f88d 000b 	strb.w	r0, [sp, #11]
          tx_packet.len = 5;
     63e:	f8ad 1008 	strh.w	r1, [sp, #8]
          Serial2.write(tx_packet.data, tx_packet.len);
     642:	f10d 0109 	add.w	r1, sp, #9
     646:	4819      	ldr	r0, [pc, #100]	; (6ac <btProcess(bt_packet*)+0x188>)
          tx_packet.data[3] = state.ped_threshold;
     648:	f88d 300c 	strb.w	r3, [sp, #12]
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     64c:	f88d 400a 	strb.w	r4, [sp, #10]
          Serial2.write(tx_packet.data, tx_packet.len);
     650:	f005 f8ba 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
          break;
     654:	e77b      	b.n	54e <btProcess(bt_packet*)+0x2a>
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     656:	4b0e      	ldr	r3, [pc, #56]	; (690 <btProcess(bt_packet*)+0x16c>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     658:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     65a:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_LOCKPOINTS;
     65e:	2400      	movs	r4, #0
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     660:	f893 0020 	ldrb.w	r0, [r3, #32]
          tx_packet.data[3] = state.custom_mode.lockpoint_rx_h;
     664:	7fdb      	ldrb	r3, [r3, #31]
     666:	e7e5      	b.n	634 <btProcess(bt_packet*)+0x110>
          state.custom_mode.lockpoint_rx_l = 0;
     668:	4b09      	ldr	r3, [pc, #36]	; (690 <btProcess(bt_packet*)+0x16c>)
     66a:	2100      	movs	r1, #0
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     66c:	221e      	movs	r2, #30
     66e:	1c58      	adds	r0, r3, #1
          state.custom_mode.lockpoint_rx_l = 0;
     670:	f883 1020 	strb.w	r1, [r3, #32]
          state.custom_mode.lockpoint_rx_h = 0;
     674:	77d9      	strb	r1, [r3, #31]
          state.custom_mode.lockpoint_count = 0;
     676:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
}
     67a:	b006      	add	sp, #24
     67c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     680:	f008 b914 	b.w	88ac <memset>
     684:	200075a8 	.word	0x200075a8
     688:	200074f0 	.word	0x200074f0
     68c:	20007714 	.word	0x20007714
     690:	20007580 	.word	0x20007580
     694:	20000640 	.word	0x20000640
     698:	20001110 	.word	0x20001110
     69c:	200074f4 	.word	0x200074f4
     6a0:	20007713 	.word	0x20007713
     6a4:	20000614 	.word	0x20000614
     6a8:	20000670 	.word	0x20000670
     6ac:	20001120 	.word	0x20001120

000006b0 <btInit()>:

void btInit() {
     6b0:	b530      	push	{r4, r5, lr}
#if stateDebug
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
     6b2:	2400      	movs	r4, #0
void btInit() {
     6b4:	b0a3      	sub	sp, #140	; 0x8c
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
     6b6:	227c      	movs	r2, #124	; 0x7c
  Serial2.begin(38400);  // AT mode requires Baud 38400

  Serial2.write("AT\r\n");  // confirm in AT mode
#if stateDebug
  Serial.println(F("AT"));
  while (!Serial2.available()) {}
     6b8:	4d88      	ldr	r5, [pc, #544]	; (8dc <btInit()+0x22c>)
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
     6ba:	4621      	mov	r1, r4
     6bc:	a803      	add	r0, sp, #12
     6be:	9402      	str	r4, [sp, #8]
     6c0:	f008 f8f4 	bl	88ac <memset>
  digitalWrite(pinLED_R, LOW);
     6c4:	4621      	mov	r1, r4
     6c6:	200c      	movs	r0, #12
     6c8:	f005 fb04 	bl	5cd4 <digitalWrite>
  digitalWrite(pinLED_G, LOW);
     6cc:	4621      	mov	r1, r4
     6ce:	200a      	movs	r0, #10
     6d0:	f005 fb00 	bl	5cd4 <digitalWrite>
  digitalWrite(pinLED_B, LOW);
     6d4:	4621      	mov	r1, r4
     6d6:	200b      	movs	r0, #11
     6d8:	f005 fafc 	bl	5cd4 <digitalWrite>
     6dc:	2120      	movs	r1, #32
     6de:	4880      	ldr	r0, [pc, #512]	; (8e0 <btInit()+0x230>)
     6e0:	f007 f934 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     6e4:	487f      	ldr	r0, [pc, #508]	; (8e4 <btInit()+0x234>)
     6e6:	f005 f8a3 	bl	5830 <Print::println()>
  pinMode(pinBT_Conf, OUTPUT);
     6ea:	2101      	movs	r1, #1
     6ec:	2004      	movs	r0, #4
     6ee:	f005 fb2d 	bl	5d4c <pinMode>
  pinMode(pinBT_Reset, OUTPUT);
     6f2:	2005      	movs	r0, #5
     6f4:	2101      	movs	r1, #1
     6f6:	f005 fb29 	bl	5d4c <pinMode>
  digitalWrite(pinBT_Reset, LOW);
     6fa:	4621      	mov	r1, r4
     6fc:	2005      	movs	r0, #5
     6fe:	f005 fae9 	bl	5cd4 <digitalWrite>
  digitalWrite(pinBT_Conf, HIGH);
     702:	2101      	movs	r1, #1
     704:	2004      	movs	r0, #4
     706:	f005 fae5 	bl	5cd4 <digitalWrite>
  blinkLED(625, 4, 10, 0, 0);  // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
     70a:	4623      	mov	r3, r4
     70c:	220a      	movs	r2, #10
     70e:	f240 2071 	movw	r0, #625	; 0x271
     712:	2104      	movs	r1, #4
     714:	9400      	str	r4, [sp, #0]
     716:	f000 fa3f 	bl	b98 <blinkLED(int, int, int, int, int)>
  pinMode(pinBT_Reset, INPUT);
     71a:	4621      	mov	r1, r4
     71c:	2005      	movs	r0, #5
     71e:	f005 fb15 	bl	5d4c <pinMode>
  delay(2500);
     722:	f640 10c4 	movw	r0, #2500	; 0x9c4
     726:	f005 fa81 	bl	5c2c <delay>
  Serial2.end();         // end current (if any) Serial2/Bluetooth connections
     72a:	4628      	mov	r0, r5
     72c:	f004 fd4a 	bl	51c4 <HardwareSerialIMXRT::end()>
  Serial2.begin(38400);  // AT mode requires Baud 38400
     730:	4622      	mov	r2, r4
     732:	f44f 4116 	mov.w	r1, #38400	; 0x9600
     736:	4628      	mov	r0, r5
     738:	f004 fd78 	bl	522c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>
							  return write((const uint8_t *)str, strlen(str)); }
     73c:	2204      	movs	r2, #4
     73e:	496a      	ldr	r1, [pc, #424]	; (8e8 <btInit()+0x238>)
     740:	4628      	mov	r0, r5
     742:	f005 f841 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
     746:	2102      	movs	r1, #2
     748:	4868      	ldr	r0, [pc, #416]	; (8ec <btInit()+0x23c>)
     74a:	f007 f8ff 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     74e:	4865      	ldr	r0, [pc, #404]	; (8e4 <btInit()+0x234>)
     750:	f005 f86e 	bl	5830 <Print::println()>
  while (!Serial2.available()) {}
     754:	4628      	mov	r0, r5
     756:	f004 fc8b 	bl	5070 <HardwareSerialIMXRT::available()>
     75a:	2800      	cmp	r0, #0
     75c:	d0fa      	beq.n	754 <btInit()+0xa4>
     75e:	2380      	movs	r3, #128	; 0x80
     760:	210d      	movs	r1, #13
     762:	aa02      	add	r2, sp, #8
     764:	485d      	ldr	r0, [pc, #372]	; (8dc <btInit()+0x22c>)
     766:	f005 f8a5 	bl	58b4 <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\r', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     76a:	aa02      	add	r2, sp, #8
     76c:	4960      	ldr	r1, [pc, #384]	; (8f0 <btInit()+0x240>)
     76e:	485d      	ldr	r0, [pc, #372]	; (8e4 <btInit()+0x234>)
     770:	f005 f87a 	bl	5868 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     774:	2300      	movs	r3, #0
     776:	220a      	movs	r2, #10
     778:	2101      	movs	r1, #1
     77a:	9300      	str	r3, [sp, #0]
     77c:	f44f 709c 	mov.w	r0, #312	; 0x138
     780:	f000 fa0a 	bl	b98 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     784:	2212      	movs	r2, #18
     786:	495b      	ldr	r1, [pc, #364]	; (8f4 <btInit()+0x244>)
     788:	4854      	ldr	r0, [pc, #336]	; (8dc <btInit()+0x22c>)
     78a:	f005 f81d 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
     78e:	2110      	movs	r1, #16
     790:	4859      	ldr	r0, [pc, #356]	; (8f8 <btInit()+0x248>)
     792:	f007 f8db 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     796:	4853      	ldr	r0, [pc, #332]	; (8e4 <btInit()+0x234>)

  Serial2.write("AT+UART=9600,0,0\r\n");  // set baud at 38400
#if stateDebug
  Serial.println(F("AT+UART=9600,0,0"));
  while (!Serial2.available()) {}
     798:	4c50      	ldr	r4, [pc, #320]	; (8dc <btInit()+0x22c>)
     79a:	f005 f849 	bl	5830 <Print::println()>
     79e:	4620      	mov	r0, r4
     7a0:	f004 fc66 	bl	5070 <HardwareSerialIMXRT::available()>
     7a4:	2800      	cmp	r0, #0
     7a6:	d0fa      	beq.n	79e <btInit()+0xee>
     7a8:	2380      	movs	r3, #128	; 0x80
     7aa:	210a      	movs	r1, #10
     7ac:	aa02      	add	r2, sp, #8
     7ae:	484b      	ldr	r0, [pc, #300]	; (8dc <btInit()+0x22c>)
     7b0:	f005 f880 	bl	58b4 <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     7b4:	aa02      	add	r2, sp, #8
     7b6:	494e      	ldr	r1, [pc, #312]	; (8f0 <btInit()+0x240>)
     7b8:	484a      	ldr	r0, [pc, #296]	; (8e4 <btInit()+0x234>)
     7ba:	f005 f855 	bl	5868 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     7be:	2300      	movs	r3, #0
     7c0:	220a      	movs	r2, #10
     7c2:	2101      	movs	r1, #1
     7c4:	9300      	str	r3, [sp, #0]
     7c6:	f44f 709c 	mov.w	r0, #312	; 0x138
     7ca:	f000 f9e5 	bl	b98 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     7ce:	2216      	movs	r2, #22
     7d0:	494a      	ldr	r1, [pc, #296]	; (8fc <btInit()+0x24c>)
     7d2:	4842      	ldr	r0, [pc, #264]	; (8dc <btInit()+0x22c>)
     7d4:	f004 fff8 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
     7d8:	2114      	movs	r1, #20
     7da:	4849      	ldr	r0, [pc, #292]	; (900 <btInit()+0x250>)
     7dc:	f007 f8b6 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     7e0:	4840      	ldr	r0, [pc, #256]	; (8e4 <btInit()+0x234>)

  Serial2.write("AT+NAME=OpenHaldexT4\r\n");  // set Bluetooth name
#if stateDebug
  Serial.println(F("AT+NAME=OpenHaldexT4"));
  while (!Serial2.available()) {}
     7e2:	4c3e      	ldr	r4, [pc, #248]	; (8dc <btInit()+0x22c>)
     7e4:	f005 f824 	bl	5830 <Print::println()>
     7e8:	4620      	mov	r0, r4
     7ea:	f004 fc41 	bl	5070 <HardwareSerialIMXRT::available()>
     7ee:	2800      	cmp	r0, #0
     7f0:	d0fa      	beq.n	7e8 <btInit()+0x138>
     7f2:	2380      	movs	r3, #128	; 0x80
     7f4:	210a      	movs	r1, #10
     7f6:	aa02      	add	r2, sp, #8
     7f8:	4838      	ldr	r0, [pc, #224]	; (8dc <btInit()+0x22c>)
     7fa:	f005 f85b 	bl	58b4 <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     7fe:	aa02      	add	r2, sp, #8
     800:	493b      	ldr	r1, [pc, #236]	; (8f0 <btInit()+0x240>)
     802:	4838      	ldr	r0, [pc, #224]	; (8e4 <btInit()+0x234>)
     804:	f005 f830 	bl	5868 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     808:	2300      	movs	r3, #0
     80a:	220a      	movs	r2, #10
     80c:	2101      	movs	r1, #1
     80e:	9300      	str	r3, [sp, #0]
     810:	f44f 709c 	mov.w	r0, #312	; 0x138
     814:	f000 f9c0 	bl	b98 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     818:	220b      	movs	r2, #11
     81a:	493a      	ldr	r1, [pc, #232]	; (904 <btInit()+0x254>)
     81c:	482f      	ldr	r0, [pc, #188]	; (8dc <btInit()+0x22c>)
     81e:	f004 ffd3 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
     822:	2109      	movs	r1, #9
     824:	4838      	ldr	r0, [pc, #224]	; (908 <btInit()+0x258>)
     826:	f007 f891 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     82a:	482e      	ldr	r0, [pc, #184]	; (8e4 <btInit()+0x234>)

  Serial2.write("AT+ROLE=0\r\n");  // query current role
#if stateDebug
  Serial.println(F("AT+ROLE=0"));
  while (!Serial2.available()) {}
     82c:	4c2b      	ldr	r4, [pc, #172]	; (8dc <btInit()+0x22c>)
     82e:	f004 ffff 	bl	5830 <Print::println()>
     832:	4620      	mov	r0, r4
     834:	f004 fc1c 	bl	5070 <HardwareSerialIMXRT::available()>
     838:	2800      	cmp	r0, #0
     83a:	d0fa      	beq.n	832 <btInit()+0x182>
     83c:	2380      	movs	r3, #128	; 0x80
     83e:	210a      	movs	r1, #10
     840:	aa02      	add	r2, sp, #8
     842:	4826      	ldr	r0, [pc, #152]	; (8dc <btInit()+0x22c>)
     844:	f005 f836 	bl	58b4 <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     848:	aa02      	add	r2, sp, #8
     84a:	4929      	ldr	r1, [pc, #164]	; (8f0 <btInit()+0x240>)
     84c:	4825      	ldr	r0, [pc, #148]	; (8e4 <btInit()+0x234>)
     84e:	f005 f80b 	bl	5868 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     852:	2300      	movs	r3, #0
     854:	220a      	movs	r2, #10
     856:	2101      	movs	r1, #1
     858:	9300      	str	r3, [sp, #0]
     85a:	f44f 709c 	mov.w	r0, #312	; 0x138
     85e:	f000 f99b 	bl	b98 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     862:	220a      	movs	r2, #10
     864:	4929      	ldr	r1, [pc, #164]	; (90c <btInit()+0x25c>)
     866:	481d      	ldr	r0, [pc, #116]	; (8dc <btInit()+0x22c>)
     868:	f004 ffae 	bl	57c8 <Print::write(unsigned char const*, unsigned int)>
     86c:	2108      	movs	r1, #8
     86e:	4828      	ldr	r0, [pc, #160]	; (910 <btInit()+0x260>)
     870:	f007 f86c 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     874:	481b      	ldr	r0, [pc, #108]	; (8e4 <btInit()+0x234>)

  Serial2.write("AT+RESET\r\n");  // reset Bluetooth module/connections
#if stateDebug
  Serial.println(F("AT+RESET"));
  while (!Serial2.available()) {}
     876:	4c19      	ldr	r4, [pc, #100]	; (8dc <btInit()+0x22c>)
     878:	f004 ffda 	bl	5830 <Print::println()>
     87c:	4620      	mov	r0, r4
     87e:	f004 fbf7 	bl	5070 <HardwareSerialIMXRT::available()>
     882:	2800      	cmp	r0, #0
     884:	d0fa      	beq.n	87c <btInit()+0x1cc>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     886:	2400      	movs	r4, #0
     888:	2380      	movs	r3, #128	; 0x80
     88a:	aa02      	add	r2, sp, #8
     88c:	210a      	movs	r1, #10
     88e:	4813      	ldr	r0, [pc, #76]	; (8dc <btInit()+0x22c>)
     890:	f005 f810 	bl	58b4 <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial.printf("%s\r\n", at_buf);
     894:	aa02      	add	r2, sp, #8
     896:	4916      	ldr	r1, [pc, #88]	; (8f0 <btInit()+0x240>)
     898:	4812      	ldr	r0, [pc, #72]	; (8e4 <btInit()+0x234>)
     89a:	f004 ffe5 	bl	5868 <Print::printf(char const*, ...)>
  blinkLED(312, 1, 10, 0, 0);
     89e:	4623      	mov	r3, r4
     8a0:	2101      	movs	r1, #1
     8a2:	220a      	movs	r2, #10
     8a4:	f44f 709c 	mov.w	r0, #312	; 0x138
     8a8:	9400      	str	r4, [sp, #0]
     8aa:	f000 f975 	bl	b98 <blinkLED(int, int, int, int, int)>

  Serial2.end();          // end AT mode
     8ae:	480b      	ldr	r0, [pc, #44]	; (8dc <btInit()+0x22c>)
     8b0:	f004 fc88 	bl	51c4 <HardwareSerialIMXRT::end()>
  Serial2.begin(baudBT);  // begin normal mode with the above baud
     8b4:	4622      	mov	r2, r4
     8b6:	4809      	ldr	r0, [pc, #36]	; (8dc <btInit()+0x22c>)
     8b8:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     8bc:	f004 fcb6 	bl	522c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>

  pinMode(pinBT_Conf, INPUT);
     8c0:	4621      	mov	r1, r4
     8c2:	2004      	movs	r0, #4
     8c4:	f005 fa42 	bl	5d4c <pinMode>
     8c8:	2116      	movs	r1, #22
     8ca:	4812      	ldr	r0, [pc, #72]	; (914 <btInit()+0x264>)
     8cc:	f007 f83e 	bl	794c <usb_serial_write>
     8d0:	4804      	ldr	r0, [pc, #16]	; (8e4 <btInit()+0x234>)
     8d2:	f004 ffad 	bl	5830 <Print::println()>

#if stateDebug
  Serial.println(F("Bluetooth initialised!"));
#endif /* stateDebug */
}
     8d6:	b023      	add	sp, #140	; 0x8c
     8d8:	bd30      	pop	{r4, r5, pc}
     8da:	bf00      	nop
     8dc:	20001120 	.word	0x20001120
     8e0:	20000480 	.word	0x20000480
     8e4:	20001110 	.word	0x20001110
     8e8:	200004a4 	.word	0x200004a4
     8ec:	200004ac 	.word	0x200004ac
     8f0:	200004b0 	.word	0x200004b0
     8f4:	200004b8 	.word	0x200004b8
     8f8:	200004cc 	.word	0x200004cc
     8fc:	200004e0 	.word	0x200004e0
     900:	200004f8 	.word	0x200004f8
     904:	20000510 	.word	0x20000510
     908:	2000051c 	.word	0x2000051c
     90c:	20000528 	.word	0x20000528
     910:	20000534 	.word	0x20000534
     914:	20000540 	.word	0x20000540

00000918 <checkSwitchMode()>:
#include "openhaldex.h"

void checkSwitchMode() {
     918:	b570      	push	{r4, r5, r6, lr}
     91a:	4d78      	ldr	r5, [pc, #480]	; (afc <checkSwitchMode()+0x1e4>)
     91c:	211b      	movs	r1, #27
     91e:	4878      	ldr	r0, [pc, #480]	; (b00 <checkSwitchMode()+0x1e8>)
  int i = 0;
     920:	2400      	movs	r4, #0
     922:	f007 f813 	bl	794c <usb_serial_write>
     926:	4628      	mov	r0, r5
     928:	4e76      	ldr	r6, [pc, #472]	; (b04 <checkSwitchMode()+0x1ec>)
     92a:	f004 ff81 	bl	5830 <Print::println()>
     92e:	e02b      	b.n	988 <checkSwitchMode()+0x70>
  }
}

void blinkLED(int duration, int flashes, int R, int G, int B) {
  for (int i = 0; i < flashes; i++) {
    delay(duration);
     930:	f005 f97c 	bl	5c2c <delay>
    analogWrite(pinLED_R, R);
     934:	2105      	movs	r1, #5
     936:	200c      	movs	r0, #12
     938:	f005 fde6 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, G);
     93c:	2100      	movs	r1, #0
     93e:	200a      	movs	r0, #10
     940:	f005 fde2 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, B);
     944:	2105      	movs	r1, #5
     946:	200b      	movs	r0, #11
     948:	f005 fdde 	bl	6508 <analogWrite>
    delay(duration);
     94c:	2064      	movs	r0, #100	; 0x64
     94e:	f005 f96d 	bl	5c2c <delay>
    analogWrite(pinLED_R, 0);
     952:	2100      	movs	r1, #0
     954:	200c      	movs	r0, #12
     956:	f005 fdd7 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, 0);
     95a:	2100      	movs	r1, #0
     95c:	200a      	movs	r0, #10
     95e:	f005 fdd3 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, 0);
     962:	2100      	movs	r1, #0
     964:	200b      	movs	r0, #11
     966:	f005 fdcf 	bl	6508 <analogWrite>
     96a:	2120      	movs	r1, #32
     96c:	4630      	mov	r0, r6
     96e:	f006 ffed 	bl	794c <usb_serial_write>
     972:	4628      	mov	r0, r5
     974:	f004 ff5c 	bl	5830 <Print::println()>
	size_t print(int n)				{ return print((long)n); }
     978:	4621      	mov	r1, r4
     97a:	4628      	mov	r0, r5
    i++;
     97c:	3401      	adds	r4, #1
     97e:	f004 ff4b 	bl	5818 <Print::print(long)>

	// Print an unsigned number and newline
	size_t println(uint8_t b)			{ return print(b) + println(); }
	// Print a signed number and newline
	size_t println(int n)				{ return print(n) + println(); }
     982:	4628      	mov	r0, r5
     984:	f004 ff54 	bl	5830 <Print::println()>
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     988:	2004      	movs	r0, #4
     98a:	f005 f9cd 	bl	5d28 <digitalRead>
     98e:	4603      	mov	r3, r0
    delay(duration);
     990:	2064      	movs	r0, #100	; 0x64
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     992:	2b00      	cmp	r3, #0
     994:	d058      	beq.n	a48 <checkSwitchMode()+0x130>
     996:	2c0b      	cmp	r4, #11
     998:	d1ca      	bne.n	930 <checkSwitchMode()+0x18>
    Serial.printf("Is Standalone: %d\n", isStandalone);
     99a:	4d5b      	ldr	r5, [pc, #364]	; (b08 <checkSwitchMode()+0x1f0>)
    isStandalone = !isStandalone;
     99c:	240b      	movs	r4, #11
    Serial.printf("Is Standalone: %d\n", isStandalone);
     99e:	495b      	ldr	r1, [pc, #364]	; (b0c <checkSwitchMode()+0x1f4>)
     9a0:	4856      	ldr	r0, [pc, #344]	; (afc <checkSwitchMode()+0x1e4>)
     9a2:	782a      	ldrb	r2, [r5, #0]
     9a4:	f004 ff60 	bl	5868 <Print::printf(char const*, ...)>
    isStandalone = !isStandalone;
     9a8:	782b      	ldrb	r3, [r5, #0]
     9aa:	f083 0301 	eor.w	r3, r3, #1
     9ae:	702b      	strb	r3, [r5, #0]
    delay(duration);
     9b0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     9b4:	f005 f93a 	bl	5c2c <delay>
    analogWrite(pinLED_R, R);
     9b8:	2105      	movs	r1, #5
     9ba:	200c      	movs	r0, #12
     9bc:	f005 fda4 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, G);
     9c0:	2100      	movs	r1, #0
     9c2:	200a      	movs	r0, #10
     9c4:	f005 fda0 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, B);
     9c8:	2105      	movs	r1, #5
     9ca:	200b      	movs	r0, #11
     9cc:	f005 fd9c 	bl	6508 <analogWrite>
    delay(duration);
     9d0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     9d4:	f005 f92a 	bl	5c2c <delay>
    analogWrite(pinLED_R, 0);
     9d8:	2100      	movs	r1, #0
     9da:	200c      	movs	r0, #12
     9dc:	f005 fd94 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, 0);
     9e0:	2100      	movs	r1, #0
     9e2:	200a      	movs	r0, #10
     9e4:	f005 fd90 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, 0);
     9e8:	2100      	movs	r1, #0
     9ea:	200b      	movs	r0, #11
     9ec:	f005 fd8c 	bl	6508 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     9f0:	3c01      	subs	r4, #1
     9f2:	d1dd      	bne.n	9b0 <checkSwitchMode()+0x98>
  if (btConnected) {
     9f4:	4b46      	ldr	r3, [pc, #280]	; (b10 <checkSwitchMode()+0x1f8>)
     9f6:	7819      	ldrb	r1, [r3, #0]
     9f8:	b361      	cbz	r1, a54 <checkSwitchMode()+0x13c>
     9fa:	240b      	movs	r4, #11
    delay(duration);
     9fc:	2064      	movs	r0, #100	; 0x64
     9fe:	f005 f915 	bl	5c2c <delay>
    analogWrite(pinLED_R, R);
     a02:	2105      	movs	r1, #5
     a04:	200c      	movs	r0, #12
     a06:	f005 fd7f 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, G);
     a0a:	2105      	movs	r1, #5
     a0c:	200a      	movs	r0, #10
     a0e:	f005 fd7b 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, B);
     a12:	2105      	movs	r1, #5
     a14:	200b      	movs	r0, #11
     a16:	f005 fd77 	bl	6508 <analogWrite>
    delay(duration);
     a1a:	2064      	movs	r0, #100	; 0x64
     a1c:	f005 f906 	bl	5c2c <delay>
    analogWrite(pinLED_R, 0);
     a20:	2100      	movs	r1, #0
     a22:	200c      	movs	r0, #12
     a24:	f005 fd70 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, 0);
     a28:	2100      	movs	r1, #0
     a2a:	200a      	movs	r0, #10
     a2c:	f005 fd6c 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, 0);
     a30:	2100      	movs	r1, #0
     a32:	200b      	movs	r0, #11
     a34:	f005 fd68 	bl	6508 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     a38:	3c01      	subs	r4, #1
     a3a:	d1df      	bne.n	9fc <checkSwitchMode()+0xe4>
  delay(300);  // reduce button bashing
     a3c:	f44f 7096 	mov.w	r0, #300	; 0x12c
}
     a40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(300);  // reduce button bashing
     a44:	f005 b8f2 	b.w	5c2c <delay>
  if (i >= 11) {
     a48:	2c0b      	cmp	r4, #11
     a4a:	d0a6      	beq.n	99a <checkSwitchMode()+0x82>
  if (btConnected) {
     a4c:	4b30      	ldr	r3, [pc, #192]	; (b10 <checkSwitchMode()+0x1f8>)
     a4e:	7819      	ldrb	r1, [r3, #0]
     a50:	2900      	cmp	r1, #0
     a52:	d1d2      	bne.n	9fa <checkSwitchMode()+0xe2>
    buttonToggle++;
     a54:	4a2f      	ldr	r2, [pc, #188]	; (b14 <checkSwitchMode()+0x1fc>)
     a56:	6813      	ldr	r3, [r2, #0]
     a58:	3301      	adds	r3, #1
    if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     a5a:	2b03      	cmp	r3, #3
    buttonToggle++;
     a5c:	6013      	str	r3, [r2, #0]
    if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     a5e:	dd06      	ble.n	a6e <checkSwitchMode()+0x156>
      buttonToggle = 0;
     a60:	6011      	str	r1, [r2, #0]
        if (isStandalone) {  // jump over 'stock' since it's Standalone and can't see Body CAN
     a62:	4b29      	ldr	r3, [pc, #164]	; (b08 <checkSwitchMode()+0x1f0>)
     a64:	781b      	ldrb	r3, [r3, #0]
     a66:	b393      	cbz	r3, ace <checkSwitchMode()+0x1b6>
          buttonToggle++;
     a68:	2301      	movs	r3, #1
     a6a:	6013      	str	r3, [r2, #0]
          break;
     a6c:	e7e6      	b.n	a3c <checkSwitchMode()+0x124>
    switch (buttonToggle) {
     a6e:	2b03      	cmp	r3, #3
     a70:	d8e4      	bhi.n	a3c <checkSwitchMode()+0x124>
     a72:	a101      	add	r1, pc, #4	; (adr r1, a78 <checkSwitchMode()+0x160>)
     a74:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
     a78:	00000a63 	.word	0x00000a63
     a7c:	00000ab7 	.word	0x00000ab7
     a80:	00000a9f 	.word	0x00000a9f
     a84:	00000a89 	.word	0x00000a89
        if (isStandalone) {
     a88:	4b1f      	ldr	r3, [pc, #124]	; (b08 <checkSwitchMode()+0x1f0>)
     a8a:	7819      	ldrb	r1, [r3, #0]
     a8c:	b321      	cbz	r1, ad8 <checkSwitchMode()+0x1c0>
          state.mode_override = false;
     a8e:	4b22      	ldr	r3, [pc, #136]	; (b18 <checkSwitchMode()+0x200>)
          state.mode = MODE_FWD;
     a90:	2101      	movs	r1, #1
          state.mode_override = false;
     a92:	2000      	movs	r0, #0
          state.mode = MODE_FWD;
     a94:	7019      	strb	r1, [r3, #0]
          buttonToggle = 1;
     a96:	6011      	str	r1, [r2, #0]
          state.mode_override = false;
     a98:	f883 0023 	strb.w	r0, [r3, #35]	; 0x23
          break;
     a9c:	e7ce      	b.n	a3c <checkSwitchMode()+0x124>
        state.mode_override = false;
     a9e:	4b1e      	ldr	r3, [pc, #120]	; (b18 <checkSwitchMode()+0x200>)
     aa0:	2100      	movs	r1, #0
        state.mode = MODE_5050;
     aa2:	2202      	movs	r2, #2
  delay(300);  // reduce button bashing
     aa4:	f44f 7096 	mov.w	r0, #300	; 0x12c
        state.mode_override = false;
     aa8:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
        state.mode = MODE_5050;
     aac:	701a      	strb	r2, [r3, #0]
}
     aae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(300);  // reduce button bashing
     ab2:	f005 b8bb 	b.w	5c2c <delay>
        state.mode_override = false;
     ab6:	4b18      	ldr	r3, [pc, #96]	; (b18 <checkSwitchMode()+0x200>)
     ab8:	2100      	movs	r1, #0
        state.mode = MODE_FWD;
     aba:	2201      	movs	r2, #1
  delay(300);  // reduce button bashing
     abc:	f44f 7096 	mov.w	r0, #300	; 0x12c
        state.mode_override = false;
     ac0:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
        state.mode = MODE_FWD;
     ac4:	701a      	strb	r2, [r3, #0]
}
     ac6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(300);  // reduce button bashing
     aca:	f005 b8af 	b.w	5c2c <delay>
        state.mode_override = false;  // was disabled & false?
     ace:	4a12      	ldr	r2, [pc, #72]	; (b18 <checkSwitchMode()+0x200>)
     ad0:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
        state.mode = MODE_STOCK;
     ad4:	7013      	strb	r3, [r2, #0]
        break;
     ad6:	e7b1      	b.n	a3c <checkSwitchMode()+0x124>
        if (isCustom) {
     ad8:	4b10      	ldr	r3, [pc, #64]	; (b1c <checkSwitchMode()+0x204>)
     ada:	781b      	ldrb	r3, [r3, #0]
     adc:	b143      	cbz	r3, af0 <checkSwitchMode()+0x1d8>
          state.mode_override = false;
     ade:	4b0e      	ldr	r3, [pc, #56]	; (b18 <checkSwitchMode()+0x200>)
          state.mode = MODE_CUSTOM;
     ae0:	2403      	movs	r4, #3
          buttonToggle = -1;
     ae2:	f04f 30ff 	mov.w	r0, #4294967295
          state.mode_override = false;
     ae6:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
          state.mode = MODE_CUSTOM;
     aea:	701c      	strb	r4, [r3, #0]
          buttonToggle = -1;
     aec:	6010      	str	r0, [r2, #0]
          break;
     aee:	e7a5      	b.n	a3c <checkSwitchMode()+0x124>
          state.mode_override = false;
     af0:	4909      	ldr	r1, [pc, #36]	; (b18 <checkSwitchMode()+0x200>)
          buttonToggle = 0;
     af2:	6013      	str	r3, [r2, #0]
          state.mode_override = false;
     af4:	f881 3023 	strb.w	r3, [r1, #35]	; 0x23
          state.mode = MODE_STOCK;
     af8:	700b      	strb	r3, [r1, #0]
          break;
     afa:	e79f      	b.n	a3c <checkSwitchMode()+0x124>
     afc:	20001110 	.word	0x20001110
     b00:	2000042c 	.word	0x2000042c
     b04:	20000448 	.word	0x20000448
     b08:	20007715 	.word	0x20007715
     b0c:	2000046c 	.word	0x2000046c
     b10:	2000770d 	.word	0x2000770d
     b14:	200074d4 	.word	0x200074d4
     b18:	20007580 	.word	0x20007580
     b1c:	20007713 	.word	0x20007713

00000b20 <LED()>:
void LED() {
     b20:	b508      	push	{r3, lr}
  switch (state.mode) {
     b22:	4b1c      	ldr	r3, [pc, #112]	; (b94 <LED()+0x74>)
     b24:	781b      	ldrb	r3, [r3, #0]
     b26:	2b03      	cmp	r3, #3
     b28:	d833      	bhi.n	b92 <LED()+0x72>
     b2a:	e8df f003 	tbb	[pc, r3]
     b2e:	1e2c      	.short	0x1e2c
     b30:	0210      	.short	0x0210
      analogWrite(pinLED_R, 5);
     b32:	2105      	movs	r1, #5
     b34:	200c      	movs	r0, #12
     b36:	f005 fce7 	bl	6508 <analogWrite>
      analogWrite(pinLED_G, 0);
     b3a:	2100      	movs	r1, #0
     b3c:	200a      	movs	r0, #10
     b3e:	f005 fce3 	bl	6508 <analogWrite>
      analogWrite(pinLED_B, 5);
     b42:	2105      	movs	r1, #5
     b44:	200b      	movs	r0, #11
}
     b46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 5);
     b4a:	f005 bcdd 	b.w	6508 <analogWrite>
      analogWrite(pinLED_R, 0);
     b4e:	2100      	movs	r1, #0
     b50:	200c      	movs	r0, #12
     b52:	f005 fcd9 	bl	6508 <analogWrite>
      analogWrite(pinLED_G, 0);
     b56:	2100      	movs	r1, #0
     b58:	200a      	movs	r0, #10
     b5a:	f005 fcd5 	bl	6508 <analogWrite>
      analogWrite(pinLED_B, 10);
     b5e:	210a      	movs	r1, #10
     b60:	200b      	movs	r0, #11
}
     b62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 10);
     b66:	f005 bccf 	b.w	6508 <analogWrite>
      analogWrite(pinLED_R, 0);
     b6a:	2100      	movs	r1, #0
     b6c:	200c      	movs	r0, #12
     b6e:	f005 fccb 	bl	6508 <analogWrite>
      analogWrite(pinLED_G, 10);
     b72:	210a      	movs	r1, #10
      analogWrite(pinLED_G, 0);
     b74:	200a      	movs	r0, #10
     b76:	f005 fcc7 	bl	6508 <analogWrite>
      analogWrite(pinLED_B, 0);
     b7a:	2100      	movs	r1, #0
     b7c:	200b      	movs	r0, #11
}
     b7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 0);
     b82:	f005 bcc1 	b.w	6508 <analogWrite>
      analogWrite(pinLED_R, 10);
     b86:	210a      	movs	r1, #10
     b88:	200c      	movs	r0, #12
     b8a:	f005 fcbd 	bl	6508 <analogWrite>
      analogWrite(pinLED_G, 0);
     b8e:	2100      	movs	r1, #0
     b90:	e7f0      	b.n	b74 <LED()+0x54>
}
     b92:	bd08      	pop	{r3, pc}
     b94:	20007580 	.word	0x20007580

00000b98 <blinkLED(int, int, int, int, int)>:
void blinkLED(int duration, int flashes, int R, int G, int B) {
     b98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (int i = 0; i < flashes; i++) {
     b9c:	1e0e      	subs	r6, r1, #0
void blinkLED(int duration, int flashes, int R, int G, int B) {
     b9e:	f8dd 9020 	ldr.w	r9, [sp, #32]
  for (int i = 0; i < flashes; i++) {
     ba2:	dd24      	ble.n	bee <blinkLED(int, int, int, int, int)+0x56>
     ba4:	4605      	mov	r5, r0
     ba6:	4617      	mov	r7, r2
     ba8:	4698      	mov	r8, r3
     baa:	2400      	movs	r4, #0
    delay(duration);
     bac:	4628      	mov	r0, r5
  for (int i = 0; i < flashes; i++) {
     bae:	3401      	adds	r4, #1
    delay(duration);
     bb0:	f005 f83c 	bl	5c2c <delay>
    analogWrite(pinLED_R, R);
     bb4:	4639      	mov	r1, r7
     bb6:	200c      	movs	r0, #12
     bb8:	f005 fca6 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, G);
     bbc:	4641      	mov	r1, r8
     bbe:	200a      	movs	r0, #10
     bc0:	f005 fca2 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, B);
     bc4:	4649      	mov	r1, r9
     bc6:	200b      	movs	r0, #11
     bc8:	f005 fc9e 	bl	6508 <analogWrite>
    delay(duration);
     bcc:	4628      	mov	r0, r5
     bce:	f005 f82d 	bl	5c2c <delay>
    analogWrite(pinLED_R, 0);
     bd2:	2100      	movs	r1, #0
     bd4:	200c      	movs	r0, #12
     bd6:	f005 fc97 	bl	6508 <analogWrite>
    analogWrite(pinLED_G, 0);
     bda:	2100      	movs	r1, #0
     bdc:	200a      	movs	r0, #10
     bde:	f005 fc93 	bl	6508 <analogWrite>
    analogWrite(pinLED_B, 0);
     be2:	2100      	movs	r1, #0
     be4:	200b      	movs	r0, #11
     be6:	f005 fc8f 	bl	6508 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     bea:	42a6      	cmp	r6, r4
     bec:	d1de      	bne.n	bac <blinkLED(int, int, int, int, int)+0x14>
  }
     bee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     bf2:	bf00      	nop

00000bf4 <_GLOBAL__sub_I__Z15checkSwitchModev>:
     bf4:	f005 b910 	b.w	5e18 <eeprom_initialize>

00000bf8 <get_lockTarget_adjusted_value(unsigned char)>:

  return target;
}

static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
  if (state.mode == MODE_5050) {
     bf8:	4b1c      	ldr	r3, [pc, #112]	; (c6c <get_lockTarget_adjusted_value(unsigned char)+0x74>)
     bfa:	781a      	ldrb	r2, [r3, #0]
     bfc:	2a02      	cmp	r2, #2
     bfe:	d022      	beq.n	c46 <get_lockTarget_adjusted_value(unsigned char)+0x4e>
    }

    return 0;
  } else {
    // Potentially avoid doing math below..
    if (lockTarget == 0) {
     c00:	4b1b      	ldr	r3, [pc, #108]	; (c70 <get_lockTarget_adjusted_value(unsigned char)+0x78>)
     c02:	ed93 7a00 	vldr	s14, [r3]
     c06:	eeb5 7a40 	vcmp.f32	s14, #0.0
     c0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c0e:	d101      	bne.n	c14 <get_lockTarget_adjusted_value(unsigned char)+0x1c>
    return 0;
     c10:	2000      	movs	r0, #0
     c12:	4770      	bx	lr

    /* Hackery to get the response closer to the target... we are trying to control the
        Haldex as if it's linear.. but it's not. In future, I'd like to implement some sort
        of feedback loop to trim the calculation being made here but this will do for now.  */
    float target_fudge_factor = lockTarget;
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     c14:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5

    return value * (target_fudge_factor / 100);
     c18:	ed9f 6a16 	vldr	s12, [pc, #88]	; c74 <get_lockTarget_adjusted_value(unsigned char)+0x7c>
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     c1c:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    return value * (target_fudge_factor / 100);
     c20:	ee07 0a90 	vmov	s15, r0
static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
     c24:	b082      	sub	sp, #8
    return value * (target_fudge_factor / 100);
     c26:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     c2a:	eee7 6a25 	vfma.f32	s13, s14, s11
    return value * (target_fudge_factor / 100);
     c2e:	ee86 7a86 	vdiv.f32	s14, s13, s12
     c32:	ee67 7a87 	vmul.f32	s15, s15, s14
     c36:	eefc 7ae7 	vcvt.u32.f32	s15, s15
     c3a:	edcd 7a01 	vstr	s15, [sp, #4]
     c3e:	f89d 0004 	ldrb.w	r0, [sp, #4]
  }
}
     c42:	b002      	add	sp, #8
     c44:	4770      	bx	lr
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0) {
     c46:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     c4a:	4a0b      	ldr	r2, [pc, #44]	; (c78 <get_lockTarget_adjusted_value(unsigned char)+0x80>)
     c4c:	ee07 3a90 	vmov	s15, r3
     c50:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     c54:	edd2 7a00 	vldr	s15, [r2]
     c58:	eeb4 7ae7 	vcmpe.f32	s14, s15
     c5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c60:	d903      	bls.n	c6a <get_lockTarget_adjusted_value(unsigned char)+0x72>
      return value;
     c62:	2b00      	cmp	r3, #0
     c64:	bf18      	it	ne
     c66:	2000      	movne	r0, #0
     c68:	4770      	bx	lr
}
     c6a:	4770      	bx	lr
     c6c:	20007580 	.word	0x20007580
     c70:	200074f4 	.word	0x200074f4
     c74:	42c80000 	.word	0x42c80000
     c78:	20007510 	.word	0x20007510

00000c7c <getLockData(CAN_message_t*)>:

void getLockData(CAN_message_t *frame) {
     c7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (state.mode == MODE_5050) {
     c80:	4d7c      	ldr	r5, [pc, #496]	; (e74 <getLockData(CAN_message_t*)+0x1f8>)
void getLockData(CAN_message_t *frame) {
     c82:	4604      	mov	r4, r0
  if (state.mode == MODE_5050) {
     c84:	782b      	ldrb	r3, [r5, #0]
     c86:	2b02      	cmp	r3, #2
void getLockData(CAN_message_t *frame) {
     c88:	ed2d 8b02 	vpush	{d8}
     c8c:	b086      	sub	sp, #24
  if (state.mode == MODE_5050) {
     c8e:	d079      	beq.n	d84 <getLockData(CAN_message_t*)+0x108>
  } else if (state.mode == MODE_FWD) {
     c90:	2b01      	cmp	r3, #1
     c92:	d047      	beq.n	d24 <getLockData(CAN_message_t*)+0xa8>
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     c94:	f895 0021 	ldrb.w	r0, [r5, #33]	; 0x21
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     c98:	786f      	ldrb	r7, [r5, #1]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     c9a:	1e42      	subs	r2, r0, #1
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     c9c:	f895 8002 	ldrb.w	r8, [r5, #2]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     ca0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
     ca4:	442a      	add	r2, r5
     ca6:	7853      	ldrb	r3, [r2, #1]
     ca8:	7892      	ldrb	r2, [r2, #2]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     caa:	b1d8      	cbz	r0, ce4 <getLockData(CAN_message_t*)+0x68>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     cac:	4972      	ldr	r1, [pc, #456]	; (e78 <getLockData(CAN_message_t*)+0x1fc>)
     cae:	46ac      	mov	ip, r5
     cb0:	46be      	mov	lr, r7
     cb2:	780e      	ldrb	r6, [r1, #0]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     cb4:	2100      	movs	r1, #0
     cb6:	e004      	b.n	cc2 <getLockData(CAN_message_t*)+0x46>
     cb8:	3101      	adds	r1, #1
     cba:	4288      	cmp	r0, r1
     cbc:	d012      	beq.n	ce4 <getLockData(CAN_message_t*)+0x68>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     cbe:	f89c e001 	ldrb.w	lr, [ip, #1]
     cc2:	4576      	cmp	r6, lr
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     cc4:	f10c 0c03 	add.w	ip, ip, #3
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     cc8:	d8f6      	bhi.n	cb8 <getLockData(CAN_message_t*)+0x3c>
      lp_upper = state.custom_mode.lockpoints[i];
     cca:	eb01 0341 	add.w	r3, r1, r1, lsl #1
     cce:	442b      	add	r3, r5
     cd0:	789a      	ldrb	r2, [r3, #2]
      lp_lower = state.custom_mode.lockpoints[(i == 0) ? 0 : i - 1];
     cd2:	b131      	cbz	r1, ce2 <getLockData(CAN_message_t*)+0x66>
     cd4:	3901      	subs	r1, #1
     cd6:	eb01 0141 	add.w	r1, r1, r1, lsl #1
     cda:	186b      	adds	r3, r5, r1
     cdc:	785f      	ldrb	r7, [r3, #1]
     cde:	f893 8002 	ldrb.w	r8, [r3, #2]
      break;
     ce2:	4673      	mov	r3, lr
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     ce4:	f895 1022 	ldrb.w	r1, [r5, #34]	; 0x22
     ce8:	4864      	ldr	r0, [pc, #400]	; (e7c <getLockData(CAN_message_t*)+0x200>)
     cea:	ee07 1a90 	vmov	s15, r1
     cee:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     cf2:	edd0 7a00 	vldr	s15, [r0]
     cf6:	eeb4 7ae7 	vcmpe.f32	s14, s15
     cfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     cfe:	d80b      	bhi.n	d18 <getLockData(CAN_message_t*)+0x9c>
    if (vehicleSpeed <= lp_lower.speed) {
     d00:	495d      	ldr	r1, [pc, #372]	; (e78 <getLockData(CAN_message_t*)+0x1fc>)
     d02:	7809      	ldrb	r1, [r1, #0]
     d04:	42b9      	cmp	r1, r7
     d06:	f240 80af 	bls.w	e68 <getLockData(CAN_message_t*)+0x1ec>
    if (vehicleSpeed >= lp_upper.speed) {
     d0a:	4299      	cmp	r1, r3
     d0c:	d37f      	bcc.n	e0e <getLockData(CAN_message_t*)+0x192>
      return lp_upper.lock;
     d0e:	ee07 2a90 	vmov	s15, r2
     d12:	eeb8 8a67 	vcvt.f32.u32	s16, s15
     d16:	e007      	b.n	d28 <getLockData(CAN_message_t*)+0xac>
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     d18:	2900      	cmp	r1, #0
     d1a:	d0f1      	beq.n	d00 <getLockData(CAN_message_t*)+0x84>
     d1c:	f895 1023 	ldrb.w	r1, [r5, #35]	; 0x23
     d20:	2900      	cmp	r1, #0
     d22:	d1ed      	bne.n	d00 <getLockData(CAN_message_t*)+0x84>
      return 0;
     d24:	ed9f 8a56 	vldr	s16, [pc, #344]	; e80 <getLockData(CAN_message_t*)+0x204>
  // returns fraction if locking slightly?
  // assumed frame.buf[1] = 0 x (0xF0)?
  // assumed frame.buf[1] = Value x (0xF0)?
  // assumed frame.buf[1] = 100 x (0xF0)?

  switch (frame->id) {
     d28:	6823      	ldr	r3, [r4, #0]
  lockTarget = get_lockTarget_adjustment();
     d2a:	4a56      	ldr	r2, [pc, #344]	; (e84 <getLockData(CAN_message_t*)+0x208>)
  switch (frame->id) {
     d2c:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
  lockTarget = get_lockTarget_adjustment();
     d30:	ed82 8a00 	vstr	s16, [r2]
  switch (frame->id) {
     d34:	d05d      	beq.n	df2 <getLockData(CAN_message_t*)+0x176>
     d36:	d83f      	bhi.n	db8 <getLockData(CAN_message_t*)+0x13c>
     d38:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
     d3c:	d051      	beq.n	de2 <getLockData(CAN_message_t*)+0x166>
     d3e:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
     d42:	d11a      	bne.n	d7a <getLockData(CAN_message_t*)+0xfe>
    case MOTOR1_ID:
      //frame->buf[0] = 0;                                  // clutch pedal etc
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
     d44:	20fa      	movs	r0, #250	; 0xfa
     d46:	f7ff ff57 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
      frame->buf[2] = 0x20;                                 // motor speed (rpm): 32 >
     d4a:	f644 6320 	movw	r3, #20000	; 0x4e20
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
     d4e:	4602      	mov	r2, r0
      frame->buf[3] = 0x4E;                                 // motor speed (rpm): 78 > 0.25 * 3278 = 819.5 RPM (was 0x4e)  Leave RPM the same?
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d50:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[2] = 0x20;                                 // motor speed (rpm): 32 >
     d52:	81e3      	strh	r3, [r4, #14]
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
     d54:	7362      	strb	r2, [r4, #13]
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d56:	f7ff ff4f 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
     d5a:	4603      	mov	r3, r0
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d5c:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d5e:	7423      	strb	r3, [r4, #16]
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d60:	f7ff ff4a 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
     d64:	4603      	mov	r3, r0
      frame->buf[6] = get_lockTarget_adjusted_value(0x20);  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
     d66:	2020      	movs	r0, #32
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d68:	7463      	strb	r3, [r4, #17]
      frame->buf[6] = get_lockTarget_adjusted_value(0x20);  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
     d6a:	f7ff ff45 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
     d6e:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // drivers moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d70:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[6] = get_lockTarget_adjusted_value(0x20);  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
     d72:	74a3      	strb	r3, [r4, #18]
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // drivers moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     d74:	f7ff ff40 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
     d78:	74e0      	strb	r0, [r4, #19]
  /*
  haldex.buf[0] = 0x00;
  haldex.buf[1] = dummy_haldexEngagement++;   // Kupplungssteifigk
  haldex.buf[2] = PNG Status (not sent?)
  */
     d7a:	b006      	add	sp, #24
     d7c:	ecbd 8b02 	vpop	{d8}
     d80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     d84:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
     d88:	4a3c      	ldr	r2, [pc, #240]	; (e7c <getLockData(CAN_message_t*)+0x200>)
     d8a:	ee07 3a90 	vmov	s15, r3
     d8e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     d92:	edd2 7a00 	vldr	s15, [r2]
     d96:	eeb4 7ae7 	vcmpe.f32	s14, s15
     d9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d9e:	d960      	bls.n	e62 <getLockData(CAN_message_t*)+0x1e6>
     da0:	2b00      	cmp	r3, #0
     da2:	d05e      	beq.n	e62 <getLockData(CAN_message_t*)+0x1e6>
     da4:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
      return 100;
     da8:	ed9f 8a35 	vldr	s16, [pc, #212]	; e80 <getLockData(CAN_message_t*)+0x204>
     dac:	eddf 7a36 	vldr	s15, [pc, #216]	; e88 <getLockData(CAN_message_t*)+0x20c>
     db0:	2b00      	cmp	r3, #0
     db2:	fe08 8a27 	vseleq.f32	s16, s16, s15
     db6:	e7b7      	b.n	d28 <getLockData(CAN_message_t*)+0xac>
  switch (frame->id) {
     db8:	f5b3 6f94 	cmp.w	r3, #1184	; 0x4a0
     dbc:	d1dd      	bne.n	d7a <getLockData(CAN_message_t*)+0xfe>
      adjusted_slip = get_lockTarget_adjusted_value(0xA);     // 0xF4 = 244 in DEC.  0A = 10 in DEC.  244+10 = 254 (max speed).  255=0xFF (inplausible)
     dbe:	200a      	movs	r0, #10
     dc0:	f7ff ff1a 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
      frame->buf[0] = 0x0;                                    // Front Left low byte
     dc4:	f04f 230a 	mov.w	r3, #167774720	; 0xa000a00
      frame->buf[5] = (0xFA)+adjusted_slip;                   // Rear Left 254+10? (5050 returns 0xA)// (left, F/R?) high byte !was (0xA) + get_lockTarget_adjusted_value(0xF4); 
     dc8:	3806      	subs	r0, #6
      frame->buf[4] = 0x0;                                    // Rear Left low byte
     dca:	2200      	movs	r2, #0
      frame->buf[0] = 0x0;                                    // Front Left low byte
     dcc:	60e3      	str	r3, [r4, #12]
      frame->buf[5] = (0xFA)+adjusted_slip;                   // Rear Left 254+10? (5050 returns 0xA)// (left, F/R?) high byte !was (0xA) + get_lockTarget_adjusted_value(0xF4); 
     dce:	b2c3      	uxtb	r3, r0
      frame->buf[4] = 0x0;                                    // Rear Left low byte
     dd0:	7422      	strb	r2, [r4, #16]
      frame->buf[6] = 0x0;                                    // Rear Right low byte
     dd2:	74a2      	strb	r2, [r4, #18]
      frame->buf[5] = (0xFA)+adjusted_slip;                   // Rear Left 254+10? (5050 returns 0xA)// (left, F/R?) high byte !was (0xA) + get_lockTarget_adjusted_value(0xF4); 
     dd4:	7463      	strb	r3, [r4, #17]
      frame->buf[7] = (0xFA)+adjusted_slip;                   // Rear Right 254+10? was FE// (right, F/R?) high byte !was (0xA) + get_lockTarget_adjusted_value(0xF4)
     dd6:	74e3      	strb	r3, [r4, #19]
     dd8:	b006      	add	sp, #24
     dda:	ecbd 8b02 	vpop	{d8}
     dde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = 0x0;
     de2:	f44f 6320 	mov.w	r3, #2560	; 0xa00
     de6:	81e3      	strh	r3, [r4, #14]
     de8:	b006      	add	sp, #24
     dea:	ecbd 8b02 	vpop	{d8}
     dee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = get_lockTarget_adjusted_value(0xFA);  // driving pedal (%): 0.4*(0xFA) = 100% (was 0xfa)
     df2:	20fa      	movs	r0, #250	; 0xfa
     df4:	f7ff ff00 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
     df8:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // throttle angle? (0.39 * 'FE' = 99.06) (was 0xfa)
     dfa:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[2] = get_lockTarget_adjusted_value(0xFA);  // driving pedal (%): 0.4*(0xFA) = 100% (was 0xfa)
     dfc:	73a3      	strb	r3, [r4, #14]
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // throttle angle? (0.39 * 'FE' = 99.06) (was 0xfa)
     dfe:	f7ff fefb 	bl	bf8 <get_lockTarget_adjusted_value(unsigned char)>
     e02:	74e0      	strb	r0, [r4, #19]
     e04:	b006      	add	sp, #24
     e06:	ecbd 8b02 	vpop	{d8}
     e0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e0e:	ee07 8a90 	vmov	s15, r8
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e12:	9102      	str	r1, [sp, #8]
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e14:	1bc9      	subs	r1, r1, r7
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e16:	9701      	str	r7, [sp, #4]
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e18:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e1c:	1bdf      	subs	r7, r3, r7
     e1e:	ee07 1a90 	vmov	s15, r1
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e22:	f8cd 8000 	str.w	r8, [sp]
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e26:	eba2 0808 	sub.w	r8, r2, r8
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e2a:	4818      	ldr	r0, [pc, #96]	; (e8c <getLockData(CAN_message_t*)+0x210>)
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e2c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     e30:	ee07 7a90 	vmov	s15, r7
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e34:	ee06 8a90 	vmov	s13, r8
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e38:	7800      	ldrb	r0, [r0, #0]
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e3a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e3e:	4914      	ldr	r1, [pc, #80]	; (e90 <getLockData(CAN_message_t*)+0x214>)
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e40:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e44:	9003      	str	r0, [sp, #12]
     e46:	4813      	ldr	r0, [pc, #76]	; (e94 <getLockData(CAN_message_t*)+0x218>)
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e48:	eec7 5a87 	vdiv.f32	s11, s15, s14
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e4c:	ee86 8aa5 	vdiv.f32	s16, s13, s11
     e50:	ee38 8a06 	vadd.f32	s16, s16, s12
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e54:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
     e58:	ed8d 7b04 	vstr	d7, [sp, #16]
     e5c:	f004 fd04 	bl	5868 <Print::printf(char const*, ...)>
     e60:	e762      	b.n	d28 <getLockData(CAN_message_t*)+0xac>
      return 100;
     e62:	ed9f 8a09 	vldr	s16, [pc, #36]	; e88 <getLockData(CAN_message_t*)+0x20c>
     e66:	e75f      	b.n	d28 <getLockData(CAN_message_t*)+0xac>
      return lp_lower.lock;
     e68:	ee07 8a90 	vmov	s15, r8
     e6c:	eeb8 8a67 	vcvt.f32.u32	s16, s15
     e70:	e75a      	b.n	d28 <getLockData(CAN_message_t*)+0xac>
     e72:	bf00      	nop
     e74:	20007580 	.word	0x20007580
     e78:	20007720 	.word	0x20007720
     e7c:	20007510 	.word	0x20007510
     e80:	00000000 	.word	0x00000000
     e84:	200074f4 	.word	0x200074f4
     e88:	42c80000 	.word	0x42c80000
     e8c:	2000770f 	.word	0x2000770f
     e90:	200003f0 	.word	0x200003f0
     e94:	20001110 	.word	0x20001110

00000e98 <_GLOBAL__sub_I_lockTarget>:
     e98:	f004 bfbe 	b.w	5e18 <eeprom_initialize>

00000e9c <CANListener::frameHandler(CAN_message_t&, int, unsigned char)>:
#define SIZE_LISTENERS 4

class CANListener {
  public:
    CANListener () { callbacksActive = 0; }
    virtual bool frameHandler (CAN_message_t &frame, int mailbox, uint8_t controller) { return false; }
     e9c:	2000      	movs	r0, #0
     e9e:	4770      	bx	lr

00000ea0 <flexcan_isr_can1()>:
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
}

#if defined(__IMXRT1062__)
static void flexcan_isr_can1() {
  if ( _CAN1 ) _CAN1->flexcan_interrupt();
     ea0:	4b03      	ldr	r3, [pc, #12]	; (eb0 <flexcan_isr_can1()+0x10>)
     ea2:	6818      	ldr	r0, [r3, #0]
     ea4:	b110      	cbz	r0, eac <flexcan_isr_can1()+0xc>
     ea6:	6803      	ldr	r3, [r0, #0]
     ea8:	681b      	ldr	r3, [r3, #0]
     eaa:	4718      	bx	r3
}
     eac:	4770      	bx	lr
     eae:	bf00      	nop
     eb0:	20007320 	.word	0x20007320

00000eb4 <flexcan_isr_can2()>:

static void flexcan_isr_can2() {
  if ( _CAN2 ) _CAN2->flexcan_interrupt();
     eb4:	4b03      	ldr	r3, [pc, #12]	; (ec4 <flexcan_isr_can2()+0x10>)
     eb6:	6818      	ldr	r0, [r3, #0]
     eb8:	b110      	cbz	r0, ec0 <flexcan_isr_can2()+0xc>
     eba:	6803      	ldr	r3, [r0, #0]
     ebc:	681b      	ldr	r3, [r3, #0]
     ebe:	4718      	bx	r3
}
     ec0:	4770      	bx	lr
     ec2:	bf00      	nop
     ec4:	20007324 	.word	0x20007324

00000ec8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     ec8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
     ecc:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     ed0:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     ed2:	4c57      	ldr	r4, [pc, #348]	; (1030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     ed4:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     ed6:	4b57      	ldr	r3, [pc, #348]	; (1034 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     ed8:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
     eda:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     ede:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     ee0:	4855      	ldr	r0, [pc, #340]	; (1038 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     ee2:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     ee6:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     ee8:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     eea:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     eee:	446b      	add	r3, sp
     ef0:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
     ef4:	4b51      	ldr	r3, [pc, #324]	; (103c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
     ef6:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     efa:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     efc:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     f00:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f04:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     f08:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f0a:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     f0c:	6803      	ldr	r3, [r0, #0]
     f0e:	01df      	lsls	r7, r3, #7
     f10:	d5fc      	bpl.n	f0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
     f12:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     f14:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
     f18:	d92a      	bls.n	f70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     f1a:	4660      	mov	r0, ip
     f1c:	1c83      	adds	r3, r0, #2
    divisor++;
     f1e:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
     f20:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
     f24:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
     f26:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
     f2a:	d8f7      	bhi.n	f1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     f2c:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
     f30:	fbb6 f3f3 	udiv	r3, r6, r3
     f34:	1acb      	subs	r3, r1, r3
     f36:	2b00      	cmp	r3, #0
     f38:	bfb8      	it	lt
     f3a:	425b      	neglt	r3, r3
      if (error < bestError) {
     f3c:	42ab      	cmp	r3, r5
     f3e:	db0b      	blt.n	f58 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
     f40:	f1a7 030c 	sub.w	r3, r7, #12
     f44:	bf18      	it	ne
     f46:	f04f 0800 	movne.w	r8, #0
     f4a:	2b06      	cmp	r3, #6
     f4c:	d80a      	bhi.n	f64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
     f4e:	f1b8 0f00 	cmp.w	r8, #0
     f52:	d007      	beq.n	f64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
     f54:	4684      	mov	ip, r0
     f56:	e7e1      	b.n	f1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     f58:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
     f5a:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
     f5e:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
     f60:	2b06      	cmp	r3, #6
     f62:	d9f4      	bls.n	f4e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
     f64:	2f05      	cmp	r7, #5
     f66:	d8d9      	bhi.n	f1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
     f68:	f10c 0301 	add.w	r3, ip, #1
     f6c:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
     f70:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
     f74:	f1a2 0205 	sub.w	r2, r2, #5
     f78:	dc4c      	bgt.n	1014 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
     f7a:	2a14      	cmp	r2, #20
     f7c:	d84a      	bhi.n	1014 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     f7e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
     f82:	4f2f      	ldr	r7, [pc, #188]	; (1040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
     f84:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     f86:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 1038 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     f8a:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     f8e:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     f92:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
     f96:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     f98:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     f9a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     f9c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     f9e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
     fa0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
     fa2:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
     fa6:	c607      	stmia	r6!, {r0, r1, r2}
     fa8:	f826 3b02 	strh.w	r3, [r6], #2
     fac:	ea4f 4313 	mov.w	r3, r3, lsr #16
     fb0:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     fb2:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     fb6:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     fba:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     fbe:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     fc2:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     fc6:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
     fca:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     fce:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     fd2:	ea43 0302 	orr.w	r3, r3, r2
     fd6:	ea43 0301 	orr.w	r3, r3, r1
     fda:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
     fde:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
     fe2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     fe6:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     fea:	f8d8 3004 	ldr.w	r3, [r8, #4]
     fee:	bf14      	ite	ne
     ff0:	f023 0308 	bicne.w	r3, r3, #8
     ff4:	f043 0308 	orreq.w	r3, r3, #8
     ff8:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
     ffc:	b93c      	cbnz	r4, 100e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
     ffe:	4a0e      	ldr	r2, [pc, #56]	; (1038 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    1000:	6813      	ldr	r3, [r2, #0]
    1002:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1006:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1008:	6813      	ldr	r3, [r2, #0]
    100a:	01db      	lsls	r3, r3, #7
    100c:	d4fc      	bmi.n	1008 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
    100e:	b010      	add	sp, #64	; 0x40
    1010:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1014:	2c00      	cmp	r4, #0
    1016:	d1fa      	bne.n	100e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1018:	4a07      	ldr	r2, [pc, #28]	; (1038 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    101a:	6813      	ldr	r3, [r2, #0]
    101c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1020:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1022:	6813      	ldr	r3, [r2, #0]
    1024:	01d9      	lsls	r1, r3, #7
    1026:	d4fc      	bmi.n	1022 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
    1028:	b010      	add	sp, #64	; 0x40
    102a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    102e:	bf00      	nop
    1030:	0050183c 	.word	0x0050183c
    1034:	400fc000 	.word	0x400fc000
    1038:	401d0000 	.word	0x401d0000
    103c:	000f4240 	.word	0x000f4240
    1040:	20000370 	.word	0x20000370

00001044 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
    1044:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
    1048:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
    104c:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    104e:	4c57      	ldr	r4, [pc, #348]	; (11ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
    1050:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    1052:	4b57      	ldr	r3, [pc, #348]	; (11b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    1054:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
    1056:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    105a:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    105c:	4855      	ldr	r0, [pc, #340]	; (11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    105e:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1062:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    1064:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1066:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    106a:	446b      	add	r3, sp
    106c:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
    1070:	4b51      	ldr	r3, [pc, #324]	; (11b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
    1072:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1076:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
    1078:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
    107c:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1080:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
    1084:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1086:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    1088:	6803      	ldr	r3, [r0, #0]
    108a:	01df      	lsls	r7, r3, #7
    108c:	d5fc      	bpl.n	1088 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
    108e:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
    1090:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
    1094:	d92a      	bls.n	10ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
    1096:	4660      	mov	r0, ip
    1098:	1c83      	adds	r3, r0, #2
    divisor++;
    109a:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
    109c:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
    10a0:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
    10a2:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
    10a6:	d8f7      	bhi.n	1098 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
    10a8:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
    10ac:	fbb6 f3f3 	udiv	r3, r6, r3
    10b0:	1acb      	subs	r3, r1, r3
    10b2:	2b00      	cmp	r3, #0
    10b4:	bfb8      	it	lt
    10b6:	425b      	neglt	r3, r3
      if (error < bestError) {
    10b8:	42ab      	cmp	r3, r5
    10ba:	db0b      	blt.n	10d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
    10bc:	f1a7 030c 	sub.w	r3, r7, #12
    10c0:	bf18      	it	ne
    10c2:	f04f 0800 	movne.w	r8, #0
    10c6:	2b06      	cmp	r3, #6
    10c8:	d80a      	bhi.n	10e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
    10ca:	f1b8 0f00 	cmp.w	r8, #0
    10ce:	d007      	beq.n	10e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
    10d0:	4684      	mov	ip, r0
    10d2:	e7e1      	b.n	1098 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
    10d4:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
    10d6:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
    10da:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
    10dc:	2b06      	cmp	r3, #6
    10de:	d9f4      	bls.n	10ca <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
    10e0:	2f05      	cmp	r7, #5
    10e2:	d8d9      	bhi.n	1098 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
    10e4:	f10c 0301 	add.w	r3, ip, #1
    10e8:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
    10ec:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
    10f0:	f1a2 0205 	sub.w	r2, r2, #5
    10f4:	dc4c      	bgt.n	1190 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
    10f6:	2a14      	cmp	r2, #20
    10f8:	d84a      	bhi.n	1190 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
    10fa:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
    10fe:	4f2f      	ldr	r7, [pc, #188]	; (11bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
    1100:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    1102:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
    1106:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
    110a:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
    110e:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
    1112:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1114:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    1116:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1118:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    111a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    111c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    111e:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    1122:	c607      	stmia	r6!, {r0, r1, r2}
    1124:	f826 3b02 	strh.w	r3, [r6], #2
    1128:	ea4f 4313 	mov.w	r3, r3, lsr #16
    112c:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    112e:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    1132:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    1136:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    113a:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    113e:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    1142:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
    1146:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    114a:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    114e:	ea43 0302 	orr.w	r3, r3, r2
    1152:	ea43 0301 	orr.w	r3, r3, r1
    1156:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    115a:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    115e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    1162:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
    1166:	f8d8 3004 	ldr.w	r3, [r8, #4]
    116a:	bf14      	ite	ne
    116c:	f023 0308 	bicne.w	r3, r3, #8
    1170:	f043 0308 	orreq.w	r3, r3, #8
    1174:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1178:	b93c      	cbnz	r4, 118a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    117a:	4a0e      	ldr	r2, [pc, #56]	; (11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    117c:	6813      	ldr	r3, [r2, #0]
    117e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1182:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1184:	6813      	ldr	r3, [r2, #0]
    1186:	01db      	lsls	r3, r3, #7
    1188:	d4fc      	bmi.n	1184 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
    118a:	b010      	add	sp, #64	; 0x40
    118c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1190:	2c00      	cmp	r4, #0
    1192:	d1fa      	bne.n	118a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1194:	4a07      	ldr	r2, [pc, #28]	; (11b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    1196:	6813      	ldr	r3, [r2, #0]
    1198:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    119c:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    119e:	6813      	ldr	r3, [r2, #0]
    11a0:	01d9      	lsls	r1, r3, #7
    11a2:	d4fc      	bmi.n	119e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
    11a4:	b010      	add	sp, #64	; 0x40
    11a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    11aa:	bf00      	nop
    11ac:	0050183c 	.word	0x0050183c
    11b0:	400fc000 	.word	0x400fc000
    11b4:	401d4000 	.word	0x401d4000
    11b8:	000f4240 	.word	0x000f4240
    11bc:	20000370 	.word	0x20000370

000011c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3); /* input 3 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4); /* input 4 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4, uint32_t id5); /* input 5 ID's to be filtered */
    bool setMBFilterRange(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2); /* filter a range of ids */
    int write(const CAN_message_t &msg); /* use any available mailbox for transmitting */
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
    11c0:	2000      	movs	r0, #0
    11c2:	4770      	bx	lr

000011c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
    11c4:	2000      	movs	r0, #0
    11c6:	4770      	bx	lr

000011c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
#endif
    void enhanceFilter(FLEXCAN_MAILBOX mb_num);
    void distribute(bool state = 1) { distribution = state; }
    void enableDMA(bool state = 1);
    void disableDMA() { enableDMA(0); }
    uint8_t getFirstTxBoxSize(){ return 8; }
    11c8:	2008      	movs	r0, #8
    11ca:	4770      	bx	lr

000011cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
    11cc:	2000      	movs	r0, #0
    11ce:	4770      	bx	lr

000011d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
    11d0:	2000      	movs	r0, #0
    11d2:	4770      	bx	lr

000011d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
    uint8_t getFirstTxBoxSize(){ return 8; }
    11d4:	2008      	movs	r0, #8
    11d6:	4770      	bx	lr

000011d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    11d8:	4910      	ldr	r1, [pc, #64]	; (121c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    11da:	680b      	ldr	r3, [r1, #0]
    11dc:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    11de:	680a      	ldr	r2, [r1, #0]
    11e0:	6b49      	ldr	r1, [r1, #52]	; 0x34
    11e2:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    11e6:	f3c1 6103 	ubfx	r1, r1, #24, #4
    11ea:	3201      	adds	r2, #1
    11ec:	3104      	adds	r1, #4
    11ee:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
    11f2:	d310      	bcc.n	1216 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    11f4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    11f8:	f3c0 6003 	ubfx	r0, r0, #24, #4
    11fc:	3b05      	subs	r3, #5
    11fe:	3001      	adds	r0, #1
    1200:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
    1204:	b2db      	uxtb	r3, r3
    1206:	4a05      	ldr	r2, [pc, #20]	; (121c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    1208:	6810      	ldr	r0, [r2, #0]
    120a:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    120e:	3001      	adds	r0, #1
    1210:	1ac0      	subs	r0, r0, r3
}
    1212:	b2c0      	uxtb	r0, r0
    1214:	4770      	bx	lr
    1216:	2300      	movs	r3, #0
    1218:	e7f5      	b.n	1206 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
    121a:	bf00      	nop
    121c:	401d0000 	.word	0x401d0000

00001220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1220:	4910      	ldr	r1, [pc, #64]	; (1264 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    1222:	680b      	ldr	r3, [r1, #0]
    1224:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1226:	680a      	ldr	r2, [r1, #0]
    1228:	6b49      	ldr	r1, [r1, #52]	; 0x34
    122a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    122e:	f3c1 6103 	ubfx	r1, r1, #24, #4
    1232:	3201      	adds	r2, #1
    1234:	3104      	adds	r1, #4
    1236:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
    123a:	d310      	bcc.n	125e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    123c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1240:	f3c0 6003 	ubfx	r0, r0, #24, #4
    1244:	3b05      	subs	r3, #5
    1246:	3001      	adds	r0, #1
    1248:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
    124c:	b2db      	uxtb	r3, r3
    124e:	4a05      	ldr	r2, [pc, #20]	; (1264 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    1250:	6810      	ldr	r0, [r2, #0]
    1252:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    1256:	3001      	adds	r0, #1
    1258:	1ac0      	subs	r0, r0, r3
}
    125a:	b2c0      	uxtb	r0, r0
    125c:	4770      	bx	lr
    125e:	2300      	movs	r3, #0
    1260:	e7f5      	b.n	124e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
    1262:	bf00      	nop
    1264:	401d4000 	.word	0x401d4000

00001268 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1268:	4a63      	ldr	r2, [pc, #396]	; (13f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    126a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    126e:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1270:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1272:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1276:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    127a:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    127c:	6813      	ldr	r3, [r2, #0]
    127e:	01dd      	lsls	r5, r3, #7
    1280:	d5fc      	bpl.n	127c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1282:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    1284:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1286:	f8df c178 	ldr.w	ip, [pc, #376]	; 1400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    128a:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    128e:	4f5b      	ldr	r7, [pc, #364]	; (13fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1290:	4e59      	ldr	r6, [pc, #356]	; (13f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1292:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1294:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    1296:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    1298:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    129a:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    129c:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    12a0:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    12a2:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    12a4:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    12a6:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    12a8:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    12aa:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    12ac:	6091      	str	r1, [r2, #8]
    12ae:	6051      	str	r1, [r2, #4]
    12b0:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    12b2:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    12b4:	6832      	ldr	r2, [r6, #0]
    12b6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    12ba:	3201      	adds	r2, #1
    12bc:	4293      	cmp	r3, r2
    12be:	d3ed      	bcc.n	129c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    12c0:	64b1      	str	r1, [r6, #72]	; 0x48
    12c2:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    12c4:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    12c6:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    12c8:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    12ca:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    12cc:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    12ce:	2800      	cmp	r0, #0
    12d0:	d149      	bne.n	1366 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    12d2:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    12d6:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    12d8:	4e47      	ldr	r6, [pc, #284]	; (13f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    12da:	4f48      	ldr	r7, [pc, #288]	; (13fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    12dc:	e019      	b.n	1312 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    12de:	6833      	ldr	r3, [r6, #0]
    12e0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    12e4:	3301      	adds	r3, #1
    12e6:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    12ea:	bf34      	ite	cc
    12ec:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    12f0:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    12f4:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    12f6:	6b73      	ldr	r3, [r6, #52]	; 0x34
    12f8:	f3c3 4300 	ubfx	r3, r3, #16, #1
    12fc:	079b      	lsls	r3, r3, #30
    12fe:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1300:	6833      	ldr	r3, [r6, #0]
    1302:	3501      	adds	r5, #1
    1304:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1308:	b2ed      	uxtb	r5, r5
    130a:	3301      	adds	r3, #1
    130c:	4628      	mov	r0, r5
    130e:	429d      	cmp	r5, r3
    1310:	d21e      	bcs.n	1350 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1312:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1314:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1318:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    131a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    131e:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1320:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1322:	3301      	adds	r3, #1
    1324:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    1328:	d3d9      	bcc.n	12de <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    132a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    132e:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1330:	6833      	ldr	r3, [r6, #0]
    1332:	009a      	lsls	r2, r3, #2
    1334:	d503      	bpl.n	133e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    1336:	f7ff ff4f 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    133a:	42a8      	cmp	r0, r5
    133c:	d8e0      	bhi.n	1300 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    133e:	2301      	movs	r3, #1
    1340:	2d1f      	cmp	r5, #31
    1342:	fa03 f305 	lsl.w	r3, r3, r5
    1346:	d84c      	bhi.n	13e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    1348:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    134a:	4313      	orrs	r3, r2
    134c:	62b3      	str	r3, [r6, #40]	; 0x28
    134e:	e7d7      	b.n	1300 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1350:	b93c      	cbnz	r4, 1362 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1352:	4a29      	ldr	r2, [pc, #164]	; (13f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    1354:	6813      	ldr	r3, [r2, #0]
    1356:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    135a:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    135c:	6813      	ldr	r3, [r2, #0]
    135e:	01db      	lsls	r3, r3, #7
    1360:	d4fc      	bmi.n	135c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    1362:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    1366:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    136a:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    136c:	6835      	ldr	r5, [r6, #0]
    136e:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    1372:	d03e      	beq.n	13f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    1374:	f7ff ff30 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1378:	6833      	ldr	r3, [r6, #0]
    137a:	4605      	mov	r5, r0
    137c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1380:	3301      	adds	r3, #1
    1382:	4283      	cmp	r3, r0
    1384:	d9e4      	bls.n	1350 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1386:	4f1e      	ldr	r7, [pc, #120]	; (1400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    1388:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    138c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 13f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    1390:	e00d      	b.n	13ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1392:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    1396:	4313      	orrs	r3, r2
    1398:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    139c:	f8d8 3000 	ldr.w	r3, [r8]
    13a0:	3501      	adds	r5, #1
    13a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    13a6:	b2ed      	uxtb	r5, r5
    13a8:	3301      	adds	r3, #1
    13aa:	429d      	cmp	r5, r3
    13ac:	d2d0      	bcs.n	1350 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    13ae:	19eb      	adds	r3, r5, r7
    13b0:	011b      	lsls	r3, r3, #4
    13b2:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    13b4:	f8d8 3000 	ldr.w	r3, [r8]
    13b8:	0099      	lsls	r1, r3, #2
    13ba:	d503      	bpl.n	13c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    13bc:	f7ff ff0c 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    13c0:	4285      	cmp	r5, r0
    13c2:	d3eb      	bcc.n	139c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    13c4:	2301      	movs	r3, #1
    13c6:	2d1f      	cmp	r5, #31
    13c8:	fa03 f305 	lsl.w	r3, r3, r5
    13cc:	d9e1      	bls.n	1392 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    13ce:	f1a5 0120 	sub.w	r1, r5, #32
    13d2:	2301      	movs	r3, #1
    13d4:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    13d8:	408b      	lsls	r3, r1
    13da:	4313      	orrs	r3, r2
    13dc:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    13e0:	e7dc      	b.n	139c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    13e2:	f1a5 0120 	sub.w	r1, r5, #32
    13e6:	2301      	movs	r3, #1
    13e8:	6a72      	ldr	r2, [r6, #36]	; 0x24
    13ea:	408b      	lsls	r3, r1
    13ec:	4313      	orrs	r3, r2
    13ee:	6273      	str	r3, [r6, #36]	; 0x24
    13f0:	e786      	b.n	1300 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    13f2:	6833      	ldr	r3, [r6, #0]
    13f4:	e7c7      	b.n	1386 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    13f6:	bf00      	nop
    13f8:	401d0000 	.word	0x401d0000
    13fc:	10074220 	.word	0x10074220
    1400:	0401d008 	.word	0x0401d008

00001404 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1404:	4a63      	ldr	r2, [pc, #396]	; (1594 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    1406:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    140a:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    140c:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    140e:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1412:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    1416:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    1418:	6813      	ldr	r3, [r2, #0]
    141a:	01dd      	lsls	r5, r3, #7
    141c:	d5fc      	bpl.n	1418 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    141e:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    1420:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1422:	f8df c178 	ldr.w	ip, [pc, #376]	; 159c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1426:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    142a:	4f5b      	ldr	r7, [pc, #364]	; (1598 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    142c:	4e59      	ldr	r6, [pc, #356]	; (1594 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    142e:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1430:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    1432:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    1434:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1436:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1438:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    143c:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    143e:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1440:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1442:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1444:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1446:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1448:	6091      	str	r1, [r2, #8]
    144a:	6051      	str	r1, [r2, #4]
    144c:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    144e:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1450:	6832      	ldr	r2, [r6, #0]
    1452:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    1456:	3201      	adds	r2, #1
    1458:	4293      	cmp	r3, r2
    145a:	d3ed      	bcc.n	1438 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    145c:	64b1      	str	r1, [r6, #72]	; 0x48
    145e:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    1460:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    1462:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    1464:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    1466:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    1468:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    146a:	2800      	cmp	r0, #0
    146c:	d149      	bne.n	1502 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    146e:	f8df 812c 	ldr.w	r8, [pc, #300]	; 159c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1472:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1474:	4e47      	ldr	r6, [pc, #284]	; (1594 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1476:	4f48      	ldr	r7, [pc, #288]	; (1598 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    1478:	e019      	b.n	14ae <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    147a:	6833      	ldr	r3, [r6, #0]
    147c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1480:	3301      	adds	r3, #1
    1482:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    1486:	bf34      	ite	cc
    1488:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    148c:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    1490:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1492:	6b73      	ldr	r3, [r6, #52]	; 0x34
    1494:	f3c3 4300 	ubfx	r3, r3, #16, #1
    1498:	079b      	lsls	r3, r3, #30
    149a:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    149c:	6833      	ldr	r3, [r6, #0]
    149e:	3501      	adds	r5, #1
    14a0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    14a4:	b2ed      	uxtb	r5, r5
    14a6:	3301      	adds	r3, #1
    14a8:	4628      	mov	r0, r5
    14aa:	429d      	cmp	r5, r3
    14ac:	d21e      	bcs.n	14ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    14ae:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    14b0:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    14b4:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    14b6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    14ba:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    14bc:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    14be:	3301      	adds	r3, #1
    14c0:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    14c4:	d3d9      	bcc.n	147a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    14c6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    14ca:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    14cc:	6833      	ldr	r3, [r6, #0]
    14ce:	009a      	lsls	r2, r3, #2
    14d0:	d503      	bpl.n	14da <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    14d2:	f7ff fea5 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    14d6:	42a8      	cmp	r0, r5
    14d8:	d8e0      	bhi.n	149c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    14da:	2301      	movs	r3, #1
    14dc:	2d1f      	cmp	r5, #31
    14de:	fa03 f305 	lsl.w	r3, r3, r5
    14e2:	d84c      	bhi.n	157e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    14e4:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    14e6:	4313      	orrs	r3, r2
    14e8:	62b3      	str	r3, [r6, #40]	; 0x28
    14ea:	e7d7      	b.n	149c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    14ec:	b93c      	cbnz	r4, 14fe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    14ee:	4a29      	ldr	r2, [pc, #164]	; (1594 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    14f0:	6813      	ldr	r3, [r2, #0]
    14f2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    14f6:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    14f8:	6813      	ldr	r3, [r2, #0]
    14fa:	01db      	lsls	r3, r3, #7
    14fc:	d4fc      	bmi.n	14f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    14fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    1502:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    1506:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1508:	6835      	ldr	r5, [r6, #0]
    150a:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    150e:	d03e      	beq.n	158e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    1510:	f7ff fe86 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1514:	6833      	ldr	r3, [r6, #0]
    1516:	4605      	mov	r5, r0
    1518:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    151c:	3301      	adds	r3, #1
    151e:	4283      	cmp	r3, r0
    1520:	d9e4      	bls.n	14ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1522:	4f1e      	ldr	r7, [pc, #120]	; (159c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    1524:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1528:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1594 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    152c:	e00d      	b.n	154a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    152e:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    1532:	4313      	orrs	r3, r2
    1534:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1538:	f8d8 3000 	ldr.w	r3, [r8]
    153c:	3501      	adds	r5, #1
    153e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1542:	b2ed      	uxtb	r5, r5
    1544:	3301      	adds	r3, #1
    1546:	429d      	cmp	r5, r3
    1548:	d2d0      	bcs.n	14ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    154a:	19eb      	adds	r3, r5, r7
    154c:	011b      	lsls	r3, r3, #4
    154e:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1550:	f8d8 3000 	ldr.w	r3, [r8]
    1554:	0099      	lsls	r1, r3, #2
    1556:	d503      	bpl.n	1560 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    1558:	f7ff fe62 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    155c:	4285      	cmp	r5, r0
    155e:	d3eb      	bcc.n	1538 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1560:	2301      	movs	r3, #1
    1562:	2d1f      	cmp	r5, #31
    1564:	fa03 f305 	lsl.w	r3, r3, r5
    1568:	d9e1      	bls.n	152e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    156a:	f1a5 0120 	sub.w	r1, r5, #32
    156e:	2301      	movs	r3, #1
    1570:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    1574:	408b      	lsls	r3, r1
    1576:	4313      	orrs	r3, r2
    1578:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    157c:	e7dc      	b.n	1538 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    157e:	f1a5 0120 	sub.w	r1, r5, #32
    1582:	2301      	movs	r3, #1
    1584:	6a72      	ldr	r2, [r6, #36]	; 0x24
    1586:	408b      	lsls	r3, r1
    1588:	4313      	orrs	r3, r2
    158a:	6273      	str	r3, [r6, #36]	; 0x24
    158c:	e786      	b.n	149c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    158e:	6833      	ldr	r3, [r6, #0]
    1590:	e7c7      	b.n	1522 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    1592:	bf00      	nop
    1594:	401d4000 	.word	0x401d4000
    1598:	10075220 	.word	0x10075220
    159c:	0401d408 	.word	0x0401d408

000015a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    15a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    15a4:	4db7      	ldr	r5, [pc, #732]	; (1884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    15a6:	682b      	ldr	r3, [r5, #0]
    15a8:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    15ac:	f040 819a 	bne.w	18e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    15b0:	211a      	movs	r1, #26
    15b2:	48b5      	ldr	r0, [pc, #724]	; (1888 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    15b4:	f006 f9ca 	bl	794c <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    15b8:	464c      	mov	r4, r9
    15ba:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    15bc:	4fb3      	ldr	r7, [pc, #716]	; (188c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    15be:	4db4      	ldr	r5, [pc, #720]	; (1890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    15c0:	4eb4      	ldr	r6, [pc, #720]	; (1894 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    15c2:	eb04 0805 	add.w	r8, r4, r5
    15c6:	ea4f 1808 	mov.w	r8, r8, lsl #4
    15ca:	f8d8 3000 	ldr.w	r3, [r8]
    15ce:	f3c3 6303 	ubfx	r3, r3, #24, #4
    15d2:	2b0e      	cmp	r3, #14
    15d4:	f200 809e 	bhi.w	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    15d8:	e8df f013 	tbh	[pc, r3, lsl #1]
    15dc:	01300142 	.word	0x01300142
    15e0:	009c011e 	.word	0x009c011e
    15e4:	009c0103 	.word	0x009c0103
    15e8:	009c00f1 	.word	0x009c00f1
    15ec:	00cd00df 	.word	0x00cd00df
    15f0:	009c00bb 	.word	0x009c00bb
    15f4:	009c000f 	.word	0x009c000f
    15f8:	00a9      	.short	0x00a9
    15fa:	2104      	movs	r1, #4
    15fc:	48a6      	ldr	r0, [pc, #664]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    15fe:	f006 f9a5 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1602:	2300      	movs	r3, #0
    1604:	4649      	mov	r1, r9
    1606:	220a      	movs	r2, #10
    1608:	48a4      	ldr	r0, [pc, #656]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    160a:	f004 f93b 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    160e:	211d      	movs	r1, #29
    1610:	48a3      	ldr	r0, [pc, #652]	; (18a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    1612:	f006 f99b 	bl	794c <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1616:	f8d8 3000 	ldr.w	r3, [r8]
    161a:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    161c:	029b      	lsls	r3, r3, #10
    161e:	f140 81e3 	bpl.w	19e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    1622:	48a0      	ldr	r0, [pc, #640]	; (18a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    1624:	f006 f992 	bl	794c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1628:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    162c:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1630:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1632:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1636:	2107      	movs	r1, #7
    1638:	489b      	ldr	r0, [pc, #620]	; (18a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    163a:	f006 f987 	bl	794c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    163e:	2300      	movs	r3, #0
    1640:	2210      	movs	r2, #16
    1642:	4651      	mov	r1, sl
    1644:	4895      	ldr	r0, [pc, #596]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1646:	f004 f91d 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    164a:	2101      	movs	r1, #1
    164c:	4897      	ldr	r0, [pc, #604]	; (18ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    164e:	f006 f97d 	bl	794c <usb_serial_write>
    1652:	210a      	movs	r1, #10
    1654:	4896      	ldr	r0, [pc, #600]	; (18b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    1656:	f006 f979 	bl	794c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    165a:	2300      	movs	r3, #0
    165c:	2210      	movs	r2, #16
    165e:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1662:	488e      	ldr	r0, [pc, #568]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1664:	f004 f90e 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1668:	2101      	movs	r1, #1
    166a:	4892      	ldr	r0, [pc, #584]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    166c:	f006 f96e 	bl	794c <usb_serial_write>
    1670:	2300      	movs	r3, #0
    1672:	2210      	movs	r2, #16
    1674:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1678:	4888      	ldr	r0, [pc, #544]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    167a:	f004 f903 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    167e:	2101      	movs	r1, #1
    1680:	488c      	ldr	r0, [pc, #560]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1682:	f006 f963 	bl	794c <usb_serial_write>
    1686:	2300      	movs	r3, #0
    1688:	2210      	movs	r2, #16
    168a:	f3c9 2107 	ubfx	r1, r9, #8, #8
    168e:	4883      	ldr	r0, [pc, #524]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1690:	f004 f8f8 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1694:	2101      	movs	r1, #1
    1696:	4887      	ldr	r0, [pc, #540]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1698:	f006 f958 	bl	794c <usb_serial_write>
    169c:	2300      	movs	r3, #0
    169e:	2210      	movs	r2, #16
    16a0:	fa5f f189 	uxtb.w	r1, r9
    16a4:	487d      	ldr	r0, [pc, #500]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16a6:	f004 f8ed 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    16aa:	f858 8007 	ldr.w	r8, [r8, r7]
    16ae:	2101      	movs	r1, #1
    16b0:	4880      	ldr	r0, [pc, #512]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    16b2:	f006 f94b 	bl	794c <usb_serial_write>
    16b6:	2300      	movs	r3, #0
    16b8:	2210      	movs	r2, #16
    16ba:	ea4f 6118 	mov.w	r1, r8, lsr #24
    16be:	4877      	ldr	r0, [pc, #476]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16c0:	f004 f8e0 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16c4:	2101      	movs	r1, #1
    16c6:	487b      	ldr	r0, [pc, #492]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    16c8:	f006 f940 	bl	794c <usb_serial_write>
    16cc:	2300      	movs	r3, #0
    16ce:	2210      	movs	r2, #16
    16d0:	f3c8 4107 	ubfx	r1, r8, #16, #8
    16d4:	4871      	ldr	r0, [pc, #452]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16d6:	f004 f8d5 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16da:	2101      	movs	r1, #1
    16dc:	4875      	ldr	r0, [pc, #468]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    16de:	f006 f935 	bl	794c <usb_serial_write>
    16e2:	2300      	movs	r3, #0
    16e4:	2210      	movs	r2, #16
    16e6:	f3c8 2107 	ubfx	r1, r8, #8, #8
    16ea:	486c      	ldr	r0, [pc, #432]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16ec:	f004 f8ca 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16f0:	2101      	movs	r1, #1
    16f2:	4870      	ldr	r0, [pc, #448]	; (18b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    16f4:	f006 f92a 	bl	794c <usb_serial_write>
    16f8:	2300      	movs	r3, #0
    16fa:	fa5f f188 	uxtb.w	r1, r8
    16fe:	2210      	movs	r2, #16
    1700:	4866      	ldr	r0, [pc, #408]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1702:	f004 f8bf 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1706:	2101      	movs	r1, #1
    1708:	4868      	ldr	r0, [pc, #416]	; (18ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    170a:	f006 f91f 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    170e:	4863      	ldr	r0, [pc, #396]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1710:	f004 f88e 	bl	5830 <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1714:	4b5b      	ldr	r3, [pc, #364]	; (1884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1716:	3401      	adds	r4, #1
    1718:	681b      	ldr	r3, [r3, #0]
    171a:	b2e4      	uxtb	r4, r4
    171c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1720:	46a1      	mov	r9, r4
    1722:	3301      	adds	r3, #1
    1724:	429c      	cmp	r4, r3
    1726:	f4ff af4c 	bcc.w	15c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    172a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    172e:	2104      	movs	r1, #4
    1730:	4859      	ldr	r0, [pc, #356]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1732:	f006 f90b 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1736:	4649      	mov	r1, r9
    1738:	2300      	movs	r3, #0
    173a:	220a      	movs	r2, #10
    173c:	4857      	ldr	r0, [pc, #348]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    173e:	f004 f8a1 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1742:	2111      	movs	r1, #17
    1744:	485c      	ldr	r0, [pc, #368]	; (18b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    1746:	f006 f901 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    174a:	4854      	ldr	r0, [pc, #336]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    174c:	f004 f870 	bl	5830 <Print::println()>
    1750:	e7e0      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1752:	2104      	movs	r1, #4
    1754:	4850      	ldr	r0, [pc, #320]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1756:	f006 f8f9 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    175a:	4649      	mov	r1, r9
    175c:	2300      	movs	r3, #0
    175e:	220a      	movs	r2, #10
    1760:	484e      	ldr	r0, [pc, #312]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1762:	f004 f88f 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1766:	2111      	movs	r1, #17
    1768:	4854      	ldr	r0, [pc, #336]	; (18bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    176a:	f006 f8ef 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    176e:	484b      	ldr	r0, [pc, #300]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1770:	f004 f85e 	bl	5830 <Print::println()>
    1774:	e7ce      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1776:	2104      	movs	r1, #4
    1778:	4847      	ldr	r0, [pc, #284]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    177a:	f006 f8e7 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    177e:	4649      	mov	r1, r9
    1780:	2300      	movs	r3, #0
    1782:	220a      	movs	r2, #10
    1784:	4845      	ldr	r0, [pc, #276]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1786:	f004 f87d 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    178a:	210f      	movs	r1, #15
    178c:	484c      	ldr	r0, [pc, #304]	; (18c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    178e:	f006 f8dd 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1792:	4842      	ldr	r0, [pc, #264]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1794:	f004 f84c 	bl	5830 <Print::println()>
    1798:	e7bc      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    179a:	2104      	movs	r1, #4
    179c:	483e      	ldr	r0, [pc, #248]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    179e:	f006 f8d5 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17a2:	4649      	mov	r1, r9
    17a4:	2300      	movs	r3, #0
    17a6:	220a      	movs	r2, #10
    17a8:	483c      	ldr	r0, [pc, #240]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17aa:	f004 f86b 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17ae:	2112      	movs	r1, #18
    17b0:	4844      	ldr	r0, [pc, #272]	; (18c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    17b2:	f006 f8cb 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17b6:	4839      	ldr	r0, [pc, #228]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17b8:	f004 f83a 	bl	5830 <Print::println()>
    17bc:	e7aa      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    17be:	2104      	movs	r1, #4
    17c0:	4835      	ldr	r0, [pc, #212]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    17c2:	f006 f8c3 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17c6:	4649      	mov	r1, r9
    17c8:	2300      	movs	r3, #0
    17ca:	220a      	movs	r2, #10
    17cc:	4833      	ldr	r0, [pc, #204]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17ce:	f004 f859 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17d2:	2111      	movs	r1, #17
    17d4:	483c      	ldr	r0, [pc, #240]	; (18c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    17d6:	f006 f8b9 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17da:	4830      	ldr	r0, [pc, #192]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17dc:	f004 f828 	bl	5830 <Print::println()>
    17e0:	e798      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    17e2:	2104      	movs	r1, #4
    17e4:	482c      	ldr	r0, [pc, #176]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    17e6:	f006 f8b1 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17ea:	220a      	movs	r2, #10
    17ec:	4649      	mov	r1, r9
    17ee:	2300      	movs	r3, #0
    17f0:	482a      	ldr	r0, [pc, #168]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17f2:	f004 f847 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17f6:	210f      	movs	r1, #15
    17f8:	4834      	ldr	r0, [pc, #208]	; (18cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    17fa:	f006 f8a7 	bl	794c <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    17fe:	f8d8 3000 	ldr.w	r3, [r8]
    1802:	2111      	movs	r1, #17
    1804:	029a      	lsls	r2, r3, #10
    1806:	bf4c      	ite	mi
    1808:	4831      	ldrmi	r0, [pc, #196]	; (18d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    180a:	4832      	ldrpl	r0, [pc, #200]	; (18d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    180c:	f006 f89e 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1810:	4822      	ldr	r0, [pc, #136]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1812:	f004 f80d 	bl	5830 <Print::println()>
    1816:	e77d      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1818:	2104      	movs	r1, #4
    181a:	481f      	ldr	r0, [pc, #124]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    181c:	f006 f896 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1820:	4649      	mov	r1, r9
    1822:	2300      	movs	r3, #0
    1824:	220a      	movs	r2, #10
    1826:	481d      	ldr	r0, [pc, #116]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1828:	f004 f82c 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    182c:	210e      	movs	r1, #14
    182e:	482a      	ldr	r0, [pc, #168]	; (18d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    1830:	f006 f88c 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1834:	4819      	ldr	r0, [pc, #100]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1836:	f003 fffb 	bl	5830 <Print::println()>
    183a:	e76b      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    183c:	2104      	movs	r1, #4
    183e:	4816      	ldr	r0, [pc, #88]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1840:	f006 f884 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1844:	4649      	mov	r1, r9
    1846:	2300      	movs	r3, #0
    1848:	220a      	movs	r2, #10
    184a:	4814      	ldr	r0, [pc, #80]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    184c:	f004 f81a 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1850:	210e      	movs	r1, #14
    1852:	4822      	ldr	r0, [pc, #136]	; (18dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    1854:	f006 f87a 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1858:	4810      	ldr	r0, [pc, #64]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    185a:	f003 ffe9 	bl	5830 <Print::println()>
    185e:	e759      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1860:	2104      	movs	r1, #4
    1862:	480d      	ldr	r0, [pc, #52]	; (1898 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1864:	f006 f872 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1868:	4649      	mov	r1, r9
    186a:	2300      	movs	r3, #0
    186c:	220a      	movs	r2, #10
    186e:	480b      	ldr	r0, [pc, #44]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1870:	f004 f808 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1874:	2112      	movs	r1, #18
    1876:	481a      	ldr	r0, [pc, #104]	; (18e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    1878:	f006 f868 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    187c:	4807      	ldr	r0, [pc, #28]	; (189c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    187e:	f003 ffd7 	bl	5830 <Print::println()>
    1882:	e747      	b.n	1714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1884:	401d4000 	.word	0x401d4000
    1888:	20000840 	.word	0x20000840
    188c:	401d408c 	.word	0x401d408c
    1890:	0401d408 	.word	0x0401d408
    1894:	bfe2bf80 	.word	0xbfe2bf80
    1898:	20000710 	.word	0x20000710
    189c:	20001110 	.word	0x20001110
    18a0:	200007d0 	.word	0x200007d0
    18a4:	200007f0 	.word	0x200007f0
    18a8:	20000818 	.word	0x20000818
    18ac:	2000074c 	.word	0x2000074c
    18b0:	20000820 	.word	0x20000820
    18b4:	200006b4 	.word	0x200006b4
    18b8:	2000082c 	.word	0x2000082c
    18bc:	20000788 	.word	0x20000788
    18c0:	200007c0 	.word	0x200007c0
    18c4:	200007ac 	.word	0x200007ac
    18c8:	20000774 	.word	0x20000774
    18cc:	2000072c 	.word	0x2000072c
    18d0:	2000073c 	.word	0x2000073c
    18d4:	20000750 	.word	0x20000750
    18d8:	20000764 	.word	0x20000764
    18dc:	2000079c 	.word	0x2000079c
    18e0:	20000718 	.word	0x20000718
    18e4:	2111      	movs	r1, #17
    18e6:	48c4      	ldr	r0, [pc, #784]	; (1bf8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    18e8:	f006 f830 	bl	794c <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    18ec:	6aab      	ldr	r3, [r5, #40]	; 0x28
    18ee:	069a      	lsls	r2, r3, #26
    18f0:	f100 81fa 	bmi.w	1ce8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    18f4:	2112      	movs	r1, #18
    18f6:	48c1      	ldr	r0, [pc, #772]	; (1bfc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    18f8:	f006 f828 	bl	794c <usb_serial_write>
    18fc:	48c0      	ldr	r0, [pc, #768]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    18fe:	f003 ff97 	bl	5830 <Print::println()>
    1902:	2116      	movs	r1, #22
    1904:	48bf      	ldr	r0, [pc, #764]	; (1c04 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    1906:	f006 f821 	bl	794c <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    190a:	4abf      	ldr	r2, [pc, #764]	; (1c08 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    190c:	6814      	ldr	r4, [r2, #0]
    190e:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1910:	6813      	ldr	r3, [r2, #0]
    1912:	6b52      	ldr	r2, [r2, #52]	; 0x34
    1914:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1918:	f3c2 6203 	ubfx	r2, r2, #24, #4
    191c:	3301      	adds	r3, #1
    191e:	3204      	adds	r2, #4
    1920:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1924:	f0c0 81e8 	bcc.w	1cf8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1928:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    192c:	f3c1 6103 	ubfx	r1, r1, #24, #4
    1930:	3c05      	subs	r4, #5
    1932:	3101      	adds	r1, #1
    1934:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    1938:	b2e5      	uxtb	r5, r4
    193a:	4eb3      	ldr	r6, [pc, #716]	; (1c08 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    193c:	48b0      	ldr	r0, [pc, #704]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    193e:	6831      	ldr	r1, [r6, #0]
    1940:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    1944:	3101      	adds	r1, #1
    1946:	1b49      	subs	r1, r1, r5
    1948:	b2c9      	uxtb	r1, r1
    194a:	2920      	cmp	r1, #32
    194c:	bfa8      	it	ge
    194e:	2120      	movge	r1, #32
    1950:	f003 ff62 	bl	5818 <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    1954:	48aa      	ldr	r0, [pc, #680]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1956:	f003 ff6b 	bl	5830 <Print::println()>
    195a:	2116      	movs	r1, #22
    195c:	48ab      	ldr	r0, [pc, #684]	; (1c0c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    195e:	f005 fff5 	bl	794c <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1962:	6833      	ldr	r3, [r6, #0]
    1964:	6b72      	ldr	r2, [r6, #52]	; 0x34
    1966:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    196a:	f3c2 6203 	ubfx	r2, r2, #24, #4
    196e:	3301      	adds	r3, #1
    1970:	3204      	adds	r2, #4
    1972:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    1976:	d201      	bcs.n	197c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    1978:	2500      	movs	r5, #0
    197a:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    197c:	2300      	movs	r3, #0
    197e:	4621      	mov	r1, r4
    1980:	220a      	movs	r2, #10
    1982:	489f      	ldr	r0, [pc, #636]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1984:	f003 ff7e 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	// Print an unsigned number and newline
	size_t println(unsigned int n)			{ return print(n) + println(); }
	// Print a signed number and newline
	size_t println(long n)				{ return print(n) + println(); }
	// Print an unsigned number and newline
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1988:	489d      	ldr	r0, [pc, #628]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    198a:	f003 ff51 	bl	5830 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    198e:	4b9e      	ldr	r3, [pc, #632]	; (1c08 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1990:	681c      	ldr	r4, [r3, #0]
    1992:	681b      	ldr	r3, [r3, #0]
    1994:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1998:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    199c:	3401      	adds	r4, #1
    199e:	3301      	adds	r3, #1
    19a0:	1b64      	subs	r4, r4, r5
    19a2:	b2e4      	uxtb	r4, r4
    19a4:	42a3      	cmp	r3, r4
    19a6:	f67f aec0 	bls.w	172a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    19aa:	4d99      	ldr	r5, [pc, #612]	; (1c10 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    19ac:	4e99      	ldr	r6, [pc, #612]	; (1c14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    19ae:	4f9a      	ldr	r7, [pc, #616]	; (1c18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    19b0:	eb04 0805 	add.w	r8, r4, r5
    19b4:	ea4f 1808 	mov.w	r8, r8, lsl #4
    19b8:	f8d8 3000 	ldr.w	r3, [r8]
    19bc:	f3c3 6303 	ubfx	r3, r3, #24, #4
    19c0:	2b0e      	cmp	r3, #14
    19c2:	f200 80a9 	bhi.w	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    19c6:	e8df f013 	tbh	[pc, r3, lsl #1]
    19ca:	0147      	.short	0x0147
    19cc:	00f20104 	.word	0x00f20104
    19d0:	00d700a7 	.word	0x00d700a7
    19d4:	016b00a7 	.word	0x016b00a7
    19d8:	015900a7 	.word	0x015900a7
    19dc:	00c5017d 	.word	0x00c5017d
    19e0:	001a00a7 	.word	0x001a00a7
    19e4:	00b300a7 	.word	0x00b300a7
    19e8:	488c      	ldr	r0, [pc, #560]	; (1c1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    19ea:	f005 ffaf 	bl	794c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    19ee:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    19f2:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    19f6:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    19f8:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    19fc:	e61b      	b.n	1636 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    19fe:	2104      	movs	r1, #4
    1a00:	4887      	ldr	r0, [pc, #540]	; (1c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1a02:	f005 ffa3 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a06:	2300      	movs	r3, #0
    1a08:	220a      	movs	r2, #10
    1a0a:	4621      	mov	r1, r4
    1a0c:	487c      	ldr	r0, [pc, #496]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1a0e:	f003 ff39 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a12:	211d      	movs	r1, #29
    1a14:	4883      	ldr	r0, [pc, #524]	; (1c24 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    1a16:	f005 ff99 	bl	794c <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1a1a:	f8d8 3000 	ldr.w	r3, [r8]
    1a1e:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1a20:	0298      	lsls	r0, r3, #10
    1a22:	f140 816c 	bpl.w	1cfe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    1a26:	4880      	ldr	r0, [pc, #512]	; (1c28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    1a28:	f005 ff90 	bl	794c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a2c:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a30:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a34:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a36:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1a3a:	2107      	movs	r1, #7
    1a3c:	487b      	ldr	r0, [pc, #492]	; (1c2c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    1a3e:	f005 ff85 	bl	794c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1a42:	2300      	movs	r3, #0
    1a44:	2210      	movs	r2, #16
    1a46:	4651      	mov	r1, sl
    1a48:	486d      	ldr	r0, [pc, #436]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1a4a:	f003 ff1b 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a4e:	2101      	movs	r1, #1
    1a50:	4877      	ldr	r0, [pc, #476]	; (1c30 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1a52:	f005 ff7b 	bl	794c <usb_serial_write>
    1a56:	210a      	movs	r1, #10
    1a58:	4876      	ldr	r0, [pc, #472]	; (1c34 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    1a5a:	f005 ff77 	bl	794c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1a5e:	2300      	movs	r3, #0
    1a60:	2210      	movs	r2, #16
    1a62:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1a66:	4866      	ldr	r0, [pc, #408]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1a68:	f003 ff0c 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a6c:	2101      	movs	r1, #1
    1a6e:	4872      	ldr	r0, [pc, #456]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1a70:	f005 ff6c 	bl	794c <usb_serial_write>
    1a74:	2300      	movs	r3, #0
    1a76:	2210      	movs	r2, #16
    1a78:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1a7c:	4860      	ldr	r0, [pc, #384]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1a7e:	f003 ff01 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a82:	2101      	movs	r1, #1
    1a84:	486c      	ldr	r0, [pc, #432]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1a86:	f005 ff61 	bl	794c <usb_serial_write>
    1a8a:	2300      	movs	r3, #0
    1a8c:	2210      	movs	r2, #16
    1a8e:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1a92:	485b      	ldr	r0, [pc, #364]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1a94:	f003 fef6 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a98:	2101      	movs	r1, #1
    1a9a:	4867      	ldr	r0, [pc, #412]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1a9c:	f005 ff56 	bl	794c <usb_serial_write>
    1aa0:	2300      	movs	r3, #0
    1aa2:	2210      	movs	r2, #16
    1aa4:	fa5f f189 	uxtb.w	r1, r9
    1aa8:	4855      	ldr	r0, [pc, #340]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1aaa:	f003 feeb 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1aae:	f858 8006 	ldr.w	r8, [r8, r6]
    1ab2:	2101      	movs	r1, #1
    1ab4:	4860      	ldr	r0, [pc, #384]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1ab6:	f005 ff49 	bl	794c <usb_serial_write>
    1aba:	2300      	movs	r3, #0
    1abc:	2210      	movs	r2, #16
    1abe:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1ac2:	484f      	ldr	r0, [pc, #316]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ac4:	f003 fede 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ac8:	2101      	movs	r1, #1
    1aca:	485b      	ldr	r0, [pc, #364]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1acc:	f005 ff3e 	bl	794c <usb_serial_write>
    1ad0:	2300      	movs	r3, #0
    1ad2:	2210      	movs	r2, #16
    1ad4:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1ad8:	4849      	ldr	r0, [pc, #292]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ada:	f003 fed3 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ade:	2101      	movs	r1, #1
    1ae0:	4855      	ldr	r0, [pc, #340]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1ae2:	f005 ff33 	bl	794c <usb_serial_write>
    1ae6:	2300      	movs	r3, #0
    1ae8:	2210      	movs	r2, #16
    1aea:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1aee:	4844      	ldr	r0, [pc, #272]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1af0:	f003 fec8 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1af4:	2101      	movs	r1, #1
    1af6:	4850      	ldr	r0, [pc, #320]	; (1c38 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1af8:	f005 ff28 	bl	794c <usb_serial_write>
    1afc:	2300      	movs	r3, #0
    1afe:	fa5f f188 	uxtb.w	r1, r8
    1b02:	2210      	movs	r2, #16
    1b04:	483e      	ldr	r0, [pc, #248]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b06:	f003 febd 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b0a:	2101      	movs	r1, #1
    1b0c:	4848      	ldr	r0, [pc, #288]	; (1c30 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1b0e:	f005 ff1d 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b12:	483b      	ldr	r0, [pc, #236]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b14:	f003 fe8c 	bl	5830 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1b18:	4b3b      	ldr	r3, [pc, #236]	; (1c08 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1b1a:	3401      	adds	r4, #1
    1b1c:	681b      	ldr	r3, [r3, #0]
    1b1e:	b2e4      	uxtb	r4, r4
    1b20:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1b24:	3301      	adds	r3, #1
    1b26:	429c      	cmp	r4, r3
    1b28:	f4ff af42 	bcc.w	19b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    1b2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1b30:	2104      	movs	r1, #4
    1b32:	483b      	ldr	r0, [pc, #236]	; (1c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1b34:	f005 ff0a 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1b38:	2300      	movs	r3, #0
    1b3a:	220a      	movs	r2, #10
    1b3c:	4621      	mov	r1, r4
    1b3e:	4830      	ldr	r0, [pc, #192]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b40:	f003 fea0 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b44:	2111      	movs	r1, #17
    1b46:	483d      	ldr	r0, [pc, #244]	; (1c3c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    1b48:	f005 ff00 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b4c:	482c      	ldr	r0, [pc, #176]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b4e:	f003 fe6f 	bl	5830 <Print::println()>
    1b52:	e7e1      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1b54:	2104      	movs	r1, #4
    1b56:	4832      	ldr	r0, [pc, #200]	; (1c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1b58:	f005 fef8 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1b5c:	2300      	movs	r3, #0
    1b5e:	220a      	movs	r2, #10
    1b60:	4621      	mov	r1, r4
    1b62:	4827      	ldr	r0, [pc, #156]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b64:	f003 fe8e 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b68:	2111      	movs	r1, #17
    1b6a:	4835      	ldr	r0, [pc, #212]	; (1c40 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    1b6c:	f005 feee 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b70:	4823      	ldr	r0, [pc, #140]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b72:	f003 fe5d 	bl	5830 <Print::println()>
    1b76:	e7cf      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1b78:	2104      	movs	r1, #4
    1b7a:	4829      	ldr	r0, [pc, #164]	; (1c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1b7c:	f005 fee6 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1b80:	220a      	movs	r2, #10
    1b82:	2300      	movs	r3, #0
    1b84:	4621      	mov	r1, r4
    1b86:	481e      	ldr	r0, [pc, #120]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b88:	f003 fe7c 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b8c:	210f      	movs	r1, #15
    1b8e:	482d      	ldr	r0, [pc, #180]	; (1c44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    1b90:	f005 fedc 	bl	794c <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1b94:	f8d8 3000 	ldr.w	r3, [r8]
    1b98:	2111      	movs	r1, #17
    1b9a:	029b      	lsls	r3, r3, #10
    1b9c:	bf4c      	ite	mi
    1b9e:	482a      	ldrmi	r0, [pc, #168]	; (1c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    1ba0:	482a      	ldrpl	r0, [pc, #168]	; (1c4c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    1ba2:	f005 fed3 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1ba6:	4816      	ldr	r0, [pc, #88]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ba8:	f003 fe42 	bl	5830 <Print::println()>
    1bac:	e7b4      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1bae:	2104      	movs	r1, #4
    1bb0:	481b      	ldr	r0, [pc, #108]	; (1c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1bb2:	f005 fecb 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1bb6:	2300      	movs	r3, #0
    1bb8:	220a      	movs	r2, #10
    1bba:	4621      	mov	r1, r4
    1bbc:	4810      	ldr	r0, [pc, #64]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bbe:	f003 fe61 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bc2:	210e      	movs	r1, #14
    1bc4:	4822      	ldr	r0, [pc, #136]	; (1c50 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    1bc6:	f005 fec1 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bca:	480d      	ldr	r0, [pc, #52]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bcc:	f003 fe30 	bl	5830 <Print::println()>
    1bd0:	e7a2      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1bd2:	2104      	movs	r1, #4
    1bd4:	4812      	ldr	r0, [pc, #72]	; (1c20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1bd6:	f005 feb9 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1bda:	2300      	movs	r3, #0
    1bdc:	220a      	movs	r2, #10
    1bde:	4621      	mov	r1, r4
    1be0:	4807      	ldr	r0, [pc, #28]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1be2:	f003 fe4f 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1be6:	210e      	movs	r1, #14
    1be8:	481a      	ldr	r0, [pc, #104]	; (1c54 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    1bea:	f005 feaf 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bee:	4804      	ldr	r0, [pc, #16]	; (1c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bf0:	f003 fe1e 	bl	5830 <Print::println()>
    1bf4:	e790      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1bf6:	bf00      	nop
    1bf8:	200006a4 	.word	0x200006a4
    1bfc:	200006cc 	.word	0x200006cc
    1c00:	20001110 	.word	0x20001110
    1c04:	200006e0 	.word	0x200006e0
    1c08:	401d4000 	.word	0x401d4000
    1c0c:	200006f8 	.word	0x200006f8
    1c10:	0401d408 	.word	0x0401d408
    1c14:	401d408c 	.word	0x401d408c
    1c18:	bfe2bf80 	.word	0xbfe2bf80
    1c1c:	20000804 	.word	0x20000804
    1c20:	20000710 	.word	0x20000710
    1c24:	200007d0 	.word	0x200007d0
    1c28:	200007f0 	.word	0x200007f0
    1c2c:	20000818 	.word	0x20000818
    1c30:	2000074c 	.word	0x2000074c
    1c34:	20000820 	.word	0x20000820
    1c38:	200006b4 	.word	0x200006b4
    1c3c:	2000082c 	.word	0x2000082c
    1c40:	20000788 	.word	0x20000788
    1c44:	2000072c 	.word	0x2000072c
    1c48:	2000073c 	.word	0x2000073c
    1c4c:	20000750 	.word	0x20000750
    1c50:	20000764 	.word	0x20000764
    1c54:	2000079c 	.word	0x2000079c
    1c58:	2104      	movs	r1, #4
    1c5a:	482e      	ldr	r0, [pc, #184]	; (1d14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1c5c:	f005 fe76 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c60:	2300      	movs	r3, #0
    1c62:	220a      	movs	r2, #10
    1c64:	4621      	mov	r1, r4
    1c66:	482c      	ldr	r0, [pc, #176]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1c68:	f003 fe0c 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c6c:	2112      	movs	r1, #18
    1c6e:	482b      	ldr	r0, [pc, #172]	; (1d1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    1c70:	f005 fe6c 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c74:	4828      	ldr	r0, [pc, #160]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1c76:	f003 fddb 	bl	5830 <Print::println()>
    1c7a:	e74d      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1c7c:	2104      	movs	r1, #4
    1c7e:	4825      	ldr	r0, [pc, #148]	; (1d14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1c80:	f005 fe64 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c84:	2300      	movs	r3, #0
    1c86:	220a      	movs	r2, #10
    1c88:	4621      	mov	r1, r4
    1c8a:	4823      	ldr	r0, [pc, #140]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1c8c:	f003 fdfa 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c90:	2112      	movs	r1, #18
    1c92:	4823      	ldr	r0, [pc, #140]	; (1d20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    1c94:	f005 fe5a 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c98:	481f      	ldr	r0, [pc, #124]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1c9a:	f003 fdc9 	bl	5830 <Print::println()>
    1c9e:	e73b      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1ca0:	2104      	movs	r1, #4
    1ca2:	481c      	ldr	r0, [pc, #112]	; (1d14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1ca4:	f005 fe52 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ca8:	2300      	movs	r3, #0
    1caa:	220a      	movs	r2, #10
    1cac:	4621      	mov	r1, r4
    1cae:	481a      	ldr	r0, [pc, #104]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cb0:	f003 fde8 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cb4:	2111      	movs	r1, #17
    1cb6:	481b      	ldr	r0, [pc, #108]	; (1d24 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    1cb8:	f005 fe48 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1cbc:	4816      	ldr	r0, [pc, #88]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cbe:	f003 fdb7 	bl	5830 <Print::println()>
    1cc2:	e729      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1cc4:	2104      	movs	r1, #4
    1cc6:	4813      	ldr	r0, [pc, #76]	; (1d14 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1cc8:	f005 fe40 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ccc:	2300      	movs	r3, #0
    1cce:	220a      	movs	r2, #10
    1cd0:	4621      	mov	r1, r4
    1cd2:	4811      	ldr	r0, [pc, #68]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cd4:	f003 fdd6 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cd8:	210f      	movs	r1, #15
    1cda:	4813      	ldr	r0, [pc, #76]	; (1d28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    1cdc:	f005 fe36 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1ce0:	480d      	ldr	r0, [pc, #52]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1ce2:	f003 fda5 	bl	5830 <Print::println()>
    1ce6:	e717      	b.n	1b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1ce8:	2111      	movs	r1, #17
    1cea:	4810      	ldr	r0, [pc, #64]	; (1d2c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    1cec:	f005 fe2e 	bl	794c <usb_serial_write>
    1cf0:	4809      	ldr	r0, [pc, #36]	; (1d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cf2:	f003 fd9d 	bl	5830 <Print::println()>
    1cf6:	e604      	b.n	1902 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    1cf8:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1cfa:	462c      	mov	r4, r5
    1cfc:	e61d      	b.n	193a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    1cfe:	480c      	ldr	r0, [pc, #48]	; (1d30 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    1d00:	f005 fe24 	bl	794c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1d04:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1d08:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1d0c:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1d0e:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    1d12:	e692      	b.n	1a3a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    1d14:	20000710 	.word	0x20000710
    1d18:	20001110 	.word	0x20001110
    1d1c:	20000718 	.word	0x20000718
    1d20:	200007ac 	.word	0x200007ac
    1d24:	20000774 	.word	0x20000774
    1d28:	200007c0 	.word	0x200007c0
    1d2c:	200006b8 	.word	0x200006b8
    1d30:	20000804 	.word	0x20000804

00001d34 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    1d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    1d38:	4db7      	ldr	r5, [pc, #732]	; (2018 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1d3a:	682b      	ldr	r3, [r5, #0]
    1d3c:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    1d40:	f040 819a 	bne.w	2078 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    1d44:	211a      	movs	r1, #26
    1d46:	48b5      	ldr	r0, [pc, #724]	; (201c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    1d48:	f005 fe00 	bl	794c <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1d4c:	464c      	mov	r4, r9
    1d4e:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1d50:	4fb3      	ldr	r7, [pc, #716]	; (2020 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1d52:	4db4      	ldr	r5, [pc, #720]	; (2024 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1d54:	4eb4      	ldr	r6, [pc, #720]	; (2028 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1d56:	eb04 0805 	add.w	r8, r4, r5
    1d5a:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1d5e:	f8d8 3000 	ldr.w	r3, [r8]
    1d62:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1d66:	2b0e      	cmp	r3, #14
    1d68:	f200 809e 	bhi.w	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1d6c:	e8df f013 	tbh	[pc, r3, lsl #1]
    1d70:	01300142 	.word	0x01300142
    1d74:	009c011e 	.word	0x009c011e
    1d78:	009c0103 	.word	0x009c0103
    1d7c:	009c00f1 	.word	0x009c00f1
    1d80:	00cd00df 	.word	0x00cd00df
    1d84:	009c00bb 	.word	0x009c00bb
    1d88:	009c000f 	.word	0x009c000f
    1d8c:	00a9      	.short	0x00a9
    1d8e:	2104      	movs	r1, #4
    1d90:	48a6      	ldr	r0, [pc, #664]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1d92:	f005 fddb 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d96:	2300      	movs	r3, #0
    1d98:	4649      	mov	r1, r9
    1d9a:	220a      	movs	r2, #10
    1d9c:	48a4      	ldr	r0, [pc, #656]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1d9e:	f003 fd71 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1da2:	211d      	movs	r1, #29
    1da4:	48a3      	ldr	r0, [pc, #652]	; (2034 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    1da6:	f005 fdd1 	bl	794c <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1daa:	f8d8 3000 	ldr.w	r3, [r8]
    1dae:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1db0:	029b      	lsls	r3, r3, #10
    1db2:	f140 81e3 	bpl.w	217c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    1db6:	48a0      	ldr	r0, [pc, #640]	; (2038 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    1db8:	f005 fdc8 	bl	794c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1dbc:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1dc0:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1dc4:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1dc6:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1dca:	2107      	movs	r1, #7
    1dcc:	489b      	ldr	r0, [pc, #620]	; (203c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    1dce:	f005 fdbd 	bl	794c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1dd2:	2300      	movs	r3, #0
    1dd4:	2210      	movs	r2, #16
    1dd6:	4651      	mov	r1, sl
    1dd8:	4895      	ldr	r0, [pc, #596]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1dda:	f003 fd53 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1dde:	2101      	movs	r1, #1
    1de0:	4897      	ldr	r0, [pc, #604]	; (2040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1de2:	f005 fdb3 	bl	794c <usb_serial_write>
    1de6:	210a      	movs	r1, #10
    1de8:	4896      	ldr	r0, [pc, #600]	; (2044 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    1dea:	f005 fdaf 	bl	794c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1dee:	2300      	movs	r3, #0
    1df0:	2210      	movs	r2, #16
    1df2:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1df6:	488e      	ldr	r0, [pc, #568]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1df8:	f003 fd44 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1dfc:	2101      	movs	r1, #1
    1dfe:	4892      	ldr	r0, [pc, #584]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e00:	f005 fda4 	bl	794c <usb_serial_write>
    1e04:	2300      	movs	r3, #0
    1e06:	2210      	movs	r2, #16
    1e08:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1e0c:	4888      	ldr	r0, [pc, #544]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e0e:	f003 fd39 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e12:	2101      	movs	r1, #1
    1e14:	488c      	ldr	r0, [pc, #560]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e16:	f005 fd99 	bl	794c <usb_serial_write>
    1e1a:	2300      	movs	r3, #0
    1e1c:	2210      	movs	r2, #16
    1e1e:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1e22:	4883      	ldr	r0, [pc, #524]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e24:	f003 fd2e 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e28:	2101      	movs	r1, #1
    1e2a:	4887      	ldr	r0, [pc, #540]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e2c:	f005 fd8e 	bl	794c <usb_serial_write>
    1e30:	2300      	movs	r3, #0
    1e32:	2210      	movs	r2, #16
    1e34:	fa5f f189 	uxtb.w	r1, r9
    1e38:	487d      	ldr	r0, [pc, #500]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e3a:	f003 fd23 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1e3e:	f858 8007 	ldr.w	r8, [r8, r7]
    1e42:	2101      	movs	r1, #1
    1e44:	4880      	ldr	r0, [pc, #512]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e46:	f005 fd81 	bl	794c <usb_serial_write>
    1e4a:	2300      	movs	r3, #0
    1e4c:	2210      	movs	r2, #16
    1e4e:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1e52:	4877      	ldr	r0, [pc, #476]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e54:	f003 fd16 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e58:	2101      	movs	r1, #1
    1e5a:	487b      	ldr	r0, [pc, #492]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e5c:	f005 fd76 	bl	794c <usb_serial_write>
    1e60:	2300      	movs	r3, #0
    1e62:	2210      	movs	r2, #16
    1e64:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1e68:	4871      	ldr	r0, [pc, #452]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e6a:	f003 fd0b 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e6e:	2101      	movs	r1, #1
    1e70:	4875      	ldr	r0, [pc, #468]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e72:	f005 fd6b 	bl	794c <usb_serial_write>
    1e76:	2300      	movs	r3, #0
    1e78:	2210      	movs	r2, #16
    1e7a:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1e7e:	486c      	ldr	r0, [pc, #432]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e80:	f003 fd00 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e84:	2101      	movs	r1, #1
    1e86:	4870      	ldr	r0, [pc, #448]	; (2048 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e88:	f005 fd60 	bl	794c <usb_serial_write>
    1e8c:	2300      	movs	r3, #0
    1e8e:	fa5f f188 	uxtb.w	r1, r8
    1e92:	2210      	movs	r2, #16
    1e94:	4866      	ldr	r0, [pc, #408]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e96:	f003 fcf5 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e9a:	2101      	movs	r1, #1
    1e9c:	4868      	ldr	r0, [pc, #416]	; (2040 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1e9e:	f005 fd55 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1ea2:	4863      	ldr	r0, [pc, #396]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ea4:	f003 fcc4 	bl	5830 <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1ea8:	4b5b      	ldr	r3, [pc, #364]	; (2018 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1eaa:	3401      	adds	r4, #1
    1eac:	681b      	ldr	r3, [r3, #0]
    1eae:	b2e4      	uxtb	r4, r4
    1eb0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1eb4:	46a1      	mov	r9, r4
    1eb6:	3301      	adds	r3, #1
    1eb8:	429c      	cmp	r4, r3
    1eba:	f4ff af4c 	bcc.w	1d56 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    1ebe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1ec2:	2104      	movs	r1, #4
    1ec4:	4859      	ldr	r0, [pc, #356]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1ec6:	f005 fd41 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1eca:	4649      	mov	r1, r9
    1ecc:	2300      	movs	r3, #0
    1ece:	220a      	movs	r2, #10
    1ed0:	4857      	ldr	r0, [pc, #348]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ed2:	f003 fcd7 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ed6:	2111      	movs	r1, #17
    1ed8:	485c      	ldr	r0, [pc, #368]	; (204c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    1eda:	f005 fd37 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1ede:	4854      	ldr	r0, [pc, #336]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ee0:	f003 fca6 	bl	5830 <Print::println()>
    1ee4:	e7e0      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1ee6:	2104      	movs	r1, #4
    1ee8:	4850      	ldr	r0, [pc, #320]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1eea:	f005 fd2f 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1eee:	4649      	mov	r1, r9
    1ef0:	2300      	movs	r3, #0
    1ef2:	220a      	movs	r2, #10
    1ef4:	484e      	ldr	r0, [pc, #312]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ef6:	f003 fcc5 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1efa:	2111      	movs	r1, #17
    1efc:	4854      	ldr	r0, [pc, #336]	; (2050 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    1efe:	f005 fd25 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f02:	484b      	ldr	r0, [pc, #300]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f04:	f003 fc94 	bl	5830 <Print::println()>
    1f08:	e7ce      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f0a:	2104      	movs	r1, #4
    1f0c:	4847      	ldr	r0, [pc, #284]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f0e:	f005 fd1d 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f12:	4649      	mov	r1, r9
    1f14:	2300      	movs	r3, #0
    1f16:	220a      	movs	r2, #10
    1f18:	4845      	ldr	r0, [pc, #276]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f1a:	f003 fcb3 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f1e:	210f      	movs	r1, #15
    1f20:	484c      	ldr	r0, [pc, #304]	; (2054 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    1f22:	f005 fd13 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f26:	4842      	ldr	r0, [pc, #264]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f28:	f003 fc82 	bl	5830 <Print::println()>
    1f2c:	e7bc      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f2e:	2104      	movs	r1, #4
    1f30:	483e      	ldr	r0, [pc, #248]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f32:	f005 fd0b 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f36:	4649      	mov	r1, r9
    1f38:	2300      	movs	r3, #0
    1f3a:	220a      	movs	r2, #10
    1f3c:	483c      	ldr	r0, [pc, #240]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f3e:	f003 fca1 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f42:	2112      	movs	r1, #18
    1f44:	4844      	ldr	r0, [pc, #272]	; (2058 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    1f46:	f005 fd01 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f4a:	4839      	ldr	r0, [pc, #228]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f4c:	f003 fc70 	bl	5830 <Print::println()>
    1f50:	e7aa      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f52:	2104      	movs	r1, #4
    1f54:	4835      	ldr	r0, [pc, #212]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f56:	f005 fcf9 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f5a:	4649      	mov	r1, r9
    1f5c:	2300      	movs	r3, #0
    1f5e:	220a      	movs	r2, #10
    1f60:	4833      	ldr	r0, [pc, #204]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f62:	f003 fc8f 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f66:	2111      	movs	r1, #17
    1f68:	483c      	ldr	r0, [pc, #240]	; (205c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    1f6a:	f005 fcef 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f6e:	4830      	ldr	r0, [pc, #192]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f70:	f003 fc5e 	bl	5830 <Print::println()>
    1f74:	e798      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f76:	2104      	movs	r1, #4
    1f78:	482c      	ldr	r0, [pc, #176]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f7a:	f005 fce7 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f7e:	220a      	movs	r2, #10
    1f80:	4649      	mov	r1, r9
    1f82:	2300      	movs	r3, #0
    1f84:	482a      	ldr	r0, [pc, #168]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f86:	f003 fc7d 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f8a:	210f      	movs	r1, #15
    1f8c:	4834      	ldr	r0, [pc, #208]	; (2060 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    1f8e:	f005 fcdd 	bl	794c <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1f92:	f8d8 3000 	ldr.w	r3, [r8]
    1f96:	2111      	movs	r1, #17
    1f98:	029a      	lsls	r2, r3, #10
    1f9a:	bf4c      	ite	mi
    1f9c:	4831      	ldrmi	r0, [pc, #196]	; (2064 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    1f9e:	4832      	ldrpl	r0, [pc, #200]	; (2068 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    1fa0:	f005 fcd4 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fa4:	4822      	ldr	r0, [pc, #136]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fa6:	f003 fc43 	bl	5830 <Print::println()>
    1faa:	e77d      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1fac:	2104      	movs	r1, #4
    1fae:	481f      	ldr	r0, [pc, #124]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1fb0:	f005 fccc 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1fb4:	4649      	mov	r1, r9
    1fb6:	2300      	movs	r3, #0
    1fb8:	220a      	movs	r2, #10
    1fba:	481d      	ldr	r0, [pc, #116]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fbc:	f003 fc62 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fc0:	210e      	movs	r1, #14
    1fc2:	482a      	ldr	r0, [pc, #168]	; (206c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    1fc4:	f005 fcc2 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fc8:	4819      	ldr	r0, [pc, #100]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fca:	f003 fc31 	bl	5830 <Print::println()>
    1fce:	e76b      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1fd0:	2104      	movs	r1, #4
    1fd2:	4816      	ldr	r0, [pc, #88]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1fd4:	f005 fcba 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1fd8:	4649      	mov	r1, r9
    1fda:	2300      	movs	r3, #0
    1fdc:	220a      	movs	r2, #10
    1fde:	4814      	ldr	r0, [pc, #80]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fe0:	f003 fc50 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fe4:	210e      	movs	r1, #14
    1fe6:	4822      	ldr	r0, [pc, #136]	; (2070 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    1fe8:	f005 fcb0 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fec:	4810      	ldr	r0, [pc, #64]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fee:	f003 fc1f 	bl	5830 <Print::println()>
    1ff2:	e759      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1ff4:	2104      	movs	r1, #4
    1ff6:	480d      	ldr	r0, [pc, #52]	; (202c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1ff8:	f005 fca8 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ffc:	4649      	mov	r1, r9
    1ffe:	2300      	movs	r3, #0
    2000:	220a      	movs	r2, #10
    2002:	480b      	ldr	r0, [pc, #44]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    2004:	f003 fc3e 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2008:	2112      	movs	r1, #18
    200a:	481a      	ldr	r0, [pc, #104]	; (2074 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    200c:	f005 fc9e 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2010:	4807      	ldr	r0, [pc, #28]	; (2030 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    2012:	f003 fc0d 	bl	5830 <Print::println()>
    2016:	e747      	b.n	1ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    2018:	401d0000 	.word	0x401d0000
    201c:	20000840 	.word	0x20000840
    2020:	401d008c 	.word	0x401d008c
    2024:	0401d008 	.word	0x0401d008
    2028:	bfe2ff80 	.word	0xbfe2ff80
    202c:	20000710 	.word	0x20000710
    2030:	20001110 	.word	0x20001110
    2034:	200007d0 	.word	0x200007d0
    2038:	200007f0 	.word	0x200007f0
    203c:	20000818 	.word	0x20000818
    2040:	2000074c 	.word	0x2000074c
    2044:	20000820 	.word	0x20000820
    2048:	200006b4 	.word	0x200006b4
    204c:	2000082c 	.word	0x2000082c
    2050:	20000788 	.word	0x20000788
    2054:	200007c0 	.word	0x200007c0
    2058:	200007ac 	.word	0x200007ac
    205c:	20000774 	.word	0x20000774
    2060:	2000072c 	.word	0x2000072c
    2064:	2000073c 	.word	0x2000073c
    2068:	20000750 	.word	0x20000750
    206c:	20000764 	.word	0x20000764
    2070:	2000079c 	.word	0x2000079c
    2074:	20000718 	.word	0x20000718
    2078:	2111      	movs	r1, #17
    207a:	48c4      	ldr	r0, [pc, #784]	; (238c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    207c:	f005 fc66 	bl	794c <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    2080:	6aab      	ldr	r3, [r5, #40]	; 0x28
    2082:	069a      	lsls	r2, r3, #26
    2084:	f100 81fa 	bmi.w	247c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    2088:	2112      	movs	r1, #18
    208a:	48c1      	ldr	r0, [pc, #772]	; (2390 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    208c:	f005 fc5e 	bl	794c <usb_serial_write>
    2090:	48c0      	ldr	r0, [pc, #768]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2092:	f003 fbcd 	bl	5830 <Print::println()>
    2096:	2116      	movs	r1, #22
    2098:	48bf      	ldr	r0, [pc, #764]	; (2398 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    209a:	f005 fc57 	bl	794c <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    209e:	4abf      	ldr	r2, [pc, #764]	; (239c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    20a0:	6814      	ldr	r4, [r2, #0]
    20a2:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    20a4:	6813      	ldr	r3, [r2, #0]
    20a6:	6b52      	ldr	r2, [r2, #52]	; 0x34
    20a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    20ac:	f3c2 6203 	ubfx	r2, r2, #24, #4
    20b0:	3301      	adds	r3, #1
    20b2:	3204      	adds	r2, #4
    20b4:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    20b8:	f0c0 81e8 	bcc.w	248c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    20bc:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    20c0:	f3c1 6103 	ubfx	r1, r1, #24, #4
    20c4:	3c05      	subs	r4, #5
    20c6:	3101      	adds	r1, #1
    20c8:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    20cc:	b2e5      	uxtb	r5, r4
    20ce:	4eb3      	ldr	r6, [pc, #716]	; (239c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    20d0:	48b0      	ldr	r0, [pc, #704]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20d2:	6831      	ldr	r1, [r6, #0]
    20d4:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    20d8:	3101      	adds	r1, #1
    20da:	1b49      	subs	r1, r1, r5
    20dc:	b2c9      	uxtb	r1, r1
    20de:	2920      	cmp	r1, #32
    20e0:	bfa8      	it	ge
    20e2:	2120      	movge	r1, #32
    20e4:	f003 fb98 	bl	5818 <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    20e8:	48aa      	ldr	r0, [pc, #680]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20ea:	f003 fba1 	bl	5830 <Print::println()>
    20ee:	2116      	movs	r1, #22
    20f0:	48ab      	ldr	r0, [pc, #684]	; (23a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    20f2:	f005 fc2b 	bl	794c <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    20f6:	6833      	ldr	r3, [r6, #0]
    20f8:	6b72      	ldr	r2, [r6, #52]	; 0x34
    20fa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    20fe:	f3c2 6203 	ubfx	r2, r2, #24, #4
    2102:	3301      	adds	r3, #1
    2104:	3204      	adds	r2, #4
    2106:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    210a:	d201      	bcs.n	2110 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    210c:	2500      	movs	r5, #0
    210e:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    2110:	2300      	movs	r3, #0
    2112:	4621      	mov	r1, r4
    2114:	220a      	movs	r2, #10
    2116:	489f      	ldr	r0, [pc, #636]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2118:	f003 fbb4 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(unsigned long n)			{ return print(n) + println(); }
    211c:	489d      	ldr	r0, [pc, #628]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    211e:	f003 fb87 	bl	5830 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    2122:	4b9e      	ldr	r3, [pc, #632]	; (239c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    2124:	681c      	ldr	r4, [r3, #0]
    2126:	681b      	ldr	r3, [r3, #0]
    2128:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    212c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2130:	3401      	adds	r4, #1
    2132:	3301      	adds	r3, #1
    2134:	1b64      	subs	r4, r4, r5
    2136:	b2e4      	uxtb	r4, r4
    2138:	42a3      	cmp	r3, r4
    213a:	f67f aec0 	bls.w	1ebe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    213e:	4d99      	ldr	r5, [pc, #612]	; (23a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    2140:	4e99      	ldr	r6, [pc, #612]	; (23a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2142:	4f9a      	ldr	r7, [pc, #616]	; (23ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    2144:	eb04 0805 	add.w	r8, r4, r5
    2148:	ea4f 1808 	mov.w	r8, r8, lsl #4
    214c:	f8d8 3000 	ldr.w	r3, [r8]
    2150:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2154:	2b0e      	cmp	r3, #14
    2156:	f200 80a9 	bhi.w	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    215a:	e8df f013 	tbh	[pc, r3, lsl #1]
    215e:	0147      	.short	0x0147
    2160:	00f20104 	.word	0x00f20104
    2164:	00d700a7 	.word	0x00d700a7
    2168:	016b00a7 	.word	0x016b00a7
    216c:	015900a7 	.word	0x015900a7
    2170:	00c5017d 	.word	0x00c5017d
    2174:	001a00a7 	.word	0x001a00a7
    2178:	00b300a7 	.word	0x00b300a7
    217c:	488c      	ldr	r0, [pc, #560]	; (23b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    217e:	f005 fbe5 	bl	794c <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2182:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    2186:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    218a:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    218c:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    2190:	e61b      	b.n	1dca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    2192:	2104      	movs	r1, #4
    2194:	4887      	ldr	r0, [pc, #540]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    2196:	f005 fbd9 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    219a:	2300      	movs	r3, #0
    219c:	220a      	movs	r2, #10
    219e:	4621      	mov	r1, r4
    21a0:	487c      	ldr	r0, [pc, #496]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    21a2:	f003 fb6f 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    21a6:	211d      	movs	r1, #29
    21a8:	4883      	ldr	r0, [pc, #524]	; (23b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    21aa:	f005 fbcf 	bl	794c <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    21ae:	f8d8 3000 	ldr.w	r3, [r8]
    21b2:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    21b4:	0298      	lsls	r0, r3, #10
    21b6:	f140 816c 	bpl.w	2492 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    21ba:	4880      	ldr	r0, [pc, #512]	; (23bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    21bc:	f005 fbc6 	bl	794c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    21c0:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    21c4:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    21c8:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    21ca:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    21ce:	2107      	movs	r1, #7
    21d0:	487b      	ldr	r0, [pc, #492]	; (23c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    21d2:	f005 fbbb 	bl	794c <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    21d6:	2300      	movs	r3, #0
    21d8:	2210      	movs	r2, #16
    21da:	4651      	mov	r1, sl
    21dc:	486d      	ldr	r0, [pc, #436]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    21de:	f003 fb51 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    21e2:	2101      	movs	r1, #1
    21e4:	4877      	ldr	r0, [pc, #476]	; (23c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    21e6:	f005 fbb1 	bl	794c <usb_serial_write>
    21ea:	210a      	movs	r1, #10
    21ec:	4876      	ldr	r0, [pc, #472]	; (23c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    21ee:	f005 fbad 	bl	794c <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    21f2:	2300      	movs	r3, #0
    21f4:	2210      	movs	r2, #16
    21f6:	ea4f 6119 	mov.w	r1, r9, lsr #24
    21fa:	4866      	ldr	r0, [pc, #408]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    21fc:	f003 fb42 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2200:	2101      	movs	r1, #1
    2202:	4872      	ldr	r0, [pc, #456]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2204:	f005 fba2 	bl	794c <usb_serial_write>
    2208:	2300      	movs	r3, #0
    220a:	2210      	movs	r2, #16
    220c:	f3c9 4107 	ubfx	r1, r9, #16, #8
    2210:	4860      	ldr	r0, [pc, #384]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2212:	f003 fb37 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2216:	2101      	movs	r1, #1
    2218:	486c      	ldr	r0, [pc, #432]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    221a:	f005 fb97 	bl	794c <usb_serial_write>
    221e:	2300      	movs	r3, #0
    2220:	2210      	movs	r2, #16
    2222:	f3c9 2107 	ubfx	r1, r9, #8, #8
    2226:	485b      	ldr	r0, [pc, #364]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2228:	f003 fb2c 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    222c:	2101      	movs	r1, #1
    222e:	4867      	ldr	r0, [pc, #412]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2230:	f005 fb8c 	bl	794c <usb_serial_write>
    2234:	2300      	movs	r3, #0
    2236:	2210      	movs	r2, #16
    2238:	fa5f f189 	uxtb.w	r1, r9
    223c:	4855      	ldr	r0, [pc, #340]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    223e:	f003 fb21 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    2242:	f858 8006 	ldr.w	r8, [r8, r6]
    2246:	2101      	movs	r1, #1
    2248:	4860      	ldr	r0, [pc, #384]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    224a:	f005 fb7f 	bl	794c <usb_serial_write>
    224e:	2300      	movs	r3, #0
    2250:	2210      	movs	r2, #16
    2252:	ea4f 6118 	mov.w	r1, r8, lsr #24
    2256:	484f      	ldr	r0, [pc, #316]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2258:	f003 fb14 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    225c:	2101      	movs	r1, #1
    225e:	485b      	ldr	r0, [pc, #364]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2260:	f005 fb74 	bl	794c <usb_serial_write>
    2264:	2300      	movs	r3, #0
    2266:	2210      	movs	r2, #16
    2268:	f3c8 4107 	ubfx	r1, r8, #16, #8
    226c:	4849      	ldr	r0, [pc, #292]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    226e:	f003 fb09 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2272:	2101      	movs	r1, #1
    2274:	4855      	ldr	r0, [pc, #340]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2276:	f005 fb69 	bl	794c <usb_serial_write>
    227a:	2300      	movs	r3, #0
    227c:	2210      	movs	r2, #16
    227e:	f3c8 2107 	ubfx	r1, r8, #8, #8
    2282:	4844      	ldr	r0, [pc, #272]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2284:	f003 fafe 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2288:	2101      	movs	r1, #1
    228a:	4850      	ldr	r0, [pc, #320]	; (23cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    228c:	f005 fb5e 	bl	794c <usb_serial_write>
    2290:	2300      	movs	r3, #0
    2292:	fa5f f188 	uxtb.w	r1, r8
    2296:	2210      	movs	r2, #16
    2298:	483e      	ldr	r0, [pc, #248]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    229a:	f003 faf3 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    229e:	2101      	movs	r1, #1
    22a0:	4848      	ldr	r0, [pc, #288]	; (23c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    22a2:	f005 fb53 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    22a6:	483b      	ldr	r0, [pc, #236]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22a8:	f003 fac2 	bl	5830 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    22ac:	4b3b      	ldr	r3, [pc, #236]	; (239c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    22ae:	3401      	adds	r4, #1
    22b0:	681b      	ldr	r3, [r3, #0]
    22b2:	b2e4      	uxtb	r4, r4
    22b4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    22b8:	3301      	adds	r3, #1
    22ba:	429c      	cmp	r4, r3
    22bc:	f4ff af42 	bcc.w	2144 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    22c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    22c4:	2104      	movs	r1, #4
    22c6:	483b      	ldr	r0, [pc, #236]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    22c8:	f005 fb40 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    22cc:	2300      	movs	r3, #0
    22ce:	220a      	movs	r2, #10
    22d0:	4621      	mov	r1, r4
    22d2:	4830      	ldr	r0, [pc, #192]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22d4:	f003 fad6 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    22d8:	2111      	movs	r1, #17
    22da:	483d      	ldr	r0, [pc, #244]	; (23d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    22dc:	f005 fb36 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    22e0:	482c      	ldr	r0, [pc, #176]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22e2:	f003 faa5 	bl	5830 <Print::println()>
    22e6:	e7e1      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    22e8:	2104      	movs	r1, #4
    22ea:	4832      	ldr	r0, [pc, #200]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    22ec:	f005 fb2e 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    22f0:	2300      	movs	r3, #0
    22f2:	220a      	movs	r2, #10
    22f4:	4621      	mov	r1, r4
    22f6:	4827      	ldr	r0, [pc, #156]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22f8:	f003 fac4 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    22fc:	2111      	movs	r1, #17
    22fe:	4835      	ldr	r0, [pc, #212]	; (23d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    2300:	f005 fb24 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2304:	4823      	ldr	r0, [pc, #140]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2306:	f003 fa93 	bl	5830 <Print::println()>
    230a:	e7cf      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    230c:	2104      	movs	r1, #4
    230e:	4829      	ldr	r0, [pc, #164]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    2310:	f005 fb1c 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2314:	220a      	movs	r2, #10
    2316:	2300      	movs	r3, #0
    2318:	4621      	mov	r1, r4
    231a:	481e      	ldr	r0, [pc, #120]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    231c:	f003 fab2 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2320:	210f      	movs	r1, #15
    2322:	482d      	ldr	r0, [pc, #180]	; (23d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    2324:	f005 fb12 	bl	794c <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    2328:	f8d8 3000 	ldr.w	r3, [r8]
    232c:	2111      	movs	r1, #17
    232e:	029b      	lsls	r3, r3, #10
    2330:	bf4c      	ite	mi
    2332:	482a      	ldrmi	r0, [pc, #168]	; (23dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    2334:	482a      	ldrpl	r0, [pc, #168]	; (23e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    2336:	f005 fb09 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    233a:	4816      	ldr	r0, [pc, #88]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    233c:	f003 fa78 	bl	5830 <Print::println()>
    2340:	e7b4      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2342:	2104      	movs	r1, #4
    2344:	481b      	ldr	r0, [pc, #108]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    2346:	f005 fb01 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    234a:	2300      	movs	r3, #0
    234c:	220a      	movs	r2, #10
    234e:	4621      	mov	r1, r4
    2350:	4810      	ldr	r0, [pc, #64]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2352:	f003 fa97 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2356:	210e      	movs	r1, #14
    2358:	4822      	ldr	r0, [pc, #136]	; (23e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    235a:	f005 faf7 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    235e:	480d      	ldr	r0, [pc, #52]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2360:	f003 fa66 	bl	5830 <Print::println()>
    2364:	e7a2      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2366:	2104      	movs	r1, #4
    2368:	4812      	ldr	r0, [pc, #72]	; (23b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    236a:	f005 faef 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    236e:	2300      	movs	r3, #0
    2370:	220a      	movs	r2, #10
    2372:	4621      	mov	r1, r4
    2374:	4807      	ldr	r0, [pc, #28]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2376:	f003 fa85 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    237a:	210e      	movs	r1, #14
    237c:	481a      	ldr	r0, [pc, #104]	; (23e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    237e:	f005 fae5 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2382:	4804      	ldr	r0, [pc, #16]	; (2394 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2384:	f003 fa54 	bl	5830 <Print::println()>
    2388:	e790      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    238a:	bf00      	nop
    238c:	200006a4 	.word	0x200006a4
    2390:	200006cc 	.word	0x200006cc
    2394:	20001110 	.word	0x20001110
    2398:	200006e0 	.word	0x200006e0
    239c:	401d0000 	.word	0x401d0000
    23a0:	200006f8 	.word	0x200006f8
    23a4:	0401d008 	.word	0x0401d008
    23a8:	401d008c 	.word	0x401d008c
    23ac:	bfe2ff80 	.word	0xbfe2ff80
    23b0:	20000804 	.word	0x20000804
    23b4:	20000710 	.word	0x20000710
    23b8:	200007d0 	.word	0x200007d0
    23bc:	200007f0 	.word	0x200007f0
    23c0:	20000818 	.word	0x20000818
    23c4:	2000074c 	.word	0x2000074c
    23c8:	20000820 	.word	0x20000820
    23cc:	200006b4 	.word	0x200006b4
    23d0:	2000082c 	.word	0x2000082c
    23d4:	20000788 	.word	0x20000788
    23d8:	2000072c 	.word	0x2000072c
    23dc:	2000073c 	.word	0x2000073c
    23e0:	20000750 	.word	0x20000750
    23e4:	20000764 	.word	0x20000764
    23e8:	2000079c 	.word	0x2000079c
    23ec:	2104      	movs	r1, #4
    23ee:	482e      	ldr	r0, [pc, #184]	; (24a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    23f0:	f005 faac 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    23f4:	2300      	movs	r3, #0
    23f6:	220a      	movs	r2, #10
    23f8:	4621      	mov	r1, r4
    23fa:	482c      	ldr	r0, [pc, #176]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    23fc:	f003 fa42 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2400:	2112      	movs	r1, #18
    2402:	482b      	ldr	r0, [pc, #172]	; (24b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    2404:	f005 faa2 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2408:	4828      	ldr	r0, [pc, #160]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    240a:	f003 fa11 	bl	5830 <Print::println()>
    240e:	e74d      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2410:	2104      	movs	r1, #4
    2412:	4825      	ldr	r0, [pc, #148]	; (24a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    2414:	f005 fa9a 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2418:	2300      	movs	r3, #0
    241a:	220a      	movs	r2, #10
    241c:	4621      	mov	r1, r4
    241e:	4823      	ldr	r0, [pc, #140]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2420:	f003 fa30 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2424:	2112      	movs	r1, #18
    2426:	4823      	ldr	r0, [pc, #140]	; (24b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    2428:	f005 fa90 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    242c:	481f      	ldr	r0, [pc, #124]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    242e:	f003 f9ff 	bl	5830 <Print::println()>
    2432:	e73b      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2434:	2104      	movs	r1, #4
    2436:	481c      	ldr	r0, [pc, #112]	; (24a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    2438:	f005 fa88 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    243c:	2300      	movs	r3, #0
    243e:	220a      	movs	r2, #10
    2440:	4621      	mov	r1, r4
    2442:	481a      	ldr	r0, [pc, #104]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2444:	f003 fa1e 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2448:	2111      	movs	r1, #17
    244a:	481b      	ldr	r0, [pc, #108]	; (24b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    244c:	f005 fa7e 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2450:	4816      	ldr	r0, [pc, #88]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2452:	f003 f9ed 	bl	5830 <Print::println()>
    2456:	e729      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2458:	2104      	movs	r1, #4
    245a:	4813      	ldr	r0, [pc, #76]	; (24a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    245c:	f005 fa76 	bl	794c <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2460:	2300      	movs	r3, #0
    2462:	220a      	movs	r2, #10
    2464:	4621      	mov	r1, r4
    2466:	4811      	ldr	r0, [pc, #68]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2468:	f003 fa0c 	bl	5884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    246c:	210f      	movs	r1, #15
    246e:	4813      	ldr	r0, [pc, #76]	; (24bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    2470:	f005 fa6c 	bl	794c <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2474:	480d      	ldr	r0, [pc, #52]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2476:	f003 f9db 	bl	5830 <Print::println()>
    247a:	e717      	b.n	22ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    247c:	2111      	movs	r1, #17
    247e:	4810      	ldr	r0, [pc, #64]	; (24c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    2480:	f005 fa64 	bl	794c <usb_serial_write>
    2484:	4809      	ldr	r0, [pc, #36]	; (24ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2486:	f003 f9d3 	bl	5830 <Print::println()>
    248a:	e604      	b.n	2096 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    248c:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    248e:	462c      	mov	r4, r5
    2490:	e61d      	b.n	20ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    2492:	480c      	ldr	r0, [pc, #48]	; (24c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    2494:	f005 fa5a 	bl	794c <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2498:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    249c:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    24a0:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    24a2:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    24a6:	e692      	b.n	21ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    24a8:	20000710 	.word	0x20000710
    24ac:	20001110 	.word	0x20001110
    24b0:	20000718 	.word	0x20000718
    24b4:	200007ac 	.word	0x200007ac
    24b8:	20000774 	.word	0x20000774
    24bc:	200007c0 	.word	0x200007c0
    24c0:	200006b8 	.word	0x200006b8
    24c4:	20000804 	.word	0x20000804

000024c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    24c8:	b570      	push	{r4, r5, r6, lr}
    24ca:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    24cc:	bb39      	cbnz	r1, 251e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    24ce:	4a3b      	ldr	r2, [pc, #236]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    24d0:	6a13      	ldr	r3, [r2, #32]
    24d2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    24d6:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    24da:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    24dc:	4b38      	ldr	r3, [pc, #224]	; (25c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    24de:	6818      	ldr	r0, [r3, #0]
    24e0:	b158      	cbz	r0, 24fa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    24e2:	4a38      	ldr	r2, [pc, #224]	; (25c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    24e4:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    24e8:	6805      	ldr	r5, [r0, #0]
    24ea:	6852      	ldr	r2, [r2, #4]
    24ec:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    24f0:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    24f4:	686b      	ldr	r3, [r5, #4]
    24f6:	0052      	lsls	r2, r2, #1
    24f8:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    24fa:	4b33      	ldr	r3, [pc, #204]	; (25c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    24fc:	6818      	ldr	r0, [r3, #0]
    24fe:	2800      	cmp	r0, #0
    2500:	d05b      	beq.n	25ba <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    2502:	4a30      	ldr	r2, [pc, #192]	; (25c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2504:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2508:	6803      	ldr	r3, [r0, #0]
    250a:	6852      	ldr	r2, [r2, #4]
    250c:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    2510:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2514:	685b      	ldr	r3, [r3, #4]
    2516:	0052      	lsls	r2, r2, #1
}
    2518:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    251c:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    251e:	2908      	cmp	r1, #8
    2520:	d107      	bne.n	2532 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    2522:	4a26      	ldr	r2, [pc, #152]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2524:	6a13      	ldr	r3, [r2, #32]
    2526:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    252a:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    252e:	6213      	str	r3, [r2, #32]
    2530:	e7d4      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    2532:	2910      	cmp	r1, #16
    2534:	d107      	bne.n	2546 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    2536:	4a21      	ldr	r2, [pc, #132]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2538:	6a13      	ldr	r3, [r2, #32]
    253a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    253e:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    2542:	6213      	str	r3, [r2, #32]
    2544:	e7ca      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2546:	2918      	cmp	r1, #24
    2548:	d107      	bne.n	255a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    254a:	4a1c      	ldr	r2, [pc, #112]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    254c:	6a13      	ldr	r3, [r2, #32]
    254e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2552:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    2556:	6213      	str	r3, [r2, #32]
    2558:	e7c0      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    255a:	2914      	cmp	r1, #20
    255c:	d107      	bne.n	256e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    255e:	4a17      	ldr	r2, [pc, #92]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2560:	6a13      	ldr	r3, [r2, #32]
    2562:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2566:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    256a:	6213      	str	r3, [r2, #32]
    256c:	e7b6      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    256e:	291e      	cmp	r1, #30
    2570:	d107      	bne.n	2582 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    2572:	4a12      	ldr	r2, [pc, #72]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2574:	6a13      	ldr	r3, [r2, #32]
    2576:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    257a:	f043 0304 	orr.w	r3, r3, #4
    257e:	6213      	str	r3, [r2, #32]
    2580:	e7ac      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2582:	2928      	cmp	r1, #40	; 0x28
    2584:	d107      	bne.n	2596 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    2586:	4a0d      	ldr	r2, [pc, #52]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2588:	6a13      	ldr	r3, [r2, #32]
    258a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    258e:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    2592:	6213      	str	r3, [r2, #32]
    2594:	e7a2      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2596:	293c      	cmp	r1, #60	; 0x3c
    2598:	d105      	bne.n	25a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    259a:	4a08      	ldr	r2, [pc, #32]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    259c:	6a13      	ldr	r3, [r2, #32]
    259e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25a2:	6213      	str	r3, [r2, #32]
    25a4:	e79a      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    25a6:	2950      	cmp	r1, #80	; 0x50
    25a8:	d198      	bne.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    25aa:	4a04      	ldr	r2, [pc, #16]	; (25bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25ac:	6a13      	ldr	r3, [r2, #32]
    25ae:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25b2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    25b6:	6213      	str	r3, [r2, #32]
    25b8:	e790      	b.n	24dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    25ba:	bd70      	pop	{r4, r5, r6, pc}
    25bc:	400fc000 	.word	0x400fc000
    25c0:	20007320 	.word	0x20007320
    25c4:	401d0000 	.word	0x401d0000
    25c8:	20007324 	.word	0x20007324

000025cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    25cc:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    25ce:	494e      	ldr	r1, [pc, #312]	; (2708 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    25d0:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    25d2:	4b4e      	ldr	r3, [pc, #312]	; (270c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    25d4:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    25d6:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    25d8:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    25da:	6a1b      	ldr	r3, [r3, #32]
    25dc:	f3c3 2301 	ubfx	r3, r3, #8, #2
    25e0:	3308      	adds	r3, #8
    25e2:	446b      	add	r3, sp
    25e4:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    25e8:	e9c0 2201 	strd	r2, r2, [r0, #4]
    25ec:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    25f0:	2b00      	cmp	r3, #0
    25f2:	f000 8085 	beq.w	2700 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C000;
    25f6:	4945      	ldr	r1, [pc, #276]	; (270c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN1;
    25f8:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    25fc:	2024      	movs	r0, #36	; 0x24
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    25fe:	4b44      	ldr	r3, [pc, #272]	; (2710 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    2600:	4a44      	ldr	r2, [pc, #272]	; (2714 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 1;
    2602:	2401      	movs	r4, #1
    nvicIrq = IRQ_CAN1;
    2604:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    2608:	2602      	movs	r6, #2
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    260a:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    260e:	2012      	movs	r0, #18
    CCM_CCGR0 |= 0x3C000;
    2610:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    2612:	4b41      	ldr	r3, [pc, #260]	; (2718 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C000;
    2614:	f442 3270 	orr.w	r2, r2, #245760	; 0x3c000
    2618:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    261a:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 1;
    261e:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2622:	4a3e      	ldr	r2, [pc, #248]	; (271c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    2624:	4c3e      	ldr	r4, [pc, #248]	; (2720 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    2626:	f8c3 011c 	str.w	r0, [r3, #284]	; 0x11c
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    262a:	f8c3 130c 	str.w	r1, [r3, #780]	; 0x30c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    262e:	64e6      	str	r6, [r4, #76]	; 0x4c
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 0x12; // pin 23 T4B1+B2
    2630:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09 = 0x10B0; // pin 23 T4B1+B2
    2634:	f8c3 1310 	str.w	r1, [r3, #784]	; 0x310
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2638:	6813      	ldr	r3, [r2, #0]
    263a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    263e:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2640:	6813      	ldr	r3, [r2, #0]
    2642:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    2646:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2648:	6813      	ldr	r3, [r2, #0]
    264a:	01dc      	lsls	r4, r3, #7
    264c:	d5fc      	bpl.n	2648 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    264e:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2650:	4932      	ldr	r1, [pc, #200]	; (271c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2652:	f043 0308 	orr.w	r3, r3, #8
    2656:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    2658:	6813      	ldr	r3, [r2, #0]
    265a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    265e:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2660:	680b      	ldr	r3, [r1, #0]
    2662:	02d8      	lsls	r0, r3, #11
    2664:	d4fc      	bmi.n	2660 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    2666:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2668:	4a2c      	ldr	r2, [pc, #176]	; (271c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    266a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    266e:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2670:	6813      	ldr	r3, [r2, #0]
    2672:	0199      	lsls	r1, r3, #6
    2674:	d4fc      	bmi.n	2670 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2676:	4c29      	ldr	r4, [pc, #164]	; (271c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    2678:	6823      	ldr	r3, [r4, #0]
    267a:	01da      	lsls	r2, r3, #7
    267c:	d5fc      	bpl.n	2678 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    267e:	6823      	ldr	r3, [r4, #0]
    void disableFIFO() { enableFIFO(0); }
    2680:	2000      	movs	r0, #0
    2682:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    2686:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    2688:	6823      	ldr	r3, [r4, #0]
    268a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    268e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    2690:	6823      	ldr	r3, [r4, #0]
    2692:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    2696:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    2698:	6823      	ldr	r3, [r4, #0]
    269a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    269e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    26a0:	6823      	ldr	r3, [r4, #0]
    26a2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    26a6:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    26a8:	6823      	ldr	r3, [r4, #0]
    26aa:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    26ae:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    26b0:	6823      	ldr	r3, [r4, #0]
    26b2:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    26b6:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    26b8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    26ba:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    26be:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    26c0:	6823      	ldr	r3, [r4, #0]
    26c2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    26c6:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    26c8:	6823      	ldr	r3, [r4, #0]
    26ca:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    26ce:	6023      	str	r3, [r4, #0]
    26d0:	f7fe fdca 	bl	1268 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    26d4:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    26d6:	4a11      	ldr	r2, [pc, #68]	; (271c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    26d8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    26dc:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    26de:	6813      	ldr	r3, [r2, #0]
    26e0:	01db      	lsls	r3, r3, #7
    26e2:	d4fc      	bmi.n	26de <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    26e4:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    26e8:	2101      	movs	r1, #1
    26ea:	4b0e      	ldr	r3, [pc, #56]	; (2724 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    26ec:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    26f0:	f002 021f 	and.w	r2, r2, #31
    26f4:	009b      	lsls	r3, r3, #2
    26f6:	fa01 f202 	lsl.w	r2, r1, r2
    26fa:	601a      	str	r2, [r3, #0]
}
    26fc:	b002      	add	sp, #8
    26fe:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2700:	2118      	movs	r1, #24
    2702:	f7ff fee1 	bl	24c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    2706:	e776      	b.n	25f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    2708:	0050183c 	.word	0x0050183c
    270c:	400fc000 	.word	0x400fc000
    2710:	20001c00 	.word	0x20001c00
    2714:	00000ea1 	.word	0x00000ea1
    2718:	401f8000 	.word	0x401f8000
    271c:	401d0000 	.word	0x401d0000
    2720:	401f8400 	.word	0x401f8400
    2724:	38003840 	.word	0x38003840

00002728 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    2728:	b570      	push	{r4, r5, r6, lr}
    272a:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    272c:	bb39      	cbnz	r1, 277e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    272e:	4a3b      	ldr	r2, [pc, #236]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2730:	6a13      	ldr	r3, [r2, #32]
    2732:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2736:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    273a:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    273c:	4b38      	ldr	r3, [pc, #224]	; (2820 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    273e:	6818      	ldr	r0, [r3, #0]
    2740:	b158      	cbz	r0, 275a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    2742:	4a38      	ldr	r2, [pc, #224]	; (2824 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2744:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    2748:	6805      	ldr	r5, [r0, #0]
    274a:	6852      	ldr	r2, [r2, #4]
    274c:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    2750:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2754:	686b      	ldr	r3, [r5, #4]
    2756:	0052      	lsls	r2, r2, #1
    2758:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    275a:	4b33      	ldr	r3, [pc, #204]	; (2828 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    275c:	6818      	ldr	r0, [r3, #0]
    275e:	2800      	cmp	r0, #0
    2760:	d05b      	beq.n	281a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    2762:	4a30      	ldr	r2, [pc, #192]	; (2824 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    2764:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2768:	6803      	ldr	r3, [r0, #0]
    276a:	6852      	ldr	r2, [r2, #4]
    276c:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    2770:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    2774:	685b      	ldr	r3, [r3, #4]
    2776:	0052      	lsls	r2, r2, #1
}
    2778:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    277c:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    277e:	2908      	cmp	r1, #8
    2780:	d107      	bne.n	2792 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    2782:	4a26      	ldr	r2, [pc, #152]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2784:	6a13      	ldr	r3, [r2, #32]
    2786:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    278a:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    278e:	6213      	str	r3, [r2, #32]
    2790:	e7d4      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    2792:	2910      	cmp	r1, #16
    2794:	d107      	bne.n	27a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    2796:	4a21      	ldr	r2, [pc, #132]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2798:	6a13      	ldr	r3, [r2, #32]
    279a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    279e:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    27a2:	6213      	str	r3, [r2, #32]
    27a4:	e7ca      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    27a6:	2918      	cmp	r1, #24
    27a8:	d107      	bne.n	27ba <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    27aa:	4a1c      	ldr	r2, [pc, #112]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    27ac:	6a13      	ldr	r3, [r2, #32]
    27ae:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    27b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    27b6:	6213      	str	r3, [r2, #32]
    27b8:	e7c0      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    27ba:	2914      	cmp	r1, #20
    27bc:	d107      	bne.n	27ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    27be:	4a17      	ldr	r2, [pc, #92]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    27c0:	6a13      	ldr	r3, [r2, #32]
    27c2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    27c6:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    27ca:	6213      	str	r3, [r2, #32]
    27cc:	e7b6      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    27ce:	291e      	cmp	r1, #30
    27d0:	d107      	bne.n	27e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    27d2:	4a12      	ldr	r2, [pc, #72]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    27d4:	6a13      	ldr	r3, [r2, #32]
    27d6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    27da:	f043 0304 	orr.w	r3, r3, #4
    27de:	6213      	str	r3, [r2, #32]
    27e0:	e7ac      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    27e2:	2928      	cmp	r1, #40	; 0x28
    27e4:	d107      	bne.n	27f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    27e6:	4a0d      	ldr	r2, [pc, #52]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    27e8:	6a13      	ldr	r3, [r2, #32]
    27ea:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    27ee:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    27f2:	6213      	str	r3, [r2, #32]
    27f4:	e7a2      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    27f6:	293c      	cmp	r1, #60	; 0x3c
    27f8:	d105      	bne.n	2806 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    27fa:	4a08      	ldr	r2, [pc, #32]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    27fc:	6a13      	ldr	r3, [r2, #32]
    27fe:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2802:	6213      	str	r3, [r2, #32]
    2804:	e79a      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2806:	2950      	cmp	r1, #80	; 0x50
    2808:	d198      	bne.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    280a:	4a04      	ldr	r2, [pc, #16]	; (281c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    280c:	6a13      	ldr	r3, [r2, #32]
    280e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2812:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    2816:	6213      	str	r3, [r2, #32]
    2818:	e790      	b.n	273c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    281a:	bd70      	pop	{r4, r5, r6, pc}
    281c:	400fc000 	.word	0x400fc000
    2820:	20007320 	.word	0x20007320
    2824:	401d4000 	.word	0x401d4000
    2828:	20007324 	.word	0x20007324

0000282c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    282c:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    282e:	494e      	ldr	r1, [pc, #312]	; (2968 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    2830:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    2832:	4b4e      	ldr	r3, [pc, #312]	; (296c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    2834:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    2836:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    2838:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    283a:	6a1b      	ldr	r3, [r3, #32]
    283c:	f3c3 2301 	ubfx	r3, r3, #8, #2
    2840:	3308      	adds	r3, #8
    2842:	446b      	add	r3, sp
    2844:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    2848:	e9c0 2201 	strd	r2, r2, [r0, #4]
    284c:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2850:	2b00      	cmp	r3, #0
    2852:	f000 8085 	beq.w	2960 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C0000;
    2856:	4945      	ldr	r1, [pc, #276]	; (296c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN2;
    2858:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    285c:	2025      	movs	r0, #37	; 0x25
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    285e:	4b44      	ldr	r3, [pc, #272]	; (2970 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    2860:	4a44      	ldr	r2, [pc, #272]	; (2974 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 2;
    2862:	2402      	movs	r4, #2
    nvicIrq = IRQ_CAN2;
    2864:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    2868:	2601      	movs	r6, #1
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    286a:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    286e:	2010      	movs	r0, #16
    CCM_CCGR0 |= 0x3C0000;
    2870:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    2872:	4b41      	ldr	r3, [pc, #260]	; (2978 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C0000;
    2874:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
    2878:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    287a:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 2;
    287e:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2882:	4a3e      	ldr	r2, [pc, #248]	; (297c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    2884:	4c3e      	ldr	r4, [pc, #248]	; (2980 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    2886:	f8c3 00c4 	str.w	r0, [r3, #196]	; 0xc4
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    288a:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    288e:	6526      	str	r6, [r4, #80]	; 0x50
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03 = 0x10; // pin 0 T4B1+B2
    2890:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03 = 0x10B0; // pin 0 T4B1+B2
    2894:	f8c3 12b8 	str.w	r1, [r3, #696]	; 0x2b8
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2898:	6813      	ldr	r3, [r2, #0]
    289a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    289e:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    28a0:	6813      	ldr	r3, [r2, #0]
    28a2:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    28a6:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    28a8:	6813      	ldr	r3, [r2, #0]
    28aa:	01dc      	lsls	r4, r3, #7
    28ac:	d5fc      	bpl.n	28a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    28ae:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    28b0:	4932      	ldr	r1, [pc, #200]	; (297c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    28b2:	f043 0308 	orr.w	r3, r3, #8
    28b6:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    28b8:	6813      	ldr	r3, [r2, #0]
    28ba:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    28be:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    28c0:	680b      	ldr	r3, [r1, #0]
    28c2:	02d8      	lsls	r0, r3, #11
    28c4:	d4fc      	bmi.n	28c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    28c6:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    28c8:	4a2c      	ldr	r2, [pc, #176]	; (297c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    28ca:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    28ce:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    28d0:	6813      	ldr	r3, [r2, #0]
    28d2:	0199      	lsls	r1, r3, #6
    28d4:	d4fc      	bmi.n	28d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    28d6:	4c29      	ldr	r4, [pc, #164]	; (297c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    28d8:	6823      	ldr	r3, [r4, #0]
    28da:	01da      	lsls	r2, r3, #7
    28dc:	d5fc      	bpl.n	28d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    28de:	6823      	ldr	r3, [r4, #0]
    28e0:	2000      	movs	r0, #0
    28e2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    28e6:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    28e8:	6823      	ldr	r3, [r4, #0]
    28ea:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    28ee:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    28f0:	6823      	ldr	r3, [r4, #0]
    28f2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    28f6:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    28f8:	6823      	ldr	r3, [r4, #0]
    28fa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    28fe:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    2900:	6823      	ldr	r3, [r4, #0]
    2902:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    2906:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    2908:	6823      	ldr	r3, [r4, #0]
    290a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    290e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    2910:	6823      	ldr	r3, [r4, #0]
    2912:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    2916:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    2918:	6b63      	ldr	r3, [r4, #52]	; 0x34
    291a:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    291e:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    2920:	6823      	ldr	r3, [r4, #0]
    2922:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    2926:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    2928:	6823      	ldr	r3, [r4, #0]
    292a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    292e:	6023      	str	r3, [r4, #0]
    2930:	f7fe fd68 	bl	1404 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2934:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2936:	4a11      	ldr	r2, [pc, #68]	; (297c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2938:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    293c:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    293e:	6813      	ldr	r3, [r2, #0]
    2940:	01db      	lsls	r3, r3, #7
    2942:	d4fc      	bmi.n	293e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    2944:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    2948:	2101      	movs	r1, #1
    294a:	4b0e      	ldr	r3, [pc, #56]	; (2984 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    294c:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2950:	f002 021f 	and.w	r2, r2, #31
    2954:	009b      	lsls	r3, r3, #2
    2956:	fa01 f202 	lsl.w	r2, r1, r2
    295a:	601a      	str	r2, [r3, #0]
}
    295c:	b002      	add	sp, #8
    295e:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2960:	2118      	movs	r1, #24
    2962:	f7ff fee1 	bl	2728 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    2966:	e776      	b.n	2856 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    2968:	0050183c 	.word	0x0050183c
    296c:	400fc000 	.word	0x400fc000
    2970:	20001c00 	.word	0x20001c00
    2974:	00000eb5 	.word	0x00000eb5
    2978:	401f8000 	.word	0x401f8000
    297c:	401d4000 	.word	0x401d4000
    2980:	401f8400 	.word	0x401f8400
    2984:	38003840 	.word	0x38003840

00002988 <canInit()>:
void canInit(void) {
    2988:	b538      	push	{r3, r4, r5, lr}
  HaldexCAN.begin();
    298a:	484a      	ldr	r0, [pc, #296]	; (2ab4 <canInit()+0x12c>)
    298c:	f7ff fe1e 	bl	25cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2990:	4c49      	ldr	r4, [pc, #292]	; (2ab8 <canInit()+0x130>)
  HaldexCAN.setClock(CLK_60MHz);
    2992:	213c      	movs	r1, #60	; 0x3c
    2994:	4847      	ldr	r0, [pc, #284]	; (2ab4 <canInit()+0x12c>)
    2996:	f7ff fd97 	bl	24c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  HaldexCAN.setBaudRate(500000);
    299a:	2200      	movs	r2, #0
    299c:	4947      	ldr	r1, [pc, #284]	; (2abc <canInit()+0x134>)
    299e:	4845      	ldr	r0, [pc, #276]	; (2ab4 <canInit()+0x12c>)
    29a0:	f7fe fa92 	bl	ec8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    29a4:	6823      	ldr	r3, [r4, #0]
    29a6:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    29aa:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    29ac:	6823      	ldr	r3, [r4, #0]
    29ae:	01dd      	lsls	r5, r3, #7
    29b0:	d5fc      	bpl.n	29ac <canInit()+0x24>
    29b2:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    29b4:	6825      	ldr	r5, [r4, #0]
    29b6:	f7fe fc57 	bl	1268 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    29ba:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    29bc:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    29be:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    29c0:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    29c2:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    29c4:	6823      	ldr	r3, [r4, #0]
    29c6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    29ca:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    29cc:	6823      	ldr	r3, [r4, #0]
    29ce:	f043 030f 	orr.w	r3, r3, #15
    29d2:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    29d4:	d469      	bmi.n	2aaa <canInit()+0x122>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    29d6:	4c38      	ldr	r4, [pc, #224]	; (2ab8 <canInit()+0x130>)
    29d8:	6823      	ldr	r3, [r4, #0]
    29da:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    29de:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    29e0:	6823      	ldr	r3, [r4, #0]
    29e2:	01d9      	lsls	r1, r3, #7
    29e4:	d4fc      	bmi.n	29e0 <canInit()+0x58>
  _mainHandler = handler;
    29e6:	4b36      	ldr	r3, [pc, #216]	; (2ac0 <canInit()+0x138>)
  HaldexCAN.enableFIFO();
    29e8:	2001      	movs	r0, #1
    29ea:	4a36      	ldr	r2, [pc, #216]	; (2ac4 <canInit()+0x13c>)
    29ec:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    29f0:	f7fe fc3a 	bl	1268 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    29f4:	6823      	ldr	r3, [r4, #0]
    29f6:	009a      	lsls	r2, r3, #2
    29f8:	d50a      	bpl.n	2a10 <canInit()+0x88>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    29fa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    29fc:	069b      	lsls	r3, r3, #26
    29fe:	d407      	bmi.n	2a10 <canInit()+0x88>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    2a00:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a02:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2a06:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2a08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a0a:	f043 0320 	orr.w	r3, r3, #32
    2a0e:	62a3      	str	r3, [r4, #40]	; 0x28
  HaldexCAN.mailboxStatus();
    2a10:	f7ff f990 	bl	1d34 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  ChassisCAN.begin();
    2a14:	482c      	ldr	r0, [pc, #176]	; (2ac8 <canInit()+0x140>)
    2a16:	f7ff ff09 	bl	282c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2a1a:	4c2c      	ldr	r4, [pc, #176]	; (2acc <canInit()+0x144>)
  ChassisCAN.setClock(CLK_60MHz);
    2a1c:	213c      	movs	r1, #60	; 0x3c
    2a1e:	482a      	ldr	r0, [pc, #168]	; (2ac8 <canInit()+0x140>)
    2a20:	f7ff fe82 	bl	2728 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  ChassisCAN.setBaudRate(500000);
    2a24:	2200      	movs	r2, #0
    2a26:	4925      	ldr	r1, [pc, #148]	; (2abc <canInit()+0x134>)
    2a28:	4827      	ldr	r0, [pc, #156]	; (2ac8 <canInit()+0x140>)
    2a2a:	f7fe fb0b 	bl	1044 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    2a2e:	6823      	ldr	r3, [r4, #0]
    2a30:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    2a34:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2a36:	6823      	ldr	r3, [r4, #0]
    2a38:	01dd      	lsls	r5, r3, #7
    2a3a:	d5fc      	bpl.n	2a36 <canInit()+0xae>
    2a3c:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    2a3e:	6825      	ldr	r5, [r4, #0]
    2a40:	f7fe fce0 	bl	1404 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    2a44:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2a46:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    2a48:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    2a4a:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    2a4c:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    2a4e:	6823      	ldr	r3, [r4, #0]
    2a50:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    2a54:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    2a56:	6823      	ldr	r3, [r4, #0]
    2a58:	f043 030f 	orr.w	r3, r3, #15
    2a5c:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    2a5e:	d420      	bmi.n	2aa2 <canInit()+0x11a>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2a60:	4c1a      	ldr	r4, [pc, #104]	; (2acc <canInit()+0x144>)
    2a62:	6823      	ldr	r3, [r4, #0]
    2a64:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2a68:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2a6a:	6823      	ldr	r3, [r4, #0]
    2a6c:	01d9      	lsls	r1, r3, #7
    2a6e:	d4fc      	bmi.n	2a6a <canInit()+0xe2>
  _mainHandler = handler;
    2a70:	4b17      	ldr	r3, [pc, #92]	; (2ad0 <canInit()+0x148>)
  ChassisCAN.enableFIFO();
    2a72:	2001      	movs	r0, #1
    2a74:	4a17      	ldr	r2, [pc, #92]	; (2ad4 <canInit()+0x14c>)
    2a76:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    2a7a:	f7fe fcc3 	bl	1404 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    2a7e:	6823      	ldr	r3, [r4, #0]
    2a80:	009a      	lsls	r2, r3, #2
    2a82:	d50a      	bpl.n	2a9a <canInit()+0x112>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    2a84:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a86:	069b      	lsls	r3, r3, #26
    2a88:	d407      	bmi.n	2a9a <canInit()+0x112>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    2a8a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a8c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2a90:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2a92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a94:	f043 0320 	orr.w	r3, r3, #32
    2a98:	62a3      	str	r3, [r4, #40]	; 0x28
}
    2a9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ChassisCAN.mailboxStatus();
    2a9e:	f7fe bd7f 	b.w	15a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  if ( fifo_was_cleared ) enableFIFO();
    2aa2:	2001      	movs	r0, #1
    2aa4:	f7fe fcae 	bl	1404 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2aa8:	e7da      	b.n	2a60 <canInit()+0xd8>
    2aaa:	2001      	movs	r0, #1
    2aac:	f7fe fbdc 	bl	1268 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2ab0:	e791      	b.n	29d6 <canInit()+0x4e>
    2ab2:	bf00      	nop
    2ab4:	200049a0 	.word	0x200049a0
    2ab8:	401d0000 	.word	0x401d0000
    2abc:	0007a120 	.word	0x0007a120
    2ac0:	200069a0 	.word	0x200069a0
    2ac4:	000035a5 	.word	0x000035a5
    2ac8:	20002088 	.word	0x20002088
    2acc:	401d4000 	.word	0x401d4000
    2ad0:	20004088 	.word	0x20004088
    2ad4:	00003349 	.word	0x00003349

00002ad8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
}
#endif


FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
  if ( mb_num == FIFO ) {
    2ad8:	780b      	ldrb	r3, [r1, #0]
    2ada:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2adc:	b510      	push	{r4, lr}
    2ade:	4604      	mov	r4, r0
    2ae0:	b082      	sub	sp, #8
    2ae2:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2ae4:	d013      	beq.n	2b0e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    if ( _mainHandler ) _mainHandler(msg);
    return;
  }
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2ae6:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    2aea:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2aee:	685b      	ldr	r3, [r3, #4]
    2af0:	b113      	cbz	r3, 2af8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2af2:	9201      	str	r2, [sp, #4]
    2af4:	4798      	blx	r3
    2af6:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2af8:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2afc:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2b00:	b11b      	cbz	r3, 2b0a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2b02:	b002      	add	sp, #8
    2b04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2b08:	4718      	bx	r3
}
    2b0a:	b002      	add	sp, #8
    2b0c:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    2b0e:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2b12:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    2b16:	2b00      	cmp	r3, #0
    2b18:	d0f0      	beq.n	2afc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2b1a:	9201      	str	r2, [sp, #4]
    2b1c:	4798      	blx	r3
    2b1e:	9801      	ldr	r0, [sp, #4]
    2b20:	e7ec      	b.n	2afc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2b22:	bf00      	nop

00002b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2b24:	291f      	cmp	r1, #31
    2b26:	481c      	ldr	r0, [pc, #112]	; (2b98 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    2b28:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2b2a:	d823      	bhi.n	2b74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    2b2c:	2301      	movs	r3, #1
    2b2e:	6b04      	ldr	r4, [r0, #48]	; 0x30
    2b30:	408b      	lsls	r3, r1
    2b32:	4323      	orrs	r3, r4
    2b34:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2b36:	4b19      	ldr	r3, [pc, #100]	; (2b9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2b38:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b3c:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2b3e:	440b      	add	r3, r1
    2b40:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2b42:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b44:	b1f8      	cbz	r0, 2b86 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    2b46:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b48:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    2b4a:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b4c:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2b50:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b54:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2b56:	68d0      	ldr	r0, [r2, #12]
}
    2b58:	f85d 4b04 	ldr.w	r4, [sp], #4
    2b5c:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2b5e:	6098      	str	r0, [r3, #8]
    2b60:	6910      	ldr	r0, [r2, #16]
    2b62:	ba00      	rev	r0, r0
    2b64:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    2b66:	7ad2      	ldrb	r2, [r2, #11]
    2b68:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2b6c:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2b70:	601a      	str	r2, [r3, #0]
}
    2b72:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2b74:	f1a1 0c20 	sub.w	ip, r1, #32
    2b78:	2301      	movs	r3, #1
    2b7a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2b7c:	fa03 f30c 	lsl.w	r3, r3, ip
    2b80:	4323      	orrs	r3, r4
    2b82:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2b84:	e7d7      	b.n	2b36 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b86:	6814      	ldr	r4, [r2, #0]
    2b88:	4805      	ldr	r0, [pc, #20]	; (2ba0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    2b8a:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b8c:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2b90:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2b92:	6058      	str	r0, [r3, #4]
    2b94:	e7df      	b.n	2b56 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2b96:	bf00      	nop
    2b98:	401d0000 	.word	0x401d0000
    2b9c:	0401d008 	.word	0x0401d008
    2ba0:	1ffc0000 	.word	0x1ffc0000

00002ba4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2ba4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2ba8:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2bac:	b08f      	sub	sp, #60	; 0x3c
    2bae:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2bb0:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2bb4:	b913      	cbnz	r3, 2bbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2bb6:	2301      	movs	r3, #1
    2bb8:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        T readBytes(T *buffer, uint16_t length);
        void flush() { clear(); }
        void clear() { head = tail = _available = 0; }
        void print(const char *p);
        void println(const char *p);
        uint16_t size() { return _available; }
    2bbc:	8b23      	ldrh	r3, [r4, #24]
    2bbe:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2bc0:	2b00      	cmp	r3, #0
    2bc2:	d157      	bne.n	2c74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2bc4:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2bc8:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2bcc:	4b72      	ldr	r3, [pc, #456]	; (2d98 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2bce:	f002 011f 	and.w	r1, r2, #31
    2bd2:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2bd6:	2201      	movs	r2, #1
    2bd8:	009b      	lsls	r3, r3, #2
    2bda:	408a      	lsls	r2, r1
    2bdc:	601a      	str	r2, [r3, #0]
    2bde:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2be2:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2be4:	b383      	cbz	r3, 2c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>


template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::peek_front(T *buffer, uint16_t length, uint32_t entry) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2be6:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2bea:	221a      	movs	r2, #26
    2bec:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    2bee:	f10d 0c08 	add.w	ip, sp, #8
    2bf2:	f003 030f 	and.w	r3, r3, #15
    2bf6:	46ae      	mov	lr, r5
    2bf8:	fb02 4303 	mla	r3, r2, r3, r4
    2bfc:	f641 3232 	movw	r2, #6962	; 0x1b32
    2c00:	eb03 0802 	add.w	r8, r3, r2
    2c04:	5898      	ldr	r0, [r3, r2]
    2c06:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2c0a:	f8d8 2008 	ldr.w	r2, [r8, #8]
    2c0e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2c12:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2c14:	f8d8 0010 	ldr.w	r0, [r8, #16]
    2c18:	f8d8 1014 	ldr.w	r1, [r8, #20]
    2c1c:	c503      	stmia	r5!, {r0, r1}
    2c1e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2c22:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2c26:	e89e 0003 	ldmia.w	lr, {r0, r1}
    2c2a:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    2c2e:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    2c32:	1c4b      	adds	r3, r1, #1
    2c34:	d054      	beq.n	2ce0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2c36:	4b59      	ldr	r3, [pc, #356]	; (2d9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    2c38:	440b      	add	r3, r1
    2c3a:	011b      	lsls	r3, r3, #4
    2c3c:	681b      	ldr	r3, [r3, #0]
    2c3e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2c42:	2b08      	cmp	r3, #8
    2c44:	f000 808b 	beq.w	2d5e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    2c48:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2c4c:	4b54      	ldr	r3, [pc, #336]	; (2da0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2c4e:	f002 011f 	and.w	r1, r2, #31
    2c52:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2c56:	2201      	movs	r2, #1
    2c58:	009b      	lsls	r3, r3, #2
    2c5a:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2c5c:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2c5e:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2c60:	8b23      	ldrh	r3, [r4, #24]
    2c62:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2c66:	b29b      	uxth	r3, r3
    2c68:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2c6a:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2c6e:	b00f      	add	sp, #60	; 0x3c
    2c70:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
}

template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::readBytes(T *buffer, uint16_t length) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c74:	8aa6      	ldrh	r6, [r4, #20]
    2c76:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2c78:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c7c:	ad08      	add	r5, sp, #32
    2c7e:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2c80:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c84:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2c88:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c8c:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2c90:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2c94:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2c98:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2c9c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2c9e:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2ca2:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2ca6:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2caa:	8b23      	ldrh	r3, [r4, #24]
    2cac:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2cae:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2cb0:	b11b      	cbz	r3, 2cba <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2cb2:	8b23      	ldrh	r3, [r4, #24]
    2cb4:	3b01      	subs	r3, #1
    2cb6:	b29b      	uxth	r3, r3
    2cb8:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2cba:	ad08      	add	r5, sp, #32
    2cbc:	ae02      	add	r6, sp, #8
    2cbe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2cc0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2cc2:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2cc6:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2cc8:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2ccc:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2cd0:	f10d 0107 	add.w	r1, sp, #7
    2cd4:	4620      	mov	r0, r4
    2cd6:	f88d 3007 	strb.w	r3, [sp, #7]
    2cda:	f7ff fefd 	bl	2ad8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    2cde:	e771      	b.n	2bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2ce0:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2da4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2ce4:	f8d8 5000 	ldr.w	r5, [r8]
    2ce8:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    2cec:	d050      	beq.n	2d90 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    2cee:	f7fe fa73 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2cf2:	f8d8 3000 	ldr.w	r3, [r8]
    2cf6:	4605      	mov	r5, r0
    2cf8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2cfc:	3301      	adds	r3, #1
    2cfe:	4283      	cmp	r3, r0
    2d00:	d9a2      	bls.n	2c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2d02:	f8df 9098 	ldr.w	r9, [pc, #152]	; 2d9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d06:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2da4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2d0a:	e008      	b.n	2d1e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    2d0c:	f8d8 3000 	ldr.w	r3, [r8]
    2d10:	3501      	adds	r5, #1
    2d12:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2d16:	b2ed      	uxtb	r5, r5
    2d18:	3301      	adds	r3, #1
    2d1a:	429d      	cmp	r5, r3
    2d1c:	d294      	bcs.n	2c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2d1e:	eb05 0309 	add.w	r3, r5, r9
    2d22:	011b      	lsls	r3, r3, #4
    2d24:	681b      	ldr	r3, [r3, #0]
    2d26:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2d2a:	2b08      	cmp	r3, #8
    2d2c:	d1ee      	bne.n	2d0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    2d2e:	aa02      	add	r2, sp, #8
    2d30:	4629      	mov	r1, r5
    2d32:	4620      	mov	r0, r4
    2d34:	f7ff fef6 	bl	2b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2d38:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2d3c:	3301      	adds	r3, #1
    2d3e:	f003 031f 	and.w	r3, r3, #31
    2d42:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2d46:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2d4a:	b29b      	uxth	r3, r3
    2d4c:	2b00      	cmp	r3, #0
    2d4e:	d0dd      	beq.n	2d0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    2d50:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2d54:	3b01      	subs	r3, #1
    2d56:	b29b      	uxth	r3, r3
    2d58:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2d5c:	e7d6      	b.n	2d0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    2d5e:	aa02      	add	r2, sp, #8
    2d60:	b2c9      	uxtb	r1, r1
    2d62:	4620      	mov	r0, r4
    2d64:	f7ff fede 	bl	2b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2d68:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2d6c:	3301      	adds	r3, #1
    2d6e:	f003 031f 	and.w	r3, r3, #31
    2d72:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2d76:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2d7a:	b29b      	uxth	r3, r3
    2d7c:	2b00      	cmp	r3, #0
    2d7e:	f43f af63 	beq.w	2c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    2d82:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2d86:	3b01      	subs	r3, #1
    2d88:	b29b      	uxth	r3, r3
    2d8a:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2d8e:	e75b      	b.n	2c48 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d90:	f8d8 3000 	ldr.w	r3, [r8]
    2d94:	e7b5      	b.n	2d02 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    2d96:	bf00      	nop
    2d98:	38003860 	.word	0x38003860
    2d9c:	0401d008 	.word	0x0401d008
    2da0:	38003840 	.word	0x38003840
    2da4:	401d0000 	.word	0x401d0000

00002da8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
  if ( mb_num == FIFO ) {
    2da8:	780b      	ldrb	r3, [r1, #0]
    2daa:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2dac:	b510      	push	{r4, lr}
    2dae:	4604      	mov	r4, r0
    2db0:	b082      	sub	sp, #8
    2db2:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2db4:	d013      	beq.n	2dde <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2db6:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    2dba:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2dbe:	685b      	ldr	r3, [r3, #4]
    2dc0:	b113      	cbz	r3, 2dc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2dc2:	9201      	str	r2, [sp, #4]
    2dc4:	4798      	blx	r3
    2dc6:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2dc8:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2dcc:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2dd0:	b11b      	cbz	r3, 2dda <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2dd2:	b002      	add	sp, #8
    2dd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2dd8:	4718      	bx	r3
}
    2dda:	b002      	add	sp, #8
    2ddc:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    2dde:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2de2:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    2de6:	2b00      	cmp	r3, #0
    2de8:	d0f0      	beq.n	2dcc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2dea:	9201      	str	r2, [sp, #4]
    2dec:	4798      	blx	r3
    2dee:	9801      	ldr	r0, [sp, #4]
    2df0:	e7ec      	b.n	2dcc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2df2:	bf00      	nop

00002df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2df4:	291f      	cmp	r1, #31
    2df6:	481c      	ldr	r0, [pc, #112]	; (2e68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    2df8:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2dfa:	d823      	bhi.n	2e44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    2dfc:	2301      	movs	r3, #1
    2dfe:	6b04      	ldr	r4, [r0, #48]	; 0x30
    2e00:	408b      	lsls	r3, r1
    2e02:	4323      	orrs	r3, r4
    2e04:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2e06:	4b19      	ldr	r3, [pc, #100]	; (2e6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2e08:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e0c:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2e0e:	440b      	add	r3, r1
    2e10:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2e12:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e14:	b1f8      	cbz	r0, 2e56 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    2e16:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e18:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    2e1a:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e1c:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2e20:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e24:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2e26:	68d0      	ldr	r0, [r2, #12]
}
    2e28:	f85d 4b04 	ldr.w	r4, [sp], #4
    2e2c:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2e2e:	6098      	str	r0, [r3, #8]
    2e30:	6910      	ldr	r0, [r2, #16]
    2e32:	ba00      	rev	r0, r0
    2e34:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    2e36:	7ad2      	ldrb	r2, [r2, #11]
    2e38:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2e3c:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2e40:	601a      	str	r2, [r3, #0]
}
    2e42:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2e44:	f1a1 0c20 	sub.w	ip, r1, #32
    2e48:	2301      	movs	r3, #1
    2e4a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2e4c:	fa03 f30c 	lsl.w	r3, r3, ip
    2e50:	4323      	orrs	r3, r4
    2e52:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2e54:	e7d7      	b.n	2e06 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e56:	6814      	ldr	r4, [r2, #0]
    2e58:	4805      	ldr	r0, [pc, #20]	; (2e70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    2e5a:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e5c:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2e60:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e62:	6058      	str	r0, [r3, #4]
    2e64:	e7df      	b.n	2e26 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2e66:	bf00      	nop
    2e68:	401d4000 	.word	0x401d4000
    2e6c:	0401d408 	.word	0x0401d408
    2e70:	1ffc0000 	.word	0x1ffc0000

00002e74 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2e74:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2e78:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2e7c:	b08f      	sub	sp, #60	; 0x3c
    2e7e:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2e80:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2e84:	b913      	cbnz	r3, 2e8c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2e86:	2301      	movs	r3, #1
    2e88:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        uint16_t size() { return _available; }
    2e8c:	8b23      	ldrh	r3, [r4, #24]
    2e8e:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2e90:	2b00      	cmp	r3, #0
    2e92:	d157      	bne.n	2f44 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2e94:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2e98:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2e9c:	4b72      	ldr	r3, [pc, #456]	; (3068 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2e9e:	f002 011f 	and.w	r1, r2, #31
    2ea2:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2ea6:	2201      	movs	r2, #1
    2ea8:	009b      	lsls	r3, r3, #2
    2eaa:	408a      	lsls	r2, r1
    2eac:	601a      	str	r2, [r3, #0]
    2eae:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2eb2:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2eb4:	b383      	cbz	r3, 2f18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2eb6:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2eba:	221a      	movs	r2, #26
    2ebc:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    2ebe:	f10d 0c08 	add.w	ip, sp, #8
    2ec2:	f003 030f 	and.w	r3, r3, #15
    2ec6:	46ae      	mov	lr, r5
    2ec8:	fb02 4303 	mla	r3, r2, r3, r4
    2ecc:	f641 3232 	movw	r2, #6962	; 0x1b32
    2ed0:	eb03 0802 	add.w	r8, r3, r2
    2ed4:	5898      	ldr	r0, [r3, r2]
    2ed6:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2eda:	f8d8 2008 	ldr.w	r2, [r8, #8]
    2ede:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2ee2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2ee4:	f8d8 0010 	ldr.w	r0, [r8, #16]
    2ee8:	f8d8 1014 	ldr.w	r1, [r8, #20]
    2eec:	c503      	stmia	r5!, {r0, r1}
    2eee:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2ef2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2ef6:	e89e 0003 	ldmia.w	lr, {r0, r1}
    2efa:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    2efe:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    2f02:	1c4b      	adds	r3, r1, #1
    2f04:	d054      	beq.n	2fb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2f06:	4b59      	ldr	r3, [pc, #356]	; (306c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    2f08:	440b      	add	r3, r1
    2f0a:	011b      	lsls	r3, r3, #4
    2f0c:	681b      	ldr	r3, [r3, #0]
    2f0e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2f12:	2b08      	cmp	r3, #8
    2f14:	f000 808b 	beq.w	302e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    2f18:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2f1c:	4b54      	ldr	r3, [pc, #336]	; (3070 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2f1e:	f002 011f 	and.w	r1, r2, #31
    2f22:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2f26:	2201      	movs	r2, #1
    2f28:	009b      	lsls	r3, r3, #2
    2f2a:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2f2c:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2f2e:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2f30:	8b23      	ldrh	r3, [r4, #24]
    2f32:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2f36:	b29b      	uxth	r3, r3
    2f38:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2f3a:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2f3e:	b00f      	add	sp, #60	; 0x3c
    2f40:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2f44:	8aa6      	ldrh	r6, [r4, #20]
    2f46:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2f48:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2f4c:	ad08      	add	r5, sp, #32
    2f4e:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2f50:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2f54:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2f58:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2f5c:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2f60:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2f64:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2f68:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2f6c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2f6e:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2f72:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2f76:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2f7a:	8b23      	ldrh	r3, [r4, #24]
    2f7c:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2f7e:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2f80:	b11b      	cbz	r3, 2f8a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2f82:	8b23      	ldrh	r3, [r4, #24]
    2f84:	3b01      	subs	r3, #1
    2f86:	b29b      	uxth	r3, r3
    2f88:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2f8a:	ad08      	add	r5, sp, #32
    2f8c:	ae02      	add	r6, sp, #8
    2f8e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2f90:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2f92:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2f96:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2f98:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2f9c:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2fa0:	f10d 0107 	add.w	r1, sp, #7
    2fa4:	4620      	mov	r0, r4
    2fa6:	f88d 3007 	strb.w	r3, [sp, #7]
    2faa:	f7ff fefd 	bl	2da8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    2fae:	e771      	b.n	2e94 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2fb0:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 3074 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2fb4:	f8d8 5000 	ldr.w	r5, [r8]
    2fb8:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    2fbc:	d050      	beq.n	3060 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    2fbe:	f7fe f92f 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2fc2:	f8d8 3000 	ldr.w	r3, [r8]
    2fc6:	4605      	mov	r5, r0
    2fc8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2fcc:	3301      	adds	r3, #1
    2fce:	4283      	cmp	r3, r0
    2fd0:	d9a2      	bls.n	2f18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2fd2:	f8df 9098 	ldr.w	r9, [pc, #152]	; 306c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2fd6:	f8df 809c 	ldr.w	r8, [pc, #156]	; 3074 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2fda:	e008      	b.n	2fee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    2fdc:	f8d8 3000 	ldr.w	r3, [r8]
    2fe0:	3501      	adds	r5, #1
    2fe2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2fe6:	b2ed      	uxtb	r5, r5
    2fe8:	3301      	adds	r3, #1
    2fea:	429d      	cmp	r5, r3
    2fec:	d294      	bcs.n	2f18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2fee:	eb05 0309 	add.w	r3, r5, r9
    2ff2:	011b      	lsls	r3, r3, #4
    2ff4:	681b      	ldr	r3, [r3, #0]
    2ff6:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2ffa:	2b08      	cmp	r3, #8
    2ffc:	d1ee      	bne.n	2fdc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    2ffe:	aa02      	add	r2, sp, #8
    3000:	4629      	mov	r1, r5
    3002:	4620      	mov	r0, r4
    3004:	f7ff fef6 	bl	2df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    3008:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    300c:	3301      	adds	r3, #1
    300e:	f003 031f 	and.w	r3, r3, #31
    3012:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    3016:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    301a:	b29b      	uxth	r3, r3
    301c:	2b00      	cmp	r3, #0
    301e:	d0dd      	beq.n	2fdc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    3020:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    3024:	3b01      	subs	r3, #1
    3026:	b29b      	uxth	r3, r3
    3028:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    302c:	e7d6      	b.n	2fdc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    302e:	aa02      	add	r2, sp, #8
    3030:	b2c9      	uxtb	r1, r1
    3032:	4620      	mov	r0, r4
    3034:	f7ff fede 	bl	2df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    3038:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    303c:	3301      	adds	r3, #1
    303e:	f003 031f 	and.w	r3, r3, #31
    3042:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    3046:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    304a:	b29b      	uxth	r3, r3
    304c:	2b00      	cmp	r3, #0
    304e:	f43f af63 	beq.w	2f18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    3052:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    3056:	3b01      	subs	r3, #1
    3058:	b29b      	uxth	r3, r3
    305a:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    305e:	e75b      	b.n	2f18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3060:	f8d8 3000 	ldr.w	r3, [r8]
    3064:	e7b5      	b.n	2fd2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    3066:	bf00      	nop
    3068:	38003860 	.word	0x38003860
    306c:	0401d408 	.word	0x0401d408
    3070:	38003840 	.word	0x38003840
    3074:	401d4000 	.word	0x401d4000

00003078 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3078:	8843      	ldrh	r3, [r0, #2]
    307a:	f04f 0c1a 	mov.w	ip, #26
    307e:	f003 030f 	and.w	r3, r3, #15
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    3082:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3084:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    3088:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    308a:	2000      	movs	r0, #0
    308c:	7598      	strb	r0, [r3, #22]
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    308e:	8863      	ldrh	r3, [r4, #2]
    3090:	f003 030f 	and.w	r3, r3, #15
    3094:	fb0c 4303 	mla	r3, ip, r3, r4
    3098:	75da      	strb	r2, [r3, #23]
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    309a:	8860      	ldrh	r0, [r4, #2]
    309c:	f000 000f 	and.w	r0, r0, #15
    30a0:	fb0c 4000 	mla	r0, ip, r0, r4
    30a4:	3018      	adds	r0, #24
    30a6:	f005 fb85 	bl	87b4 <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    30aa:	8862      	ldrh	r2, [r4, #2]
    30ac:	8823      	ldrh	r3, [r4, #0]
    30ae:	b292      	uxth	r2, r2
    30b0:	b29b      	uxth	r3, r3
    30b2:	f083 0310 	eor.w	r3, r3, #16
    30b6:	429a      	cmp	r2, r3
    30b8:	d104      	bne.n	30c4 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    30ba:	8823      	ldrh	r3, [r4, #0]
    30bc:	3301      	adds	r3, #1
    30be:	f003 031f 	and.w	r3, r3, #31
    30c2:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    30c4:	8863      	ldrh	r3, [r4, #2]
    30c6:	3301      	adds	r3, #1
    30c8:	f003 031f 	and.w	r3, r3, #31
    30cc:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    30ce:	88a3      	ldrh	r3, [r4, #4]
    30d0:	b29b      	uxth	r3, r3
    30d2:	2b0f      	cmp	r3, #15
    30d4:	d803      	bhi.n	30de <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    30d6:	88a3      	ldrh	r3, [r4, #4]
    30d8:	3301      	adds	r3, #1
    30da:	b29b      	uxth	r3, r3
    30dc:	80a3      	strh	r3, [r4, #4]
}
    30de:	bd10      	pop	{r4, pc}

000030e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    30e0:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    30e2:	b5f0      	push	{r4, r5, r6, r7, lr}
    30e4:	460d      	mov	r5, r1
    30e6:	b08d      	sub	sp, #52	; 0x34
    30e8:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    30ea:	4e4b      	ldr	r6, [pc, #300]	; (3218 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    30ec:	2b00      	cmp	r3, #0
    30ee:	d14c      	bne.n	318a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    30f0:	6833      	ldr	r3, [r6, #0]
    30f2:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    30f6:	d025      	beq.n	3144 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    30f8:	f7fe f86e 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    30fc:	6833      	ldr	r3, [r6, #0]
    30fe:	4684      	mov	ip, r0
    3100:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3104:	3301      	adds	r3, #1
    3106:	4298      	cmp	r0, r3
    3108:	d21e      	bcs.n	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    310a:	4944      	ldr	r1, [pc, #272]	; (321c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    310c:	4842      	ldr	r0, [pc, #264]	; (3218 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    310e:	e007      	b.n	3120 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    3110:	6803      	ldr	r3, [r0, #0]
    3112:	fa5f fc82 	uxtb.w	ip, r2
    3116:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    311a:	3301      	adds	r3, #1
    311c:	459c      	cmp	ip, r3
    311e:	d213      	bcs.n	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3120:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3124:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3128:	011b      	lsls	r3, r3, #4
    312a:	681b      	ldr	r3, [r3, #0]
    312c:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3130:	2b08      	cmp	r3, #8
    3132:	d1ed      	bne.n	3110 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    3134:	4620      	mov	r0, r4
    3136:	462a      	mov	r2, r5
    3138:	4661      	mov	r1, ip
    313a:	f7ff fcf3 	bl	2b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    313e:	2001      	movs	r0, #1
}
    3140:	b00d      	add	sp, #52	; 0x34
    3142:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3144:	6833      	ldr	r3, [r6, #0]
    3146:	e7e0      	b.n	310a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    3148:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    314a:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    314c:	27ff      	movs	r7, #255	; 0xff
    314e:	466e      	mov	r6, sp
    3150:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    3154:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3158:	e895 0003 	ldmia.w	r5, {r0, r1}
    315c:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    3160:	f88d 7014 	strb.w	r7, [sp, #20]
    3164:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    3166:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    316a:	e89c 0003 	ldmia.w	ip, {r0, r1}
    316e:	e88e 0003 	stmia.w	lr, {r0, r1}
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    3172:	2218      	movs	r2, #24
    3174:	f641 301a 	movw	r0, #6938	; 0x1b1a
    3178:	eb0d 0102 	add.w	r1, sp, r2
    317c:	4420      	add	r0, r4
    317e:	f7ff ff7b 	bl	3078 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    3182:	f04f 30ff 	mov.w	r0, #4294967295
}
    3186:	b00d      	add	sp, #52	; 0x34
    3188:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    318a:	6830      	ldr	r0, [r6, #0]
    318c:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    3190:	d040      	beq.n	3214 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    3192:	f7fe f821 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3196:	6833      	ldr	r3, [r6, #0]
    3198:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    319c:	3301      	adds	r3, #1
    319e:	4283      	cmp	r3, r0
    31a0:	d927      	bls.n	31f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31a2:	491e      	ldr	r1, [pc, #120]	; (321c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31a4:	4e1c      	ldr	r6, [pc, #112]	; (3218 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    31a6:	e005      	b.n	31b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    31a8:	6833      	ldr	r3, [r6, #0]
    31aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    31ae:	3301      	adds	r3, #1
    31b0:	4298      	cmp	r0, r3
    31b2:	d21e      	bcs.n	31f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31b4:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31b6:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31b8:	4684      	mov	ip, r0
    31ba:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31bc:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    31be:	681a      	ldr	r2, [r3, #0]
    31c0:	0112      	lsls	r2, r2, #4
    31c2:	d5f1      	bpl.n	31a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    31c4:	681b      	ldr	r3, [r3, #0]
    31c6:	f3c3 6303 	ubfx	r3, r3, #24, #4
    31ca:	2b08      	cmp	r3, #8
    31cc:	d019      	beq.n	3202 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    31ce:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    31d0:	466f      	mov	r7, sp
    31d2:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    31d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    31d8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    31da:	e895 0003 	ldmia.w	r5, {r0, r1}
    31de:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    31e2:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    31e6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    31e8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    31ec:	e896 0003 	ldmia.w	r6, {r0, r1}
    31f0:	e7bd      	b.n	316e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    31f2:	4b0b      	ldr	r3, [pc, #44]	; (3220 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    31f4:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    31f8:	681b      	ldr	r3, [r3, #0]
    31fa:	f3c3 6303 	ubfx	r3, r3, #24, #4
    31fe:	2b08      	cmp	r3, #8
    3200:	d1e5      	bne.n	31ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    3202:	4620      	mov	r0, r4
    3204:	462a      	mov	r2, r5
    3206:	fa5f f18c 	uxtb.w	r1, ip
    320a:	f7ff fc8b 	bl	2b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    320e:	2001      	movs	r0, #1
}
    3210:	b00d      	add	sp, #52	; 0x34
    3212:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3214:	6833      	ldr	r3, [r6, #0]
    3216:	e7c4      	b.n	31a2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    3218:	401d0000 	.word	0x401d0000
    321c:	0401d008 	.word	0x0401d008
    3220:	401d0070 	.word	0x401d0070

00003224 <sendOpenFrame()>:
void sendOpenFrame() {
    3224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t motor1;
    3228:	4c44      	ldr	r4, [pc, #272]	; (333c <sendOpenFrame()+0x118>)
void sendOpenFrame() {
    322a:	b09f      	sub	sp, #124	; 0x7c
  HaldexCAN.write(motor1);
    322c:	4d44      	ldr	r5, [pc, #272]	; (3340 <sendOpenFrame()+0x11c>)
  motor1.id = MOTOR1_ID;
    322e:	f44f 7b20 	mov.w	fp, #640	; 0x280
  CAN_message_t motor1;
    3232:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    3236:	46ec      	mov	ip, sp
  motor1.buf[1] = 0xFA;  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
    3238:	f04f 0afa 	mov.w	sl, #250	; 0xfa
  motor1.buf[2] = 0x20;  // motor speed (rpm): 32 >
    323c:	f644 6920 	movw	r9, #20000	; 0x4e20
  motor3.len = 1;
    3240:	f04f 0801 	mov.w	r8, #1
  motor3.buf[0] = 0xff;
    3244:	27ff      	movs	r7, #255	; 0xff
  brakes1.buf[3] = 0xa;
    3246:	260a      	movs	r6, #10
  CAN_message_t motor1;
    3248:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    324c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3250:	e89e 0003 	ldmia.w	lr, {r0, r1}
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
    3254:	4b3b      	ldr	r3, [pc, #236]	; (3344 <sendOpenFrame()+0x120>)
  motor1.buf[1] = 0xFA;  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
    3256:	f88d a00d 	strb.w	sl, [sp, #13]
  brakes1.id = BRAKES1_ID;
    325a:	f44f 7ad0 	mov.w	sl, #416	; 0x1a0
  motor1.buf[2] = 0x20;  // motor speed (rpm): 32 >
    325e:	f8ad 900e 	strh.w	r9, [sp, #14]
  motor3.id = MOTOR3_ID;
    3262:	f44f 7960 	mov.w	r9, #896	; 0x380
  motor1.id = MOTOR1_ID;
    3266:	f8cd b000 	str.w	fp, [sp]
  CAN_message_t motor1;
    326a:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(motor1);
    326e:	4669      	mov	r1, sp
    3270:	4628      	mov	r0, r5
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
    3272:	9304      	str	r3, [sp, #16]
  HaldexCAN.write(motor1);
    3274:	f7ff ff34 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t motor3;
    3278:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    327c:	f10d 0c18 	add.w	ip, sp, #24
    3280:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3284:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3288:	e89e 0003 	ldmia.w	lr, {r0, r1}
  motor3.id = MOTOR3_ID;
    328c:	f8cd 9018 	str.w	r9, [sp, #24]
  brakes1.len = 4;
    3290:	f04f 0904 	mov.w	r9, #4
  motor3.len = 1;
    3294:	f88d 8023 	strb.w	r8, [sp, #35]	; 0x23
  motor3.buf[0] = 0xff;
    3298:	f88d 7024 	strb.w	r7, [sp, #36]	; 0x24
  CAN_message_t motor3;
    329c:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(motor3);
    32a0:	a906      	add	r1, sp, #24
    32a2:	4628      	mov	r0, r5
    32a4:	f7ff ff1c 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes1;
    32a8:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    32ac:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
    32b0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    32b4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    32b8:	e89e 0003 	ldmia.w	lr, {r0, r1}
  brakes1.len = 4;
    32bc:	f88d 903b 	strb.w	r9, [sp, #59]	; 0x3b
  brakes3.id = BRAKES3_ID;
    32c0:	f44f 6994 	mov.w	r9, #1184	; 0x4a0
  brakes1.buf[3] = 0xa;
    32c4:	f88d 603f 	strb.w	r6, [sp, #63]	; 0x3f
  brakes1.id = BRAKES1_ID;
    32c8:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
  CAN_message_t brakes1;
    32cc:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(brakes1);
    32d0:	a90c      	add	r1, sp, #48	; 0x30
    32d2:	4628      	mov	r0, r5
    32d4:	f7ff ff04 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes3;
    32d8:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    32dc:	f10d 0c48 	add.w	ip, sp, #72	; 0x48
  CAN_message_t brakes5;
    32e0:	3440      	adds	r4, #64	; 0x40
  CAN_message_t brakes3;
    32e2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    32e6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    32ea:	e89e 0003 	ldmia.w	lr, {r0, r1}
  brakes3.buf[1] = 0xA;
    32ee:	f88d 6055 	strb.w	r6, [sp, #85]	; 0x55
  brakes3.buf[3] = 0xA;
    32f2:	f88d 6057 	strb.w	r6, [sp, #87]	; 0x57
  brakes3.id = BRAKES3_ID;
    32f6:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
  CAN_message_t brakes3;
    32fa:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(brakes3);
    32fe:	a912      	add	r1, sp, #72	; 0x48
    3300:	4628      	mov	r0, r5
  brakes3.buf[5] = 0xA;  // 254+10? (5050 returns 0xA)
    3302:	f88d 6059 	strb.w	r6, [sp, #89]	; 0x59
  brakes3.buf[7] = 0xA;  // 254+10? was FE
    3306:	f88d 605b 	strb.w	r6, [sp, #91]	; 0x5b
  HaldexCAN.write(brakes3);
    330a:	f7ff fee9 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes5;
    330e:	ae18      	add	r6, sp, #96	; 0x60
  brakes5.id = BRAKES5_ID;
    3310:	f44f 6cb4 	mov.w	ip, #1440	; 0x5a0
  CAN_message_t brakes5;
    3314:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    3316:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    3318:	e894 0003 	ldmia.w	r4, {r0, r1}
  brakes5.id = BRAKES5_ID;
    331c:	f8cd c060 	str.w	ip, [sp, #96]	; 0x60
  brakes5.len = 1;
    3320:	f88d 806b 	strb.w	r8, [sp, #107]	; 0x6b
  brakes5.buf[0] = 0xff;
    3324:	f88d 706c 	strb.w	r7, [sp, #108]	; 0x6c
  CAN_message_t brakes5;
    3328:	e886 0003 	stmia.w	r6, {r0, r1}
  HaldexCAN.write(brakes5);
    332c:	a918      	add	r1, sp, #96	; 0x60
    332e:	4628      	mov	r0, r5
    3330:	f7ff fed6 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
}
    3334:	b01f      	add	sp, #124	; 0x7c
    3336:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    333a:	bf00      	nop
    333c:	20000370 	.word	0x20000370
    3340:	200049a0 	.word	0x200049a0
    3344:	fe20fefe 	.word	0xfe20fefe

00003348 <onBodyRX(CAN_message_t const&)>:
void onBodyRX(const CAN_message_t &frame) {
    3348:	b5f0      	push	{r4, r5, r6, r7, lr}
  CAN_message_t frame_out;
    334a:	4c3d      	ldr	r4, [pc, #244]	; (3440 <onBodyRX(CAN_message_t const&)+0xf8>)
void onBodyRX(const CAN_message_t &frame) {
    334c:	b087      	sub	sp, #28
  frame_out.len = frame.len;
    334e:	7ac7      	ldrb	r7, [r0, #11]
void onBodyRX(const CAN_message_t &frame) {
    3350:	4605      	mov	r5, r0
  frame_out.id = frame.id;
    3352:	6806      	ldr	r6, [r0, #0]
  CAN_message_t frame_out;
    3354:	46ec      	mov	ip, sp
  frame_out.flags = frame.flags;
    3356:	f8d0 e007 	ldr.w	lr, [r0, #7]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    335a:	2f08      	cmp	r7, #8
  CAN_message_t frame_out;
    335c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    335e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3362:	e894 0003 	ldmia.w	r4, {r0, r1}
  frame_out.flags = frame.flags;
    3366:	f8cd e007 	str.w	lr, [sp, #7]
  frame_out.id = frame.id;
    336a:	9600      	str	r6, [sp, #0]
  frame_out.len = frame.len;
    336c:	f88d 700b 	strb.w	r7, [sp, #11]
  CAN_message_t frame_out;
    3370:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3374:	d957      	bls.n	3426 <onBodyRX(CAN_message_t const&)+0xde>
  switch (frame.id) {
    3376:	f5b6 7f20 	cmp.w	r6, #640	; 0x280
    337a:	d03b      	beq.n	33f4 <onBodyRX(CAN_message_t const&)+0xac>
    337c:	f5b6 7f22 	cmp.w	r6, #648	; 0x288
    3380:	d10d      	bne.n	339e <onBodyRX(CAN_message_t const&)+0x56>
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    3382:	f44f 5248 	mov.w	r2, #12800	; 0x3200
    3386:	7beb      	ldrb	r3, [r5, #15]
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    3388:	492e      	ldr	r1, [pc, #184]	; (3444 <onBodyRX(CAN_message_t const&)+0xfc>)
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    338a:	fb02 f303 	mul.w	r3, r2, r3
    338e:	4a2e      	ldr	r2, [pc, #184]	; (3448 <onBodyRX(CAN_message_t const&)+0x100>)
    3390:	fba2 2303 	umull	r2, r3, r2, r3
    3394:	0b5b      	lsrs	r3, r3, #13
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    3396:	2bff      	cmp	r3, #255	; 0xff
    3398:	bfa8      	it	ge
    339a:	23ff      	movge	r3, #255	; 0xff
    339c:	700b      	strb	r3, [r1, #0]
  if (state.mode == MODE_STOCK) {
    339e:	4c2b      	ldr	r4, [pc, #172]	; (344c <onBodyRX(CAN_message_t const&)+0x104>)
    33a0:	7823      	ldrb	r3, [r4, #0]
    33a2:	2b00      	cmp	r3, #0
    33a4:	d038      	beq.n	3418 <onBodyRX(CAN_message_t const&)+0xd0>
  if (state.mode == MODE_FWD) {
    33a6:	2b01      	cmp	r3, #1
    33a8:	d01d      	beq.n	33e6 <onBodyRX(CAN_message_t const&)+0x9e>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    33aa:	3b02      	subs	r3, #2
    33ac:	2b01      	cmp	r3, #1
    33ae:	d906      	bls.n	33be <onBodyRX(CAN_message_t const&)+0x76>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    33b0:	4669      	mov	r1, sp
    33b2:	4827      	ldr	r0, [pc, #156]	; (3450 <onBodyRX(CAN_message_t const&)+0x108>)
    33b4:	f7ff fe94 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    33b8:	b150      	cbz	r0, 33d0 <onBodyRX(CAN_message_t const&)+0x88>
}
    33ba:	b007      	add	sp, #28
    33bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    getLockData(&frame_out);
    33be:	4668      	mov	r0, sp
    33c0:	f7fd fc5c 	bl	c7c <getLockData(CAN_message_t*)>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    33c4:	4669      	mov	r1, sp
    33c6:	4822      	ldr	r0, [pc, #136]	; (3450 <onBodyRX(CAN_message_t const&)+0x108>)
    33c8:	f7ff fe8a 	bl	30e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    33cc:	2800      	cmp	r0, #0
    33ce:	d1f4      	bne.n	33ba <onBodyRX(CAN_message_t const&)+0x72>
    33d0:	2113      	movs	r1, #19
    33d2:	4820      	ldr	r0, [pc, #128]	; (3454 <onBodyRX(CAN_message_t const&)+0x10c>)
    33d4:	f004 faba 	bl	794c <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    33d8:	481f      	ldr	r0, [pc, #124]	; (3458 <onBodyRX(CAN_message_t const&)+0x110>)
    33da:	f002 fa29 	bl	5830 <Print::println()>
    HaldexCAN.mailboxStatus();                 // print the mailbox status if there's a failure
    33de:	f7fe fca9 	bl	1d34 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    33e2:	b007      	add	sp, #28
    33e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    sendOpenFrame();
    33e6:	f7ff ff1d 	bl	3224 <sendOpenFrame()>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    33ea:	7823      	ldrb	r3, [r4, #0]
    33ec:	3b02      	subs	r3, #2
    33ee:	2b01      	cmp	r3, #1
    33f0:	d8de      	bhi.n	33b0 <onBodyRX(CAN_message_t const&)+0x68>
    33f2:	e7e4      	b.n	33be <onBodyRX(CAN_message_t const&)+0x76>
      pedValue = frame.buf[5] * 0.4;
    33f4:	7c6b      	ldrb	r3, [r5, #17]
  if (state.mode == MODE_STOCK) {
    33f6:	4c15      	ldr	r4, [pc, #84]	; (344c <onBodyRX(CAN_message_t const&)+0x104>)
      pedValue = frame.buf[5] * 0.4;
    33f8:	ee07 3a10 	vmov	s14, r3
    33fc:	4b17      	ldr	r3, [pc, #92]	; (345c <onBodyRX(CAN_message_t const&)+0x114>)
    33fe:	ed9f 6b0e 	vldr	d6, [pc, #56]	; 3438 <onBodyRX(CAN_message_t const&)+0xf0>
    3402:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    3406:	ee27 7b06 	vmul.f64	d7, d7, d6
    340a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    340e:	ed83 7a00 	vstr	s14, [r3]
  if (state.mode == MODE_STOCK) {
    3412:	7823      	ldrb	r3, [r4, #0]
    3414:	2b00      	cmp	r3, #0
    3416:	d1c6      	bne.n	33a6 <onBodyRX(CAN_message_t const&)+0x5e>
    memcpy(frame_out.buf, frame.buf, frame.len);
    3418:	463a      	mov	r2, r7
    341a:	f105 010c 	add.w	r1, r5, #12
    341e:	a803      	add	r0, sp, #12
    3420:	f002 ff4c 	bl	62bc <memcpy>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    3424:	e7c4      	b.n	33b0 <onBodyRX(CAN_message_t const&)+0x68>
    memcpy(frame_out.buf, frame.buf, frame.len);
    3426:	463a      	mov	r2, r7
    3428:	f105 010c 	add.w	r1, r5, #12
    342c:	a803      	add	r0, sp, #12
    342e:	f002 ff45 	bl	62bc <memcpy>
    3432:	e7a0      	b.n	3376 <onBodyRX(CAN_message_t const&)+0x2e>
    3434:	f3af 8000 	nop.w
    3438:	9999999a 	.word	0x9999999a
    343c:	3fd99999 	.word	0x3fd99999
    3440:	200003b0 	.word	0x200003b0
    3444:	20007720 	.word	0x20007720
    3448:	d1b71759 	.word	0xd1b71759
    344c:	20007580 	.word	0x20007580
    3450:	200049a0 	.word	0x200049a0
    3454:	200005c0 	.word	0x200005c0
    3458:	20001110 	.word	0x20001110
    345c:	20007510 	.word	0x20007510

00003460 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    3460:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    3462:	b5f0      	push	{r4, r5, r6, r7, lr}
    3464:	460d      	mov	r5, r1
    3466:	b08d      	sub	sp, #52	; 0x34
    3468:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    346a:	4e4b      	ldr	r6, [pc, #300]	; (3598 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    346c:	2b00      	cmp	r3, #0
    346e:	d14c      	bne.n	350a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3470:	6833      	ldr	r3, [r6, #0]
    3472:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    3476:	d025      	beq.n	34c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    3478:	f7fd fed2 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    347c:	6833      	ldr	r3, [r6, #0]
    347e:	4684      	mov	ip, r0
    3480:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3484:	3301      	adds	r3, #1
    3486:	4298      	cmp	r0, r3
    3488:	d21e      	bcs.n	34c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    348a:	4944      	ldr	r1, [pc, #272]	; (359c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    348c:	4842      	ldr	r0, [pc, #264]	; (3598 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    348e:	e007      	b.n	34a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    3490:	6803      	ldr	r3, [r0, #0]
    3492:	fa5f fc82 	uxtb.w	ip, r2
    3496:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    349a:	3301      	adds	r3, #1
    349c:	459c      	cmp	ip, r3
    349e:	d213      	bcs.n	34c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    34a0:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    34a4:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    34a8:	011b      	lsls	r3, r3, #4
    34aa:	681b      	ldr	r3, [r3, #0]
    34ac:	f3c3 6303 	ubfx	r3, r3, #24, #4
    34b0:	2b08      	cmp	r3, #8
    34b2:	d1ed      	bne.n	3490 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    34b4:	4620      	mov	r0, r4
    34b6:	462a      	mov	r2, r5
    34b8:	4661      	mov	r1, ip
    34ba:	f7ff fc9b 	bl	2df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    34be:	2001      	movs	r0, #1
}
    34c0:	b00d      	add	sp, #52	; 0x34
    34c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    34c4:	6833      	ldr	r3, [r6, #0]
    34c6:	e7e0      	b.n	348a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    34c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    34ca:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    34cc:	27ff      	movs	r7, #255	; 0xff
    34ce:	466e      	mov	r6, sp
    34d0:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    34d4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    34d8:	e895 0003 	ldmia.w	r5, {r0, r1}
    34dc:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    34e0:	f88d 7014 	strb.w	r7, [sp, #20]
    34e4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    34e6:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    34ea:	e89c 0003 	ldmia.w	ip, {r0, r1}
    34ee:	e88e 0003 	stmia.w	lr, {r0, r1}
    34f2:	2218      	movs	r2, #24
    34f4:	f641 301a 	movw	r0, #6938	; 0x1b1a
    34f8:	eb0d 0102 	add.w	r1, sp, r2
    34fc:	4420      	add	r0, r4
    34fe:	f7ff fdbb 	bl	3078 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    3502:	f04f 30ff 	mov.w	r0, #4294967295
}
    3506:	b00d      	add	sp, #52	; 0x34
    3508:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    350a:	6830      	ldr	r0, [r6, #0]
    350c:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    3510:	d040      	beq.n	3594 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    3512:	f7fd fe85 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3516:	6833      	ldr	r3, [r6, #0]
    3518:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    351c:	3301      	adds	r3, #1
    351e:	4283      	cmp	r3, r0
    3520:	d927      	bls.n	3572 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    3522:	491e      	ldr	r1, [pc, #120]	; (359c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3524:	4e1c      	ldr	r6, [pc, #112]	; (3598 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    3526:	e005      	b.n	3534 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    3528:	6833      	ldr	r3, [r6, #0]
    352a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    352e:	3301      	adds	r3, #1
    3530:	4298      	cmp	r0, r3
    3532:	d21e      	bcs.n	3572 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    3534:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3536:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    3538:	4684      	mov	ip, r0
    353a:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    353c:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    353e:	681a      	ldr	r2, [r3, #0]
    3540:	0112      	lsls	r2, r2, #4
    3542:	d5f1      	bpl.n	3528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3544:	681b      	ldr	r3, [r3, #0]
    3546:	f3c3 6303 	ubfx	r3, r3, #24, #4
    354a:	2b08      	cmp	r3, #8
    354c:	d019      	beq.n	3582 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    354e:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    3550:	466f      	mov	r7, sp
    3552:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    3556:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3558:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    355a:	e895 0003 	ldmia.w	r5, {r0, r1}
    355e:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    3562:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    3566:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3568:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    356c:	e896 0003 	ldmia.w	r6, {r0, r1}
    3570:	e7bd      	b.n	34ee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3572:	4b0b      	ldr	r3, [pc, #44]	; (35a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    3574:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3578:	681b      	ldr	r3, [r3, #0]
    357a:	f3c3 6303 	ubfx	r3, r3, #24, #4
    357e:	2b08      	cmp	r3, #8
    3580:	d1e5      	bne.n	354e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    3582:	4620      	mov	r0, r4
    3584:	462a      	mov	r2, r5
    3586:	fa5f f18c 	uxtb.w	r1, ip
    358a:	f7ff fc33 	bl	2df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    358e:	2001      	movs	r0, #1
}
    3590:	b00d      	add	sp, #52	; 0x34
    3592:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3594:	6833      	ldr	r3, [r6, #0]
    3596:	e7c4      	b.n	3522 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    3598:	401d4000 	.word	0x401d4000
    359c:	0401d408 	.word	0x0401d408
    35a0:	401d4070 	.word	0x401d4070

000035a4 <onHaldexRX(CAN_message_t const&)>:
void onHaldexRX(const CAN_message_t &frame) {
    35a4:	b570      	push	{r4, r5, r6, lr}
  haldexState = frame.buf[0];
    35a6:	4b1d      	ldr	r3, [pc, #116]	; (361c <onHaldexRX(CAN_message_t const&)+0x78>)
void onHaldexRX(const CAN_message_t &frame) {
    35a8:	b086      	sub	sp, #24
  haldexState = frame.buf[0];
    35aa:	7b02      	ldrb	r2, [r0, #12]
void onHaldexRX(const CAN_message_t &frame) {
    35ac:	4686      	mov	lr, r0
  CAN_message_t frame_out;
    35ae:	4c1c      	ldr	r4, [pc, #112]	; (3620 <onHaldexRX(CAN_message_t const&)+0x7c>)
    35b0:	46ec      	mov	ip, sp
  haldexState = frame.buf[0];
    35b2:	701a      	strb	r2, [r3, #0]
  haldexEngagement = frame.buf[1];
    35b4:	4b1b      	ldr	r3, [pc, #108]	; (3624 <onHaldexRX(CAN_message_t const&)+0x80>)
    35b6:	7b42      	ldrb	r2, [r0, #13]
  frame_out.len = frame.len;
    35b8:	7ac5      	ldrb	r5, [r0, #11]
  frame_out.flags = frame.flags;
    35ba:	f8d0 6007 	ldr.w	r6, [r0, #7]
  haldexEngagement = frame.buf[1];
    35be:	701a      	strb	r2, [r3, #0]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    35c0:	2d08      	cmp	r5, #8
  CAN_message_t frame_out;
    35c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    35c4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  frame_out.id = frame.id;
    35c8:	f8de 3000 	ldr.w	r3, [lr]
  frame_out.flags = frame.flags;
    35cc:	f8cd 6007 	str.w	r6, [sp, #7]
  frame_out.id = frame.id;
    35d0:	9300      	str	r3, [sp, #0]
  frame_out.len = frame.len;
    35d2:	f88d 500b 	strb.w	r5, [sp, #11]
  CAN_message_t frame_out;
    35d6:	e894 0003 	ldmia.w	r4, {r0, r1}
    35da:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    35de:	d906      	bls.n	35ee <onHaldexRX(CAN_message_t const&)+0x4a>
  if (!ChassisCAN.write(frame_out)) {
    35e0:	4669      	mov	r1, sp
    35e2:	4811      	ldr	r0, [pc, #68]	; (3628 <onHaldexRX(CAN_message_t const&)+0x84>)
    35e4:	f7ff ff3c 	bl	3460 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    35e8:	b168      	cbz	r0, 3606 <onHaldexRX(CAN_message_t const&)+0x62>
}
    35ea:	b006      	add	sp, #24
    35ec:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(frame_out.buf, frame.buf, frame.len);
    35ee:	f10e 010c 	add.w	r1, lr, #12
    35f2:	462a      	mov	r2, r5
    35f4:	a803      	add	r0, sp, #12
    35f6:	f002 fe61 	bl	62bc <memcpy>
  if (!ChassisCAN.write(frame_out)) {
    35fa:	4669      	mov	r1, sp
    35fc:	480a      	ldr	r0, [pc, #40]	; (3628 <onHaldexRX(CAN_message_t const&)+0x84>)
    35fe:	f7ff ff2f 	bl	3460 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3602:	2800      	cmp	r0, #0
    3604:	d1f1      	bne.n	35ea <onHaldexRX(CAN_message_t const&)+0x46>
    3606:	2111      	movs	r1, #17
    3608:	4808      	ldr	r0, [pc, #32]	; (362c <onHaldexRX(CAN_message_t const&)+0x88>)
    360a:	f004 f99f 	bl	794c <usb_serial_write>
    360e:	4808      	ldr	r0, [pc, #32]	; (3630 <onHaldexRX(CAN_message_t const&)+0x8c>)
    3610:	f002 f90e 	bl	5830 <Print::println()>
    ChassisCAN.mailboxStatus();
    3614:	f7fd ffc4 	bl	15a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    3618:	b006      	add	sp, #24
    361a:	bd70      	pop	{r4, r5, r6, pc}
    361c:	20007711 	.word	0x20007711
    3620:	200003b0 	.word	0x200003b0
    3624:	20007710 	.word	0x20007710
    3628:	20002088 	.word	0x20002088
    362c:	200003dc 	.word	0x200003dc
    3630:	20001110 	.word	0x20001110

00003634 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( mb_num == FIFO ) fifo_filter_table[0][0] |= (1UL << 28); /* enable fifo enhancement */
  else mb_filter_table[mb_num][0] |= (1UL << 28); /* enable mb enhancement */
}

FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3634:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    3638:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    363c:	00db      	lsls	r3, r3, #3
    363e:	d569      	bpl.n	3714 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3640:	4b37      	ldr	r3, [pc, #220]	; (3720 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    3642:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3646:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    3648:	f04f 0e00 	mov.w	lr, #0
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    }
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    364c:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3650:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3654:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3658:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    365c:	00f6      	lsls	r6, r6, #3
    365e:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3660:	e009      	b.n	3676 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    3662:	6813      	ldr	r3, [r2, #0]
    3664:	0f5b      	lsrs	r3, r3, #29
    3666:	2b05      	cmp	r3, #5
    3668:	d034      	beq.n	36d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    366a:	f10e 0e01 	add.w	lr, lr, #1
    366e:	fa5f f38e 	uxtb.w	r3, lr
    3672:	429e      	cmp	r6, r3
    3674:	d950      	bls.n	3718 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3676:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    367a:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    367e:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    3682:	6813      	ldr	r3, [r2, #0]
    3684:	0f5b      	lsrs	r3, r3, #29
    3686:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3688:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    368a:	d00d      	beq.n	36a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    368c:	0f5b      	lsrs	r3, r3, #29
    368e:	2b02      	cmp	r3, #2
    3690:	d1e7      	bne.n	3662 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3692:	f85c 3007 	ldr.w	r3, [ip, r7]
    3696:	428b      	cmp	r3, r1
    3698:	d8e7      	bhi.n	366a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    369a:	f85c 3008 	ldr.w	r3, [ip, r8]
    369e:	428b      	cmp	r3, r1
    36a0:	d3e3      	bcc.n	366a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    36a2:	2001      	movs	r0, #1
      }
    }
  }
  return 0;
}
    36a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    36a8:	f413 7f60 	tst.w	r3, #896	; 0x380
    36ac:	d0dd      	beq.n	366a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    36ae:	006d      	lsls	r5, r5, #1
    36b0:	2300      	movs	r3, #0
    36b2:	e004      	b.n	36be <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    36b4:	6814      	ldr	r4, [r2, #0]
    36b6:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    36ba:	4563      	cmp	r3, ip
    36bc:	d2d5      	bcs.n	366a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    36be:	3301      	adds	r3, #1
    36c0:	eb05 0c03 	add.w	ip, r5, r3
    36c4:	b2db      	uxtb	r3, r3
    36c6:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    36ca:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    36ce:	428c      	cmp	r4, r1
    36d0:	d1f0      	bne.n	36b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    36d2:	e7e6      	b.n	36a2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    36d4:	6813      	ldr	r3, [r2, #0]
    36d6:	f413 7f60 	tst.w	r3, #896	; 0x380
    36da:	d0c6      	beq.n	366a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    36dc:	44cc      	add	ip, r9
    36de:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    36e0:	2401      	movs	r4, #1
    36e2:	e005      	b.n	36f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    36e4:	6813      	ldr	r3, [r2, #0]
    36e6:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    36ea:	3301      	adds	r3, #1
    36ec:	429c      	cmp	r4, r3
    36ee:	d2bc      	bcs.n	366a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    36f0:	192b      	adds	r3, r5, r4
    36f2:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    36f6:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    36f8:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    36fc:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3700:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3702:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    3706:	f8dc b000 	ldr.w	fp, [ip]
    370a:	ea03 030b 	and.w	r3, r3, fp
    370e:	459a      	cmp	sl, r3
    3710:	d1e8      	bne.n	36e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    3712:	e7c6      	b.n	36a2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3714:	2001      	movs	r0, #1
}
    3716:	4770      	bx	lr
  return 0;
    3718:	2000      	movs	r0, #0
}
    371a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    371e:	bf00      	nop
    3720:	401d4000 	.word	0x401d4000

00003724 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:

FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3724:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    3728:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    372a:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    372e:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    3732:	f8de 3000 	ldr.w	r3, [lr]
    3736:	00db      	lsls	r3, r3, #3
    3738:	d528      	bpl.n	378c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    373a:	f8de 3000 	ldr.w	r3, [lr]
    373e:	0f5b      	lsrs	r3, r3, #29
    3740:	2b01      	cmp	r3, #1
    3742:	d00b      	beq.n	375c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3744:	f8de 3000 	ldr.w	r3, [lr]
    3748:	0f5b      	lsrs	r3, r3, #29
    374a:	2b02      	cmp	r3, #2
    374c:	d042      	beq.n	37d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    374e:	f8de 3000 	ldr.w	r3, [lr]
    3752:	0f5b      	lsrs	r3, r3, #29
    3754:	2b05      	cmp	r3, #5
    3756:	d01b      	beq.n	3790 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    }
  }
  return 0;
    3758:	2000      	movs	r0, #0
}
    375a:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    375c:	f8de 4000 	ldr.w	r4, [lr]
    3760:	f414 7f60 	tst.w	r4, #896	; 0x380
    3764:	d0f8      	beq.n	3758 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3766:	2300      	movs	r3, #0
    3768:	004d      	lsls	r5, r1, #1
    376a:	e005      	b.n	3778 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    376c:	f8de 1000 	ldr.w	r1, [lr]
    3770:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    3774:	4563      	cmp	r3, ip
    3776:	d2ef      	bcs.n	3758 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3778:	3301      	adds	r3, #1
    377a:	eb05 0c03 	add.w	ip, r5, r3
    377e:	b2db      	uxtb	r3, r3
    3780:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    3784:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3788:	4294      	cmp	r4, r2
    378a:	d1ef      	bne.n	376c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    378c:	2001      	movs	r0, #1
}
    378e:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3790:	f8de 5000 	ldr.w	r5, [lr]
    3794:	f415 7f60 	tst.w	r5, #896	; 0x380
    3798:	d0de      	beq.n	3758 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    379a:	f242 1514 	movw	r5, #8468	; 0x2114
    379e:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    37a0:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    37a2:	4425      	add	r5, r4
    37a4:	e007      	b.n	37b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    37a6:	f8de 4000 	ldr.w	r4, [lr]
    37aa:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    37ae:	f10c 0c01 	add.w	ip, ip, #1
    37b2:	4563      	cmp	r3, ip
    37b4:	d2d0      	bcs.n	3758 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    37b6:	682c      	ldr	r4, [r5, #0]
    37b8:	ea04 0c02 	and.w	ip, r4, r2
    37bc:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    37be:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    37c0:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    37c4:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    37c6:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    37ca:	682e      	ldr	r6, [r5, #0]
    37cc:	4034      	ands	r4, r6
    37ce:	45a4      	cmp	ip, r4
    37d0:	d1e9      	bne.n	37a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    37d2:	e7db      	b.n	378c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    37d4:	f242 1304 	movw	r3, #8452	; 0x2104
    37d8:	58e3      	ldr	r3, [r4, r3]
    37da:	4293      	cmp	r3, r2
    37dc:	d8bc      	bhi.n	3758 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    37de:	f242 1308 	movw	r3, #8456	; 0x2108
    37e2:	58e0      	ldr	r0, [r4, r3]
    37e4:	4290      	cmp	r0, r2
    37e6:	bf34      	ite	cc
    37e8:	2000      	movcc	r0, #0
    37ea:	2001      	movcs	r0, #1
}
    37ec:	bd70      	pop	{r4, r5, r6, pc}
    37ee:	bf00      	nop

000037f0 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>:
  if ( _available < _size ) _available++;
    37f0:	8883      	ldrh	r3, [r0, #4]
    37f2:	b29b      	uxth	r3, r3
    37f4:	2b0f      	cmp	r3, #15
    37f6:	d803      	bhi.n	3800 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x10>
    37f8:	8883      	ldrh	r3, [r0, #4]
    37fa:	3301      	adds	r3, #1
    37fc:	b29b      	uxth	r3, r3
    37fe:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    3800:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3802:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    3806:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    3808:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    380c:	fa1f fc8c 	uxth.w	ip, ip
    3810:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    3812:	3202      	adds	r2, #2
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3814:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    3818:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    381c:	459c      	cmp	ip, r3
    381e:	d104      	bne.n	382a <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x3a>
    3820:	8803      	ldrh	r3, [r0, #0]
    3822:	3301      	adds	r3, #1
    3824:	f003 031f 	and.w	r3, r3, #31
    3828:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    382a:	8843      	ldrh	r3, [r0, #2]
    382c:	3301      	adds	r3, #1
    382e:	f003 031f 	and.w	r3, r3, #31
    3832:	8043      	strh	r3, [r0, #2]
}
    3834:	4770      	bx	lr
    3836:	bf00      	nop

00003838 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>:
  if ( _available < _size ) _available++;
    3838:	8883      	ldrh	r3, [r0, #4]
    383a:	b29b      	uxth	r3, r3
    383c:	2b0f      	cmp	r3, #15
    383e:	d803      	bhi.n	3848 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x10>
    3840:	8883      	ldrh	r3, [r0, #4]
    3842:	3301      	adds	r3, #1
    3844:	b29b      	uxth	r3, r3
    3846:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    3848:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    384a:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    384e:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    3850:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3854:	fa1f fc8c 	uxth.w	ip, ip
    3858:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    385a:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    385e:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    3862:	80d1      	strh	r1, [r2, #6]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3864:	459c      	cmp	ip, r3
    3866:	d104      	bne.n	3872 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x3a>
    3868:	8803      	ldrh	r3, [r0, #0]
    386a:	3301      	adds	r3, #1
    386c:	f003 031f 	and.w	r3, r3, #31
    3870:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    3872:	8843      	ldrh	r3, [r0, #2]
    3874:	3301      	adds	r3, #1
    3876:	f003 031f 	and.w	r3, r3, #31
    387a:	8043      	strh	r3, [r0, #2]
}
    387c:	4770      	bx	lr
    387e:	bf00      	nop

00003880 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3880:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    3884:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    3888:	00db      	lsls	r3, r3, #3
    388a:	d569      	bpl.n	3960 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    388c:	4b37      	ldr	r3, [pc, #220]	; (396c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    388e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3892:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    3894:	f04f 0e00 	mov.w	lr, #0
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3898:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    389c:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    38a0:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    38a4:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    38a8:	00f6      	lsls	r6, r6, #3
    38aa:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    38ac:	e009      	b.n	38c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    38ae:	6813      	ldr	r3, [r2, #0]
    38b0:	0f5b      	lsrs	r3, r3, #29
    38b2:	2b05      	cmp	r3, #5
    38b4:	d034      	beq.n	3920 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    38b6:	f10e 0e01 	add.w	lr, lr, #1
    38ba:	fa5f f38e 	uxtb.w	r3, lr
    38be:	429e      	cmp	r6, r3
    38c0:	d950      	bls.n	3964 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    38c2:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    38c6:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    38ca:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    38ce:	6813      	ldr	r3, [r2, #0]
    38d0:	0f5b      	lsrs	r3, r3, #29
    38d2:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    38d4:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    38d6:	d00d      	beq.n	38f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    38d8:	0f5b      	lsrs	r3, r3, #29
    38da:	2b02      	cmp	r3, #2
    38dc:	d1e7      	bne.n	38ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    38de:	f85c 3007 	ldr.w	r3, [ip, r7]
    38e2:	428b      	cmp	r3, r1
    38e4:	d8e7      	bhi.n	38b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    38e6:	f85c 3008 	ldr.w	r3, [ip, r8]
    38ea:	428b      	cmp	r3, r1
    38ec:	d3e3      	bcc.n	38b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    38ee:	2001      	movs	r0, #1
}
    38f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    38f4:	f413 7f60 	tst.w	r3, #896	; 0x380
    38f8:	d0dd      	beq.n	38b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    38fa:	006d      	lsls	r5, r5, #1
    38fc:	2300      	movs	r3, #0
    38fe:	e004      	b.n	390a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    3900:	6814      	ldr	r4, [r2, #0]
    3902:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3906:	4563      	cmp	r3, ip
    3908:	d2d5      	bcs.n	38b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    390a:	3301      	adds	r3, #1
    390c:	eb05 0c03 	add.w	ip, r5, r3
    3910:	b2db      	uxtb	r3, r3
    3912:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    3916:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    391a:	428c      	cmp	r4, r1
    391c:	d1f0      	bne.n	3900 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    391e:	e7e6      	b.n	38ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3920:	6813      	ldr	r3, [r2, #0]
    3922:	f413 7f60 	tst.w	r3, #896	; 0x380
    3926:	d0c6      	beq.n	38b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3928:	44cc      	add	ip, r9
    392a:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    392c:	2401      	movs	r4, #1
    392e:	e005      	b.n	393c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    3930:	6813      	ldr	r3, [r2, #0]
    3932:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    3936:	3301      	adds	r3, #1
    3938:	429c      	cmp	r4, r3
    393a:	d2bc      	bcs.n	38b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    393c:	192b      	adds	r3, r5, r4
    393e:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3942:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3944:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    3948:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    394c:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    394e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    3952:	f8dc b000 	ldr.w	fp, [ip]
    3956:	ea03 030b 	and.w	r3, r3, fp
    395a:	459a      	cmp	sl, r3
    395c:	d1e8      	bne.n	3930 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    395e:	e7c6      	b.n	38ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3960:	2001      	movs	r0, #1
}
    3962:	4770      	bx	lr
  return 0;
    3964:	2000      	movs	r0, #0
}
    3966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    396a:	bf00      	nop
    396c:	401d0000 	.word	0x401d0000

00003970 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3970:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    3974:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3976:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    397a:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    397e:	f8de 3000 	ldr.w	r3, [lr]
    3982:	00db      	lsls	r3, r3, #3
    3984:	d528      	bpl.n	39d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3986:	f8de 3000 	ldr.w	r3, [lr]
    398a:	0f5b      	lsrs	r3, r3, #29
    398c:	2b01      	cmp	r3, #1
    398e:	d00b      	beq.n	39a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3990:	f8de 3000 	ldr.w	r3, [lr]
    3994:	0f5b      	lsrs	r3, r3, #29
    3996:	2b02      	cmp	r3, #2
    3998:	d042      	beq.n	3a20 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    399a:	f8de 3000 	ldr.w	r3, [lr]
    399e:	0f5b      	lsrs	r3, r3, #29
    39a0:	2b05      	cmp	r3, #5
    39a2:	d01b      	beq.n	39dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
  return 0;
    39a4:	2000      	movs	r0, #0
}
    39a6:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    39a8:	f8de 4000 	ldr.w	r4, [lr]
    39ac:	f414 7f60 	tst.w	r4, #896	; 0x380
    39b0:	d0f8      	beq.n	39a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    39b2:	2300      	movs	r3, #0
    39b4:	004d      	lsls	r5, r1, #1
    39b6:	e005      	b.n	39c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    39b8:	f8de 1000 	ldr.w	r1, [lr]
    39bc:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    39c0:	4563      	cmp	r3, ip
    39c2:	d2ef      	bcs.n	39a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    39c4:	3301      	adds	r3, #1
    39c6:	eb05 0c03 	add.w	ip, r5, r3
    39ca:	b2db      	uxtb	r3, r3
    39cc:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    39d0:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    39d4:	4294      	cmp	r4, r2
    39d6:	d1ef      	bne.n	39b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    39d8:	2001      	movs	r0, #1
}
    39da:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    39dc:	f8de 5000 	ldr.w	r5, [lr]
    39e0:	f415 7f60 	tst.w	r5, #896	; 0x380
    39e4:	d0de      	beq.n	39a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    39e6:	f242 1514 	movw	r5, #8468	; 0x2114
    39ea:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    39ec:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    39ee:	4425      	add	r5, r4
    39f0:	e007      	b.n	3a02 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    39f2:	f8de 4000 	ldr.w	r4, [lr]
    39f6:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    39fa:	f10c 0c01 	add.w	ip, ip, #1
    39fe:	4563      	cmp	r3, ip
    3a00:	d2d0      	bcs.n	39a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3a02:	682c      	ldr	r4, [r5, #0]
    3a04:	ea04 0c02 	and.w	ip, r4, r2
    3a08:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3a0a:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3a0c:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3a10:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3a12:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    3a16:	682e      	ldr	r6, [r5, #0]
    3a18:	4034      	ands	r4, r6
    3a1a:	45a4      	cmp	ip, r4
    3a1c:	d1e9      	bne.n	39f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    3a1e:	e7db      	b.n	39d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    3a20:	f242 1304 	movw	r3, #8452	; 0x2104
    3a24:	58e3      	ldr	r3, [r4, r3]
    3a26:	4293      	cmp	r3, r2
    3a28:	d8bc      	bhi.n	39a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3a2a:	f242 1308 	movw	r3, #8456	; 0x2108
    3a2e:	58e0      	ldr	r0, [r4, r3]
    3a30:	4290      	cmp	r0, r2
    3a32:	bf34      	ite	cc
    3a34:	2000      	movcc	r0, #0
    3a36:	2001      	movcs	r0, #1
}
    3a38:	bd70      	pop	{r4, r5, r6, pc}
    3a3a:	bf00      	nop

00003a3c <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3a3c:	8843      	ldrh	r3, [r0, #2]
    3a3e:	f04f 0c1a 	mov.w	ip, #26
    3a42:	b2db      	uxtb	r3, r3
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    3a44:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3a46:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    3a4a:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3a4c:	2000      	movs	r0, #0
    3a4e:	f883 0106 	strb.w	r0, [r3, #262]	; 0x106
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    3a52:	8863      	ldrh	r3, [r4, #2]
    3a54:	b2db      	uxtb	r3, r3
    3a56:	fb0c 4303 	mla	r3, ip, r3, r4
    3a5a:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    3a5e:	8860      	ldrh	r0, [r4, #2]
    3a60:	b2c0      	uxtb	r0, r0
    3a62:	fb0c 4000 	mla	r0, ip, r0, r4
    3a66:	f500 7084 	add.w	r0, r0, #264	; 0x108
    3a6a:	f004 fea3 	bl	87b4 <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3a6e:	8862      	ldrh	r2, [r4, #2]
    3a70:	8823      	ldrh	r3, [r4, #0]
    3a72:	b292      	uxth	r2, r2
    3a74:	b29b      	uxth	r3, r3
    3a76:	f483 7380 	eor.w	r3, r3, #256	; 0x100
    3a7a:	429a      	cmp	r2, r3
    3a7c:	d104      	bne.n	3a88 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    3a7e:	8823      	ldrh	r3, [r4, #0]
    3a80:	3301      	adds	r3, #1
    3a82:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3a86:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    3a88:	8863      	ldrh	r3, [r4, #2]
    3a8a:	3301      	adds	r3, #1
    3a8c:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3a90:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    3a92:	88a3      	ldrh	r3, [r4, #4]
    3a94:	b29b      	uxth	r3, r3
    3a96:	2bff      	cmp	r3, #255	; 0xff
    3a98:	d803      	bhi.n	3aa2 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    3a9a:	88a3      	ldrh	r3, [r4, #4]
    3a9c:	3301      	adds	r3, #1
    3a9e:	b29b      	uxth	r3, r3
    3aa0:	80a3      	strh	r3, [r4, #4]
}
    3aa2:	bd10      	pop	{r4, pc}

00003aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    3aa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    3aa8:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    3aaa:	b08d      	sub	sp, #52	; 0x34
    3aac:	460e      	mov	r6, r1
    3aae:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    3ab0:	466c      	mov	r4, sp
    3ab2:	4605      	mov	r5, r0
    3ab4:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3ab8:	f04f 0901 	mov.w	r9, #1
    3abc:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 3b60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    3ac0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3ac4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3ac6:	e89c 0003 	ldmia.w	ip, {r0, r1}
    3aca:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    3ace:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    3ad2:	b15c      	cbz	r4, 3aec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3ad4:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    3ad8:	68a3      	ldr	r3, [r4, #8]
    3ada:	fa09 f102 	lsl.w	r1, r9, r2
    3ade:	4219      	tst	r1, r3
    3ae0:	d023      	beq.n	3b2a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    3ae2:	6823      	ldr	r3, [r4, #0]
    3ae4:	f8d3 b000 	ldr.w	fp, [r3]
    3ae8:	45d3      	cmp	fp, sl
    3aea:	d119      	bne.n	3b20 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    3aec:	4545      	cmp	r5, r8
    3aee:	d1ee      	bne.n	3ace <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    3af0:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    3af4:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    3af8:	b33b      	cbz	r3, 3b4a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    3afa:	6830      	ldr	r0, [r6, #0]
    3afc:	ac06      	add	r4, sp, #24
    3afe:	6871      	ldr	r1, [r6, #4]
    3b00:	68b2      	ldr	r2, [r6, #8]
    3b02:	68f3      	ldr	r3, [r6, #12]
    3b04:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3b06:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    3b08:	2218      	movs	r2, #24
    3b0a:	6971      	ldr	r1, [r6, #20]
    3b0c:	c403      	stmia	r4!, {r0, r1}
    3b0e:	eb0d 0102 	add.w	r1, sp, r2
    3b12:	f107 0014 	add.w	r0, r7, #20
    3b16:	f7ff ff91 	bl	3a3c <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    3b1a:	b00d      	add	sp, #52	; 0x34
    3b1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3b20:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3b24:	4669      	mov	r1, sp
    3b26:	4620      	mov	r0, r4
    3b28:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    3b2a:	7c23      	ldrb	r3, [r4, #16]
    3b2c:	2b00      	cmp	r3, #0
    3b2e:	d0dd      	beq.n	3aec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    3b30:	6823      	ldr	r3, [r4, #0]
    3b32:	f8d3 b000 	ldr.w	fp, [r3]
    3b36:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3b3a:	45d3      	cmp	fp, sl
    3b3c:	d0d6      	beq.n	3aec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    3b3e:	4620      	mov	r0, r4
    3b40:	f04f 32ff 	mov.w	r2, #4294967295
    3b44:	4669      	mov	r1, sp
    3b46:	47d8      	blx	fp
    3b48:	e7d0      	b.n	3aec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    3b4a:	7d33      	ldrb	r3, [r6, #20]
    3b4c:	4632      	mov	r2, r6
    3b4e:	a906      	add	r1, sp, #24
    3b50:	4638      	mov	r0, r7
    3b52:	f88d 3018 	strb.w	r3, [sp, #24]
    3b56:	f7ff f927 	bl	2da8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    3b5a:	b00d      	add	sp, #52	; 0x34
    3b5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3b60:	00000e9d 	.word	0x00000e9d

00003b64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  mb_filter_table[mb_num][4] = id4; // id4
  mb_filter_table[mb_num][5] = id5; // id5
}

FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
  if ( !distribution ) return; /* distribution not enabled */
    3b64:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    3b68:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    3b6c:	2b00      	cmp	r3, #0
    3b6e:	f000 80db 	beq.w	3d28 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  CAN_message_t frame = msg;

  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3b72:	f8df c26c 	ldr.w	ip, [pc, #620]	; 3de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    3b76:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    3b7a:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    3b7c:	b089      	sub	sp, #36	; 0x24
    3b7e:	4605      	mov	r5, r0
    3b80:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    3b82:	ac02      	add	r4, sp, #8
    3b84:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3b86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3b88:	e897 0003 	ldmia.w	r7, {r0, r1}
    3b8c:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3b90:	f8dc 3000 	ldr.w	r3, [ip]
    3b94:	009b      	lsls	r3, r3, #2
    3b96:	d552      	bpl.n	3c3e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3b98:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    3b9c:	2400      	movs	r4, #0
        }
      }
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
            frame.mb = FIFO;
    3b9e:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3ba2:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    3ba6:	4622      	mov	r2, r4
    3ba8:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    3bac:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3bb0:	e00c      	b.n	3bcc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3bb2:	0f5b      	lsrs	r3, r3, #29
    3bb4:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3bb6:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3bb8:	f000 809a 	beq.w	3cf0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    3bbc:	0f5b      	lsrs	r3, r3, #29
    3bbe:	2b05      	cmp	r3, #5
    3bc0:	f000 80dd 	beq.w	3d7e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3bc4:	3401      	adds	r4, #1
    3bc6:	b2e2      	uxtb	r2, r4
    3bc8:	4592      	cmp	sl, r2
    3bca:	d938      	bls.n	3c3e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    3bcc:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3bd0:	2b63      	cmp	r3, #99	; 0x63
    3bd2:	d034      	beq.n	3c3e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    3bd4:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    3bd8:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    3bdc:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    3be0:	683b      	ldr	r3, [r7, #0]
    3be2:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3be6:	d0ed      	beq.n	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3be8:	683b      	ldr	r3, [r7, #0]
    3bea:	0f5b      	lsrs	r3, r3, #29
    3bec:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3bee:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3bf0:	d1df      	bne.n	3bb2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3bf2:	f3c3 4300 	ubfx	r3, r3, #16, #1
    3bf6:	79f2      	ldrb	r2, [r6, #7]
    3bf8:	429a      	cmp	r2, r3
    3bfa:	d1e3      	bne.n	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3bfc:	683b      	ldr	r3, [r7, #0]
    3bfe:	f413 7f60 	tst.w	r3, #896	; 0x380
    3c02:	d0df      	beq.n	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    3c04:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3c08:	2300      	movs	r3, #0
    3c0a:	e006      	b.n	3c1a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    3c0c:	683a      	ldr	r2, [r7, #0]
    3c0e:	fa5f f388 	uxtb.w	r3, r8
    3c12:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    3c16:	4293      	cmp	r3, r2
    3c18:	d2d4      	bcs.n	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    3c1a:	f103 0801 	add.w	r8, r3, #1
    3c1e:	9a02      	ldr	r2, [sp, #8]
    3c20:	eb0b 0308 	add.w	r3, fp, r8
    3c24:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    3c28:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    3c2c:	429a      	cmp	r2, r3
    3c2e:	d1ed      	bne.n	3c0c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    3c30:	a902      	add	r1, sp, #8
    3c32:	4628      	mov	r0, r5
            frame.mb = FIFO;
    3c34:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    3c38:	f7ff ff34 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3c3c:	e7e6      	b.n	3c0c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
        }
      }
    } /* end of fifo scan */
  } /* end of fifo checking */

  frame.idhit = 0;
    3c3e:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3c40:	4f67      	ldr	r7, [pc, #412]	; (3de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    3c42:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3c46:	683c      	ldr	r4, [r7, #0]
    3c48:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    3c4c:	d03f      	beq.n	3cce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    3c4e:	f7fd fae7 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>

  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3c52:	683b      	ldr	r3, [r7, #0]
    3c54:	4604      	mov	r4, r0
    3c56:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3c5a:	3301      	adds	r3, #1
    3c5c:	4283      	cmp	r3, r0
    3c5e:	d933      	bls.n	3cc8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
          struct2queueRx(frame);
        }
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    3c60:	f242 1704 	movw	r7, #8452	; 0x2104
    3c64:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3c68:	f8df 9174 	ldr.w	r9, [pc, #372]	; 3de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    3c6c:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3c70:	42a3      	cmp	r3, r4
    3c72:	d020      	beq.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    3c74:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    3c78:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    3c7c:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    3c80:	f8da 3000 	ldr.w	r3, [sl]
    3c84:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3c88:	d015      	beq.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    3c8a:	f8da 3000 	ldr.w	r3, [sl]
    3c8e:	79f0      	ldrb	r0, [r6, #7]
    3c90:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    3c94:	4298      	cmp	r0, r3
    3c96:	d10e      	bne.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3c98:	f8da 3000 	ldr.w	r3, [sl]
    3c9c:	0f5b      	lsrs	r3, r3, #29
    3c9e:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3ca0:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3ca4:	d041      	beq.n	3d2a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3ca6:	0f5b      	lsrs	r3, r3, #29
    3ca8:	2b02      	cmp	r3, #2
    3caa:	d012      	beq.n	3cd2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    3cac:	f8da 3000 	ldr.w	r3, [sl]
    3cb0:	0f5b      	lsrs	r3, r3, #29
    3cb2:	2b05      	cmp	r3, #5
    3cb4:	d05b      	beq.n	3d6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3cb6:	f8d9 3000 	ldr.w	r3, [r9]
    3cba:	3401      	adds	r4, #1
    3cbc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3cc0:	b2e4      	uxtb	r4, r4
    3cc2:	3301      	adds	r3, #1
    3cc4:	429c      	cmp	r4, r3
    3cc6:	d3d1      	bcc.n	3c6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
  } /* end of mb scan */
}
    3cc8:	b009      	add	sp, #36	; 0x24
    3cca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3cce:	683b      	ldr	r3, [r7, #0]
    3cd0:	e7c6      	b.n	3c60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    3cd2:	59d1      	ldr	r1, [r2, r7]
    3cd4:	9b02      	ldr	r3, [sp, #8]
    3cd6:	428b      	cmp	r3, r1
    3cd8:	d3ed      	bcc.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3cda:	f852 2008 	ldr.w	r2, [r2, r8]
    3cde:	4293      	cmp	r3, r2
    3ce0:	d8e9      	bhi.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    3ce2:	a902      	add	r1, sp, #8
    3ce4:	4628      	mov	r0, r5
        frame.mb = i;
    3ce6:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    3cea:	f7ff fedb 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3cee:	e7e2      	b.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3cf0:	f3c3 4300 	ubfx	r3, r3, #16, #1
    3cf4:	79f2      	ldrb	r2, [r6, #7]
    3cf6:	429a      	cmp	r2, r3
    3cf8:	f47f af64 	bne.w	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    3cfc:	f641 6304 	movw	r3, #7684	; 0x1e04
    3d00:	f85b 2003 	ldr.w	r2, [fp, r3]
    3d04:	9b02      	ldr	r3, [sp, #8]
    3d06:	4293      	cmp	r3, r2
    3d08:	f4ff af5c 	bcc.w	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    3d0c:	f641 6208 	movw	r2, #7688	; 0x1e08
    3d10:	f85b 2002 	ldr.w	r2, [fp, r2]
    3d14:	4293      	cmp	r3, r2
    3d16:	f63f af55 	bhi.w	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    3d1a:	a902      	add	r1, sp, #8
    3d1c:	4628      	mov	r0, r5
          frame.mb = FIFO;
    3d1e:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    3d22:	f7ff febf 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3d26:	e74d      	b.n	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    3d28:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3d2a:	f413 7f60 	tst.w	r3, #896	; 0x380
    3d2e:	d0c2      	beq.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    3d30:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3d32:	2300      	movs	r3, #0
    3d34:	e007      	b.n	3d46 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    3d36:	f8da 1000 	ldr.w	r1, [sl]
    3d3a:	fa5f f38b 	uxtb.w	r3, fp
    3d3e:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    3d42:	428b      	cmp	r3, r1
    3d44:	d2b7      	bcs.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    3d46:	f103 0b01 	add.w	fp, r3, #1
    3d4a:	9902      	ldr	r1, [sp, #8]
    3d4c:	eb02 030b 	add.w	r3, r2, fp
    3d50:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    3d54:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    3d58:	4299      	cmp	r1, r3
    3d5a:	d1ec      	bne.n	3d36 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    3d5c:	a902      	add	r1, sp, #8
    3d5e:	4628      	mov	r0, r5
    3d60:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    3d62:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    3d66:	f7ff fe9d 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3d6a:	9a00      	ldr	r2, [sp, #0]
    3d6c:	e7e3      	b.n	3d36 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    3d6e:	9a02      	ldr	r2, [sp, #8]
    3d70:	4621      	mov	r1, r4
    3d72:	4628      	mov	r0, r5
    3d74:	f7ff fcd6 	bl	3724 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3d78:	2800      	cmp	r0, #0
    3d7a:	d09c      	beq.n	3cb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3d7c:	e7b1      	b.n	3ce2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3d7e:	683b      	ldr	r3, [r7, #0]
    3d80:	f413 7f60 	tst.w	r3, #896	; 0x380
    3d84:	f43f af1e 	beq.w	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3d88:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3d8c:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3d8e:	445b      	add	r3, fp
    3d90:	e00a      	b.n	3da8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3d92:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    3d96:	3701      	adds	r7, #1
    3d98:	6809      	ldr	r1, [r1, #0]
    3d9a:	b2ff      	uxtb	r7, r7
    3d9c:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    3da0:	3101      	adds	r1, #1
    3da2:	428f      	cmp	r7, r1
    3da4:	f4bf af0e 	bcs.w	3bc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3da8:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    3dac:	6818      	ldr	r0, [r3, #0]
    3dae:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    3db2:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    3db6:	9902      	ldr	r1, [sp, #8]
    3db8:	f8d3 c000 	ldr.w	ip, [r3]
    3dbc:	4008      	ands	r0, r1
    3dbe:	ea0e 010c 	and.w	r1, lr, ip
    3dc2:	4288      	cmp	r0, r1
    3dc4:	d1e5      	bne.n	3d92 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    3dc6:	a902      	add	r1, sp, #8
    3dc8:	4628      	mov	r0, r5
    3dca:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    3dcc:	f88d 200e 	strb.w	r2, [sp, #14]
    3dd0:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    3dd2:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    3dd6:	f7ff fe65 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3dda:	e9dd 2300 	ldrd	r2, r3, [sp]
    3dde:	e7d8      	b.n	3d92 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    3de0:	401d4000 	.word	0x401d4000

00003de4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3de4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    3de8:	4d94      	ldr	r5, [pc, #592]	; (403c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3dea:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3dec:	4f94      	ldr	r7, [pc, #592]	; (4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    3dee:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3df0:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    3df2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3df4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3df6:	e895 0003 	ldmia.w	r5, {r0, r1}
    3dfa:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3dfe:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    3e00:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3e02:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    3e06:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3e08:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3e0a:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3e0c:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3e10:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3e12:	d103      	bne.n	3e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    3e14:	683a      	ldr	r2, [r7, #0]
    3e16:	0094      	lsls	r4, r2, #2
    3e18:	f100 811a 	bmi.w	4050 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3e1c:	9b03      	ldr	r3, [sp, #12]
    3e1e:	f043 0301 	orr.w	r3, r3, #1
    3e22:	f1bb 0f00 	cmp.w	fp, #0
    3e26:	f000 8105 	beq.w	4034 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    3e2a:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3e2e:	4d84      	ldr	r5, [pc, #528]	; (4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3e30:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3e34:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3e36:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3e38:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3e3c:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3e3e:	f000 8284 	beq.w	434a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    3e42:	f7fd f9ed 	bl	1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3e46:	682b      	ldr	r3, [r5, #0]
    3e48:	4604      	mov	r4, r0
    3e4a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3e4e:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    3e50:	4283      	cmp	r3, r0
    3e52:	f240 80c2 	bls.w	3fda <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    3e56:	4287      	cmp	r7, r0
    3e58:	f240 80bf 	bls.w	3fda <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    3e5c:	9b04      	ldr	r3, [sp, #16]
    3e5e:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    3e60:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    3e64:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    3e68:	b2fd      	uxtb	r5, r7
    3e6a:	9305      	str	r3, [sp, #20]
    3e6c:	e018      	b.n	3ea0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    3e6e:	2a04      	cmp	r2, #4
    3e70:	f000 8162 	beq.w	4138 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3e74:	2a08      	cmp	r2, #8
    3e76:	f000 8203 	beq.w	4280 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3e7a:	f8d9 3000 	ldr.w	r3, [r9]
    3e7e:	b2fc      	uxtb	r4, r7
    3e80:	9a01      	ldr	r2, [sp, #4]
    3e82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3e86:	3301      	adds	r3, #1
    3e88:	42a2      	cmp	r2, r4
    3e8a:	bf88      	it	hi
    3e8c:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    3e8e:	f105 0501 	add.w	r5, r5, #1
    3e92:	bf94      	ite	ls
    3e94:	2301      	movls	r3, #1
    3e96:	2300      	movhi	r3, #0
    3e98:	2b00      	cmp	r3, #0
    3e9a:	f040 809e 	bne.w	3fda <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    3e9e:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    3ea0:	f1c4 0220 	rsb	r2, r4, #32
    3ea4:	9b02      	ldr	r3, [sp, #8]
    3ea6:	f1a4 0a20 	sub.w	sl, r4, #32
    3eaa:	fa06 f102 	lsl.w	r1, r6, r2
    3eae:	40e3      	lsrs	r3, r4
    3eb0:	430b      	orrs	r3, r1
    3eb2:	fa26 f10a 	lsr.w	r1, r6, sl
    3eb6:	430b      	orrs	r3, r1
    3eb8:	07d8      	lsls	r0, r3, #31
    3eba:	d5de      	bpl.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    3ebc:	9b03      	ldr	r3, [sp, #12]
    3ebe:	fa0b f202 	lsl.w	r2, fp, r2
    3ec2:	40e3      	lsrs	r3, r4
    3ec4:	4313      	orrs	r3, r2
    3ec6:	fa2b f20a 	lsr.w	r2, fp, sl
    3eca:	4313      	orrs	r3, r2
    3ecc:	07d9      	lsls	r1, r3, #31
    3ece:	d5d4      	bpl.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    3ed0:	f8df 8178 	ldr.w	r8, [pc, #376]	; 404c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    3ed4:	44a0      	add	r8, r4
    3ed6:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    3eda:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    3ede:	0e19      	lsrs	r1, r3, #24
    3ee0:	f3c3 6203 	ubfx	r2, r3, #24, #4
    3ee4:	f001 010b 	and.w	r1, r1, #11
    3ee8:	2902      	cmp	r1, #2
    3eea:	d1c0      	bne.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3eec:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    3ef0:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3ef4:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    3ef8:	2800      	cmp	r0, #0
    3efa:	bf12      	itee	ne
    3efc:	f04f 0c01 	movne.w	ip, #1
    3f00:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f04:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    3f06:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    3f08:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    3f0c:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    3f0e:	d102      	bne.n	3f16 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    3f10:	2201      	movs	r2, #1
    3f12:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    3f16:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    3f1a:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    3f1e:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3f22:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    3f24:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    3f28:	9b05      	ldr	r3, [sp, #20]
    3f2a:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    3f2e:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    3f32:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f36:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    3f3a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f3e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3f42:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    3f46:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f4a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3f4e:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    3f52:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3f56:	ea4f 6313 	mov.w	r3, r3, lsr #24
    3f5a:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    3f5e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f62:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    3f66:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f6a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    3f6e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    3f72:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f76:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3f7a:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    3f7e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    3f82:	ea4f 6313 	mov.w	r3, r3, lsr #24
    3f86:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3f8a:	bf14      	ite	ne
    3f8c:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    3f90:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3f94:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    3f96:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    3f9a:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3f9e:	f04f 0301 	mov.w	r3, #1
    3fa2:	d834      	bhi.n	400e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    3fa4:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    3fa8:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3faa:	4621      	mov	r1, r4
    3fac:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    3fae:	4313      	orrs	r3, r2
    3fb0:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    3fb4:	9a08      	ldr	r2, [sp, #32]
    3fb6:	f7ff fbb5 	bl	3724 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3fba:	2800      	cmp	r0, #0
    3fbc:	d135      	bne.n	402a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    3fbe:	a908      	add	r1, sp, #32
    3fc0:	9804      	ldr	r0, [sp, #16]
    3fc2:	f7ff fdcf 	bl	3b64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    3fc6:	a808      	add	r0, sp, #32
    3fc8:	f3af 8000 	nop.w
      ext_output2(msg);
    3fcc:	a808      	add	r0, sp, #32
    3fce:	f3af 8000 	nop.w
      ext_output3(msg);
    3fd2:	a808      	add	r0, sp, #32
    3fd4:	f3af 8000 	nop.w
    3fd8:	e74f      	b.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    3fda:	4e19      	ldr	r6, [pc, #100]	; (4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    3fdc:	4d19      	ldr	r5, [pc, #100]	; (4044 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    3fde:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    3fe0:	682a      	ldr	r2, [r5, #0]
    3fe2:	4b19      	ldr	r3, [pc, #100]	; (4048 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    3fe4:	4062      	eors	r2, r4
    3fe6:	4013      	ands	r3, r2
    3fe8:	b143      	cbz	r3, 3ffc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    3fea:	9b04      	ldr	r3, [sp, #16]
    3fec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    3ff0:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    3ff4:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    3ff6:	2b0f      	cmp	r3, #15
    3ff8:	f240 81a9 	bls.w	434e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    3ffc:	4a10      	ldr	r2, [pc, #64]	; (4040 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    3ffe:	6a13      	ldr	r3, [r2, #32]
    4000:	4323      	orrs	r3, r4
    4002:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    4004:	f3bf 8f4f 	dsb	sy
}
    4008:	b01b      	add	sp, #108	; 0x6c
    400a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    400e:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4012:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4016:	4621      	mov	r1, r4
    4018:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    401a:	4313      	orrs	r3, r2
    401c:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4020:	9a08      	ldr	r2, [sp, #32]
    4022:	f7ff fb7f 	bl	3724 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4026:	2800      	cmp	r0, #0
    4028:	d0c9      	beq.n	3fbe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    402a:	a908      	add	r1, sp, #32
    402c:	9804      	ldr	r0, [sp, #16]
    402e:	f7ff fd39 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4032:	e7c4      	b.n	3fbe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4034:	fab3 f383 	clz	r3, r3
    4038:	3320      	adds	r3, #32
    403a:	e6f8      	b.n	3e2e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    403c:	200003b0 	.word	0x200003b0
    4040:	401d4000 	.word	0x401d4000
    4044:	20007358 	.word	0x20007358
    4048:	0007ffbf 	.word	0x0007ffbf
    404c:	0401d408 	.word	0x0401d408
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    4050:	0689      	lsls	r1, r1, #26
    4052:	f57f aee3 	bpl.w	3e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    4056:	0682      	lsls	r2, r0, #26
    4058:	f57f aee0 	bpl.w	3e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    405c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4060:	4cc3      	ldr	r4, [pc, #780]	; (4370 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    4062:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    4066:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    406a:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    406e:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    4070:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    4074:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    4078:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    407c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    4080:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    4084:	bf18      	it	ne
    4086:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4088:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    408c:	bf08      	it	eq
    408e:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    4090:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    4094:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4098:	bf08      	it	eq
    409a:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    409c:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    40a0:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    40a2:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    40a4:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    40a8:	40d1      	lsrs	r1, r2
    40aa:	3208      	adds	r2, #8
    40ac:	2a20      	cmp	r2, #32
    40ae:	f800 1d01 	strb.w	r1, [r0, #-1]!
    40b2:	d1f7      	bne.n	40a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    40b4:	a80d      	add	r0, sp, #52	; 0x34
    40b6:	49ae      	ldr	r1, [pc, #696]	; (4370 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    40b8:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    40bc:	40da      	lsrs	r2, r3
    40be:	3308      	adds	r3, #8
    40c0:	2b20      	cmp	r3, #32
    40c2:	f800 2d01 	strb.w	r2, [r0, #-1]!
    40c6:	d1f7      	bne.n	40b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    40c8:	9b04      	ldr	r3, [sp, #16]
    40ca:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    40ce:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    40d2:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    40d6:	2363      	movs	r3, #99	; 0x63
    40d8:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    40dc:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    40de:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    40e0:	f043 0320 	orr.w	r3, r3, #32
    40e4:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    40e6:	9b03      	ldr	r3, [sp, #12]
    40e8:	065d      	lsls	r5, r3, #25
    40ea:	d503      	bpl.n	40f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    40ec:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    40ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    40f2:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    40f4:	9b03      	ldr	r3, [sp, #12]
    40f6:	061c      	lsls	r4, r3, #24
    40f8:	d504      	bpl.n	4104 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    40fa:	4a9d      	ldr	r2, [pc, #628]	; (4370 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    40fc:	6b13      	ldr	r3, [r2, #48]	; 0x30
    40fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4102:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    4104:	9c04      	ldr	r4, [sp, #16]
    4106:	a908      	add	r1, sp, #32
    4108:	4620      	mov	r0, r4
    410a:	f7ff fd2b 	bl	3b64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    410e:	a808      	add	r0, sp, #32
    4110:	f3af 8000 	nop.w
      ext_output2(msg);
    4114:	a808      	add	r0, sp, #32
    4116:	f3af 8000 	nop.w
      ext_output3(msg);
    411a:	a808      	add	r0, sp, #32
    411c:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    4120:	9908      	ldr	r1, [sp, #32]
    4122:	4620      	mov	r0, r4
    4124:	f7ff fa86 	bl	3634 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    4128:	2800      	cmp	r0, #0
    412a:	f43f ae77 	beq.w	3e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    412e:	a908      	add	r1, sp, #32
    4130:	9804      	ldr	r0, [sp, #16]
    4132:	f7ff fcb7 	bl	3aa4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4136:	e671      	b.n	3e1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4138:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    413c:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    413e:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4142:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4146:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    414a:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    414e:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4152:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4156:	bf18      	it	ne
    4158:	2101      	movne	r1, #1
      msg.bus = busNumber;
    415a:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    415c:	bf04      	itt	eq
    415e:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4160:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4162:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4166:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4168:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    416c:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4170:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4172:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4176:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    417a:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    417e:	0a1b      	lsrs	r3, r3, #8
    4180:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4184:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4188:	0c1b      	lsrs	r3, r3, #16
    418a:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    418e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4192:	0e1b      	lsrs	r3, r3, #24
    4194:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4198:	f8d8 300c 	ldr.w	r3, [r8, #12]
    419c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    41a0:	f8d8 300c 	ldr.w	r3, [r8, #12]
    41a4:	0a1b      	lsrs	r3, r3, #8
    41a6:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    41aa:	f8d8 300c 	ldr.w	r3, [r8, #12]
    41ae:	0c1b      	lsrs	r3, r3, #16
    41b0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    41b4:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    41b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    41bc:	f8d8 200c 	ldr.w	r2, [r8, #12]
    41c0:	0e12      	lsrs	r2, r2, #24
    41c2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    41c6:	b10b      	cbz	r3, 41cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    41c8:	a808      	add	r0, sp, #32
    41ca:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    41cc:	9b05      	ldr	r3, [sp, #20]
    41ce:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    41d2:	b10b      	cbz	r3, 41d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    41d4:	a808      	add	r0, sp, #32
    41d6:	4798      	blx	r3
    41d8:	9904      	ldr	r1, [sp, #16]
    41da:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    41de:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    41e2:	9207      	str	r2, [sp, #28]
    41e4:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    41e6:	2b00      	cmp	r3, #0
    41e8:	f000 80c4 	beq.w	4374 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    41ec:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    41f0:	221a      	movs	r2, #26
    41f2:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    41f6:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    41fa:	46e0      	mov	r8, ip
    41fc:	fb02 1303 	mla	r3, r2, r3, r1
    4200:	f641 3232 	movw	r2, #6962	; 0x1b32
    4204:	a90e      	add	r1, sp, #56	; 0x38
    4206:	eb03 0a02 	add.w	sl, r3, r2
    420a:	9106      	str	r1, [sp, #24]
    420c:	468e      	mov	lr, r1
    420e:	5898      	ldr	r0, [r3, r2]
    4210:	f8da 1004 	ldr.w	r1, [sl, #4]
    4214:	f8da 2008 	ldr.w	r2, [sl, #8]
    4218:	f8da 300c 	ldr.w	r3, [sl, #12]
    421c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    4220:	f8da 0010 	ldr.w	r0, [sl, #16]
    4224:	f8da 1014 	ldr.w	r1, [sl, #20]
    4228:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    422c:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    4230:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    4234:	e898 0003 	ldmia.w	r8, {r0, r1}
    4238:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    423c:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    4240:	1c5a      	adds	r2, r3, #1
    4242:	f000 80a6 	beq.w	4392 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    4246:	429c      	cmp	r4, r3
    4248:	f47f ae17 	bne.w	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    424c:	9a06      	ldr	r2, [sp, #24]
    424e:	b2e1      	uxtb	r1, r4
    4250:	9804      	ldr	r0, [sp, #16]
    4252:	f7fe fdcf 	bl	2df4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    4256:	9a07      	ldr	r2, [sp, #28]
    4258:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    425c:	3301      	adds	r3, #1
    425e:	f003 031f 	and.w	r3, r3, #31
    4262:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    4266:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    426a:	b29b      	uxth	r3, r3
    426c:	2b00      	cmp	r3, #0
    426e:	f43f ae04 	beq.w	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    4272:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4276:	3b01      	subs	r3, #1
    4278:	b29b      	uxth	r3, r3
    427a:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    427e:	e5fc      	b.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4280:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4284:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4286:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    428a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    428e:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4292:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4296:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    429a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    429e:	bf18      	it	ne
    42a0:	2101      	movne	r1, #1
      msg.bus = busNumber;
    42a2:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    42a4:	bf04      	itt	eq
    42a6:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    42a8:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    42aa:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    42ae:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    42b0:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    42b4:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    42b8:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    42ba:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    42be:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    42c2:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    42c6:	0a1b      	lsrs	r3, r3, #8
    42c8:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    42cc:	f8d8 3008 	ldr.w	r3, [r8, #8]
    42d0:	0c1b      	lsrs	r3, r3, #16
    42d2:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    42d6:	f8d8 3008 	ldr.w	r3, [r8, #8]
    42da:	0e1b      	lsrs	r3, r3, #24
    42dc:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    42e0:	f8d8 300c 	ldr.w	r3, [r8, #12]
    42e4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    42e8:	f8d8 300c 	ldr.w	r3, [r8, #12]
    42ec:	0a1b      	lsrs	r3, r3, #8
    42ee:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    42f2:	f8d8 300c 	ldr.w	r3, [r8, #12]
    42f6:	0c1b      	lsrs	r3, r3, #16
    42f8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    42fc:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4300:	0e1b      	lsrs	r3, r3, #24
    4302:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4306:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    430a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    430e:	b10b      	cbz	r3, 4314 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    4310:	a808      	add	r0, sp, #32
    4312:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4314:	9b05      	ldr	r3, [sp, #20]
    4316:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    431a:	b10b      	cbz	r3, 4320 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    431c:	a808      	add	r0, sp, #32
    431e:	4798      	blx	r3
        uint16_t size() { return _available; }
    4320:	9904      	ldr	r1, [sp, #16]
    4322:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4326:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    432a:	9207      	str	r2, [sp, #28]
    432c:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    432e:	2b00      	cmp	r3, #0
    4330:	f47f af5c 	bne.w	41ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4334:	2c1f      	cmp	r4, #31
    4336:	f04f 0301 	mov.w	r3, #1
    433a:	d835      	bhi.n	43a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    433c:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4340:	40a3      	lsls	r3, r4
    4342:	4313      	orrs	r3, r2
    4344:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    4348:	e597      	b.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    434a:	682b      	ldr	r3, [r5, #0]
    434c:	e586      	b.n	3e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    434e:	9f04      	ldr	r7, [sp, #16]
    4350:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    4354:	4621      	mov	r1, r4
    4356:	4438      	add	r0, r7
    4358:	f7ff fa4a 	bl	37f0 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    435c:	69f1      	ldr	r1, [r6, #28]
    435e:	f641 5098 	movw	r0, #7576	; 0x1d98
    4362:	b289      	uxth	r1, r1
    4364:	4438      	add	r0, r7
    4366:	f7ff fa67 	bl	3838 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    436a:	602c      	str	r4, [r5, #0]
    436c:	e646      	b.n	3ffc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    436e:	bf00      	nop
    4370:	401d4000 	.word	0x401d4000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4374:	2c1f      	cmp	r4, #31
    4376:	f04f 0301 	mov.w	r3, #1
    437a:	d80d      	bhi.n	4398 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    437c:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4380:	40a3      	lsls	r3, r4
    4382:	4313      	orrs	r3, r2
    4384:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4388:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    438c:	f8c8 3000 	str.w	r3, [r8]
    4390:	e573      	b.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    4392:	9a06      	ldr	r2, [sp, #24]
    4394:	4621      	mov	r1, r4
    4396:	e75b      	b.n	4250 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4398:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    439c:	fa03 f30a 	lsl.w	r3, r3, sl
    43a0:	4313      	orrs	r3, r2
    43a2:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    43a6:	e7ef      	b.n	4388 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    43a8:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    43ac:	fa03 f30a 	lsl.w	r3, r3, sl
    43b0:	4313      	orrs	r3, r2
    43b2:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    43b6:	e560      	b.n	3e7a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

000043b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    43b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    43bc:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    43be:	b08d      	sub	sp, #52	; 0x34
    43c0:	460e      	mov	r6, r1
    43c2:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    43c4:	466c      	mov	r4, sp
    43c6:	4605      	mov	r5, r0
    43c8:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    43cc:	f04f 0901 	mov.w	r9, #1
    43d0:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 4474 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    43d4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    43d8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    43da:	e89c 0003 	ldmia.w	ip, {r0, r1}
    43de:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    43e2:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    43e6:	b15c      	cbz	r4, 4400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    43e8:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    43ec:	68a3      	ldr	r3, [r4, #8]
    43ee:	fa09 f102 	lsl.w	r1, r9, r2
    43f2:	4219      	tst	r1, r3
    43f4:	d023      	beq.n	443e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    43f6:	6823      	ldr	r3, [r4, #0]
    43f8:	f8d3 b000 	ldr.w	fp, [r3]
    43fc:	45d3      	cmp	fp, sl
    43fe:	d119      	bne.n	4434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    4400:	4545      	cmp	r5, r8
    4402:	d1ee      	bne.n	43e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    4404:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    4408:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    440c:	b33b      	cbz	r3, 445e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    440e:	6830      	ldr	r0, [r6, #0]
    4410:	ac06      	add	r4, sp, #24
    4412:	6871      	ldr	r1, [r6, #4]
    4414:	68b2      	ldr	r2, [r6, #8]
    4416:	68f3      	ldr	r3, [r6, #12]
    4418:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    441a:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    441c:	2218      	movs	r2, #24
    441e:	6971      	ldr	r1, [r6, #20]
    4420:	c403      	stmia	r4!, {r0, r1}
    4422:	eb0d 0102 	add.w	r1, sp, r2
    4426:	f107 0014 	add.w	r0, r7, #20
    442a:	f7ff fb07 	bl	3a3c <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    442e:	b00d      	add	sp, #52	; 0x34
    4430:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    4434:	f89d 3015 	ldrb.w	r3, [sp, #21]
    4438:	4669      	mov	r1, sp
    443a:	4620      	mov	r0, r4
    443c:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    443e:	7c23      	ldrb	r3, [r4, #16]
    4440:	2b00      	cmp	r3, #0
    4442:	d0dd      	beq.n	4400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    4444:	6823      	ldr	r3, [r4, #0]
    4446:	f8d3 b000 	ldr.w	fp, [r3]
    444a:	f89d 3015 	ldrb.w	r3, [sp, #21]
    444e:	45d3      	cmp	fp, sl
    4450:	d0d6      	beq.n	4400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    4452:	4620      	mov	r0, r4
    4454:	f04f 32ff 	mov.w	r2, #4294967295
    4458:	4669      	mov	r1, sp
    445a:	47d8      	blx	fp
    445c:	e7d0      	b.n	4400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    445e:	7d33      	ldrb	r3, [r6, #20]
    4460:	4632      	mov	r2, r6
    4462:	a906      	add	r1, sp, #24
    4464:	4638      	mov	r0, r7
    4466:	f88d 3018 	strb.w	r3, [sp, #24]
    446a:	f7fe fb35 	bl	2ad8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    446e:	b00d      	add	sp, #52	; 0x34
    4470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4474:	00000e9d 	.word	0x00000e9d

00004478 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  if ( !distribution ) return; /* distribution not enabled */
    4478:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    447c:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    4480:	2b00      	cmp	r3, #0
    4482:	f000 80db 	beq.w	463c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    4486:	f8df c26c 	ldr.w	ip, [pc, #620]	; 46f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    448a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    448e:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    4490:	b089      	sub	sp, #36	; 0x24
    4492:	4605      	mov	r5, r0
    4494:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    4496:	ac02      	add	r4, sp, #8
    4498:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    449a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    449c:	e897 0003 	ldmia.w	r7, {r0, r1}
    44a0:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    44a4:	f8dc 3000 	ldr.w	r3, [ip]
    44a8:	009b      	lsls	r3, r3, #2
    44aa:	d552      	bpl.n	4552 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    44ac:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    44b0:	2400      	movs	r4, #0
            frame.mb = FIFO;
    44b2:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    44b6:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    44ba:	4622      	mov	r2, r4
    44bc:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    44c0:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    44c4:	e00c      	b.n	44e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    44c6:	0f5b      	lsrs	r3, r3, #29
    44c8:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    44ca:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    44cc:	f000 809a 	beq.w	4604 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    44d0:	0f5b      	lsrs	r3, r3, #29
    44d2:	2b05      	cmp	r3, #5
    44d4:	f000 80dd 	beq.w	4692 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    44d8:	3401      	adds	r4, #1
    44da:	b2e2      	uxtb	r2, r4
    44dc:	4592      	cmp	sl, r2
    44de:	d938      	bls.n	4552 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    44e0:	f996 3014 	ldrsb.w	r3, [r6, #20]
    44e4:	2b63      	cmp	r3, #99	; 0x63
    44e6:	d034      	beq.n	4552 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    44e8:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    44ec:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    44f0:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    44f4:	683b      	ldr	r3, [r7, #0]
    44f6:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    44fa:	d0ed      	beq.n	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    44fc:	683b      	ldr	r3, [r7, #0]
    44fe:	0f5b      	lsrs	r3, r3, #29
    4500:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4502:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4504:	d1df      	bne.n	44c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4506:	f3c3 4300 	ubfx	r3, r3, #16, #1
    450a:	79f2      	ldrb	r2, [r6, #7]
    450c:	429a      	cmp	r2, r3
    450e:	d1e3      	bne.n	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    4510:	683b      	ldr	r3, [r7, #0]
    4512:	f413 7f60 	tst.w	r3, #896	; 0x380
    4516:	d0df      	beq.n	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    4518:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    451c:	2300      	movs	r3, #0
    451e:	e006      	b.n	452e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    4520:	683a      	ldr	r2, [r7, #0]
    4522:	fa5f f388 	uxtb.w	r3, r8
    4526:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    452a:	4293      	cmp	r3, r2
    452c:	d2d4      	bcs.n	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    452e:	f103 0801 	add.w	r8, r3, #1
    4532:	9a02      	ldr	r2, [sp, #8]
    4534:	eb0b 0308 	add.w	r3, fp, r8
    4538:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    453c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    4540:	429a      	cmp	r2, r3
    4542:	d1ed      	bne.n	4520 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    4544:	a902      	add	r1, sp, #8
    4546:	4628      	mov	r0, r5
            frame.mb = FIFO;
    4548:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    454c:	f7ff ff34 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4550:	e7e6      	b.n	4520 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
  frame.idhit = 0;
    4552:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4554:	4f67      	ldr	r7, [pc, #412]	; (46f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    4556:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    455a:	683c      	ldr	r4, [r7, #0]
    455c:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    4560:	d03f      	beq.n	45e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    4562:	f7fc fe39 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    4566:	683b      	ldr	r3, [r7, #0]
    4568:	4604      	mov	r4, r0
    456a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    456e:	3301      	adds	r3, #1
    4570:	4283      	cmp	r3, r0
    4572:	d933      	bls.n	45dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    4574:	f242 1704 	movw	r7, #8452	; 0x2104
    4578:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    457c:	f8df 9174 	ldr.w	r9, [pc, #372]	; 46f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    4580:	f996 3014 	ldrsb.w	r3, [r6, #20]
    4584:	42a3      	cmp	r3, r4
    4586:	d020      	beq.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    4588:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    458c:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    4590:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    4594:	f8da 3000 	ldr.w	r3, [sl]
    4598:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    459c:	d015      	beq.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    459e:	f8da 3000 	ldr.w	r3, [sl]
    45a2:	79f0      	ldrb	r0, [r6, #7]
    45a4:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    45a8:	4298      	cmp	r0, r3
    45aa:	d10e      	bne.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    45ac:	f8da 3000 	ldr.w	r3, [sl]
    45b0:	0f5b      	lsrs	r3, r3, #29
    45b2:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    45b4:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    45b8:	d041      	beq.n	463e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    45ba:	0f5b      	lsrs	r3, r3, #29
    45bc:	2b02      	cmp	r3, #2
    45be:	d012      	beq.n	45e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    45c0:	f8da 3000 	ldr.w	r3, [sl]
    45c4:	0f5b      	lsrs	r3, r3, #29
    45c6:	2b05      	cmp	r3, #5
    45c8:	d05b      	beq.n	4682 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    45ca:	f8d9 3000 	ldr.w	r3, [r9]
    45ce:	3401      	adds	r4, #1
    45d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    45d4:	b2e4      	uxtb	r4, r4
    45d6:	3301      	adds	r3, #1
    45d8:	429c      	cmp	r4, r3
    45da:	d3d1      	bcc.n	4580 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
}
    45dc:	b009      	add	sp, #36	; 0x24
    45de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    45e2:	683b      	ldr	r3, [r7, #0]
    45e4:	e7c6      	b.n	4574 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    45e6:	59d1      	ldr	r1, [r2, r7]
    45e8:	9b02      	ldr	r3, [sp, #8]
    45ea:	428b      	cmp	r3, r1
    45ec:	d3ed      	bcc.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    45ee:	f852 2008 	ldr.w	r2, [r2, r8]
    45f2:	4293      	cmp	r3, r2
    45f4:	d8e9      	bhi.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    45f6:	a902      	add	r1, sp, #8
    45f8:	4628      	mov	r0, r5
        frame.mb = i;
    45fa:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    45fe:	f7ff fedb 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4602:	e7e2      	b.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4604:	f3c3 4300 	ubfx	r3, r3, #16, #1
    4608:	79f2      	ldrb	r2, [r6, #7]
    460a:	429a      	cmp	r2, r3
    460c:	f47f af64 	bne.w	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    4610:	f641 6304 	movw	r3, #7684	; 0x1e04
    4614:	f85b 2003 	ldr.w	r2, [fp, r3]
    4618:	9b02      	ldr	r3, [sp, #8]
    461a:	4293      	cmp	r3, r2
    461c:	f4ff af5c 	bcc.w	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    4620:	f641 6208 	movw	r2, #7688	; 0x1e08
    4624:	f85b 2002 	ldr.w	r2, [fp, r2]
    4628:	4293      	cmp	r3, r2
    462a:	f63f af55 	bhi.w	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    462e:	a902      	add	r1, sp, #8
    4630:	4628      	mov	r0, r5
          frame.mb = FIFO;
    4632:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    4636:	f7ff febf 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    463a:	e74d      	b.n	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    463c:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    463e:	f413 7f60 	tst.w	r3, #896	; 0x380
    4642:	d0c2      	beq.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    4644:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    4646:	2300      	movs	r3, #0
    4648:	e007      	b.n	465a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    464a:	f8da 1000 	ldr.w	r1, [sl]
    464e:	fa5f f38b 	uxtb.w	r3, fp
    4652:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    4656:	428b      	cmp	r3, r1
    4658:	d2b7      	bcs.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    465a:	f103 0b01 	add.w	fp, r3, #1
    465e:	9902      	ldr	r1, [sp, #8]
    4660:	eb02 030b 	add.w	r3, r2, fp
    4664:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    4668:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    466c:	4299      	cmp	r1, r3
    466e:	d1ec      	bne.n	464a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    4670:	a902      	add	r1, sp, #8
    4672:	4628      	mov	r0, r5
    4674:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    4676:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    467a:	f7ff fe9d 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    467e:	9a00      	ldr	r2, [sp, #0]
    4680:	e7e3      	b.n	464a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    4682:	9a02      	ldr	r2, [sp, #8]
    4684:	4621      	mov	r1, r4
    4686:	4628      	mov	r0, r5
    4688:	f7ff f972 	bl	3970 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    468c:	2800      	cmp	r0, #0
    468e:	d09c      	beq.n	45ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    4690:	e7b1      	b.n	45f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    4692:	683b      	ldr	r3, [r7, #0]
    4694:	f413 7f60 	tst.w	r3, #896	; 0x380
    4698:	f43f af1e 	beq.w	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    469c:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    46a0:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    46a2:	445b      	add	r3, fp
    46a4:	e00a      	b.n	46bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    46a6:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    46aa:	3701      	adds	r7, #1
    46ac:	6809      	ldr	r1, [r1, #0]
    46ae:	b2ff      	uxtb	r7, r7
    46b0:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    46b4:	3101      	adds	r1, #1
    46b6:	428f      	cmp	r7, r1
    46b8:	f4bf af0e 	bcs.w	44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    46bc:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    46c0:	6818      	ldr	r0, [r3, #0]
    46c2:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    46c6:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    46ca:	9902      	ldr	r1, [sp, #8]
    46cc:	f8d3 c000 	ldr.w	ip, [r3]
    46d0:	4008      	ands	r0, r1
    46d2:	ea0e 010c 	and.w	r1, lr, ip
    46d6:	4288      	cmp	r0, r1
    46d8:	d1e5      	bne.n	46a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    46da:	a902      	add	r1, sp, #8
    46dc:	4628      	mov	r0, r5
    46de:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    46e0:	f88d 200e 	strb.w	r2, [sp, #14]
    46e4:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    46e6:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    46ea:	f7ff fe65 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    46ee:	e9dd 2300 	ldrd	r2, r3, [sp]
    46f2:	e7d8      	b.n	46a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    46f4:	401d0000 	.word	0x401d0000

000046f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    46f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    46fc:	4d94      	ldr	r5, [pc, #592]	; (4950 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    46fe:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    4700:	4f94      	ldr	r7, [pc, #592]	; (4954 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    4702:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    4704:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    4706:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    4708:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    470a:	e895 0003 	ldmia.w	r5, {r0, r1}
    470e:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    4712:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    4714:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    4716:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    471a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    471c:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    471e:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    4720:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    4724:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    4726:	d103      	bne.n	4730 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    4728:	683a      	ldr	r2, [r7, #0]
    472a:	0094      	lsls	r4, r2, #2
    472c:	f100 811a 	bmi.w	4964 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4730:	9b03      	ldr	r3, [sp, #12]
    4732:	f043 0301 	orr.w	r3, r3, #1
    4736:	f1bb 0f00 	cmp.w	fp, #0
    473a:	f000 8105 	beq.w	4948 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    473e:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4742:	4d84      	ldr	r5, [pc, #528]	; (4954 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4744:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4748:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    474a:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    474c:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4750:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4752:	f000 8284 	beq.w	4c5e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    4756:	f7fc fd3f 	bl	11d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    475a:	682b      	ldr	r3, [r5, #0]
    475c:	4604      	mov	r4, r0
    475e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4762:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    4764:	4283      	cmp	r3, r0
    4766:	f240 80c2 	bls.w	48ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    476a:	4287      	cmp	r7, r0
    476c:	f240 80bf 	bls.w	48ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    4770:	9b04      	ldr	r3, [sp, #16]
    4772:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4774:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4954 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    4778:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    477c:	b2fd      	uxtb	r5, r7
    477e:	9305      	str	r3, [sp, #20]
    4780:	e018      	b.n	47b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    4782:	2a04      	cmp	r2, #4
    4784:	f000 8162 	beq.w	4a4c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    4788:	2a08      	cmp	r2, #8
    478a:	f000 8203 	beq.w	4b94 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    478e:	f8d9 3000 	ldr.w	r3, [r9]
    4792:	b2fc      	uxtb	r4, r7
    4794:	9a01      	ldr	r2, [sp, #4]
    4796:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    479a:	3301      	adds	r3, #1
    479c:	42a2      	cmp	r2, r4
    479e:	bf88      	it	hi
    47a0:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    47a2:	f105 0501 	add.w	r5, r5, #1
    47a6:	bf94      	ite	ls
    47a8:	2301      	movls	r3, #1
    47aa:	2300      	movhi	r3, #0
    47ac:	2b00      	cmp	r3, #0
    47ae:	f040 809e 	bne.w	48ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    47b2:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    47b4:	f1c4 0220 	rsb	r2, r4, #32
    47b8:	9b02      	ldr	r3, [sp, #8]
    47ba:	f1a4 0a20 	sub.w	sl, r4, #32
    47be:	fa06 f102 	lsl.w	r1, r6, r2
    47c2:	40e3      	lsrs	r3, r4
    47c4:	430b      	orrs	r3, r1
    47c6:	fa26 f10a 	lsr.w	r1, r6, sl
    47ca:	430b      	orrs	r3, r1
    47cc:	07d8      	lsls	r0, r3, #31
    47ce:	d5de      	bpl.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    47d0:	9b03      	ldr	r3, [sp, #12]
    47d2:	fa0b f202 	lsl.w	r2, fp, r2
    47d6:	40e3      	lsrs	r3, r4
    47d8:	4313      	orrs	r3, r2
    47da:	fa2b f20a 	lsr.w	r2, fp, sl
    47de:	4313      	orrs	r3, r2
    47e0:	07d9      	lsls	r1, r3, #31
    47e2:	d5d4      	bpl.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    47e4:	f8df 8178 	ldr.w	r8, [pc, #376]	; 4960 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    47e8:	44a0      	add	r8, r4
    47ea:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    47ee:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    47f2:	0e19      	lsrs	r1, r3, #24
    47f4:	f3c3 6203 	ubfx	r2, r3, #24, #4
    47f8:	f001 010b 	and.w	r1, r1, #11
    47fc:	2902      	cmp	r1, #2
    47fe:	d1c0      	bne.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4800:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4804:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4808:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    480c:	2800      	cmp	r0, #0
    480e:	bf12      	itee	ne
    4810:	f04f 0c01 	movne.w	ip, #1
    4814:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4818:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    481a:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    481c:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4820:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    4822:	d102      	bne.n	482a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    4824:	2201      	movs	r2, #1
    4826:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    482a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    482e:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4832:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    4836:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    4838:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    483c:	9b05      	ldr	r3, [sp, #20]
    483e:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    4842:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4846:	f8d8 3008 	ldr.w	r3, [r8, #8]
    484a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    484e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4852:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4856:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    485a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    485e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4862:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4866:	f8d8 3008 	ldr.w	r3, [r8, #8]
    486a:	ea4f 6313 	mov.w	r3, r3, lsr #24
    486e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4872:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4876:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    487a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    487e:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4882:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4886:	f8d8 300c 	ldr.w	r3, [r8, #12]
    488a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    488e:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4892:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4896:	ea4f 6313 	mov.w	r3, r3, lsr #24
    489a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    489e:	bf14      	ite	ne
    48a0:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    48a4:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    48a8:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    48aa:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    48ae:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    48b2:	f04f 0301 	mov.w	r3, #1
    48b6:	d834      	bhi.n	4922 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    48b8:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    48bc:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    48be:	4621      	mov	r1, r4
    48c0:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    48c2:	4313      	orrs	r3, r2
    48c4:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    48c8:	9a08      	ldr	r2, [sp, #32]
    48ca:	f7ff f851 	bl	3970 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    48ce:	2800      	cmp	r0, #0
    48d0:	d135      	bne.n	493e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    48d2:	a908      	add	r1, sp, #32
    48d4:	9804      	ldr	r0, [sp, #16]
    48d6:	f7ff fdcf 	bl	4478 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    48da:	a808      	add	r0, sp, #32
    48dc:	f3af 8000 	nop.w
      ext_output2(msg);
    48e0:	a808      	add	r0, sp, #32
    48e2:	f3af 8000 	nop.w
      ext_output3(msg);
    48e6:	a808      	add	r0, sp, #32
    48e8:	f3af 8000 	nop.w
    48ec:	e74f      	b.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    48ee:	4e19      	ldr	r6, [pc, #100]	; (4954 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    48f0:	4d19      	ldr	r5, [pc, #100]	; (4958 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    48f2:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    48f4:	682a      	ldr	r2, [r5, #0]
    48f6:	4b19      	ldr	r3, [pc, #100]	; (495c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    48f8:	4062      	eors	r2, r4
    48fa:	4013      	ands	r3, r2
    48fc:	b143      	cbz	r3, 4910 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    48fe:	9b04      	ldr	r3, [sp, #16]
    4900:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    4904:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    4908:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    490a:	2b0f      	cmp	r3, #15
    490c:	f240 81a9 	bls.w	4c62 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    4910:	4a10      	ldr	r2, [pc, #64]	; (4954 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    4912:	6a13      	ldr	r3, [r2, #32]
    4914:	4323      	orrs	r3, r4
    4916:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    4918:	f3bf 8f4f 	dsb	sy
}
    491c:	b01b      	add	sp, #108	; 0x6c
    491e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4922:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4926:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    492a:	4621      	mov	r1, r4
    492c:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    492e:	4313      	orrs	r3, r2
    4930:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4934:	9a08      	ldr	r2, [sp, #32]
    4936:	f7ff f81b 	bl	3970 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    493a:	2800      	cmp	r0, #0
    493c:	d0c9      	beq.n	48d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    493e:	a908      	add	r1, sp, #32
    4940:	9804      	ldr	r0, [sp, #16]
    4942:	f7ff fd39 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4946:	e7c4      	b.n	48d2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4948:	fab3 f383 	clz	r3, r3
    494c:	3320      	adds	r3, #32
    494e:	e6f8      	b.n	4742 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    4950:	200003b0 	.word	0x200003b0
    4954:	401d0000 	.word	0x401d0000
    4958:	20007354 	.word	0x20007354
    495c:	0007ffbf 	.word	0x0007ffbf
    4960:	0401d008 	.word	0x0401d008
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    4964:	0689      	lsls	r1, r1, #26
    4966:	f57f aee3 	bpl.w	4730 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    496a:	0682      	lsls	r2, r0, #26
    496c:	f57f aee0 	bpl.w	4730 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    4970:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4974:	4cc3      	ldr	r4, [pc, #780]	; (4c84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    4976:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    497a:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    497e:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    4982:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    4984:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    4988:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    498c:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4990:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    4994:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    4998:	bf18      	it	ne
    499a:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    499c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    49a0:	bf08      	it	eq
    49a2:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    49a4:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    49a8:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    49ac:	bf08      	it	eq
    49ae:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    49b0:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    49b4:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    49b6:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    49b8:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    49bc:	40d1      	lsrs	r1, r2
    49be:	3208      	adds	r2, #8
    49c0:	2a20      	cmp	r2, #32
    49c2:	f800 1d01 	strb.w	r1, [r0, #-1]!
    49c6:	d1f7      	bne.n	49b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    49c8:	a80d      	add	r0, sp, #52	; 0x34
    49ca:	49ae      	ldr	r1, [pc, #696]	; (4c84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    49cc:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    49d0:	40da      	lsrs	r2, r3
    49d2:	3308      	adds	r3, #8
    49d4:	2b20      	cmp	r3, #32
    49d6:	f800 2d01 	strb.w	r2, [r0, #-1]!
    49da:	d1f7      	bne.n	49cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    49dc:	9b04      	ldr	r3, [sp, #16]
    49de:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    49e2:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    49e6:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    49ea:	2363      	movs	r3, #99	; 0x63
    49ec:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    49f0:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    49f2:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    49f4:	f043 0320 	orr.w	r3, r3, #32
    49f8:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    49fa:	9b03      	ldr	r3, [sp, #12]
    49fc:	065d      	lsls	r5, r3, #25
    49fe:	d503      	bpl.n	4a08 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4a00:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4a02:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4a06:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    4a08:	9b03      	ldr	r3, [sp, #12]
    4a0a:	061c      	lsls	r4, r3, #24
    4a0c:	d504      	bpl.n	4a18 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4a0e:	4a9d      	ldr	r2, [pc, #628]	; (4c84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    4a10:	6b13      	ldr	r3, [r2, #48]	; 0x30
    4a12:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4a16:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    4a18:	9c04      	ldr	r4, [sp, #16]
    4a1a:	a908      	add	r1, sp, #32
    4a1c:	4620      	mov	r0, r4
    4a1e:	f7ff fd2b 	bl	4478 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    4a22:	a808      	add	r0, sp, #32
    4a24:	f3af 8000 	nop.w
      ext_output2(msg);
    4a28:	a808      	add	r0, sp, #32
    4a2a:	f3af 8000 	nop.w
      ext_output3(msg);
    4a2e:	a808      	add	r0, sp, #32
    4a30:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    4a34:	9908      	ldr	r1, [sp, #32]
    4a36:	4620      	mov	r0, r4
    4a38:	f7fe ff22 	bl	3880 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    4a3c:	2800      	cmp	r0, #0
    4a3e:	f43f ae77 	beq.w	4730 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    4a42:	a908      	add	r1, sp, #32
    4a44:	9804      	ldr	r0, [sp, #16]
    4a46:	f7ff fcb7 	bl	43b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4a4a:	e671      	b.n	4730 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4a4c:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4a50:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4a52:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4a56:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4a5a:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4a5e:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4a62:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4a66:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4a6a:	bf18      	it	ne
    4a6c:	2101      	movne	r1, #1
      msg.bus = busNumber;
    4a6e:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4a70:	bf04      	itt	eq
    4a72:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4a74:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4a76:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4a7a:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4a7c:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4a80:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4a84:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4a86:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4a8a:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4a8e:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4a92:	0a1b      	lsrs	r3, r3, #8
    4a94:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4a98:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4a9c:	0c1b      	lsrs	r3, r3, #16
    4a9e:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4aa2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4aa6:	0e1b      	lsrs	r3, r3, #24
    4aa8:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4aac:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4ab0:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4ab4:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4ab8:	0a1b      	lsrs	r3, r3, #8
    4aba:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4abe:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4ac2:	0c1b      	lsrs	r3, r3, #16
    4ac4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4ac8:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    4acc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4ad0:	f8d8 200c 	ldr.w	r2, [r8, #12]
    4ad4:	0e12      	lsrs	r2, r2, #24
    4ad6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4ada:	b10b      	cbz	r3, 4ae0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    4adc:	a808      	add	r0, sp, #32
    4ade:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4ae0:	9b05      	ldr	r3, [sp, #20]
    4ae2:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    4ae6:	b10b      	cbz	r3, 4aec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    4ae8:	a808      	add	r0, sp, #32
    4aea:	4798      	blx	r3
    4aec:	9904      	ldr	r1, [sp, #16]
    4aee:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4af2:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4af6:	9207      	str	r2, [sp, #28]
    4af8:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    4afa:	2b00      	cmp	r3, #0
    4afc:	f000 80c4 	beq.w	4c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    4b00:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4b04:	221a      	movs	r2, #26
    4b06:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    4b0a:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    4b0e:	46e0      	mov	r8, ip
    4b10:	fb02 1303 	mla	r3, r2, r3, r1
    4b14:	f641 3232 	movw	r2, #6962	; 0x1b32
    4b18:	a90e      	add	r1, sp, #56	; 0x38
    4b1a:	eb03 0a02 	add.w	sl, r3, r2
    4b1e:	9106      	str	r1, [sp, #24]
    4b20:	468e      	mov	lr, r1
    4b22:	5898      	ldr	r0, [r3, r2]
    4b24:	f8da 1004 	ldr.w	r1, [sl, #4]
    4b28:	f8da 2008 	ldr.w	r2, [sl, #8]
    4b2c:	f8da 300c 	ldr.w	r3, [sl, #12]
    4b30:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    4b34:	f8da 0010 	ldr.w	r0, [sl, #16]
    4b38:	f8da 1014 	ldr.w	r1, [sl, #20]
    4b3c:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    4b40:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    4b44:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    4b48:	e898 0003 	ldmia.w	r8, {r0, r1}
    4b4c:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    4b50:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    4b54:	1c5a      	adds	r2, r3, #1
    4b56:	f000 80a6 	beq.w	4ca6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    4b5a:	429c      	cmp	r4, r3
    4b5c:	f47f ae17 	bne.w	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    4b60:	9a06      	ldr	r2, [sp, #24]
    4b62:	b2e1      	uxtb	r1, r4
    4b64:	9804      	ldr	r0, [sp, #16]
    4b66:	f7fd ffdd 	bl	2b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    4b6a:	9a07      	ldr	r2, [sp, #28]
    4b6c:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4b70:	3301      	adds	r3, #1
    4b72:	f003 031f 	and.w	r3, r3, #31
    4b76:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    4b7a:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4b7e:	b29b      	uxth	r3, r3
    4b80:	2b00      	cmp	r3, #0
    4b82:	f43f ae04 	beq.w	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    4b86:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4b8a:	3b01      	subs	r3, #1
    4b8c:	b29b      	uxth	r3, r3
    4b8e:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4b92:	e5fc      	b.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4b94:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4b98:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4b9a:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4b9e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4ba2:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4ba6:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4baa:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4bae:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4bb2:	bf18      	it	ne
    4bb4:	2101      	movne	r1, #1
      msg.bus = busNumber;
    4bb6:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4bb8:	bf04      	itt	eq
    4bba:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4bbc:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4bbe:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4bc2:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4bc4:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4bc8:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4bcc:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4bce:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4bd2:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4bd6:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4bda:	0a1b      	lsrs	r3, r3, #8
    4bdc:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4be0:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4be4:	0c1b      	lsrs	r3, r3, #16
    4be6:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4bea:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4bee:	0e1b      	lsrs	r3, r3, #24
    4bf0:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4bf4:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4bf8:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4bfc:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4c00:	0a1b      	lsrs	r3, r3, #8
    4c02:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4c06:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4c0a:	0c1b      	lsrs	r3, r3, #16
    4c0c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4c10:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4c14:	0e1b      	lsrs	r3, r3, #24
    4c16:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4c1a:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    4c1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4c22:	b10b      	cbz	r3, 4c28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    4c24:	a808      	add	r0, sp, #32
    4c26:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4c28:	9b05      	ldr	r3, [sp, #20]
    4c2a:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    4c2e:	b10b      	cbz	r3, 4c34 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    4c30:	a808      	add	r0, sp, #32
    4c32:	4798      	blx	r3
        uint16_t size() { return _available; }
    4c34:	9904      	ldr	r1, [sp, #16]
    4c36:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4c3a:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4c3e:	9207      	str	r2, [sp, #28]
    4c40:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    4c42:	2b00      	cmp	r3, #0
    4c44:	f47f af5c 	bne.w	4b00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4c48:	2c1f      	cmp	r4, #31
    4c4a:	f04f 0301 	mov.w	r3, #1
    4c4e:	d835      	bhi.n	4cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    4c50:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4c54:	40a3      	lsls	r3, r4
    4c56:	4313      	orrs	r3, r2
    4c58:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    4c5c:	e597      	b.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4c5e:	682b      	ldr	r3, [r5, #0]
    4c60:	e586      	b.n	4770 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    4c62:	9f04      	ldr	r7, [sp, #16]
    4c64:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    4c68:	4621      	mov	r1, r4
    4c6a:	4438      	add	r0, r7
    4c6c:	f7fe fdc0 	bl	37f0 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    4c70:	69f1      	ldr	r1, [r6, #28]
    4c72:	f641 5098 	movw	r0, #7576	; 0x1d98
    4c76:	b289      	uxth	r1, r1
    4c78:	4438      	add	r0, r7
    4c7a:	f7fe fddd 	bl	3838 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    4c7e:	602c      	str	r4, [r5, #0]
    4c80:	e646      	b.n	4910 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    4c82:	bf00      	nop
    4c84:	401d0000 	.word	0x401d0000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4c88:	2c1f      	cmp	r4, #31
    4c8a:	f04f 0301 	mov.w	r3, #1
    4c8e:	d80d      	bhi.n	4cac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    4c90:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4c94:	40a3      	lsls	r3, r4
    4c96:	4313      	orrs	r3, r2
    4c98:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4c9c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    4ca0:	f8c8 3000 	str.w	r3, [r8]
    4ca4:	e573      	b.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    4ca6:	9a06      	ldr	r2, [sp, #24]
    4ca8:	4621      	mov	r1, r4
    4caa:	e75b      	b.n	4b64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4cac:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4cb0:	fa03 f30a 	lsl.w	r3, r3, sl
    4cb4:	4313      	orrs	r3, r2
    4cb6:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4cba:	e7ef      	b.n	4c9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4cbc:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4cc0:	fa03 f30a 	lsl.w	r3, r3, sl
    4cc4:	4313      	orrs	r3, r2
    4cc6:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4cca:	e560      	b.n	478e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

00004ccc <_GLOBAL__sub_I_HaldexCAN>:
}
    4ccc:	b538      	push	{r3, r4, r5, lr}
    4cce:	f001 f8a3 	bl	5e18 <eeprom_initialize>
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4cd2:	4829      	ldr	r0, [pc, #164]	; (4d78 <_GLOBAL__sub_I_HaldexCAN+0xac>)
    4cd4:	4929      	ldr	r1, [pc, #164]	; (4d7c <_GLOBAL__sub_I_HaldexCAN+0xb0>)
class Circular_Buffer {
    4cd6:	2300      	movs	r3, #0
    4cd8:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
  if ( _bus == CAN1 ) _CAN1 = this;
    4cdc:	4c28      	ldr	r4, [pc, #160]	; (4d80 <_GLOBAL__sub_I_HaldexCAN+0xb4>)
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4cde:	6001      	str	r1, [r0, #0]
    4ce0:	f500 5c00 	add.w	ip, r0, #8192	; 0x2000
    4ce4:	4927      	ldr	r1, [pc, #156]	; (4d84 <_GLOBAL__sub_I_HaldexCAN+0xb8>)
    4ce6:	8283      	strh	r3, [r0, #20]
  if ( _bus == CAN1 ) _CAN1 = this;
    4ce8:	6020      	str	r0, [r4, #0]
    4cea:	82c3      	strh	r3, [r0, #22]
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4cec:	4d26      	ldr	r5, [pc, #152]	; (4d88 <_GLOBAL__sub_I_HaldexCAN+0xbc>)
    4cee:	8303      	strh	r3, [r0, #24]
    4cf0:	f501 5000 	add.w	r0, r1, #8192	; 0x2000
    4cf4:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
  if ( _bus == CAN2 ) _CAN2 = this;
    4cf8:	4c24      	ldr	r4, [pc, #144]	; (4d8c <_GLOBAL__sub_I_HaldexCAN+0xc0>)
    4cfa:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    4cfe:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4d02:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    4d06:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    4d0a:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    4d0e:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    4d12:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    4d16:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    4d1a:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4d1e:	f88c 3700 	strb.w	r3, [ip, #1792]	; 0x700
    4d22:	f8cc 390c 	str.w	r3, [ip, #2316]	; 0x90c
    4d26:	f88c 3701 	strb.w	r3, [ip, #1793]	; 0x701
    4d2a:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
    4d2e:	828b      	strh	r3, [r1, #20]
    4d30:	f88c 3914 	strb.w	r3, [ip, #2324]	; 0x914
    4d34:	82cb      	strh	r3, [r1, #22]
    4d36:	600d      	str	r5, [r1, #0]
    4d38:	830b      	strh	r3, [r1, #24]
    4d3a:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    4d3e:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    4d42:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4d46:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    4d4a:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    4d4e:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    4d52:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    4d56:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    4d5a:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    4d5e:	f880 3700 	strb.w	r3, [r0, #1792]	; 0x700
    4d62:	f880 3701 	strb.w	r3, [r0, #1793]	; 0x701
    4d66:	f8c0 390c 	str.w	r3, [r0, #2316]	; 0x90c
    4d6a:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
    4d6e:	f880 3914 	strb.w	r3, [r0, #2324]	; 0x914
  if ( _bus == CAN2 ) _CAN2 = this;
    4d72:	6021      	str	r1, [r4, #0]
    4d74:	bd38      	pop	{r3, r4, r5, pc}
    4d76:	bf00      	nop
    4d78:	200049a0 	.word	0x200049a0
    4d7c:	20000864 	.word	0x20000864
    4d80:	20007320 	.word	0x20007320
    4d84:	20002088 	.word	0x20002088
    4d88:	20000888 	.word	0x20000888
    4d8c:	20007324 	.word	0x20007324

00004d90 <readEEP()>:
    4d90:	2114      	movs	r1, #20
    4d92:	483a      	ldr	r0, [pc, #232]	; (4e7c <readEEP()+0xec>)
#include "openhaldex.h"

void readEEP() {
    4d94:	b510      	push	{r4, lr}
    4d96:	f002 fdd9 	bl	794c <usb_serial_write>
    4d9a:	4839      	ldr	r0, [pc, #228]	; (4e80 <readEEP()+0xf0>)
    4d9c:	f000 fd48 	bl	5830 <Print::println()>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4da0:	2000      	movs	r0, #0
    4da2:	f001 f85d 	bl	5e60 <eeprom_read_byte>
#if stateDebug
  Serial.println(F("EEPROM initialising!"));
#endif /* stateDebug */

  if (EEPROM.read(0) == 255) {
    4da6:	28ff      	cmp	r0, #255	; 0xff
    4da8:	d014      	beq.n	4dd4 <readEEP()+0x44>
    EERef( const int index )
    4daa:	4603      	mov	r3, r0
    EEPROM.write(1, 0);                    // EEP Address 1: isCustom
    EEPROM.write(2, 0);                    // EEP Address 2: lastMode
    EEPROM.write(3, 0);                    // EEP Address 2: isStandalone
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
  } else {
    softwareVersion = EEPROM.read(0);
    4dac:	4a35      	ldr	r2, [pc, #212]	; (4e84 <readEEP()+0xf4>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4dae:	2001      	movs	r0, #1
    4db0:	6013      	str	r3, [r2, #0]
    4db2:	f001 f855 	bl	5e60 <eeprom_read_byte>
    4db6:	4603      	mov	r3, r0
    isCustom = EEPROM.read(1);
    4db8:	4a33      	ldr	r2, [pc, #204]	; (4e88 <readEEP()+0xf8>)
    4dba:	2002      	movs	r0, #2
    4dbc:	3b00      	subs	r3, #0
    4dbe:	bf18      	it	ne
    4dc0:	2301      	movne	r3, #1
    4dc2:	7013      	strb	r3, [r2, #0]
    4dc4:	f001 f84c 	bl	5e60 <eeprom_read_byte>

    switch (EEPROM.read(2)) {
    4dc8:	2803      	cmp	r0, #3
    4dca:	d854      	bhi.n	4e76 <readEEP()+0xe6>
    4dcc:	e8df f000 	tbb	[pc, r0]
    4dd0:	2b504842 	.word	0x2b504842
    4dd4:	213b      	movs	r1, #59	; 0x3b
    4dd6:	482d      	ldr	r0, [pc, #180]	; (4e8c <readEEP()+0xfc>)
    4dd8:	f002 fdb8 	bl	794c <usb_serial_write>
    4ddc:	4828      	ldr	r0, [pc, #160]	; (4e80 <readEEP()+0xf0>)
    4dde:	f000 fd27 	bl	5830 <Print::println()>
    btInit();
    4de2:	f7fb fc65 	bl	6b0 <btInit()>
    EEPROM.write(0, softwareVersion);      // EEP Address 0: SW Version
    4de6:	4b27      	ldr	r3, [pc, #156]	; (4e84 <readEEP()+0xf4>)
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4de8:	2000      	movs	r0, #0
    4dea:	7819      	ldrb	r1, [r3, #0]
    4dec:	f001 f944 	bl	6078 <eeprom_write_byte>
    4df0:	2100      	movs	r1, #0
    4df2:	2001      	movs	r0, #1
    4df4:	f001 f940 	bl	6078 <eeprom_write_byte>
    4df8:	2100      	movs	r1, #0
    4dfa:	2002      	movs	r0, #2
    4dfc:	f001 f93c 	bl	6078 <eeprom_write_byte>
    4e00:	2100      	movs	r1, #0
    4e02:	2003      	movs	r0, #3
    4e04:	f001 f938 	bl	6078 <eeprom_write_byte>
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
    4e08:	4b21      	ldr	r3, [pc, #132]	; (4e90 <readEEP()+0x100>)
    4e0a:	2004      	movs	r0, #4
    4e0c:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
    4e10:	f001 f932 	bl	6078 <eeprom_write_byte>
    4e14:	2113      	movs	r1, #19
    4e16:	481f      	ldr	r0, [pc, #124]	; (4e94 <readEEP()+0x104>)
    4e18:	f002 fd98 	bl	794c <usb_serial_write>
    4e1c:	4818      	ldr	r0, [pc, #96]	; (4e80 <readEEP()+0xf0>)
    state.ped_threshold = EEPROM.read(4);
  }
#if stateDebug
  Serial.println(F("EEPROM initialised!"));
#endif /* stateDebug */
}
    4e1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4e22:	f000 bd05 	b.w	5830 <Print::println()>
        state.mode_override = true;
    4e26:	4c1a      	ldr	r4, [pc, #104]	; (4e90 <readEEP()+0x100>)
        state.mode = MODE_CUSTOM;
    4e28:	2303      	movs	r3, #3
        state.mode_override = true;
    4e2a:	2101      	movs	r1, #1
        lastMode = 3;
    4e2c:	4a1a      	ldr	r2, [pc, #104]	; (4e98 <readEEP()+0x108>)
        state.mode = MODE_CUSTOM;
    4e2e:	7023      	strb	r3, [r4, #0]
        state.mode_override = true;
    4e30:	f884 1023 	strb.w	r1, [r4, #35]	; 0x23
        lastMode = 3;
    4e34:	6013      	str	r3, [r2, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4e36:	2003      	movs	r0, #3
    4e38:	f001 f812 	bl	5e60 <eeprom_read_byte>
    4e3c:	4603      	mov	r3, r0
    isStandalone = EEPROM.read(3);
    4e3e:	4a17      	ldr	r2, [pc, #92]	; (4e9c <readEEP()+0x10c>)
    4e40:	2004      	movs	r0, #4
    4e42:	3b00      	subs	r3, #0
    4e44:	bf18      	it	ne
    4e46:	2301      	movne	r3, #1
    4e48:	7013      	strb	r3, [r2, #0]
    4e4a:	f001 f809 	bl	5e60 <eeprom_read_byte>
    state.ped_threshold = EEPROM.read(4);
    4e4e:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
    4e52:	e7df      	b.n	4e14 <readEEP()+0x84>
        state.mode = MODE_STOCK;
    4e54:	2300      	movs	r3, #0
    4e56:	4c0e      	ldr	r4, [pc, #56]	; (4e90 <readEEP()+0x100>)
        lastMode = 0;
    4e58:	4a0f      	ldr	r2, [pc, #60]	; (4e98 <readEEP()+0x108>)
        state.mode = MODE_STOCK;
    4e5a:	7023      	strb	r3, [r4, #0]
        lastMode = 0;
    4e5c:	6013      	str	r3, [r2, #0]
        break;
    4e5e:	e7ea      	b.n	4e36 <readEEP()+0xa6>
        state.mode_override = true;
    4e60:	2301      	movs	r3, #1
    4e62:	4c0b      	ldr	r4, [pc, #44]	; (4e90 <readEEP()+0x100>)
        lastMode = 1;
    4e64:	4a0c      	ldr	r2, [pc, #48]	; (4e98 <readEEP()+0x108>)
        state.mode_override = true;
    4e66:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
        state.mode = MODE_FWD;
    4e6a:	7023      	strb	r3, [r4, #0]
        lastMode = 1;
    4e6c:	6013      	str	r3, [r2, #0]
        break;
    4e6e:	e7e2      	b.n	4e36 <readEEP()+0xa6>
        state.mode_override = true;
    4e70:	4c07      	ldr	r4, [pc, #28]	; (4e90 <readEEP()+0x100>)
        state.mode = MODE_5050;
    4e72:	2302      	movs	r3, #2
    4e74:	e7d9      	b.n	4e2a <readEEP()+0x9a>
    4e76:	4c06      	ldr	r4, [pc, #24]	; (4e90 <readEEP()+0x100>)
    4e78:	e7dd      	b.n	4e36 <readEEP()+0xa6>
    4e7a:	bf00      	nop
    4e7c:	20000558 	.word	0x20000558
    4e80:	20001110 	.word	0x20001110
    4e84:	200019c0 	.word	0x200019c0
    4e88:	20007713 	.word	0x20007713
    4e8c:	20000570 	.word	0x20000570
    4e90:	20007580 	.word	0x20007580
    4e94:	200005ac 	.word	0x200005ac
    4e98:	200074ec 	.word	0x200074ec
    4e9c:	20007715 	.word	0x20007715

00004ea0 <writeEEP(void*)>:

bool writeEEP(void *params) {
    4ea0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  // only update if the value has changed
  switch (state.mode) {
    4ea4:	4c42      	ldr	r4, [pc, #264]	; (4fb0 <writeEEP(void*)+0x110>)
bool writeEEP(void *params) {
    4ea6:	b082      	sub	sp, #8
    4ea8:	4d42      	ldr	r5, [pc, #264]	; (4fb4 <writeEEP(void*)+0x114>)
  switch (state.mode) {
    4eaa:	7823      	ldrb	r3, [r4, #0]
    4eac:	2b03      	cmp	r3, #3
    4eae:	d805      	bhi.n	4ebc <writeEEP(void*)+0x1c>
    4eb0:	e8df f003 	tbb	[pc, r3]
    4eb4:	0275787b 	.word	0x0275787b
      break;
    case MODE_5050:
      lastMode = 2;
      break;
    case MODE_CUSTOM:
      lastMode = 3;
    4eb8:	2303      	movs	r3, #3
    4eba:	602b      	str	r3, [r5, #0]
      break;
  }

  // update EEP only if changes have been made
  EEPROM.update(0, softwareVersion);
    4ebc:	4f3e      	ldr	r7, [pc, #248]	; (4fb8 <writeEEP(void*)+0x118>)
    4ebe:	2000      	movs	r0, #0
    4ec0:	f000 ffce 	bl	5e60 <eeprom_read_byte>
    4ec4:	7839      	ldrb	r1, [r7, #0]
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4ec6:	4281      	cmp	r1, r0
    4ec8:	d002      	beq.n	4ed0 <writeEEP(void*)+0x30>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4eca:	2000      	movs	r0, #0
    4ecc:	f001 f8d4 	bl	6078 <eeprom_write_byte>
  EEPROM.update(1, isCustom);
    4ed0:	4b3a      	ldr	r3, [pc, #232]	; (4fbc <writeEEP(void*)+0x11c>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4ed2:	2001      	movs	r0, #1
    4ed4:	781e      	ldrb	r6, [r3, #0]
    4ed6:	f000 ffc3 	bl	5e60 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4eda:	4286      	cmp	r6, r0
    4edc:	d003      	beq.n	4ee6 <writeEEP(void*)+0x46>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4ede:	4631      	mov	r1, r6
    4ee0:	2001      	movs	r0, #1
    4ee2:	f001 f8c9 	bl	6078 <eeprom_write_byte>
  EEPROM.update(2, lastMode);
    4ee6:	782e      	ldrb	r6, [r5, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4ee8:	2002      	movs	r0, #2
    4eea:	f000 ffb9 	bl	5e60 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4eee:	4286      	cmp	r6, r0
    4ef0:	d003      	beq.n	4efa <writeEEP(void*)+0x5a>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4ef2:	4631      	mov	r1, r6
    4ef4:	2002      	movs	r0, #2
    4ef6:	f001 f8bf 	bl	6078 <eeprom_write_byte>
  EEPROM.update(3, isStandalone);
    4efa:	4e31      	ldr	r6, [pc, #196]	; (4fc0 <writeEEP(void*)+0x120>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4efc:	2003      	movs	r0, #3
    4efe:	f000 ffaf 	bl	5e60 <eeprom_read_byte>
    4f02:	f896 8000 	ldrb.w	r8, [r6]
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4f06:	4580      	cmp	r8, r0
    4f08:	d003      	beq.n	4f12 <writeEEP(void*)+0x72>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4f0a:	4641      	mov	r1, r8
    4f0c:	2003      	movs	r0, #3
    4f0e:	f001 f8b3 	bl	6078 <eeprom_write_byte>
  EEPROM.update(4, state.ped_threshold);
    4f12:	f894 8022 	ldrb.w	r8, [r4, #34]	; 0x22
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4f16:	2004      	movs	r0, #4
    4f18:	f000 ffa2 	bl	5e60 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    4f1c:	4580      	cmp	r8, r0
    4f1e:	d003      	beq.n	4f28 <writeEEP(void*)+0x88>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4f20:	4641      	mov	r1, r8
    4f22:	2004      	movs	r0, #4
    4f24:	f001 f8a8 	bl	6078 <eeprom_write_byte>

#if stateDebug
  Serial.printf("Software Version: %d.%d%d%\n", (softwareVersion / 100) % 10, (softwareVersion / 10) % 10, (softwareVersion / 1) % 10);
    4f28:	683a      	ldr	r2, [r7, #0]
    4f2a:	4b26      	ldr	r3, [pc, #152]	; (4fc4 <writeEEP(void*)+0x124>)
    4f2c:	4826      	ldr	r0, [pc, #152]	; (4fc8 <writeEEP(void*)+0x128>)
    4f2e:	fb83 c702 	smull	ip, r7, r3, r2
    4f32:	fb80 1002 	smull	r1, r0, r0, r2
    4f36:	17d1      	asrs	r1, r2, #31
    4f38:	ebc1 1060 	rsb	r0, r1, r0, asr #5
    4f3c:	ebc1 01a7 	rsb	r1, r1, r7, asr #2
    4f40:	fb83 7c00 	smull	r7, ip, r3, r0
    4f44:	fb83 3e01 	smull	r3, lr, r3, r1
    4f48:	17cb      	asrs	r3, r1, #31
    4f4a:	ebc3 03ae 	rsb	r3, r3, lr, asr #2
    4f4e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    4f52:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
    4f56:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    4f5a:	eba2 0241 	sub.w	r2, r2, r1, lsl #1
    4f5e:	491b      	ldr	r1, [pc, #108]	; (4fcc <writeEEP(void*)+0x12c>)
    4f60:	9200      	str	r2, [sp, #0]
    4f62:	17c2      	asrs	r2, r0, #31
    4f64:	ebc2 02ac 	rsb	r2, r2, ip, asr #2
    4f68:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    4f6c:	eba0 0242 	sub.w	r2, r0, r2, lsl #1
    4f70:	4817      	ldr	r0, [pc, #92]	; (4fd0 <writeEEP(void*)+0x130>)
    4f72:	f000 fc79 	bl	5868 <Print::printf(char const*, ...)>
  Serial.printf("Last Mode: %d\n", lastMode);
    4f76:	682a      	ldr	r2, [r5, #0]
    4f78:	4916      	ldr	r1, [pc, #88]	; (4fd4 <writeEEP(void*)+0x134>)
    4f7a:	4815      	ldr	r0, [pc, #84]	; (4fd0 <writeEEP(void*)+0x130>)
    4f7c:	f000 fc74 	bl	5868 <Print::printf(char const*, ...)>
  Serial.printf("Is Standalone: %d\n", isStandalone);
    4f80:	7832      	ldrb	r2, [r6, #0]
    4f82:	4915      	ldr	r1, [pc, #84]	; (4fd8 <writeEEP(void*)+0x138>)
    4f84:	4812      	ldr	r0, [pc, #72]	; (4fd0 <writeEEP(void*)+0x130>)
    4f86:	f000 fc6f 	bl	5868 <Print::printf(char const*, ...)>
  Serial.printf("Minimum Pedal: %d%\n", state.ped_threshold);
    4f8a:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
    4f8e:	4913      	ldr	r1, [pc, #76]	; (4fdc <writeEEP(void*)+0x13c>)
    4f90:	480f      	ldr	r0, [pc, #60]	; (4fd0 <writeEEP(void*)+0x130>)
    4f92:	f000 fc69 	bl	5868 <Print::printf(char const*, ...)>
#endif /* stateDebug */

  return true;
}
    4f96:	2001      	movs	r0, #1
    4f98:	b002      	add	sp, #8
    4f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      lastMode = 2;
    4f9e:	2302      	movs	r3, #2
    4fa0:	602b      	str	r3, [r5, #0]
      break;
    4fa2:	e78b      	b.n	4ebc <writeEEP(void*)+0x1c>
      lastMode = 1;
    4fa4:	2301      	movs	r3, #1
    4fa6:	602b      	str	r3, [r5, #0]
      break;
    4fa8:	e788      	b.n	4ebc <writeEEP(void*)+0x1c>
      lastMode = 0;
    4faa:	2300      	movs	r3, #0
    4fac:	602b      	str	r3, [r5, #0]
      break;
    4fae:	e785      	b.n	4ebc <writeEEP(void*)+0x1c>
    4fb0:	20007580 	.word	0x20007580
    4fb4:	200074ec 	.word	0x200074ec
    4fb8:	200019c0 	.word	0x200019c0
    4fbc:	20007713 	.word	0x20007713
    4fc0:	20007715 	.word	0x20007715
    4fc4:	66666667 	.word	0x66666667
    4fc8:	51eb851f 	.word	0x51eb851f
    4fcc:	200005d4 	.word	0x200005d4
    4fd0:	20001110 	.word	0x20001110
    4fd4:	200005f0 	.word	0x200005f0
    4fd8:	2000046c 	.word	0x2000046c
    4fdc:	20000600 	.word	0x20000600

00004fe0 <_GLOBAL__sub_I__Z7readEEPv>:
    EEPROMClass()                        { eeprom_initialize(); }
    4fe0:	f000 bf1a 	b.w	5e18 <eeprom_initialize>

00004fe4 <EventResponder::runFromInterrupt()>:
{
    4fe4:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4fe6:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    4fea:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    4fec:	4c0c      	ldr	r4, [pc, #48]	; (5020 <EventResponder::runFromInterrupt()+0x3c>)
    4fee:	6820      	ldr	r0, [r4, #0]
		if (first) {
    4ff0:	b180      	cbz	r0, 5014 <EventResponder::runFromInterrupt()+0x30>
				lastInterrupt = nullptr;
    4ff2:	4e0c      	ldr	r6, [pc, #48]	; (5024 <EventResponder::runFromInterrupt()+0x40>)
				firstInterrupt->_prev = nullptr;
    4ff4:	2500      	movs	r5, #0
			firstInterrupt = first->_next;
    4ff6:	6943      	ldr	r3, [r0, #20]
    4ff8:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    4ffa:	b173      	cbz	r3, 501a <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    4ffc:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    4ffe:	b902      	cbnz	r2, 5002 <EventResponder::runFromInterrupt()+0x1e>
    5000:	b662      	cpsie	i
			(*(first->_function))(*first);
    5002:	6883      	ldr	r3, [r0, #8]
			first->_triggered = false;
    5004:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    5006:	4798      	blx	r3
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    5008:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    500c:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    500e:	6820      	ldr	r0, [r4, #0]
		if (first) {
    5010:	2800      	cmp	r0, #0
    5012:	d1f0      	bne.n	4ff6 <EventResponder::runFromInterrupt()+0x12>
		if (doit) __enable_irq();
    5014:	b902      	cbnz	r2, 5018 <EventResponder::runFromInterrupt()+0x34>
    5016:	b662      	cpsie	i
}
    5018:	bd70      	pop	{r4, r5, r6, pc}
				lastInterrupt = nullptr;
    501a:	6033      	str	r3, [r6, #0]
    501c:	e7ef      	b.n	4ffe <EventResponder::runFromInterrupt()+0x1a>
    501e:	bf00      	nop
    5020:	20007330 	.word	0x20007330
    5024:	2000732c 	.word	0x2000732c

00005028 <pendablesrvreq_isr>:
	EventResponder::runFromInterrupt();
    5028:	f7ff bfdc 	b.w	4fe4 <EventResponder::runFromInterrupt()>

0000502c <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    502c:	4904      	ldr	r1, [pc, #16]	; (5040 <systick_isr+0x14>)
	systick_millis_count++;
    502e:	4a05      	ldr	r2, [pc, #20]	; (5044 <systick_isr+0x18>)
	systick_cycle_count = ARM_DWT_CYCCNT;
    5030:	6849      	ldr	r1, [r1, #4]
    5032:	4b05      	ldr	r3, [pc, #20]	; (5048 <systick_isr+0x1c>)
    5034:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    5036:	6813      	ldr	r3, [r2, #0]
    5038:	3301      	adds	r3, #1
    503a:	6013      	str	r3, [r2, #0]
}
    503c:	4770      	bx	lr
    503e:	bf00      	nop
    5040:	e0001000 	.word	0xe0001000
    5044:	200075a8 	.word	0x200075a8
    5048:	200075a4 	.word	0x200075a4

0000504c <HardwareSerialIMXRT::operator bool()>:
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	*/

	operator bool()			{ return true; }
    504c:	2001      	movs	r0, #1
    504e:	4770      	bx	lr

00005050 <HardwareSerialIMXRT::availableForWrite()>:

int HardwareSerialIMXRT::availableForWrite(void)
{
	uint32_t head, tail;

	head = tx_buffer_head_;
    5050:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
	tail = tx_buffer_tail_;
    5054:	f8b0 2048 	ldrh.w	r2, [r0, #72]	; 0x48
	head = tx_buffer_head_;
    5058:	b29b      	uxth	r3, r3
	tail = tx_buffer_tail_;
    505a:	b292      	uxth	r2, r2
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    505c:	4293      	cmp	r3, r2
    505e:	d202      	bcs.n	5066 <HardwareSerialIMXRT::availableForWrite()+0x16>
	return tail - head - 1;
    5060:	3a01      	subs	r2, #1
    5062:	1ad0      	subs	r0, r2, r3
}
    5064:	4770      	bx	lr
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    5066:	6b41      	ldr	r1, [r0, #52]	; 0x34
    5068:	3901      	subs	r1, #1
    506a:	440a      	add	r2, r1
    506c:	1ad0      	subs	r0, r2, r3
    506e:	4770      	bx	lr

00005070 <HardwareSerialIMXRT::available()>:



int HardwareSerialIMXRT::available(void)
{
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5070:	6901      	ldr	r1, [r0, #16]
	uint32_t head, tail;

	// WATER> 0 so IDLE involved may want to check if port has already has RX data to retrieve
	__disable_irq();
    5072:	b672      	cpsid	i
	head = rx_buffer_head_;
    5074:	f8b0 204a 	ldrh.w	r2, [r0, #74]	; 0x4a
	tail = rx_buffer_tail_;
    5078:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    507c:	b292      	uxth	r2, r2
	tail = rx_buffer_tail_;
    507e:	b29b      	uxth	r3, r3
	int avail;
	if (head >= tail) avail = head - tail;
    5080:	429a      	cmp	r2, r3
	else avail = rx_buffer_total_size_ + head - tail;	
    5082:	bf3c      	itt	cc
    5084:	6b80      	ldrcc	r0, [r0, #56]	; 0x38
    5086:	1812      	addcc	r2, r2, r0
	avail += (port->WATER >> 24) & 0x7;
    5088:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
	else avail = rx_buffer_total_size_ + head - tail;	
    508a:	1ad3      	subs	r3, r2, r3
	__enable_irq();
    508c:	b662      	cpsie	i
	avail += (port->WATER >> 24) & 0x7;
    508e:	f3c0 6002 	ubfx	r0, r0, #24, #3
	return avail;
}
    5092:	4418      	add	r0, r3
    5094:	4770      	bx	lr
    5096:	bf00      	nop

00005098 <HardwareSerialIMXRT::peek()>:
int HardwareSerialIMXRT::peek(void)
{
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
	uint32_t head, tail;

	head = rx_buffer_head_;
    5098:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    509c:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    509e:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    50a2:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    50a4:	b29b      	uxth	r3, r3
	if (head == tail) {
    50a6:	4299      	cmp	r1, r3
{
    50a8:	b410      	push	{r4}
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    50aa:	6904      	ldr	r4, [r0, #16]
	if (head == tail) {
    50ac:	d014      	beq.n	50d8 <HardwareSerialIMXRT::peek()+0x40>
			return c;
		}
		__enable_irq();

	} 
	if (++tail >= rx_buffer_total_size_) tail = 0;
    50ae:	3301      	adds	r3, #1
    50b0:	6b90      	ldr	r0, [r2, #56]	; 0x38
	if (tail < rx_buffer_size_) {
    50b2:	6b11      	ldr	r1, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    50b4:	4298      	cmp	r0, r3
    50b6:	bf98      	it	ls
    50b8:	2300      	movls	r3, #0
	if (tail < rx_buffer_size_) {
    50ba:	4299      	cmp	r1, r3
    50bc:	d806      	bhi.n	50cc <HardwareSerialIMXRT::peek()+0x34>
		return rx_buffer_[tail];
	} else {
		return rx_buffer_storage_[tail-rx_buffer_size_];
    50be:	1a5b      	subs	r3, r3, r1
    50c0:	6a52      	ldr	r2, [r2, #36]	; 0x24
    50c2:	5cd0      	ldrb	r0, [r2, r3]
    50c4:	b2c0      	uxtb	r0, r0
	}
}
    50c6:	f85d 4b04 	ldr.w	r4, [sp], #4
    50ca:	4770      	bx	lr
		return rx_buffer_[tail];
    50cc:	6a12      	ldr	r2, [r2, #32]
}
    50ce:	f85d 4b04 	ldr.w	r4, [sp], #4
		return rx_buffer_[tail];
    50d2:	5cd0      	ldrb	r0, [r2, r3]
    50d4:	b2c0      	uxtb	r0, r0
}
    50d6:	4770      	bx	lr
		__disable_irq();
    50d8:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    50da:	f8b0 004a 	ldrh.w	r0, [r0, #74]	; 0x4a
    50de:	b280      	uxth	r0, r0
		if (head == tail) {
    50e0:	4281      	cmp	r1, r0
    50e2:	d001      	beq.n	50e8 <HardwareSerialIMXRT::peek()+0x50>
		__enable_irq();
    50e4:	b662      	cpsie	i
    50e6:	e7e2      	b.n	50ae <HardwareSerialIMXRT::peek()+0x16>
			if (port->WATER & 0x7000000) {
    50e8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    50ea:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
    50ee:	d103      	bne.n	50f8 <HardwareSerialIMXRT::peek()+0x60>
			int c = -1;	// assume nothing to return
    50f0:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    50f4:	b662      	cpsie	i
			return c;
    50f6:	e7e6      	b.n	50c6 <HardwareSerialIMXRT::peek()+0x2e>
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    50f8:	69e3      	ldr	r3, [r4, #28]
				rx_buffer_head_ = 1;
    50fa:	2001      	movs	r0, #1
				rx_buffer_tail_ = 0; 
    50fc:	2400      	movs	r4, #0
				rx_buffer_[1] = c;
    50fe:	6a11      	ldr	r1, [r2, #32]
				rx_buffer_head_ = 1;
    5100:	f8a2 004a 	strh.w	r0, [r2, #74]	; 0x4a
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5104:	f3c3 0009 	ubfx	r0, r3, #0, #10
				rx_buffer_[1] = c;
    5108:	b2db      	uxtb	r3, r3
				rx_buffer_tail_ = 0; 
    510a:	f8a2 404c 	strh.w	r4, [r2, #76]	; 0x4c
				rx_buffer_[1] = c;
    510e:	704b      	strb	r3, [r1, #1]
    5110:	e7f0      	b.n	50f4 <HardwareSerialIMXRT::peek()+0x5c>
    5112:	bf00      	nop

00005114 <HardwareSerialIMXRT::read()>:
{
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
	uint32_t head, tail;
	int c;

	head = rx_buffer_head_;
    5114:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    5118:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    511a:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    511e:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    5120:	b29b      	uxth	r3, r3
	if (head == tail) {
    5122:	4299      	cmp	r1, r3
{
    5124:	b430      	push	{r4, r5}
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5126:	6904      	ldr	r4, [r0, #16]
	if (head == tail) {
    5128:	d025      	beq.n	5176 <HardwareSerialIMXRT::read()+0x62>
			return c;
		}
		__enable_irq();

	}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    512a:	3301      	adds	r3, #1
    512c:	6b94      	ldr	r4, [r2, #56]	; 0x38
    512e:	429c      	cmp	r4, r3
    5130:	d916      	bls.n	5160 <HardwareSerialIMXRT::read()+0x4c>
	if (tail < rx_buffer_size_) {
    5132:	6b10      	ldr	r0, [r2, #48]	; 0x30
		c = rx_buffer_[tail];
	} else {
		c = rx_buffer_storage_[tail-rx_buffer_size_];
	}
	rx_buffer_tail_ = tail;
    5134:	fa1f fc83 	uxth.w	ip, r3
	if (tail < rx_buffer_size_) {
    5138:	4298      	cmp	r0, r3
    513a:	d917      	bls.n	516c <HardwareSerialIMXRT::read()+0x58>
		c = rx_buffer_[tail];
    513c:	6a10      	ldr	r0, [r2, #32]
    513e:	5cc0      	ldrb	r0, [r0, r3]
    5140:	b2c0      	uxtb	r0, r0
	if (rts_pin_baseReg_) {
    5142:	6d95      	ldr	r5, [r2, #88]	; 0x58
	rx_buffer_tail_ = tail;
    5144:	f8a2 c04c 	strh.w	ip, [r2, #76]	; 0x4c
	if (rts_pin_baseReg_) {
    5148:	b145      	cbz	r5, 515c <HardwareSerialIMXRT::read()+0x48>
		uint32_t avail;
		if (head >= tail) avail = head - tail;
    514a:	4299      	cmp	r1, r3
    514c:	d31c      	bcc.n	5188 <HardwareSerialIMXRT::read()+0x74>
    514e:	1acb      	subs	r3, r1, r3
		else avail = rx_buffer_total_size_ + head - tail;

		if (avail <= rts_low_watermark_) rts_assert();
    5150:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
    5152:	4299      	cmp	r1, r3
    5154:	d302      	bcc.n	515c <HardwareSerialIMXRT::read()+0x48>
	DIRECT_WRITE_LOW(rts_pin_baseReg_, rts_pin_bitmask_);
    5156:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    5158:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
	}
	return c;
}	
    515c:	bc30      	pop	{r4, r5}
    515e:	4770      	bx	lr
    5160:	f04f 0c00 	mov.w	ip, #0
	if (tail < rx_buffer_size_) {
    5164:	6b10      	ldr	r0, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    5166:	4663      	mov	r3, ip
	if (tail < rx_buffer_size_) {
    5168:	4298      	cmp	r0, r3
    516a:	d8e7      	bhi.n	513c <HardwareSerialIMXRT::read()+0x28>
		c = rx_buffer_storage_[tail-rx_buffer_size_];
    516c:	1a18      	subs	r0, r3, r0
    516e:	6a55      	ldr	r5, [r2, #36]	; 0x24
    5170:	5c28      	ldrb	r0, [r5, r0]
    5172:	b2c0      	uxtb	r0, r0
    5174:	e7e5      	b.n	5142 <HardwareSerialIMXRT::read()+0x2e>
    5176:	4608      	mov	r0, r1
		__disable_irq();
    5178:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    517a:	f8b2 104a 	ldrh.w	r1, [r2, #74]	; 0x4a
    517e:	b289      	uxth	r1, r1
		if (head == tail) {
    5180:	4288      	cmp	r0, r1
    5182:	d004      	beq.n	518e <HardwareSerialIMXRT::read()+0x7a>
		__enable_irq();
    5184:	b662      	cpsie	i
    5186:	e7d0      	b.n	512a <HardwareSerialIMXRT::read()+0x16>
		else avail = rx_buffer_total_size_ + head - tail;
    5188:	440c      	add	r4, r1
    518a:	1ae3      	subs	r3, r4, r3
    518c:	e7e0      	b.n	5150 <HardwareSerialIMXRT::read()+0x3c>
			if (port->WATER & 0x7000000) {
    518e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5190:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
    5194:	d103      	bne.n	519e <HardwareSerialIMXRT::read()+0x8a>
			c = -1;	// assume nothing to return
    5196:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    519a:	b662      	cpsie	i
			return c;
    519c:	e7de      	b.n	515c <HardwareSerialIMXRT::read()+0x48>
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    519e:	69e0      	ldr	r0, [r4, #28]
    51a0:	f3c0 0009 	ubfx	r0, r0, #0, #10
    51a4:	e7f9      	b.n	519a <HardwareSerialIMXRT::read()+0x86>
    51a6:	bf00      	nop

000051a8 <HardwareSerialIMXRT::flush()>:

void HardwareSerialIMXRT::flush(void)
{
	while (transmitting_) yield(); // wait
    51a8:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
    51ac:	b143      	cbz	r3, 51c0 <HardwareSerialIMXRT::flush()+0x18>
{
    51ae:	b510      	push	{r4, lr}
    51b0:	4604      	mov	r4, r0
	while (transmitting_) yield(); // wait
    51b2:	f002 fc49 	bl	7a48 <yield>
    51b6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    51ba:	2b00      	cmp	r3, #0
    51bc:	d1f9      	bne.n	51b2 <HardwareSerialIMXRT::flush()+0xa>
}
    51be:	bd10      	pop	{r4, pc}
    51c0:	4770      	bx	lr
    51c2:	bf00      	nop

000051c4 <HardwareSerialIMXRT::end()>:
{
    51c4:	b538      	push	{r3, r4, r5, lr}
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    51c6:	e9d0 5304 	ldrd	r5, r3, [r0, #16]
	if (!(hardware->ccm_register & hardware->ccm_value)) return;
    51ca:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
    51ce:	6809      	ldr	r1, [r1, #0]
    51d0:	4211      	tst	r1, r2
    51d2:	d028      	beq.n	5226 <HardwareSerialIMXRT::end()+0x62>
	while (transmitting_) yield();  // wait for buffered data to send
    51d4:	f890 2044 	ldrb.w	r2, [r0, #68]	; 0x44
    51d8:	4604      	mov	r4, r0
    51da:	b132      	cbz	r2, 51ea <HardwareSerialIMXRT::end()+0x26>
    51dc:	f002 fc34 	bl	7a48 <yield>
    51e0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    51e4:	2b00      	cmp	r3, #0
    51e6:	d1f9      	bne.n	51dc <HardwareSerialIMXRT::end()+0x18>
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    51e8:	6963      	ldr	r3, [r4, #20]
	port->CTRL = 0;	// disable the TX and RX ...
    51ea:	2100      	movs	r1, #0
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    51ec:	4a0e      	ldr	r2, [pc, #56]	; (5228 <HardwareSerialIMXRT::end()+0x64>)
	port->CTRL = 0;	// disable the TX and RX ...
    51ee:	61a9      	str	r1, [r5, #24]
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    51f0:	7e20      	ldrb	r0, [r4, #24]
    51f2:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    51f6:	7d00      	ldrb	r0, [r0, #20]
    51f8:	eb02 1000 	add.w	r0, r2, r0, lsl #4
    51fc:	6845      	ldr	r5, [r0, #4]
    51fe:	2005      	movs	r0, #5
    5200:	6028      	str	r0, [r5, #0]
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    5202:	7e65      	ldrb	r5, [r4, #25]
    5204:	eb03 1305 	add.w	r3, r3, r5, lsl #4
    5208:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
    520c:	eb02 1203 	add.w	r2, r2, r3, lsl #4
	if (rts_pin_baseReg_) rts_deassert();
    5210:	6da3      	ldr	r3, [r4, #88]	; 0x58
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    5212:	6852      	ldr	r2, [r2, #4]
    5214:	6010      	str	r0, [r2, #0]
	rx_buffer_head_ = 0;
    5216:	f8a4 104a 	strh.w	r1, [r4, #74]	; 0x4a
	rx_buffer_tail_ = 0;
    521a:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
	if (rts_pin_baseReg_) rts_deassert();
    521e:	b113      	cbz	r3, 5226 <HardwareSerialIMXRT::end()+0x62>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    5220:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    5222:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    5226:	bd38      	pop	{r3, r4, r5, pc}
    5228:	20000b7c 	.word	0x20000b7c

0000522c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>:
	float base = (float)UART_CLOCK / (float)baud;
    522c:	ee07 1a90 	vmov	s15, r1
    5230:	ed9f 7a9a 	vldr	s14, [pc, #616]	; 549c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x270>
	for (int osr=4; osr <= 32; osr++) {
    5234:	2104      	movs	r1, #4
		int divint = (int)(div + 0.5f);
    5236:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
	float base = (float)UART_CLOCK / (float)baud;
    523a:	eef8 7a67 	vcvt.f32.u32	s15, s15
	float besterr = 1e20;
    523e:	ed9f 6a98 	vldr	s12, [pc, #608]	; 54a0 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x274>
    5242:	f641 7cff 	movw	ip, #8191	; 0x1fff
	float base = (float)UART_CLOCK / (float)baud;
    5246:	eec7 5a27 	vdiv.f32	s11, s14, s15
{
    524a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int bestosr = 4;
    524e:	468e      	mov	lr, r1
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5250:	6905      	ldr	r5, [r0, #16]
	int bestdiv = 1;
    5252:	2401      	movs	r4, #1
		float div = base / (float)osr;
    5254:	ee07 1a90 	vmov	s15, r1
    5258:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    525c:	ee85 7aa7 	vdiv.f32	s14, s11, s15
		int divint = (int)(div + 0.5f);
    5260:	ee77 7a05 	vadd.f32	s15, s14, s10
    5264:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    5268:	ee17 3a90 	vmov	r3, s15
    526c:	4563      	cmp	r3, ip
    526e:	bfa8      	it	ge
    5270:	4663      	movge	r3, ip
    5272:	2b01      	cmp	r3, #1
    5274:	bfb8      	it	lt
    5276:	2301      	movlt	r3, #1
		float err = ((float)divint - div) / div;
    5278:	ee07 3a90 	vmov	s15, r3
    527c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    5280:	ee76 6ac7 	vsub.f32	s13, s13, s14
    5284:	eec6 7a87 	vdiv.f32	s15, s13, s14
		if (err < 0.0f) err = -err;
    5288:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    528c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5290:	bf48      	it	mi
    5292:	eef1 7a67 	vnegmi.f32	s15, s15
		if (err <= besterr) {
    5296:	eef4 7ac6 	vcmpe.f32	s15, s12
    529a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    529e:	d803      	bhi.n	52a8 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x7c>
			besterr = err;
    52a0:	eeb0 6a67 	vmov.f32	s12, s15
		if (err <= besterr) {
    52a4:	468e      	mov	lr, r1
			bestdiv = divint;
    52a6:	461c      	mov	r4, r3
	for (int osr=4; osr <= 32; osr++) {
    52a8:	3101      	adds	r1, #1
    52aa:	2921      	cmp	r1, #33	; 0x21
    52ac:	d1d2      	bne.n	5254 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x28>
	rx_buffer_head_ = 0;
    52ae:	2100      	movs	r1, #0
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    52b0:	6943      	ldr	r3, [r0, #20]
    52b2:	f402 7600 	and.w	r6, r2, #512	; 0x200
	rx_buffer_head_ = 0;
    52b6:	f8a0 104a 	strh.w	r1, [r0, #74]	; 0x4a
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    52ba:	f8b3 c05a 	ldrh.w	ip, [r3, #90]	; 0x5a
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    52be:	428e      	cmp	r6, r1
	rx_buffer_tail_ = 0;
    52c0:	f8a0 104c 	strh.w	r1, [r0, #76]	; 0x4c
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    52c4:	f8b3 6058 	ldrh.w	r6, [r3, #88]	; 0x58
	tx_buffer_head_ = 0;
    52c8:	f8a0 1046 	strh.w	r1, [r0, #70]	; 0x46
	tx_buffer_tail_ = 0;
    52cc:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	transmitting_ = 0;
    52d0:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    52d4:	6b81      	ldr	r1, [r0, #56]	; 0x38
	hardware->ccm_register |= hardware->ccm_value;
    52d6:	68df      	ldr	r7, [r3, #12]
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    52d8:	eba1 0606 	sub.w	r6, r1, r6
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    52dc:	eba1 010c 	sub.w	r1, r1, ip
    52e0:	e9c0 610f 	strd	r6, r1, [r0, #60]	; 0x3c
	hardware->ccm_register |= hardware->ccm_value;
    52e4:	6839      	ldr	r1, [r7, #0]
    52e6:	691e      	ldr	r6, [r3, #16]
    52e8:	ea41 0106 	orr.w	r1, r1, r6
    52ec:	6039      	str	r1, [r7, #0]
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    52ee:	bf14      	ite	ne
    52f0:	2101      	movne	r1, #1
    52f2:	2100      	moveq	r1, #0
    52f4:	7681      	strb	r1, [r0, #26]
	if (!half_duplex_mode_)  {
    52f6:	f040 80ac 	bne.w	5452 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x226>
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    52fa:	7e01      	ldrb	r1, [r0, #24]
    52fc:	4e69      	ldr	r6, [pc, #420]	; (54a4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x278>)
    52fe:	eb03 1801 	add.w	r8, r3, r1, lsl #4
    5302:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 54c4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x298>
    5306:	f898 7014 	ldrb.w	r7, [r8, #20]
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
    530a:	f8d8 a01c 	ldr.w	sl, [r8, #28]
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    530e:	eb06 1707 	add.w	r7, r6, r7, lsl #4
    5312:	68b9      	ldr	r1, [r7, #8]
    5314:	f8c1 9000 	str.w	r9, [r1]
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
    5318:	6879      	ldr	r1, [r7, #4]
    531a:	f8d8 7018 	ldr.w	r7, [r8, #24]
    531e:	600f      	str	r7, [r1, #0]
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
    5320:	f1ba 0f00 	cmp.w	sl, #0
    5324:	d003      	beq.n	532e <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x102>
		 	*(hardware->rx_pins[rx_pin_index_].select_input_register) =  hardware->rx_pins[rx_pin_index_].select_val;		
    5326:	f8d8 1020 	ldr.w	r1, [r8, #32]
    532a:	f8ca 1000 	str.w	r1, [sl]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
    532e:	7e47      	ldrb	r7, [r0, #25]
    5330:	21d9      	movs	r1, #217	; 0xd9
    5332:	eb03 1807 	add.w	r8, r3, r7, lsl #4
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    5336:	f898 c034 	ldrb.w	ip, [r8, #52]	; 0x34
    533a:	eb06 1c0c 	add.w	ip, r6, ip, lsl #4
    533e:	f8dc 7008 	ldr.w	r7, [ip, #8]
    5342:	6039      	str	r1, [r7, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    5344:	f8dc 1004 	ldr.w	r1, [ip, #4]
    5348:	f8d8 7038 	ldr.w	r7, [r8, #56]	; 0x38
    534c:	600f      	str	r7, [r1, #0]
	if (hardware->tx_pins[tx_pin_index_].select_input_register) {
    534e:	7e41      	ldrb	r1, [r0, #25]
    5350:	eb03 1101 	add.w	r1, r3, r1, lsl #4
    5354:	6bcf      	ldr	r7, [r1, #60]	; 0x3c
    5356:	b10f      	cbz	r7, 535c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x130>
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
    5358:	6c09      	ldr	r1, [r1, #64]	; 0x40
    535a:	6039      	str	r1, [r7, #0]
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    535c:	f10e 31ff 	add.w	r1, lr, #4294967295
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    5360:	f1be 0f08 	cmp.w	lr, #8
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    5364:	ea4f 6101 	mov.w	r1, r1, lsl #24
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    5368:	bfcc      	ite	gt
    536a:	f04f 0e00 	movgt.w	lr, #0
    536e:	f04f 0e01 	movle.w	lr, #1
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    5372:	f001 51f8 	and.w	r1, r1, #520093696	; 0x1f000000
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    5376:	ea44 444e 	orr.w	r4, r4, lr, lsl #17
    537a:	4321      	orrs	r1, r4
	attachInterruptVector(hardware->irq, hardware->irq_handler);
    537c:	685c      	ldr	r4, [r3, #4]
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    537e:	6129      	str	r1, [r5, #16]
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    5380:	7859      	ldrb	r1, [r3, #1]
    5382:	f101 0310 	add.w	r3, r1, #16
	port->PINCFG = 0;
    5386:	2100      	movs	r1, #0
    5388:	60e9      	str	r1, [r5, #12]
    538a:	4947      	ldr	r1, [pc, #284]	; (54a8 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x27c>)
    538c:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    5390:	6941      	ldr	r1, [r0, #20]
	NVIC_ENABLE_IRQ(hardware->irq);
    5392:	f04f 0e01 	mov.w	lr, #1
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    5396:	4c45      	ldr	r4, [pc, #276]	; (54ac <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x280>)
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    5398:	f002 0c03 	and.w	ip, r2, #3
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    539c:	784f      	ldrb	r7, [r1, #1]
    539e:	f891 1056 	ldrb.w	r1, [r1, #86]	; 0x56
	NVIC_ENABLE_IRQ(hardware->irq);
    53a2:	4b43      	ldr	r3, [pc, #268]	; (54b0 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x284>)
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    53a4:	5539      	strb	r1, [r7, r4]
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
    53a6:	f04f 1702 	mov.w	r7, #131074	; 0x20002
	NVIC_ENABLE_IRQ(hardware->irq);
    53aa:	6944      	ldr	r4, [r0, #20]
    53ac:	7861      	ldrb	r1, [r4, #1]
    53ae:	eb03 1351 	add.w	r3, r3, r1, lsr #5
    53b2:	f001 011f 	and.w	r1, r1, #31
    53b6:	009b      	lsls	r3, r3, #2
    53b8:	fa0e f101 	lsl.w	r1, lr, r1
    53bc:	6019      	str	r1, [r3, #0]
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
    53be:	62ef      	str	r7, [r5, #44]	; 0x2c
	port->FIFO |= LPUART_FIFO_TXFE | LPUART_FIFO_RXFE;
    53c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
    53c2:	f043 0388 	orr.w	r3, r3, #136	; 0x88
    53c6:	62ab      	str	r3, [r5, #40]	; 0x28
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    53c8:	0753      	lsls	r3, r2, #29
    53ca:	d43e      	bmi.n	544a <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x21e>
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    53cc:	f44c 1370 	orr.w	r3, ip, #3932160	; 0x3c0000
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
    53d0:	f002 010f 	and.w	r1, r2, #15
    53d4:	2904      	cmp	r1, #4
    53d6:	bf08      	it	eq
    53d8:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
	if (format & 0x20) {
    53dc:	0697      	lsls	r7, r2, #26
    53de:	d52e      	bpl.n	543e <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x212>
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    53e0:	7e81      	ldrb	r1, [r0, #26]
		ctrl |= LPUART_CTRL_TXINV;		// tx invert
    53e2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    53e6:	2900      	cmp	r1, #0
    53e8:	d13a      	bne.n	5460 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x234>
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    53ea:	0716      	lsls	r6, r2, #28
	port->CTRL = ctrl;
    53ec:	61ab      	str	r3, [r5, #24]
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    53ee:	d503      	bpl.n	53f8 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1cc>
    53f0:	692b      	ldr	r3, [r5, #16]
    53f2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    53f6:	612b      	str	r3, [r5, #16]
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    53f8:	696b      	ldr	r3, [r5, #20]
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    53fa:	06d1      	lsls	r1, r2, #27
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    53fc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    5400:	bf48      	it	mi
    5402:	f043 5380 	orrmi.w	r3, r3, #268435456	; 0x10000000
	port->STAT = c;
    5406:	616b      	str	r3, [r5, #20]
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
    5408:	05d3      	lsls	r3, r2, #23
    540a:	d503      	bpl.n	5414 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1e8>
    540c:	692b      	ldr	r3, [r5, #16]
    540e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    5412:	612b      	str	r3, [r5, #16]
	if (hardware->_serialEvent) addToSerialEventsList();
    5414:	68a3      	ldr	r3, [r4, #8]
    5416:	b183      	cbz	r3, 543a <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x20e>
	//digitalWrite(4, LOW);
}


void HardwareSerialIMXRT::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    5418:	4e26      	ldr	r6, [pc, #152]	; (54b4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x288>)
    541a:	7834      	ldrb	r4, [r6, #0]
    541c:	2c00      	cmp	r4, #0
    541e:	d03a      	beq.n	5496 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x26a>
    5420:	1e61      	subs	r1, r4, #1
    5422:	4d25      	ldr	r5, [pc, #148]	; (54b8 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x28c>)
    5424:	b2c9      	uxtb	r1, r1
    5426:	1f2b      	subs	r3, r5, #4
    5428:	eb05 0181 	add.w	r1, r5, r1, lsl #2
    542c:	e001      	b.n	5432 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x206>
    542e:	4299      	cmp	r1, r3
    5430:	d025      	beq.n	547e <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x252>
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
    5432:	f853 2f04 	ldr.w	r2, [r3, #4]!
    5436:	4290      	cmp	r0, r2
    5438:	d1f9      	bne.n	542e <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x202>
};
    543a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    543e:	7e81      	ldrb	r1, [r0, #26]
    5440:	2900      	cmp	r1, #0
    5442:	d0d2      	beq.n	53ea <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1be>
    5444:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
    5448:	e7cf      	b.n	53ea <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1be>
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    544a:	4b1c      	ldr	r3, [pc, #112]	; (54bc <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x290>)
    544c:	ea4c 0303 	orr.w	r3, ip, r3
    5450:	e7be      	b.n	53d0 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1a4>
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    5452:	7e47      	ldrb	r7, [r0, #25]
    5454:	f24f 01d9 	movw	r1, #61657	; 0xf0d9
    5458:	4e12      	ldr	r6, [pc, #72]	; (54a4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x278>)
    545a:	eb03 1807 	add.w	r8, r3, r7, lsl #4
    545e:	e76a      	b.n	5336 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x10a>
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    5460:	7e41      	ldrb	r1, [r0, #25]
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    5462:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    5466:	eb04 1101 	add.w	r1, r4, r1, lsl #4
    546a:	f891 1034 	ldrb.w	r1, [r1, #52]	; 0x34
    546e:	eb06 1601 	add.w	r6, r6, r1, lsl #4
    5472:	68b6      	ldr	r6, [r6, #8]
    5474:	6831      	ldr	r1, [r6, #0]
    5476:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    547a:	6031      	str	r1, [r6, #0]
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    547c:	e7b5      	b.n	53ea <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1be>
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    547e:	1c63      	adds	r3, r4, #1
    5480:	b2db      	uxtb	r3, r3
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    5482:	4a0f      	ldr	r2, [pc, #60]	; (54c0 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x294>)
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    5484:	7033      	strb	r3, [r6, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    5486:	7813      	ldrb	r3, [r2, #0]
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    5488:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    548c:	f043 0302 	orr.w	r3, r3, #2
    5490:	7013      	strb	r3, [r2, #0]
};
    5492:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    5496:	2301      	movs	r3, #1
    5498:	4d07      	ldr	r5, [pc, #28]	; (54b8 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x28c>)
    549a:	e7f2      	b.n	5482 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x256>
    549c:	4bb71b00 	.word	0x4bb71b00
    54a0:	60ad78ec 	.word	0x60ad78ec
    54a4:	20000b7c 	.word	0x20000b7c
    54a8:	20001c00 	.word	0x20001c00
    54ac:	e000e400 	.word	0xe000e400
    54b0:	38003840 	.word	0x38003840
    54b4:	2000770b 	.word	0x2000770b
    54b8:	20007338 	.word	0x20007338
    54bc:	003c0010 	.word	0x003c0010
    54c0:	20007721 	.word	0x20007721
    54c4:	0001f038 	.word	0x0001f038

000054c8 <nvic_execution_priority()>:
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
    54c8:	f3ef 8013 	mrs	r0, FAULTMASK
	if (faultmask) return -1;
    54cc:	b9b8      	cbnz	r0, 54fe <nvic_execution_priority()+0x36>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    54ce:	f3ef 8310 	mrs	r3, PRIMASK
	if (primask) return 0;
    54d2:	b94b      	cbnz	r3, 54e8 <nvic_execution_priority()+0x20>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    54d4:	f3ef 8205 	mrs	r2, IPSR
	if (ipsr) {
    54d8:	b93a      	cbnz	r2, 54ea <nvic_execution_priority()+0x22>
	uint32_t priority=256;
    54da:	f44f 7380 	mov.w	r3, #256	; 0x100
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    54de:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    54e2:	b150      	cbz	r0, 54fa <nvic_execution_priority()+0x32>
    54e4:	4298      	cmp	r0, r3
    54e6:	d208      	bcs.n	54fa <nvic_execution_priority()+0x32>
}
    54e8:	4770      	bx	lr
		if (ipsr < 16) priority = 0; // could be non-zero
    54ea:	2a0f      	cmp	r2, #15
    54ec:	d9f7      	bls.n	54de <nvic_execution_priority()+0x16>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
    54ee:	4b05      	ldr	r3, [pc, #20]	; (5504 <nvic_execution_priority()+0x3c>)
    54f0:	5c9b      	ldrb	r3, [r3, r2]
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    54f2:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    54f6:	2800      	cmp	r0, #0
    54f8:	d1f4      	bne.n	54e4 <nvic_execution_priority()+0x1c>
    54fa:	4618      	mov	r0, r3
	return priority;
    54fc:	4770      	bx	lr
	if (faultmask) return -1;
    54fe:	f04f 30ff 	mov.w	r0, #4294967295
    5502:	e7f1      	b.n	54e8 <nvic_execution_priority()+0x20>
    5504:	e000e3f0 	.word	0xe000e3f0

00005508 <HardwareSerialIMXRT::write9bit(unsigned long)>:
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5508:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    550a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    550e:	4604      	mov	r4, r0
    5510:	460f      	mov	r7, r1
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5512:	6906      	ldr	r6, [r0, #16]
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5514:	b113      	cbz	r3, 551c <HardwareSerialIMXRT::write9bit(unsigned long)+0x14>
    5516:	6d42      	ldr	r2, [r0, #84]	; 0x54
    5518:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	if(half_duplex_mode_) {		
    551c:	7ea3      	ldrb	r3, [r4, #26]
    551e:	b12b      	cbz	r3, 552c <HardwareSerialIMXRT::write9bit(unsigned long)+0x24>
		__disable_irq();
    5520:	b672      	cpsid	i
	    port->CTRL |= LPUART_CTRL_TXDIR;
    5522:	69b3      	ldr	r3, [r6, #24]
    5524:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    5528:	61b3      	str	r3, [r6, #24]
		__enable_irq();
    552a:	b662      	cpsie	i
	head = tx_buffer_head_;
    552c:	f8b4 5046 	ldrh.w	r5, [r4, #70]	; 0x46
	if (++head >= tx_buffer_total_size_) head = 0;
    5530:	6b63      	ldr	r3, [r4, #52]	; 0x34
	head = tx_buffer_head_;
    5532:	b2ad      	uxth	r5, r5
	if (++head >= tx_buffer_total_size_) head = 0;
    5534:	3501      	adds	r5, #1
    5536:	42ab      	cmp	r3, r5
    5538:	d84c      	bhi.n	55d4 <HardwareSerialIMXRT::write9bit(unsigned long)+0xcc>
    553a:	f04f 0800 	mov.w	r8, #0
    553e:	4645      	mov	r5, r8
	while (tx_buffer_tail_ == head) {
    5540:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    5544:	b29b      	uxth	r3, r3
    5546:	429d      	cmp	r5, r3
    5548:	d019      	beq.n	557e <HardwareSerialIMXRT::write9bit(unsigned long)+0x76>
    554a:	e028      	b.n	559e <HardwareSerialIMXRT::write9bit(unsigned long)+0x96>
			if ((port->STAT & LPUART_STAT_TDRE)) {
    554c:	6973      	ldr	r3, [r6, #20]
    554e:	021b      	lsls	r3, r3, #8
    5550:	d510      	bpl.n	5574 <HardwareSerialIMXRT::write9bit(unsigned long)+0x6c>
				uint32_t tail = tx_buffer_tail_;
    5552:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
				if (++tail >= tx_buffer_total_size_) tail = 0;
    5556:	6b62      	ldr	r2, [r4, #52]	; 0x34
				uint32_t tail = tx_buffer_tail_;
    5558:	b29b      	uxth	r3, r3
				if (++tail >= tx_buffer_total_size_) tail = 0;
    555a:	3301      	adds	r3, #1
    555c:	429a      	cmp	r2, r3
    555e:	d936      	bls.n	55ce <HardwareSerialIMXRT::write9bit(unsigned long)+0xc6>
				tx_buffer_tail_ = tail;
    5560:	b29a      	uxth	r2, r3
				if (tail < tx_buffer_size_) {
    5562:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    5564:	4299      	cmp	r1, r3
    5566:	d92d      	bls.n	55c4 <HardwareSerialIMXRT::write9bit(unsigned long)+0xbc>
					n = tx_buffer_[tail];
    5568:	69e1      	ldr	r1, [r4, #28]
    556a:	5ccb      	ldrb	r3, [r1, r3]
    556c:	b2db      	uxtb	r3, r3
				port->DATA  = n;
    556e:	61f3      	str	r3, [r6, #28]
				tx_buffer_tail_ = tail;
    5570:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
	while (tx_buffer_tail_ == head) {
    5574:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    5578:	b29b      	uxth	r3, r3
    557a:	42ab      	cmp	r3, r5
    557c:	d10f      	bne.n	559e <HardwareSerialIMXRT::write9bit(unsigned long)+0x96>
		int priority = nvic_execution_priority();
    557e:	f7ff ffa3 	bl	54c8 <nvic_execution_priority()>
		if (priority <= hardware->irq_priority) {
    5582:	6963      	ldr	r3, [r4, #20]
    5584:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
    5588:	4283      	cmp	r3, r0
    558a:	dadf      	bge.n	554c <HardwareSerialIMXRT::write9bit(unsigned long)+0x44>
		} else if (priority >= 256) 
    558c:	28ff      	cmp	r0, #255	; 0xff
    558e:	ddf1      	ble.n	5574 <HardwareSerialIMXRT::write9bit(unsigned long)+0x6c>
			yield(); // wait
    5590:	f002 fa5a 	bl	7a48 <yield>
	while (tx_buffer_tail_ == head) {
    5594:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    5598:	b29b      	uxth	r3, r3
    559a:	42ab      	cmp	r3, r5
    559c:	d0ef      	beq.n	557e <HardwareSerialIMXRT::write9bit(unsigned long)+0x76>
	if (head < tx_buffer_size_) {
    559e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    55a0:	42ab      	cmp	r3, r5
    55a2:	d91a      	bls.n	55da <HardwareSerialIMXRT::write9bit(unsigned long)+0xd2>
		tx_buffer_[head] = c;
    55a4:	b2ff      	uxtb	r7, r7
    55a6:	69e3      	ldr	r3, [r4, #28]
    55a8:	555f      	strb	r7, [r3, r5]
	__disable_irq();
    55aa:	b672      	cpsid	i
	transmitting_ = 1;
    55ac:	2001      	movs	r0, #1
    55ae:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
	tx_buffer_head_ = head;
    55b2:	f8a4 8046 	strh.w	r8, [r4, #70]	; 0x46
	port->CTRL |= LPUART_CTRL_TIE; // (may need to handle this issue)BITBAND_SET_BIT(LPUART0_CTRL, TIE_BIT);
    55b6:	69b3      	ldr	r3, [r6, #24]
    55b8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    55bc:	61b3      	str	r3, [r6, #24]
	__enable_irq();
    55be:	b662      	cpsie	i
}
    55c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					n = tx_buffer_storage_[tail-tx_buffer_size_];
    55c4:	1a5b      	subs	r3, r3, r1
    55c6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    55c8:	5ccb      	ldrb	r3, [r1, r3]
    55ca:	b2db      	uxtb	r3, r3
    55cc:	e7cf      	b.n	556e <HardwareSerialIMXRT::write9bit(unsigned long)+0x66>
    55ce:	2200      	movs	r2, #0
				if (++tail >= tx_buffer_total_size_) tail = 0;
    55d0:	4613      	mov	r3, r2
    55d2:	e7c6      	b.n	5562 <HardwareSerialIMXRT::write9bit(unsigned long)+0x5a>
	tx_buffer_head_ = head;
    55d4:	fa1f f885 	uxth.w	r8, r5
    55d8:	e7b2      	b.n	5540 <HardwareSerialIMXRT::write9bit(unsigned long)+0x38>
		tx_buffer_storage_[head - tx_buffer_size_] = c;
    55da:	1aed      	subs	r5, r5, r3
    55dc:	b2ff      	uxtb	r7, r7
    55de:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    55e0:	555f      	strb	r7, [r3, r5]
    55e2:	e7e2      	b.n	55aa <HardwareSerialIMXRT::write9bit(unsigned long)+0xa2>

000055e4 <HardwareSerialIMXRT::write(unsigned char)>:
	return write9bit(c);
    55e4:	f7ff bf90 	b.w	5508 <HardwareSerialIMXRT::write9bit(unsigned long)>

000055e8 <HardwareSerialIMXRT::IRQHandler()>:
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    55e8:	6902      	ldr	r2, [r0, #16]
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    55ea:	6953      	ldr	r3, [r2, #20]
    55ec:	f413 1f40 	tst.w	r3, #3145728	; 0x300000
{
    55f0:	b570      	push	{r4, r5, r6, lr}
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    55f2:	d043      	beq.n	567c <HardwareSerialIMXRT::IRQHandler()+0x94>
		uint8_t avail = (port->WATER >> 24) & 0x7;
    55f4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
		if (avail) {
    55f6:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
		uint8_t avail = (port->WATER >> 24) & 0x7;
    55fa:	f3c3 6e02 	ubfx	lr, r3, #24, #3
		if (avail) {
    55fe:	d03a      	beq.n	5676 <HardwareSerialIMXRT::IRQHandler()+0x8e>
			head = rx_buffer_head_;
    5600:	f8b0 504a 	ldrh.w	r5, [r0, #74]	; 0x4a
			tail = rx_buffer_tail_;
    5604:	f8b0 604c 	ldrh.w	r6, [r0, #76]	; 0x4c
			head = rx_buffer_head_;
    5608:	b2ad      	uxth	r5, r5
			tail = rx_buffer_tail_;
    560a:	b2b6      	uxth	r6, r6
    560c:	e007      	b.n	561e <HardwareSerialIMXRT::IRQHandler()+0x36>
						rx_buffer_[head] = n;
    560e:	6a01      	ldr	r1, [r0, #32]
    5610:	f801 c003 	strb.w	ip, [r1, r3]
			} while (--avail > 0) ;
    5614:	f10e 33ff 	add.w	r3, lr, #4294967295
    5618:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    561c:	d01d      	beq.n	565a <HardwareSerialIMXRT::IRQHandler()+0x72>
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    561e:	69d1      	ldr	r1, [r2, #28]
				newhead = head + 1;
    5620:	1c6b      	adds	r3, r5, #1
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    5622:	6b84      	ldr	r4, [r0, #56]	; 0x38
				if (newhead != rx_buffer_tail_) {
    5624:	f8b0 c04c 	ldrh.w	ip, [r0, #76]	; 0x4c
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5628:	f3c1 0109 	ubfx	r1, r1, #0, #10
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    562c:	429c      	cmp	r4, r3
    562e:	bf98      	it	ls
    5630:	2300      	movls	r3, #0
				if (newhead != rx_buffer_tail_) {
    5632:	fa1f fc8c 	uxth.w	ip, ip
    5636:	459c      	cmp	ip, r3
    5638:	d0ec      	beq.n	5614 <HardwareSerialIMXRT::IRQHandler()+0x2c>
					if (newhead < rx_buffer_size_) {
    563a:	6b04      	ldr	r4, [r0, #48]	; 0x30
						rx_buffer_[head] = n;
    563c:	fa5f fc81 	uxtb.w	ip, r1
    5640:	461d      	mov	r5, r3
					if (newhead < rx_buffer_size_) {
    5642:	429c      	cmp	r4, r3
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    5644:	eba3 0404 	sub.w	r4, r3, r4
					if (newhead < rx_buffer_size_) {
    5648:	d8e1      	bhi.n	560e <HardwareSerialIMXRT::IRQHandler()+0x26>
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    564a:	6a43      	ldr	r3, [r0, #36]	; 0x24
    564c:	f803 c004 	strb.w	ip, [r3, r4]
			} while (--avail > 0) ;
    5650:	f10e 33ff 	add.w	r3, lr, #4294967295
    5654:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    5658:	d1e1      	bne.n	561e <HardwareSerialIMXRT::IRQHandler()+0x36>
			rx_buffer_head_ = head;
    565a:	b2ab      	uxth	r3, r5
    565c:	f8a0 304a 	strh.w	r3, [r0, #74]	; 0x4a
			if (rts_pin_baseReg_) {
    5660:	6d83      	ldr	r3, [r0, #88]	; 0x58
    5662:	b143      	cbz	r3, 5676 <HardwareSerialIMXRT::IRQHandler()+0x8e>
				if (head >= tail) avail = head - tail;
    5664:	42b5      	cmp	r5, r6
    5666:	d354      	bcc.n	5712 <HardwareSerialIMXRT::IRQHandler()+0x12a>
    5668:	1bad      	subs	r5, r5, r6
				if (avail >= rts_high_watermark_) rts_deassert();
    566a:	6c01      	ldr	r1, [r0, #64]	; 0x40
    566c:	42a9      	cmp	r1, r5
    566e:	d802      	bhi.n	5676 <HardwareSerialIMXRT::IRQHandler()+0x8e>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    5670:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
    5672:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
		if (port->STAT & LPUART_STAT_IDLE) {
    5676:	6953      	ldr	r3, [r2, #20]
    5678:	02d9      	lsls	r1, r3, #11
    567a:	d445      	bmi.n	5708 <HardwareSerialIMXRT::IRQHandler()+0x120>
	ctrl = port->CTRL;
    567c:	6996      	ldr	r6, [r2, #24]
	if ((ctrl & LPUART_CTRL_TIE) && (port->STAT & LPUART_STAT_TDRE))
    567e:	0233      	lsls	r3, r6, #8
    5680:	d528      	bpl.n	56d4 <HardwareSerialIMXRT::IRQHandler()+0xec>
    5682:	6953      	ldr	r3, [r2, #20]
    5684:	021d      	lsls	r5, r3, #8
    5686:	d525      	bpl.n	56d4 <HardwareSerialIMXRT::IRQHandler()+0xec>
		head = tx_buffer_head_;
    5688:	f8b0 5046 	ldrh.w	r5, [r0, #70]	; 0x46
		tail = tx_buffer_tail_;
    568c:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
		head = tx_buffer_head_;
    5690:	b2ad      	uxth	r5, r5
		tail = tx_buffer_tail_;
    5692:	b29b      	uxth	r3, r3
    5694:	e006      	b.n	56a4 <HardwareSerialIMXRT::IRQHandler()+0xbc>
				n = tx_buffer_[tail];
    5696:	69c1      	ldr	r1, [r0, #28]
    5698:	5cc9      	ldrb	r1, [r1, r3]
    569a:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    569c:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    569e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    56a0:	054c      	lsls	r4, r1, #21
    56a2:	d412      	bmi.n	56ca <HardwareSerialIMXRT::IRQHandler()+0xe2>
			if (head == tail) break;
    56a4:	42ab      	cmp	r3, r5
    56a6:	d038      	beq.n	571a <HardwareSerialIMXRT::IRQHandler()+0x132>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    56a8:	6b44      	ldr	r4, [r0, #52]	; 0x34
    56aa:	3301      	adds	r3, #1
			if (tail < tx_buffer_size_) {
    56ac:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
			if (++tail >= tx_buffer_total_size_) tail = 0;
    56ae:	429c      	cmp	r4, r3
    56b0:	bf98      	it	ls
    56b2:	2300      	movls	r3, #0
			if (tail < tx_buffer_size_) {
    56b4:	4299      	cmp	r1, r3
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    56b6:	eba3 0401 	sub.w	r4, r3, r1
			if (tail < tx_buffer_size_) {
    56ba:	d8ec      	bhi.n	5696 <HardwareSerialIMXRT::IRQHandler()+0xae>
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    56bc:	6a81      	ldr	r1, [r0, #40]	; 0x28
    56be:	5d09      	ldrb	r1, [r1, r4]
    56c0:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    56c2:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    56c4:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    56c6:	054c      	lsls	r4, r1, #21
    56c8:	d5ec      	bpl.n	56a4 <HardwareSerialIMXRT::IRQHandler()+0xbc>
		tx_buffer_tail_ = tail;
    56ca:	b299      	uxth	r1, r3
		if (head == tail) {
    56cc:	42ab      	cmp	r3, r5
		tx_buffer_tail_ = tail;
    56ce:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
		if (head == tail) {
    56d2:	d025      	beq.n	5720 <HardwareSerialIMXRT::IRQHandler()+0x138>
	if ((ctrl & LPUART_CTRL_TCIE) && (port->STAT & LPUART_STAT_TC))
    56d4:	0271      	lsls	r1, r6, #9
    56d6:	d516      	bpl.n	5706 <HardwareSerialIMXRT::IRQHandler()+0x11e>
    56d8:	6953      	ldr	r3, [r2, #20]
    56da:	025b      	lsls	r3, r3, #9
    56dc:	d513      	bpl.n	5706 <HardwareSerialIMXRT::IRQHandler()+0x11e>
		transmitting_ = 0;
    56de:	2100      	movs	r1, #0
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    56e0:	6d03      	ldr	r3, [r0, #80]	; 0x50
		transmitting_ = 0;
    56e2:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    56e6:	b113      	cbz	r3, 56ee <HardwareSerialIMXRT::IRQHandler()+0x106>
    56e8:	6d41      	ldr	r1, [r0, #84]	; 0x54
    56ea:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
		if(half_duplex_mode_) {		
    56ee:	7e83      	ldrb	r3, [r0, #26]
    56f0:	b12b      	cbz	r3, 56fe <HardwareSerialIMXRT::IRQHandler()+0x116>
			__disable_irq();
    56f2:	b672      	cpsid	i
		    port->CTRL &= ~LPUART_CTRL_TXDIR;
    56f4:	6993      	ldr	r3, [r2, #24]
    56f6:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
    56fa:	6193      	str	r3, [r2, #24]
			__enable_irq();
    56fc:	b662      	cpsie	i
		port->CTRL &= ~LPUART_CTRL_TCIE;
    56fe:	6993      	ldr	r3, [r2, #24]
    5700:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
    5704:	6193      	str	r3, [r2, #24]
}
    5706:	bd70      	pop	{r4, r5, r6, pc}
			port->STAT |= LPUART_STAT_IDLE;	// writing a 1 to idle should clear it. 
    5708:	6953      	ldr	r3, [r2, #20]
    570a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    570e:	6153      	str	r3, [r2, #20]
    5710:	e7b4      	b.n	567c <HardwareSerialIMXRT::IRQHandler()+0x94>
				else avail = rx_buffer_total_size_ + head - tail;
    5712:	6b81      	ldr	r1, [r0, #56]	; 0x38
    5714:	1b89      	subs	r1, r1, r6
    5716:	440d      	add	r5, r1
    5718:	e7a7      	b.n	566a <HardwareSerialIMXRT::IRQHandler()+0x82>
		tx_buffer_tail_ = tail;
    571a:	b29b      	uxth	r3, r3
    571c:	f8a0 3048 	strh.w	r3, [r0, #72]	; 0x48
			port->CTRL &= ~LPUART_CTRL_TIE; 
    5720:	6993      	ldr	r3, [r2, #24]
    5722:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    5726:	6193      	str	r3, [r2, #24]
  			port->CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
    5728:	6993      	ldr	r3, [r2, #24]
    572a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    572e:	6193      	str	r3, [r2, #24]
    5730:	e7d0      	b.n	56d4 <HardwareSerialIMXRT::IRQHandler()+0xec>
    5732:	bf00      	nop

00005734 <IRQHandler_Serial2>:
#define IRQ_PRIORITY  64  // 0 = highest priority, 255 = lowest


void IRQHandler_Serial2()
{
	Serial2.IRQHandler();
    5734:	4801      	ldr	r0, [pc, #4]	; (573c <IRQHandler_Serial2+0x8>)
    5736:	f7ff bf57 	b.w	55e8 <HardwareSerialIMXRT::IRQHandler()>
    573a:	bf00      	nop
    573c:	20001120 	.word	0x20001120

00005740 <usb_serial_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    5740:	4608      	mov	r0, r1
    5742:	f002 b8ed 	b.w	7920 <usb_serial_putchar>
    5746:	bf00      	nop

00005748 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>:
		base = 10;
    5748:	2a01      	cmp	r2, #1
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    574a:	b570      	push	{r4, r5, r6, lr}
		base = 10;
    574c:	bf08      	it	eq
    574e:	220a      	moveq	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    5750:	b08a      	sub	sp, #40	; 0x28
	if (n == 0) {
    5752:	b391      	cbz	r1, 57ba <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x72>
		i = sizeof(buf) - 1;
    5754:	f04f 0e21 	mov.w	lr, #33	; 0x21
    5758:	e001      	b.n	575e <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x16>
			i--;
    575a:	fa5f fe86 	uxtb.w	lr, r6
    575e:	f10e 36ff 	add.w	r6, lr, #4294967295
			digit = n % base;
    5762:	fbb1 f5f2 	udiv	r5, r1, r2
    5766:	fb02 1415 	mls	r4, r2, r5, r1
    576a:	fa5f fc84 	uxtb.w	ip, r4
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    576e:	2c09      	cmp	r4, #9
    5770:	f10c 0437 	add.w	r4, ip, #55	; 0x37
    5774:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    5778:	bf98      	it	ls
    577a:	fa5f f48c 	uxtbls.w	r4, ip
    577e:	f10e 0c28 	add.w	ip, lr, #40	; 0x28
    5782:	bf88      	it	hi
    5784:	b2e4      	uxtbhi	r4, r4
			if (n == 0) break;
    5786:	4291      	cmp	r1, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5788:	44ec      	add	ip, sp
			n /= base;
    578a:	4629      	mov	r1, r5
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    578c:	f80c 4c24 	strb.w	r4, [ip, #-36]
			if (n == 0) break;
    5790:	d2e3      	bcs.n	575a <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x12>
	if (sign) {
    5792:	b14b      	cbz	r3, 57a8 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x60>
		i--;
    5794:	f10e 3eff 	add.w	lr, lr, #4294967295
		buf[i] = '-';
    5798:	222d      	movs	r2, #45	; 0x2d
		i--;
    579a:	fa5f fe8e 	uxtb.w	lr, lr
		buf[i] = '-';
    579e:	f10e 0328 	add.w	r3, lr, #40	; 0x28
    57a2:	446b      	add	r3, sp
    57a4:	f803 2c24 	strb.w	r2, [r3, #-36]
	return write(buf + i, sizeof(buf) - i);
    57a8:	6803      	ldr	r3, [r0, #0]
    57aa:	a901      	add	r1, sp, #4
    57ac:	f1ce 0222 	rsb	r2, lr, #34	; 0x22
    57b0:	685b      	ldr	r3, [r3, #4]
    57b2:	4471      	add	r1, lr
    57b4:	4798      	blx	r3
}
    57b6:	b00a      	add	sp, #40	; 0x28
    57b8:	bd70      	pop	{r4, r5, r6, pc}
		buf[sizeof(buf) - 1] = '0';
    57ba:	2230      	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    57bc:	f04f 0e21 	mov.w	lr, #33	; 0x21
		buf[sizeof(buf) - 1] = '0';
    57c0:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    57c4:	e7e5      	b.n	5792 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x4a>
    57c6:	bf00      	nop

000057c8 <Print::write(unsigned char const*, unsigned int)>:
{
    57c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buffer == nullptr) return 0;
    57cc:	460c      	mov	r4, r1
    57ce:	b1d1      	cbz	r1, 5806 <Print::write(unsigned char const*, unsigned int)+0x3e>
	while (size--) count += write(*buffer++);
    57d0:	b1ea      	cbz	r2, 580e <Print::write(unsigned char const*, unsigned int)+0x46>
    57d2:	4680      	mov	r8, r0
    57d4:	188e      	adds	r6, r1, r2
	size_t count = 0;
    57d6:	2500      	movs	r5, #0
    57d8:	4f0e      	ldr	r7, [pc, #56]	; (5814 <Print::write(unsigned char const*, unsigned int)+0x4c>)
    57da:	e004      	b.n	57e6 <Print::write(unsigned char const*, unsigned int)+0x1e>
    57dc:	f002 f8a0 	bl	7920 <usb_serial_putchar>
	while (size--) count += write(*buffer++);
    57e0:	42b4      	cmp	r4, r6
    57e2:	4405      	add	r5, r0
    57e4:	d00c      	beq.n	5800 <Print::write(unsigned char const*, unsigned int)+0x38>
    57e6:	f8d8 3000 	ldr.w	r3, [r8]
    57ea:	f814 0b01 	ldrb.w	r0, [r4], #1
    57ee:	681b      	ldr	r3, [r3, #0]
    57f0:	42bb      	cmp	r3, r7
    57f2:	d0f3      	beq.n	57dc <Print::write(unsigned char const*, unsigned int)+0x14>
    57f4:	4601      	mov	r1, r0
    57f6:	4640      	mov	r0, r8
    57f8:	4798      	blx	r3
    57fa:	42b4      	cmp	r4, r6
    57fc:	4405      	add	r5, r0
    57fe:	d1f2      	bne.n	57e6 <Print::write(unsigned char const*, unsigned int)+0x1e>
}
    5800:	4628      	mov	r0, r5
    5802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    5806:	460d      	mov	r5, r1
}
    5808:	4628      	mov	r0, r5
    580a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    580e:	4615      	mov	r5, r2
    5810:	e7f6      	b.n	5800 <Print::write(unsigned char const*, unsigned int)+0x38>
    5812:	bf00      	nop
    5814:	00005741 	.word	0x00005741

00005818 <Print::print(long)>:
	if (n < 0) {
    5818:	2900      	cmp	r1, #0
    581a:	db03      	blt.n	5824 <Print::print(long)+0xc>
	uint8_t sign=0;
    581c:	2300      	movs	r3, #0
	if (base == 0) {
    581e:	220a      	movs	r2, #10
    5820:	f7ff bf92 	b.w	5748 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
		n = -n;
    5824:	4249      	negs	r1, r1
		sign = '-';
    5826:	232d      	movs	r3, #45	; 0x2d
	if (base == 0) {
    5828:	220a      	movs	r2, #10
    582a:	f7ff bf8d 	b.w	5748 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    582e:	bf00      	nop

00005830 <Print::println()>:
{
    5830:	b500      	push	{lr}
	return write(buf, 2);
    5832:	6803      	ldr	r3, [r0, #0]
{
    5834:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    5836:	f640 2c0d 	movw	ip, #2573	; 0xa0d
	return write(buf, 2);
    583a:	2202      	movs	r2, #2
    583c:	a901      	add	r1, sp, #4
    583e:	685b      	ldr	r3, [r3, #4]
	uint8_t buf[2]={'\r', '\n'};
    5840:	f8ad c004 	strh.w	ip, [sp, #4]
	return write(buf, 2);
    5844:	4798      	blx	r3
}
    5846:	b003      	add	sp, #12
    5848:	f85d fb04 	ldr.w	pc, [sp], #4

0000584c <_write>:
	return ((class Print *)file)->write((uint8_t *)ptr, len);
    584c:	4b05      	ldr	r3, [pc, #20]	; (5864 <_write+0x18>)
    584e:	2802      	cmp	r0, #2
    5850:	bf88      	it	hi
    5852:	4603      	movhi	r3, r0
{
    5854:	b410      	push	{r4}
	return ((class Print *)file)->write((uint8_t *)ptr, len);
    5856:	681c      	ldr	r4, [r3, #0]
    5858:	4618      	mov	r0, r3
    585a:	6863      	ldr	r3, [r4, #4]
}
    585c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return ((class Print *)file)->write((uint8_t *)ptr, len);
    5860:	4718      	bx	r3
    5862:	bf00      	nop
    5864:	20001110 	.word	0x20001110

00005868 <Print::printf(char const*, ...)>:
{
    5868:	b40e      	push	{r1, r2, r3}
    586a:	b500      	push	{lr}
    586c:	b082      	sub	sp, #8
    586e:	aa03      	add	r2, sp, #12
    5870:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(ap, format);
    5874:	9201      	str	r2, [sp, #4]
	int retval = vdprintf((int)this, format, ap);
    5876:	f002 ff5d 	bl	8734 <vdprintf>
}
    587a:	b002      	add	sp, #8
    587c:	f85d eb04 	ldr.w	lr, [sp], #4
    5880:	b003      	add	sp, #12
    5882:	4770      	bx	lr

00005884 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	if (base == 0) {
    5884:	b95a      	cbnz	r2, 589e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1a>
		return write((uint8_t)n);
    5886:	6803      	ldr	r3, [r0, #0]
    5888:	b2c9      	uxtb	r1, r1
    588a:	4a07      	ldr	r2, [pc, #28]	; (58a8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x24>)
    588c:	681b      	ldr	r3, [r3, #0]
    588e:	4293      	cmp	r3, r2
{
    5890:	b500      	push	{lr}
    5892:	d106      	bne.n	58a2 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    5894:	4608      	mov	r0, r1
}
    5896:	f85d eb04 	ldr.w	lr, [sp], #4
    589a:	f002 b841 	b.w	7920 <usb_serial_putchar>
    589e:	f7ff bf53 	b.w	5748 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    58a2:	f85d eb04 	ldr.w	lr, [sp], #4
		return write((uint8_t)n);
    58a6:	4718      	bx	r3
    58a8:	00005741 	.word	0x00005741

000058ac <usb_serial_class::read()>:
        virtual int read() { return usb_serial_getchar(); }
    58ac:	f002 b828 	b.w	7900 <usb_serial_getchar>

000058b0 <usb_serial_class::peek()>:
        virtual int peek() { return usb_serial_peekchar(); }
    58b0:	f001 bfc0 	b.w	7834 <usb_serial_peekchar>

000058b4 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    58b4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
    58b8:	b392      	cbz	r2, 5920 <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
    58ba:	4617      	mov	r7, r2
    58bc:	fab3 f283 	clz	r2, r3
    58c0:	0952      	lsrs	r2, r2, #5
    58c2:	b36b      	cbz	r3, 5920 <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
	length--;
	size_t index = 0;
	while (index < length) {
    58c4:	f1b3 0801 	subs.w	r8, r3, #1
    58c8:	d025      	beq.n	5916 <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    58ca:	eb07 0a08 	add.w	sl, r7, r8
    58ce:	4683      	mov	fp, r0
    58d0:	4689      	mov	r9, r1
	size_t index = 0;
    58d2:	4690      	mov	r8, r2
    58d4:	4c17      	ldr	r4, [pc, #92]	; (5934 <Stream::readBytesUntil(char, char*, unsigned int)+0x80>)
    58d6:	4e18      	ldr	r6, [pc, #96]	; (5938 <Stream::readBytesUntil(char, char*, unsigned int)+0x84>)
    58d8:	6825      	ldr	r5, [r4, #0]
    58da:	e00b      	b.n	58f4 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
        virtual int read() { return usb_serial_getchar(); }
    58dc:	f002 f810 	bl	7900 <usb_serial_getchar>
    if (c >= 0) return c;
    58e0:	2800      	cmp	r0, #0
    58e2:	da10      	bge.n	5906 <Stream::readBytesUntil(char, char*, unsigned int)+0x52>
    yield();
    58e4:	f002 f8b0 	bl	7a48 <yield>
    58e8:	6823      	ldr	r3, [r4, #0]
  } while(millis() - startMillis < _timeout);
    58ea:	f8db 2008 	ldr.w	r2, [fp, #8]
    58ee:	1b5b      	subs	r3, r3, r5
    58f0:	4293      	cmp	r3, r2
    58f2:	d21a      	bcs.n	592a <Stream::readBytesUntil(char, char*, unsigned int)+0x76>
    c = read();
    58f4:	f8db 3000 	ldr.w	r3, [fp]
    58f8:	695b      	ldr	r3, [r3, #20]
    58fa:	42b3      	cmp	r3, r6
    58fc:	d0ee      	beq.n	58dc <Stream::readBytesUntil(char, char*, unsigned int)+0x28>
    58fe:	4658      	mov	r0, fp
    5900:	4798      	blx	r3
    if (c >= 0) return c;
    5902:	2800      	cmp	r0, #0
    5904:	dbee      	blt.n	58e4 <Stream::readBytesUntil(char, char*, unsigned int)+0x30>
		int c = timedRead();
		if (c == terminator) break;
    5906:	4548      	cmp	r0, r9
    5908:	d005      	beq.n	5916 <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
		if (c < 0) {
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    590a:	f807 0b01 	strb.w	r0, [r7], #1
	while (index < length) {
    590e:	45ba      	cmp	sl, r7
		index++;
    5910:	f108 0801 	add.w	r8, r8, #1
	while (index < length) {
    5914:	d1e0      	bne.n	58d8 <Stream::readBytesUntil(char, char*, unsigned int)+0x24>
	}
	*buffer = 0;
    5916:	2300      	movs	r3, #0
	return index; // return number of characters, not including null terminator
}
    5918:	4640      	mov	r0, r8
	*buffer = 0;
    591a:	703b      	strb	r3, [r7, #0]
}
    591c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (length < 1) return 0;
    5920:	f04f 0800 	mov.w	r8, #0
}
    5924:	4640      	mov	r0, r8
    5926:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	String readString(size_t max = 0 /* 0 means unlimited length */);
	String readStringUntil(char terminator, size_t max = 0 /* 0 means unlimited length */);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    592a:	2301      	movs	r3, #1
    592c:	f88b 300c 	strb.w	r3, [fp, #12]
    5930:	e7f1      	b.n	5916 <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    5932:	bf00      	nop
    5934:	200075a8 	.word	0x200075a8
    5938:	000058ad 	.word	0x000058ad

0000593c <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    593c:	49a2      	ldr	r1, [pc, #648]	; (5bc8 <set_arm_clock+0x28c>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    593e:	4ba3      	ldr	r3, [pc, #652]	; (5bcc <set_arm_clock+0x290>)
	if (frequency > 528000000) {
    5940:	4288      	cmp	r0, r1
{
    5942:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t dcdc = DCDC_REG3;
    5946:	4ca2      	ldr	r4, [pc, #648]	; (5bd0 <set_arm_clock+0x294>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    5948:	695e      	ldr	r6, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    594a:	699a      	ldr	r2, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    594c:	f8d4 800c 	ldr.w	r8, [r4, #12]
	if (frequency > 528000000) {
    5950:	d91b      	bls.n	598a <set_arm_clock+0x4e>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    5952:	4ba0      	ldr	r3, [pc, #640]	; (5bd4 <set_arm_clock+0x298>)
    5954:	4298      	cmp	r0, r3
    5956:	f240 8102 	bls.w	5b5e <set_arm_clock+0x222>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    595a:	1ac3      	subs	r3, r0, r3
    595c:	499e      	ldr	r1, [pc, #632]	; (5bd8 <set_arm_clock+0x29c>)
    595e:	0a1b      	lsrs	r3, r3, #8
    5960:	fba1 1303 	umull	r1, r3, r1, r3
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5964:	f240 6127 	movw	r1, #1575	; 0x627
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    5968:	09db      	lsrs	r3, r3, #7
    596a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    596e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    5972:	f203 43e2 	addw	r3, r3, #1250	; 0x4e2
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5976:	428b      	cmp	r3, r1
    5978:	bf28      	it	cs
    597a:	460b      	movcs	r3, r1
    597c:	f5a3 7748 	sub.w	r7, r3, #800	; 0x320
    5980:	4b96      	ldr	r3, [pc, #600]	; (5bdc <set_arm_clock+0x2a0>)
    5982:	fba3 3707 	umull	r3, r7, r3, r7
    5986:	08ff      	lsrs	r7, r7, #3
    5988:	e004      	b.n	5994 <set_arm_clock+0x58>
	} else if (frequency <= 24000000) {
    598a:	4f95      	ldr	r7, [pc, #596]	; (5be0 <set_arm_clock+0x2a4>)
    598c:	42b8      	cmp	r0, r7
    598e:	bf8c      	ite	hi
    5990:	270e      	movhi	r7, #14
    5992:	2706      	movls	r7, #6
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    5994:	498d      	ldr	r1, [pc, #564]	; (5bcc <set_arm_clock+0x290>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5996:	f008 091f 	and.w	r9, r8, #31
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    599a:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    599e:	45b9      	cmp	r9, r7
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    59a0:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    59a4:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    59a8:	d20c      	bcs.n	59c4 <set_arm_clock+0x88>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    59aa:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    59ae:	f5a1 21f8 	sub.w	r1, r1, #507904	; 0x7c000
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    59b2:	ea48 0807 	orr.w	r8, r8, r7
		DCDC_REG3 = dcdc;
    59b6:	f8c1 800c 	str.w	r8, [r1, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    59ba:	680b      	ldr	r3, [r1, #0]
    59bc:	2b00      	cmp	r3, #0
    59be:	dafc      	bge.n	59ba <set_arm_clock+0x7e>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    59c0:	f008 091f 	and.w	r9, r8, #31
	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    59c4:	f016 7300 	ands.w	r3, r6, #33554432	; 0x2000000
    59c8:	d124      	bne.n	5a14 <set_arm_clock+0xd8>
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    59ca:	4986      	ldr	r1, [pc, #536]	; (5be4 <set_arm_clock+0x2a8>)
    59cc:	690c      	ldr	r4, [r1, #16]
    59ce:	4986      	ldr	r1, [pc, #536]	; (5be8 <set_arm_clock+0x2ac>)
    59d0:	43a1      	bics	r1, r4
    59d2:	f000 80ea 	beq.w	5baa <set_arm_clock+0x26e>
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    59d6:	f482 5180 	eor.w	r1, r2, #4096	; 0x1000
    59da:	4634      	mov	r4, r6
    59dc:	f44f 5580 	mov.w	r5, #4096	; 0x1000
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    59e0:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    59e4:	d004      	beq.n	59f0 <set_arm_clock+0xb4>
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    59e6:	f026 5660 	bic.w	r6, r6, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    59ea:	431e      	orrs	r6, r3
			CCM_CBCDR = cbcdr;
    59ec:	4b77      	ldr	r3, [pc, #476]	; (5bcc <set_arm_clock+0x290>)
    59ee:	615e      	str	r6, [r3, #20]
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    59f0:	f411 5f40 	tst.w	r1, #12288	; 0x3000
    59f4:	d007      	beq.n	5a06 <set_arm_clock+0xca>
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    59f6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
			CCM_CBCMR = cbcmr;
    59fa:	4974      	ldr	r1, [pc, #464]	; (5bcc <set_arm_clock+0x290>)
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    59fc:	432a      	orrs	r2, r5
			CCM_CBCMR = cbcmr;
    59fe:	618a      	str	r2, [r1, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    5a00:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    5a02:	071a      	lsls	r2, r3, #28
    5a04:	d4fc      	bmi.n	5a00 <set_arm_clock+0xc4>
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    5a06:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    5a0a:	4a70      	ldr	r2, [pc, #448]	; (5bcc <set_arm_clock+0x290>)
    5a0c:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    5a0e:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5a10:	069b      	lsls	r3, r3, #26
    5a12:	d4fc      	bmi.n	5a0e <set_arm_clock+0xd2>
	while (frequency * div_arm * div_ahb < 648000000) {
    5a14:	4c75      	ldr	r4, [pc, #468]	; (5bec <set_arm_clock+0x2b0>)
    5a16:	42a0      	cmp	r0, r4
    5a18:	f200 80ce 	bhi.w	5bb8 <set_arm_clock+0x27c>
	uint32_t div_ahb = 1;
    5a1c:	f04f 0c01 	mov.w	ip, #1
    5a20:	4601      	mov	r1, r0
	uint32_t div_arm = 1;
    5a22:	4663      	mov	r3, ip
	while (frequency * div_arm * div_ahb < 648000000) {
    5a24:	fb03 1201 	mla	r2, r3, r1, r1
			div_arm = div_arm + 1;
    5a28:	f103 0e01 	add.w	lr, r3, #1
				div_ahb = div_ahb + 1;
    5a2c:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5a30:	42a2      	cmp	r2, r4
    5a32:	d818      	bhi.n	5a66 <set_arm_clock+0x12a>
		if (div_arm < 8) {
    5a34:	f1be 0f08 	cmp.w	lr, #8
				div_arm = 1;
    5a38:	f04f 0301 	mov.w	r3, #1
		if (div_arm < 8) {
    5a3c:	f040 808d 	bne.w	5b5a <set_arm_clock+0x21e>
			if (div_ahb < 5) {
    5a40:	f1bc 0f04 	cmp.w	ip, #4
    5a44:	f200 8091 	bhi.w	5b6a <set_arm_clock+0x22e>
	while (frequency * div_arm * div_ahb < 648000000) {
    5a48:	180a      	adds	r2, r1, r0
    5a4a:	42a2      	cmp	r2, r4
    5a4c:	f200 80a4 	bhi.w	5b98 <set_arm_clock+0x25c>
    5a50:	fb05 f100 	mul.w	r1, r5, r0
				div_ahb = div_ahb + 1;
    5a54:	46ac      	mov	ip, r5
			div_arm = div_arm + 1;
    5a56:	f103 0e01 	add.w	lr, r3, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5a5a:	fb03 1201 	mla	r2, r3, r1, r1
				div_ahb = div_ahb + 1;
    5a5e:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5a62:	42a2      	cmp	r2, r4
    5a64:	d9e6      	bls.n	5a34 <set_arm_clock+0xf8>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5a66:	f10c 31ff 	add.w	r1, ip, #4294967295
    5a6a:	028c      	lsls	r4, r1, #10
    5a6c:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5a70:	485f      	ldr	r0, [pc, #380]	; (5bf0 <set_arm_clock+0x2b4>)
    5a72:	4410      	add	r0, r2
	if (mult > 108) mult = 108;
    5a74:	4a5f      	ldr	r2, [pc, #380]	; (5bf4 <set_arm_clock+0x2b8>)
    5a76:	4290      	cmp	r0, r2
    5a78:	d97f      	bls.n	5b7a <set_arm_clock+0x23e>
    5a7a:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 5c20 <set_arm_clock+0x2e4>
    5a7e:	226c      	movs	r2, #108	; 0x6c
    5a80:	485d      	ldr	r0, [pc, #372]	; (5bf8 <set_arm_clock+0x2bc>)
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    5a82:	4d58      	ldr	r5, [pc, #352]	; (5be4 <set_arm_clock+0x2a8>)
	frequency = mult * 12000000 / div_arm / div_ahb;
    5a84:	fbb0 f0fe 	udiv	r0, r0, lr
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    5a88:	f8d5 e000 	ldr.w	lr, [r5]
	frequency = mult * 12000000 / div_arm / div_ahb;
    5a8c:	fbb0 f0fc 	udiv	r0, r0, ip
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    5a90:	f8df c190 	ldr.w	ip, [pc, #400]	; 5c24 <set_arm_clock+0x2e8>
    5a94:	ea0e 0c0c 	and.w	ip, lr, ip
    5a98:	45d4      	cmp	ip, sl
    5a9a:	d009      	beq.n	5ab0 <set_arm_clock+0x174>
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    5a9c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    5aa0:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    5aa4:	f8c5 c000 	str.w	ip, [r5]
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    5aa8:	602a      	str	r2, [r5, #0]
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    5aaa:	682a      	ldr	r2, [r5, #0]
    5aac:	2a00      	cmp	r2, #0
    5aae:	dafc      	bge.n	5aaa <set_arm_clock+0x16e>
	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    5ab0:	4a46      	ldr	r2, [pc, #280]	; (5bcc <set_arm_clock+0x290>)
    5ab2:	6915      	ldr	r5, [r2, #16]
    5ab4:	f005 0507 	and.w	r5, r5, #7
    5ab8:	429d      	cmp	r5, r3
    5aba:	d003      	beq.n	5ac4 <set_arm_clock+0x188>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    5abc:	6113      	str	r3, [r2, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    5abe:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5ac0:	03dd      	lsls	r5, r3, #15
    5ac2:	d4fc      	bmi.n	5abe <set_arm_clock+0x182>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5ac4:	f411 5fe0 	tst.w	r1, #7168	; 0x1c00
    5ac8:	d009      	beq.n	5ade <set_arm_clock+0x1a2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    5aca:	f426 56e0 	bic.w	r6, r6, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    5ace:	f404 54e0 	and.w	r4, r4, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
    5ad2:	4a3e      	ldr	r2, [pc, #248]	; (5bcc <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    5ad4:	4326      	orrs	r6, r4
		CCM_CBCDR = cbcdr;
    5ad6:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    5ad8:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5ada:	0799      	lsls	r1, r3, #30
    5adc:	d4fc      	bmi.n	5ad8 <set_arm_clock+0x19c>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    5ade:	4947      	ldr	r1, [pc, #284]	; (5bfc <set_arm_clock+0x2c0>)
	if (div_ipg > 4) div_ipg = 4;
    5ae0:	4a47      	ldr	r2, [pc, #284]	; (5c00 <set_arm_clock+0x2c4>)
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    5ae2:	4401      	add	r1, r0
	if (div_ipg > 4) div_ipg = 4;
    5ae4:	4291      	cmp	r1, r2
    5ae6:	d83c      	bhi.n	5b62 <set_arm_clock+0x226>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    5ae8:	4b46      	ldr	r3, [pc, #280]	; (5c04 <set_arm_clock+0x2c8>)
    5aea:	09c9      	lsrs	r1, r1, #7
    5aec:	fba3 3101 	umull	r3, r1, r3, r1
    5af0:	0b09      	lsrs	r1, r1, #12
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    5af2:	1e4b      	subs	r3, r1, #1
    5af4:	021b      	lsls	r3, r3, #8
    5af6:	ea86 0203 	eor.w	r2, r6, r3
    5afa:	f412 7f40 	tst.w	r2, #768	; 0x300
    5afe:	d006      	beq.n	5b0e <set_arm_clock+0x1d2>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    5b00:	f426 7640 	bic.w	r6, r6, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    5b04:	f403 7340 	and.w	r3, r3, #768	; 0x300
		CCM_CBCDR = cbcdr;
    5b08:	4a30      	ldr	r2, [pc, #192]	; (5bcc <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    5b0a:	4333      	orrs	r3, r6
		CCM_CBCDR = cbcdr;
    5b0c:	6153      	str	r3, [r2, #20]
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    5b0e:	4a2f      	ldr	r2, [pc, #188]	; (5bcc <set_arm_clock+0x290>)
    5b10:	6953      	ldr	r3, [r2, #20]
    5b12:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
    5b16:	6153      	str	r3, [r2, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    5b18:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5b1a:	069b      	lsls	r3, r3, #26
    5b1c:	d4fc      	bmi.n	5b18 <set_arm_clock+0x1dc>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5b1e:	4b3a      	ldr	r3, [pc, #232]	; (5c08 <set_arm_clock+0x2cc>)
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b20:	454f      	cmp	r7, r9
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5b22:	fba3 2300 	umull	r2, r3, r3, r0
    5b26:	f04f 32ff 	mov.w	r2, #4294967295
    5b2a:	ea4f 4393 	mov.w	r3, r3, lsr #18
	F_BUS_ACTUAL = frequency / div_ipg;
    5b2e:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5b32:	fbb2 f3f3 	udiv	r3, r2, r3
	F_CPU_ACTUAL = frequency;
    5b36:	4a35      	ldr	r2, [pc, #212]	; (5c0c <set_arm_clock+0x2d0>)
    5b38:	6010      	str	r0, [r2, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
    5b3a:	4a35      	ldr	r2, [pc, #212]	; (5c10 <set_arm_clock+0x2d4>)
    5b3c:	6011      	str	r1, [r2, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5b3e:	4a35      	ldr	r2, [pc, #212]	; (5c14 <set_arm_clock+0x2d8>)
    5b40:	6013      	str	r3, [r2, #0]
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b42:	d208      	bcs.n	5b56 <set_arm_clock+0x21a>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    5b44:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    5b48:	4a21      	ldr	r2, [pc, #132]	; (5bd0 <set_arm_clock+0x294>)
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    5b4a:	ea48 0707 	orr.w	r7, r8, r7
		DCDC_REG3 = dcdc;
    5b4e:	60d7      	str	r7, [r2, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    5b50:	6813      	ldr	r3, [r2, #0]
    5b52:	2b00      	cmp	r3, #0
    5b54:	dafc      	bge.n	5b50 <set_arm_clock+0x214>
	}

	return frequency;
}
    5b56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5b5a:	4673      	mov	r3, lr
    5b5c:	e762      	b.n	5a24 <set_arm_clock+0xe8>
    5b5e:	2712      	movs	r7, #18
    5b60:	e718      	b.n	5994 <set_arm_clock+0x58>
    5b62:	f44f 7340 	mov.w	r3, #768	; 0x300
	if (div_ipg > 4) div_ipg = 4;
    5b66:	2104      	movs	r1, #4
    5b68:	e7c5      	b.n	5af6 <set_arm_clock+0x1ba>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5b6a:	f10c 31ff 	add.w	r1, ip, #4294967295
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5b6e:	4820      	ldr	r0, [pc, #128]	; (5bf0 <set_arm_clock+0x2b4>)
    5b70:	2307      	movs	r3, #7
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5b72:	028c      	lsls	r4, r1, #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5b74:	4410      	add	r0, r2
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5b76:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5b7a:	4a27      	ldr	r2, [pc, #156]	; (5c18 <set_arm_clock+0x2dc>)
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    5b7c:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 5c28 <set_arm_clock+0x2ec>
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5b80:	fba2 2000 	umull	r2, r0, r2, r0
    5b84:	0d02      	lsrs	r2, r0, #20
	frequency = mult * 12000000 / div_arm / div_ahb;
    5b86:	4825      	ldr	r0, [pc, #148]	; (5c1c <set_arm_clock+0x2e0>)
    5b88:	2a36      	cmp	r2, #54	; 0x36
    5b8a:	bf38      	it	cc
    5b8c:	2236      	movcc	r2, #54	; 0x36
    5b8e:	fb02 f000 	mul.w	r0, r2, r0
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    5b92:	ea42 0a0a 	orr.w	sl, r2, sl
    5b96:	e774      	b.n	5a82 <set_arm_clock+0x146>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5b98:	ea4f 248c 	mov.w	r4, ip, lsl #10
    5b9c:	2300      	movs	r3, #0
    5b9e:	ea86 218c 	eor.w	r1, r6, ip, lsl #10
				div_arm = 1;
    5ba2:	f04f 0e01 	mov.w	lr, #1
				div_ahb = div_ahb + 1;
    5ba6:	46ac      	mov	ip, r5
    5ba8:	e762      	b.n	5a70 <set_arm_clock+0x134>
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    5baa:	461d      	mov	r5, r3
    5bac:	f086 54c0 	eor.w	r4, r6, #402653184	; 0x18000000
    5bb0:	4611      	mov	r1, r2
    5bb2:	f04f 53c0 	mov.w	r3, #402653184	; 0x18000000
    5bb6:	e713      	b.n	59e0 <set_arm_clock+0xa4>
	while (frequency * div_arm * div_ahb < 648000000) {
    5bb8:	2400      	movs	r4, #0
	uint32_t div_ahb = 1;
    5bba:	f04f 0c01 	mov.w	ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5bbe:	4602      	mov	r2, r0
    5bc0:	4631      	mov	r1, r6
    5bc2:	4623      	mov	r3, r4
	uint32_t div_arm = 1;
    5bc4:	46e6      	mov	lr, ip
    5bc6:	e753      	b.n	5a70 <set_arm_clock+0x134>
    5bc8:	1f78a400 	.word	0x1f78a400
    5bcc:	400fc000 	.word	0x400fc000
    5bd0:	40080000 	.word	0x40080000
    5bd4:	23c34600 	.word	0x23c34600
    5bd8:	004cb223 	.word	0x004cb223
    5bdc:	51eb851f 	.word	0x51eb851f
    5be0:	016e3600 	.word	0x016e3600
    5be4:	400d8000 	.word	0x400d8000
    5be8:	80003040 	.word	0x80003040
    5bec:	269fb1ff 	.word	0x269fb1ff
    5bf0:	005b8d80 	.word	0x005b8d80
    5bf4:	4df67eff 	.word	0x4df67eff
    5bf8:	4d3f6400 	.word	0x4d3f6400
    5bfc:	08f0d17f 	.word	0x08f0d17f
    5c00:	2cb4177f 	.word	0x2cb4177f
    5c04:	00e5109f 	.word	0x00e5109f
    5c08:	431bde83 	.word	0x431bde83
    5c0c:	2000110c 	.word	0x2000110c
    5c10:	20001108 	.word	0x20001108
    5c14:	2000755c 	.word	0x2000755c
    5c18:	165e9f81 	.word	0x165e9f81
    5c1c:	00b71b00 	.word	0x00b71b00
    5c20:	8000206c 	.word	0x8000206c
    5c24:	8001307f 	.word	0x8001307f
    5c28:	80002000 	.word	0x80002000

00005c2c <delay>:
	if (msec == 0) return;
    5c2c:	b900      	cbnz	r0, 5c30 <delay+0x4>
    5c2e:	4770      	bx	lr
{
    5c30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5c34:	2101      	movs	r1, #1
    5c36:	4681      	mov	r9, r0
    5c38:	4c21      	ldr	r4, [pc, #132]	; (5cc0 <delay+0x94>)
    5c3a:	4d22      	ldr	r5, [pc, #136]	; (5cc4 <delay+0x98>)
    5c3c:	4e22      	ldr	r6, [pc, #136]	; (5cc8 <delay+0x9c>)
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    5c3e:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    5c42:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5c44:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5c46:	e844 1300 	strex	r3, r1, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    5c4a:	2b00      	cmp	r3, #0
    5c4c:	d1f7      	bne.n	5c3e <delay+0x12>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    5c4e:	491f      	ldr	r1, [pc, #124]	; (5ccc <delay+0xa0>)
    5c50:	684b      	ldr	r3, [r1, #4]
	uint32_t usec = 1000*smc + frac;
    5c52:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5c56:	f8df a078 	ldr.w	sl, [pc, #120]	; 5cd0 <delay+0xa4>
	uint32_t ccdelta = cyccnt - scc;
    5c5a:	1a1b      	subs	r3, r3, r0
    5c5c:	2701      	movs	r7, #1
	uint32_t usec = 1000*smc + frac;
    5c5e:	fb0b f802 	mul.w	r8, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5c62:	f8da 2000 	ldr.w	r2, [sl]
    5c66:	fba3 3202 	umull	r3, r2, r3, r2
	uint32_t usec = 1000*smc + frac;
    5c6a:	455a      	cmp	r2, fp
    5c6c:	bf94      	ite	ls
    5c6e:	4490      	addls	r8, r2
    5c70:	44d8      	addhi	r8, fp
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    5c72:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    5c76:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5c78:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5c7a:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    5c7e:	2b00      	cmp	r3, #0
    5c80:	d1f7      	bne.n	5c72 <delay+0x46>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    5c82:	684b      	ldr	r3, [r1, #4]
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5c84:	f8da c000 	ldr.w	ip, [sl]
	uint32_t ccdelta = cyccnt - scc;
    5c88:	1a1b      	subs	r3, r3, r0
	uint32_t usec = 1000*smc + frac;
    5c8a:	fb0b f202 	mul.w	r2, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5c8e:	fba3 3c0c 	umull	r3, ip, r3, ip
	uint32_t usec = 1000*smc + frac;
    5c92:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
    5c96:	bf94      	ite	ls
    5c98:	4462      	addls	r2, ip
    5c9a:	f502 727a 	addhi.w	r2, r2, #1000	; 0x3e8
		while ((micros() - start) >= 1000) {
    5c9e:	eba2 0208 	sub.w	r2, r2, r8
    5ca2:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
    5ca6:	d306      	bcc.n	5cb6 <delay+0x8a>
			if (--msec == 0) return;
    5ca8:	f1b9 0901 	subs.w	r9, r9, #1
			start += 1000;
    5cac:	f508 787a 	add.w	r8, r8, #1000	; 0x3e8
			if (--msec == 0) return;
    5cb0:	d1df      	bne.n	5c72 <delay+0x46>
}
    5cb2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		yield();
    5cb6:	f001 fec7 	bl	7a48 <yield>
		while ((micros() - start) >= 1000) {
    5cba:	4904      	ldr	r1, [pc, #16]	; (5ccc <delay+0xa0>)
    5cbc:	e7d9      	b.n	5c72 <delay+0x46>
    5cbe:	bf00      	nop
    5cc0:	200075ac 	.word	0x200075ac
    5cc4:	200075a8 	.word	0x200075a8
    5cc8:	200075a4 	.word	0x200075a4
    5ccc:	e0001000 	.word	0xe0001000
    5cd0:	2000755c 	.word	0x2000755c

00005cd4 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    5cd4:	2827      	cmp	r0, #39	; 0x27
    5cd6:	d816      	bhi.n	5d06 <digitalWrite+0x32>
	p = digital_pin_to_info_PGM + pin;
    5cd8:	0102      	lsls	r2, r0, #4
    5cda:	4b10      	ldr	r3, [pc, #64]	; (5d1c <digitalWrite+0x48>)
    5cdc:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	pinmode = *(p->reg + 1);
    5ce0:	589b      	ldr	r3, [r3, r2]
{
    5ce2:	b410      	push	{r4}
	mask = p->mask;
    5ce4:	68c2      	ldr	r2, [r0, #12]
	pinmode = *(p->reg + 1);
    5ce6:	685c      	ldr	r4, [r3, #4]
	if (pinmode & mask) {
    5ce8:	4214      	tst	r4, r2
    5cea:	d005      	beq.n	5cf8 <digitalWrite+0x24>
		// pin is configured for output mode
		if (val) {
    5cec:	b961      	cbnz	r1, 5d08 <digitalWrite+0x34>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    5cee:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x22) = mask; // clear register
    5cf2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
    5cf6:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5cf8:	6883      	ldr	r3, [r0, #8]
		if (val) {
    5cfa:	b151      	cbz	r1, 5d12 <digitalWrite+0x3e>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5cfc:	4a08      	ldr	r2, [pc, #32]	; (5d20 <digitalWrite+0x4c>)
}
    5cfe:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5d02:	601a      	str	r2, [r3, #0]
}
    5d04:	4770      	bx	lr
    5d06:	4770      	bx	lr
    5d08:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x21) = mask; // set register
    5d0c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    5d10:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5d12:	4a04      	ldr	r2, [pc, #16]	; (5d24 <digitalWrite+0x50>)
}
    5d14:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5d18:	601a      	str	r2, [r3, #0]
}
    5d1a:	4770      	bx	lr
    5d1c:	20000b7c 	.word	0x20000b7c
    5d20:	0001f038 	.word	0x0001f038
    5d24:	00013038 	.word	0x00013038

00005d28 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    5d28:	2827      	cmp	r0, #39	; 0x27
    5d2a:	d80b      	bhi.n	5d44 <digitalRead+0x1c>
	p = digital_pin_to_info_PGM + pin;
    5d2c:	4b06      	ldr	r3, [pc, #24]	; (5d48 <digitalRead+0x20>)
    5d2e:	0102      	lsls	r2, r0, #4
    5d30:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    5d34:	589a      	ldr	r2, [r3, r2]
    5d36:	68c3      	ldr	r3, [r0, #12]
    5d38:	6892      	ldr	r2, [r2, #8]
    5d3a:	421a      	tst	r2, r3
    5d3c:	bf14      	ite	ne
    5d3e:	2001      	movne	r0, #1
    5d40:	2000      	moveq	r0, #0
    5d42:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return 0;
    5d44:	2000      	movs	r0, #0
}
    5d46:	4770      	bx	lr
    5d48:	20000b7c 	.word	0x20000b7c

00005d4c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    5d4c:	2827      	cmp	r0, #39	; 0x27
    5d4e:	d829      	bhi.n	5da4 <pinMode+0x58>
	p = digital_pin_to_info_PGM + pin;
    5d50:	4b16      	ldr	r3, [pc, #88]	; (5dac <pinMode+0x60>)
    5d52:	0102      	lsls	r2, r0, #4
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5d54:	2901      	cmp	r1, #1
	p = digital_pin_to_info_PGM + pin;
    5d56:	eb03 1000 	add.w	r0, r3, r0, lsl #4
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5d5a:	589a      	ldr	r2, [r3, r2]
{
    5d5c:	b410      	push	{r4}
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5d5e:	6853      	ldr	r3, [r2, #4]
    5d60:	68c4      	ldr	r4, [r0, #12]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5d62:	d00e      	beq.n	5d82 <pinMode+0x36>
    5d64:	2904      	cmp	r1, #4
    5d66:	d00c      	beq.n	5d82 <pinMode+0x36>
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5d68:	ea23 0304 	bic.w	r3, r3, r4
    5d6c:	6053      	str	r3, [r2, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5d6e:	6883      	ldr	r3, [r0, #8]
		if (mode == INPUT) {
    5d70:	b1a9      	cbz	r1, 5d9e <pinMode+0x52>
		} else if (mode == INPUT_PULLUP) {
    5d72:	2902      	cmp	r1, #2
    5d74:	d017      	beq.n	5da6 <pinMode+0x5a>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    5d76:	2903      	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5d78:	bf0c      	ite	eq
    5d7a:	4a0d      	ldreq	r2, [pc, #52]	; (5db0 <pinMode+0x64>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    5d7c:	4a0d      	ldrne	r2, [pc, #52]	; (5db4 <pinMode+0x68>)
    5d7e:	601a      	str	r2, [r3, #0]
    5d80:	e007      	b.n	5d92 <pinMode+0x46>
		*(p->reg + 1) |= p->mask; // TODO: atomic
    5d82:	4323      	orrs	r3, r4
		if (mode == OUTPUT) {
    5d84:	2901      	cmp	r1, #1
		*(p->reg + 1) |= p->mask; // TODO: atomic
    5d86:	6053      	str	r3, [r2, #4]
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5d88:	6883      	ldr	r3, [r0, #8]
		if (mode == OUTPUT) {
    5d8a:	d008      	beq.n	5d9e <pinMode+0x52>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    5d8c:	f640 0238 	movw	r2, #2104	; 0x838
    5d90:	601a      	str	r2, [r3, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    5d92:	6843      	ldr	r3, [r0, #4]
    5d94:	2215      	movs	r2, #21
}
    5d96:	f85d 4b04 	ldr.w	r4, [sp], #4
	*(p->mux) = 5 | 0x10;
    5d9a:	601a      	str	r2, [r3, #0]
}
    5d9c:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5d9e:	2238      	movs	r2, #56	; 0x38
    5da0:	601a      	str	r2, [r3, #0]
    5da2:	e7f6      	b.n	5d92 <pinMode+0x46>
    5da4:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5da6:	4a04      	ldr	r2, [pc, #16]	; (5db8 <pinMode+0x6c>)
    5da8:	601a      	str	r2, [r3, #0]
    5daa:	e7f2      	b.n	5d92 <pinMode+0x46>
    5dac:	20000b7c 	.word	0x20000b7c
    5db0:	00013038 	.word	0x00013038
    5db4:	00010038 	.word	0x00010038
    5db8:	0001f038 	.word	0x0001f038

00005dbc <flash_wait>:
{
    5dbc:	b430      	push	{r4, r5}
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5dbe:	4a12      	ldr	r2, [pc, #72]	; (5e08 <flash_wait+0x4c>)
	FLEXSPI_LUT61 = 0;
    5dc0:	2000      	movs	r0, #0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5dc2:	4b12      	ldr	r3, [pc, #72]	; (5e0c <flash_wait+0x50>)
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5dc4:	2101      	movs	r1, #1
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    5dc6:	4d12      	ldr	r5, [pc, #72]	; (5e10 <flash_wait+0x54>)
		status = *(uint8_t *)&FLEXSPI_RFDR0;
    5dc8:	4c12      	ldr	r4, [pc, #72]	; (5e14 <flash_wait+0x58>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5dca:	f8c2 32f0 	str.w	r3, [r2, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    5dce:	f8c2 02f4 	str.w	r0, [r2, #756]	; 0x2f4
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5dd2:	f8c2 10b8 	str.w	r1, [r2, #184]	; 0xb8
		FLEXSPI_IPCR0 = 0;
    5dd6:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    5dda:	f8c2 50a4 	str.w	r5, [r2, #164]	; 0xa4
		FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5dde:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
		while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) {;}
    5de2:	6953      	ldr	r3, [r2, #20]
    5de4:	07db      	lsls	r3, r3, #31
    5de6:	d5fc      	bpl.n	5de2 <flash_wait+0x26>
		FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5de8:	6151      	str	r1, [r2, #20]
	} while (status & 1);
    5dea:	7823      	ldrb	r3, [r4, #0]
    5dec:	07db      	lsls	r3, r3, #31
    5dee:	d4f0      	bmi.n	5dd2 <flash_wait+0x16>
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    5df0:	6813      	ldr	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    5df2:	4905      	ldr	r1, [pc, #20]	; (5e08 <flash_wait+0x4c>)
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    5df4:	f043 0301 	orr.w	r3, r3, #1
    5df8:	6013      	str	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    5dfa:	680b      	ldr	r3, [r1, #0]
    5dfc:	07db      	lsls	r3, r3, #31
    5dfe:	d4fc      	bmi.n	5dfa <flash_wait+0x3e>
	__enable_irq();
    5e00:	b662      	cpsie	i
}
    5e02:	bc30      	pop	{r4, r5}
    5e04:	4770      	bx	lr
    5e06:	bf00      	nop
    5e08:	402a8000 	.word	0x402a8000
    5e0c:	24010405 	.word	0x24010405
    5e10:	000f0001 	.word	0x000f0001
    5e14:	402a8100 	.word	0x402a8100

00005e18 <eeprom_initialize>:
{
    5e18:	b570      	push	{r4, r5, r6, lr}
    5e1a:	4c0e      	ldr	r4, [pc, #56]	; (5e54 <eeprom_initialize+0x3c>)
			if (*p++ == 0xFFFF) break;
    5e1c:	f64f 7eff 	movw	lr, #65535	; 0xffff
{
    5e20:	4e0d      	ldr	r6, [pc, #52]	; (5e58 <eeprom_initialize+0x40>)
    5e22:	f104 051e 	add.w	r5, r4, #30
		const uint16_t *p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5e26:	f5a6 5380 	sub.w	r3, r6, #4096	; 0x1000
		uint16_t index = 0;
    5e2a:	2100      	movs	r1, #0
    5e2c:	e002      	b.n	5e34 <eeprom_initialize+0x1c>
		} while (p < end);
    5e2e:	42b3      	cmp	r3, r6
			index++;
    5e30:	b281      	uxth	r1, r0
		} while (p < end);
    5e32:	d204      	bcs.n	5e3e <eeprom_initialize+0x26>
			if (*p++ == 0xFFFF) break;
    5e34:	881a      	ldrh	r2, [r3, #0]
			index++;
    5e36:	1c48      	adds	r0, r1, #1
			if (*p++ == 0xFFFF) break;
    5e38:	3302      	adds	r3, #2
    5e3a:	4572      	cmp	r2, lr
    5e3c:	d1f7      	bne.n	5e2e <eeprom_initialize+0x16>
		sector_index[sector] = index;
    5e3e:	f824 1f02 	strh.w	r1, [r4, #2]!
	for (sector=0; sector < FLASH_SECTORS; sector++) {
    5e42:	42ac      	cmp	r4, r5
    5e44:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
    5e48:	d1ed      	bne.n	5e26 <eeprom_initialize+0xe>
	initialized = 1;
    5e4a:	4b04      	ldr	r3, [pc, #16]	; (5e5c <eeprom_initialize+0x44>)
    5e4c:	2201      	movs	r2, #1
    5e4e:	701a      	strb	r2, [r3, #0]
}
    5e50:	bd70      	pop	{r4, r5, r6, pc}
    5e52:	bf00      	nop
    5e54:	2000755e 	.word	0x2000755e
    5e58:	601f1000 	.word	0x601f1000
    5e5c:	20007712 	.word	0x20007712

00005e60 <eeprom_read_byte>:
	if (addr > E2END) return 0xFF;
    5e60:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    5e64:	d22c      	bcs.n	5ec0 <eeprom_read_byte+0x60>
	if (!initialized) eeprom_initialize();
    5e66:	4b17      	ldr	r3, [pc, #92]	; (5ec4 <eeprom_read_byte+0x64>)
{
    5e68:	b510      	push	{r4, lr}
	if (!initialized) eeprom_initialize();
    5e6a:	781b      	ldrb	r3, [r3, #0]
    5e6c:	4604      	mov	r4, r0
    5e6e:	b323      	cbz	r3, 5eba <eeprom_read_byte+0x5a>
	sector = (addr >> 2) % FLASH_SECTORS;
    5e70:	08a0      	lsrs	r0, r4, #2
    5e72:	4b15      	ldr	r3, [pc, #84]	; (5ec8 <eeprom_read_byte+0x68>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5e74:	f004 0103 	and.w	r1, r4, #3
	end = p + sector_index[sector];
    5e78:	4c14      	ldr	r4, [pc, #80]	; (5ecc <eeprom_read_byte+0x6c>)
	sector = (addr >> 2) % FLASH_SECTORS;
    5e7a:	fba3 2300 	umull	r2, r3, r3, r0
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5e7e:	4a14      	ldr	r2, [pc, #80]	; (5ed0 <eeprom_read_byte+0x70>)
	sector = (addr >> 2) % FLASH_SECTORS;
    5e80:	08db      	lsrs	r3, r3, #3
    5e82:	ebc3 1e03 	rsb	lr, r3, r3, lsl #4
    5e86:	469c      	mov	ip, r3
    5e88:	eba0 030e 	sub.w	r3, r0, lr
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    5e8c:	ea41 018c 	orr.w	r1, r1, ip, lsl #2
	uint8_t data=0xFF;
    5e90:	20ff      	movs	r0, #255	; 0xff
	end = p + sector_index[sector];
    5e92:	f834 c013 	ldrh.w	ip, [r4, r3, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5e96:	441a      	add	r2, r3
	end = p + sector_index[sector];
    5e98:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5e9c:	0313      	lsls	r3, r2, #12
	end = p + sector_index[sector];
    5e9e:	eb0c 3c02 	add.w	ip, ip, r2, lsl #12
	while (p < end) {
    5ea2:	ebbc 3f02 	cmp.w	ip, r2, lsl #12
    5ea6:	d907      	bls.n	5eb8 <eeprom_read_byte+0x58>
		uint32_t val = *p++;
    5ea8:	881a      	ldrh	r2, [r3, #0]
    5eaa:	3302      	adds	r3, #2
		if ((val & 255) == offset) data = val >> 8;
    5eac:	b2d4      	uxtb	r4, r2
    5eae:	428c      	cmp	r4, r1
    5eb0:	bf08      	it	eq
    5eb2:	0a10      	lsreq	r0, r2, #8
	while (p < end) {
    5eb4:	459c      	cmp	ip, r3
    5eb6:	d8f7      	bhi.n	5ea8 <eeprom_read_byte+0x48>
}
    5eb8:	bd10      	pop	{r4, pc}
	if (!initialized) eeprom_initialize();
    5eba:	f7ff ffad 	bl	5e18 <eeprom_initialize>
    5ebe:	e7d7      	b.n	5e70 <eeprom_read_byte+0x10>
	if (addr > E2END) return 0xFF;
    5ec0:	20ff      	movs	r0, #255	; 0xff
}
    5ec2:	4770      	bx	lr
    5ec4:	20007712 	.word	0x20007712
    5ec8:	88888889 	.word	0x88888889
    5ecc:	20007560 	.word	0x20007560
    5ed0:	000601f0 	.word	0x000601f0

00005ed4 <eepromemu_flash_write>:
{
    5ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5ed6:	460f      	mov	r7, r1
    5ed8:	4616      	mov	r6, r2
	__disable_irq();
    5eda:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5edc:	4b34      	ldr	r3, [pc, #208]	; (5fb0 <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5ede:	f240 4106 	movw	r1, #1030	; 0x406
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5ee2:	4a34      	ldr	r2, [pc, #208]	; (5fb4 <eepromemu_flash_write+0xe0>)
    5ee4:	619a      	str	r2, [r3, #24]
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5ee6:	2202      	movs	r2, #2
    5ee8:	61da      	str	r2, [r3, #28]
	FLEXSPI_IPCR0 = 0;
    5eea:	2200      	movs	r2, #0
    5eec:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5ef0:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    5ef4:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    5ef8:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    5efc:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5f00:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    5f04:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5f08:	2201      	movs	r2, #1
    5f0a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    5f0e:	f020 031f 	bic.w	r3, r0, #31
	uint32_t end_addr = (uint32_t)addr + size;
    5f12:	1982      	adds	r2, r0, r6
	asm volatile("": : :"memory");
	asm("dsb");
    5f14:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    5f18:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
    5f1c:	f8c4 3f5c 	str.w	r3, [r4, #3932]	; 0xf5c
		location += 32;
    5f20:	3320      	adds	r3, #32
	} while (location < end_addr);
    5f22:	429a      	cmp	r2, r3
    5f24:	d8fa      	bhi.n	5f1c <eepromemu_flash_write+0x48>
	asm("dsb");
    5f26:	f3bf 8f4f 	dsb	sy
	asm("isb");
    5f2a:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    5f2e:	4d20      	ldr	r5, [pc, #128]	; (5fb0 <eepromemu_flash_write+0xdc>)
    5f30:	696b      	ldr	r3, [r5, #20]
    5f32:	07da      	lsls	r2, r3, #31
    5f34:	d5fc      	bpl.n	5f30 <eepromemu_flash_write+0x5c>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5f36:	2301      	movs	r3, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    5f38:	491f      	ldr	r1, [pc, #124]	; (5fb8 <eepromemu_flash_write+0xe4>)
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5f3a:	b2b2      	uxth	r2, r6
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    5f3c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5f40:	616b      	str	r3, [r5, #20]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5f42:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    5f46:	f8c5 12f0 	str.w	r1, [r5, #752]	; 0x2f0
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    5f4a:	f242 2101 	movw	r1, #8705	; 0x2201
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5f4e:	4c18      	ldr	r4, [pc, #96]	; (5fb0 <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    5f50:	f8c5 12f4 	str.w	r1, [r5, #756]	; 0x2f4
	FLEXSPI_IPTXFCR = FLEXSPI_IPTXFCR_CLRIPTXF; // clear tx fifo
    5f54:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    5f58:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    5f5c:	f8c5 20a4 	str.w	r2, [r5, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5f60:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5f64:	4d15      	ldr	r5, [pc, #84]	; (5fbc <eepromemu_flash_write+0xe8>)
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5f66:	e001      	b.n	5f6c <eepromemu_flash_write+0x98>
		if (n & FLEXSPI_INTR_IPTXWE) {
    5f68:	065b      	lsls	r3, r3, #25
    5f6a:	d409      	bmi.n	5f80 <eepromemu_flash_write+0xac>
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    5f6c:	6963      	ldr	r3, [r4, #20]
    5f6e:	f013 0001 	ands.w	r0, r3, #1
    5f72:	d0f9      	beq.n	5f68 <eepromemu_flash_write+0x94>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPTXWE;
    5f74:	2341      	movs	r3, #65	; 0x41
    5f76:	6163      	str	r3, [r4, #20]
}
    5f78:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	flash_wait();
    5f7c:	f7ff bf1e 	b.w	5dbc <flash_wait>
			if (wrlen > 8) wrlen = 8;
    5f80:	2e08      	cmp	r6, #8
    5f82:	d80a      	bhi.n	5f9a <eepromemu_flash_write+0xc6>
			if (wrlen > 0) {
    5f84:	b136      	cbz	r6, 5f94 <eepromemu_flash_write+0xc0>
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5f86:	4632      	mov	r2, r6
    5f88:	4639      	mov	r1, r7
				src += wrlen;
    5f8a:	4437      	add	r7, r6
				len -= wrlen;
    5f8c:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5f8e:	4628      	mov	r0, r5
    5f90:	f000 f994 	bl	62bc <memcpy>
			FLEXSPI_INTR = FLEXSPI_INTR_IPTXWE;
    5f94:	2340      	movs	r3, #64	; 0x40
    5f96:	6163      	str	r3, [r4, #20]
    5f98:	e7e8      	b.n	5f6c <eepromemu_flash_write+0x98>
    5f9a:	f1a6 0008 	sub.w	r0, r6, #8
			if (wrlen > 8) wrlen = 8;
    5f9e:	2608      	movs	r6, #8
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5fa0:	4639      	mov	r1, r7
    5fa2:	4632      	mov	r2, r6
				src += wrlen;
    5fa4:	4437      	add	r7, r6
				len -= wrlen;
    5fa6:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    5fa8:	4628      	mov	r0, r5
    5faa:	f000 f987 	bl	62bc <memcpy>
				len -= wrlen;
    5fae:	e7f1      	b.n	5f94 <eepromemu_flash_write+0xc0>
    5fb0:	402a8000 	.word	0x402a8000
    5fb4:	5af05af0 	.word	0x5af05af0
    5fb8:	08180432 	.word	0x08180432
    5fbc:	402a8180 	.word	0x402a8180

00005fc0 <eepromemu_flash_erase_sector>:
{
    5fc0:	b410      	push	{r4}
	__disable_irq();
    5fc2:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5fc4:	4b28      	ldr	r3, [pc, #160]	; (6068 <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5fc6:	2102      	movs	r1, #2
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5fc8:	4c28      	ldr	r4, [pc, #160]	; (606c <eepromemu_flash_erase_sector+0xac>)
	FLEXSPI_LUT61 = 0;
    5fca:	2200      	movs	r2, #0
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    5fcc:	619c      	str	r4, [r3, #24]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5fce:	f44f 2470 	mov.w	r4, #983040	; 0xf0000
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    5fd2:	61d9      	str	r1, [r3, #28]
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    5fd4:	f240 4106 	movw	r1, #1030	; 0x406
    5fd8:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5fdc:	2101      	movs	r1, #1
	FLEXSPI_LUT61 = 0;
    5fde:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    5fe2:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    5fe6:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR0 = 0;
    5fea:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    5fee:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    5ff2:	f8c3 40a4 	str.w	r4, [r3, #164]	; 0xa4
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    5ff6:	4002      	ands	r2, r0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5ff8:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
	asm("dsb");
    5ffc:	f3bf 8f4f 	dsb	sy
	uint32_t end_addr = (uint32_t)addr + size;
    6000:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
    6004:	f102 0320 	add.w	r3, r2, #32
		SCB_CACHE_DCIMVAC = location;
    6008:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
    600c:	4299      	cmp	r1, r3
    600e:	bf34      	ite	cc
    6010:	2101      	movcc	r1, #1
    6012:	2180      	movcs	r1, #128	; 0x80
    6014:	eb02 1141 	add.w	r1, r2, r1, lsl #5
	} while (location < end_addr);
    6018:	428b      	cmp	r3, r1
		SCB_CACHE_DCIMVAC = location;
    601a:	f8cc 2f5c 	str.w	r2, [ip, #3932]	; 0xf5c
		location += 32;
    601e:	461a      	mov	r2, r3
	} while (location < end_addr);
    6020:	f103 0320 	add.w	r3, r3, #32
    6024:	d1f8      	bne.n	6018 <eepromemu_flash_erase_sector+0x58>
	asm("dsb");
    6026:	f3bf 8f4f 	dsb	sy
	asm("isb");
    602a:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    602e:	4a0e      	ldr	r2, [pc, #56]	; (6068 <eepromemu_flash_erase_sector+0xa8>)
    6030:	6953      	ldr	r3, [r2, #20]
    6032:	07d9      	lsls	r1, r3, #31
    6034:	d5fc      	bpl.n	6030 <eepromemu_flash_erase_sector+0x70>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    6036:	2401      	movs	r4, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    6038:	490d      	ldr	r1, [pc, #52]	; (6070 <eepromemu_flash_erase_sector+0xb0>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    603a:	4b0e      	ldr	r3, [pc, #56]	; (6074 <eepromemu_flash_erase_sector+0xb4>)
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    603c:	6154      	str	r4, [r2, #20]
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    603e:	4003      	ands	r3, r0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    6040:	f8c2 12f0 	str.w	r1, [r2, #752]	; 0x2f0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    6044:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    6048:	4907      	ldr	r1, [pc, #28]	; (6068 <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    604a:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    604e:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    6052:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    6056:	694b      	ldr	r3, [r1, #20]
    6058:	07db      	lsls	r3, r3, #31
    605a:	d5fc      	bpl.n	6056 <eepromemu_flash_erase_sector+0x96>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    605c:	2301      	movs	r3, #1
}
    605e:	f85d 4b04 	ldr.w	r4, [sp], #4
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    6062:	614b      	str	r3, [r1, #20]
	flash_wait();
    6064:	f7ff beaa 	b.w	5dbc <flash_wait>
    6068:	402a8000 	.word	0x402a8000
    606c:	5af05af0 	.word	0x5af05af0
    6070:	08180420 	.word	0x08180420
    6074:	00fff000 	.word	0x00fff000

00006078 <eeprom_write_byte>:
	if (addr > E2END) return;
    6078:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    607c:	f080 8086 	bcs.w	618c <eeprom_write_byte+0x114>
	if (!initialized) eeprom_initialize();
    6080:	4b44      	ldr	r3, [pc, #272]	; (6194 <eeprom_write_byte+0x11c>)
{
    6082:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!initialized) eeprom_initialize();
    6086:	781b      	ldrb	r3, [r3, #0]
{
    6088:	b0c2      	sub	sp, #264	; 0x108
    608a:	4605      	mov	r5, r0
    608c:	4689      	mov	r9, r1
	if (!initialized) eeprom_initialize();
    608e:	2b00      	cmp	r3, #0
    6090:	d079      	beq.n	6186 <eeprom_write_byte+0x10e>
	sector = (addr >> 2) % FLASH_SECTORS; 
    6092:	08ab      	lsrs	r3, r5, #2
    6094:	4e40      	ldr	r6, [pc, #256]	; (6198 <eeprom_write_byte+0x120>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    6096:	f005 0503 	and.w	r5, r5, #3
	end = p + sector_index[sector];
    609a:	4f40      	ldr	r7, [pc, #256]	; (619c <eeprom_write_byte+0x124>)
	sector = (addr >> 2) % FLASH_SECTORS; 
    609c:	fba6 2603 	umull	r2, r6, r6, r3
    60a0:	08f6      	lsrs	r6, r6, #3
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    60a2:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
	sector = (addr >> 2) % FLASH_SECTORS; 
    60a6:	ebc6 1606 	rsb	r6, r6, r6, lsl #4
    60aa:	1b9e      	subs	r6, r3, r6
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    60ac:	4b3c      	ldr	r3, [pc, #240]	; (61a0 <eeprom_write_byte+0x128>)
	end = p + sector_index[sector];
    60ae:	f837 4016 	ldrh.w	r4, [r7, r6, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    60b2:	4433      	add	r3, r6
	end = p + sector_index[sector];
    60b4:	0060      	lsls	r0, r4, #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    60b6:	ea4f 3803 	mov.w	r8, r3, lsl #12
	end = p + sector_index[sector];
    60ba:	eb00 3003 	add.w	r0, r0, r3, lsl #12
	while (p < end) {
    60be:	ebb0 3f03 	cmp.w	r0, r3, lsl #12
    60c2:	d964      	bls.n	618e <eeprom_write_byte+0x116>
    60c4:	4643      	mov	r3, r8
	uint8_t olddata=0xFF;
    60c6:	f04f 0cff 	mov.w	ip, #255	; 0xff
		uint16_t val = *p++;
    60ca:	881a      	ldrh	r2, [r3, #0]
    60cc:	3302      	adds	r3, #2
		if ((val & 255) == offset) olddata = val >> 8;
    60ce:	b2d1      	uxtb	r1, r2
    60d0:	42a9      	cmp	r1, r5
    60d2:	bf08      	it	eq
    60d4:	ea4f 2c12 	moveq.w	ip, r2, lsr #8
	while (p < end) {
    60d8:	4298      	cmp	r0, r3
    60da:	d8f6      	bhi.n	60ca <eeprom_write_byte+0x52>
	if (data == olddata) return;
    60dc:	45e1      	cmp	r9, ip
    60de:	d041      	beq.n	6164 <eeprom_write_byte+0xec>
	if (sector_index[sector] < 2048) {
    60e0:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
    60e4:	d341      	bcc.n	616a <eeprom_write_byte+0xf2>
		memset(buf, 0xFF, sizeof(buf));
    60e6:	ac02      	add	r4, sp, #8
    60e8:	f44f 7280 	mov.w	r2, #256	; 0x100
    60ec:	21ff      	movs	r1, #255	; 0xff
    60ee:	4620      	mov	r0, r4
    60f0:	f002 fbdc 	bl	88ac <memset>
		while (p < end) {
    60f4:	f508 5080 	add.w	r0, r8, #4096	; 0x1000
    60f8:	f108 0302 	add.w	r3, r8, #2
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    60fc:	4642      	mov	r2, r8
    60fe:	4298      	cmp	r0, r3
    6100:	bf34      	ite	cc
    6102:	2001      	movcc	r0, #1
    6104:	f44f 6000 	movcs.w	r0, #2048	; 0x800
    6108:	eb08 0040 	add.w	r0, r8, r0, lsl #1
			uint16_t val = *p++;
    610c:	4613      	mov	r3, r2
    610e:	3202      	adds	r2, #2
    6110:	881b      	ldrh	r3, [r3, #0]
		while (p < end) {
    6112:	4282      	cmp	r2, r0
			buf[val & 255] = val >> 8;
    6114:	b2d9      	uxtb	r1, r3
    6116:	ea4f 2313 	mov.w	r3, r3, lsr #8
    611a:	5463      	strb	r3, [r4, r1]
		while (p < end) {
    611c:	d1f6      	bne.n	610c <eeprom_write_byte+0x94>
		buf[offset] = data;
    611e:	f804 9005 	strb.w	r9, [r4, r5]
		eepromemu_flash_erase_sector(p);
    6122:	f10d 0907 	add.w	r9, sp, #7
    6126:	f20d 1a07 	addw	sl, sp, #263	; 0x107
		index = 0;
    612a:	2500      	movs	r5, #0
		eepromemu_flash_erase_sector(p);
    612c:	464c      	mov	r4, r9
    612e:	4640      	mov	r0, r8
    6130:	f7ff ff46 	bl	5fc0 <eepromemu_flash_erase_sector>
			if (buf[i] != 0xFF) {
    6134:	f814 cf01 	ldrb.w	ip, [r4, #1]!
				eepromemu_flash_write(p + index, &newval, 2);
    6138:	eb08 0045 	add.w	r0, r8, r5, lsl #1
    613c:	2202      	movs	r2, #2
    613e:	f10d 0106 	add.w	r1, sp, #6
				uint16_t newval = i | (buf[i] << 8);
    6142:	1e63      	subs	r3, r4, #1
			if (buf[i] != 0xFF) {
    6144:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
				uint16_t newval = i | (buf[i] << 8);
    6148:	eba3 0309 	sub.w	r3, r3, r9
			if (buf[i] != 0xFF) {
    614c:	d006      	beq.n	615c <eeprom_write_byte+0xe4>
				uint16_t newval = i | (buf[i] << 8);
    614e:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
				index = index + 1;
    6152:	3501      	adds	r5, #1
				uint16_t newval = i | (buf[i] << 8);
    6154:	f8ad 3006 	strh.w	r3, [sp, #6]
				eepromemu_flash_write(p + index, &newval, 2);
    6158:	f7ff febc 	bl	5ed4 <eepromemu_flash_write>
		for (i=0; i < 256; i++) {
    615c:	45a2      	cmp	sl, r4
    615e:	d1e9      	bne.n	6134 <eeprom_write_byte+0xbc>
		sector_index[sector] = index;
    6160:	f827 5016 	strh.w	r5, [r7, r6, lsl #1]
}
    6164:	b042      	add	sp, #264	; 0x108
    6166:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint16_t newdata = offset | (data << 8);
    616a:	ea45 2509 	orr.w	r5, r5, r9, lsl #8
		eepromemu_flash_write(end, &newdata, 2);
    616e:	a902      	add	r1, sp, #8
    6170:	2202      	movs	r2, #2
		sector_index[sector] = sector_index[sector] + 1;
    6172:	3401      	adds	r4, #1
		uint16_t newdata = offset | (data << 8);
    6174:	f8ad 5008 	strh.w	r5, [sp, #8]
		eepromemu_flash_write(end, &newdata, 2);
    6178:	f7ff feac 	bl	5ed4 <eepromemu_flash_write>
		sector_index[sector] = sector_index[sector] + 1;
    617c:	f827 4016 	strh.w	r4, [r7, r6, lsl #1]
}
    6180:	b042      	add	sp, #264	; 0x108
    6182:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!initialized) eeprom_initialize();
    6186:	f7ff fe47 	bl	5e18 <eeprom_initialize>
    618a:	e782      	b.n	6092 <eeprom_write_byte+0x1a>
    618c:	4770      	bx	lr
	uint8_t olddata=0xFF;
    618e:	f04f 0cff 	mov.w	ip, #255	; 0xff
    6192:	e7a3      	b.n	60dc <eeprom_write_byte+0x64>
    6194:	20007712 	.word	0x20007712
    6198:	88888889 	.word	0x88888889
    619c:	20007560 	.word	0x20007560
    61a0:	000601f0 	.word	0x000601f0

000061a4 <dummy_isr>:
static void dummy_isr() {};
    61a4:	4770      	bx	lr
    61a6:	bf00      	nop

000061a8 <attachInterrupt>:

#endif

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    61a8:	2827      	cmp	r0, #39	; 0x27
    61aa:	d858      	bhi.n	625e <attachInterrupt+0xb6>
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
    61ac:	0100      	lsls	r0, r0, #4
{
    61ae:	b4f0      	push	{r4, r5, r6, r7}
	volatile uint32_t *gpio = portOutputRegister(pin);
    61b0:	4c34      	ldr	r4, [pc, #208]	; (6284 <attachInterrupt+0xdc>)

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
    61b2:	4d35      	ldr	r5, [pc, #212]	; (6288 <attachInterrupt+0xe0>)
	volatile uint32_t *gpio = portOutputRegister(pin);
    61b4:	5823      	ldr	r3, [r4, r0]
	switch((uint32_t)gpio) {
    61b6:	42ab      	cmp	r3, r5
    61b8:	d056      	beq.n	6268 <attachInterrupt+0xc0>
    61ba:	d849      	bhi.n	6250 <attachInterrupt+0xa8>
    61bc:	f1b3 4f84 	cmp.w	r3, #1107296256	; 0x42000000
    61c0:	d04b      	beq.n	625a <attachInterrupt+0xb2>
    61c2:	f5a5 4580 	sub.w	r5, r5, #16384	; 0x4000
    61c6:	42ab      	cmp	r3, r5
    61c8:	d140      	bne.n	624c <attachInterrupt+0xa4>
    61ca:	4d30      	ldr	r5, [pc, #192]	; (628c <attachInterrupt+0xe4>)
	volatile uint32_t *mux = portConfigRegister(pin);
    61cc:	4420      	add	r0, r4
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    61ce:	4e30      	ldr	r6, [pc, #192]	; (6290 <attachInterrupt+0xe8>)
    61d0:	4c30      	ldr	r4, [pc, #192]	; (6294 <attachInterrupt+0xec>)
    61d2:	f8c4 62b4 	str.w	r6, [r4, #692]	; 0x2b4
	volatile uint32_t *pad = portControlRegister(pin);
    61d6:	e9d0 c401 	ldrd	ip, r4, [r0, #4]
	uint32_t mask = digitalPinToBitMask(pin);
    61da:	68c0      	ldr	r0, [r0, #12]
		default:
			return;
	}

	attachInterruptVector(IRQ_GPIO6789, &irq_gpio6789);
	NVIC_ENABLE_IRQ(IRQ_GPIO6789);
    61dc:	f04f 26e0 	mov.w	r6, #3758153728	; 0xe000e000
    61e0:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
    61e4:	2a04      	cmp	r2, #4
    61e6:	f8c6 7110 	str.w	r7, [r6, #272]	; 0x110

#endif

	uint32_t icr;
	switch (mode) {
    61ea:	d82f      	bhi.n	624c <attachInterrupt+0xa4>
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    61ec:	695e      	ldr	r6, [r3, #20]
    61ee:	ea26 0600 	bic.w	r6, r6, r0
    61f2:	615e      	str	r6, [r3, #20]
	*mux = 5;			// pin is GPIO
    61f4:	f04f 0605 	mov.w	r6, #5
    61f8:	f8cc 6000 	str.w	r6, [ip]
	*pad |= IOMUXC_PAD_HYS;		// use hystersis avoid false trigger by slow signals
    61fc:	6826      	ldr	r6, [r4, #0]
    61fe:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
    6202:	6026      	str	r6, [r4, #0]
	gpio[GDIR_INDEX] &= ~mask;	// pin to input mode
    6204:	685c      	ldr	r4, [r3, #4]
    6206:	ea24 0400 	bic.w	r4, r4, r0
    620a:	605c      	str	r4, [r3, #4]
    620c:	4c22      	ldr	r4, [pc, #136]	; (6298 <attachInterrupt+0xf0>)
    620e:	f854 4022 	ldr.w	r4, [r4, r2, lsl #2]
	uint32_t index = __builtin_ctz(mask);
    6212:	fa90 f2a0 	rbit	r2, r0
    6216:	fab2 f282 	clz	r2, r2
	table[index] = function;
    621a:	f845 1022 	str.w	r1, [r5, r2, lsl #2]
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    621e:	ea6f 0100 	mvn.w	r1, r0
	if (mode == CHANGE) {
    6222:	d01d      	beq.n	6260 <attachInterrupt+0xb8>
		gpio[EDGE_INDEX] |= mask;
	} else {
		gpio[EDGE_INDEX] &= ~mask;
    6224:	69dd      	ldr	r5, [r3, #28]
		if (index < 16) {
    6226:	2a0f      	cmp	r2, #15
		gpio[EDGE_INDEX] &= ~mask;
    6228:	ea01 0105 	and.w	r1, r1, r5
    622c:	61d9      	str	r1, [r3, #28]
		if (index < 16) {
    622e:	dc1d      	bgt.n	626c <attachInterrupt+0xc4>
			uint32_t shift = index * 2;
    6230:	0052      	lsls	r2, r2, #1
			gpio[ICR1_INDEX] = (gpio[ICR1_INDEX] & ~(3 << shift)) | (icr << shift);
    6232:	2503      	movs	r5, #3
    6234:	68d9      	ldr	r1, [r3, #12]
    6236:	4094      	lsls	r4, r2
    6238:	fa05 f202 	lsl.w	r2, r5, r2
    623c:	ea21 0202 	bic.w	r2, r1, r2
    6240:	4322      	orrs	r2, r4
    6242:	60da      	str	r2, [r3, #12]
		} else {
			uint32_t shift = (index - 16) * 2;
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
		}
	}
	gpio[ISR_INDEX] = mask;  // clear any prior pending interrupt
    6244:	6198      	str	r0, [r3, #24]
	gpio[IMR_INDEX] |= mask; // enable interrupt
    6246:	695a      	ldr	r2, [r3, #20]
    6248:	4302      	orrs	r2, r0
    624a:	615a      	str	r2, [r3, #20]
}
    624c:	bcf0      	pop	{r4, r5, r6, r7}
    624e:	4770      	bx	lr
	switch((uint32_t)gpio) {
    6250:	4d12      	ldr	r5, [pc, #72]	; (629c <attachInterrupt+0xf4>)
    6252:	42ab      	cmp	r3, r5
    6254:	d1fa      	bne.n	624c <attachInterrupt+0xa4>
			table = isr_table_gpio4;
    6256:	4d12      	ldr	r5, [pc, #72]	; (62a0 <attachInterrupt+0xf8>)
    6258:	e7b8      	b.n	61cc <attachInterrupt+0x24>
			table = isr_table_gpio1;
    625a:	4d12      	ldr	r5, [pc, #72]	; (62a4 <attachInterrupt+0xfc>)
    625c:	e7b6      	b.n	61cc <attachInterrupt+0x24>
    625e:	4770      	bx	lr
		gpio[EDGE_INDEX] |= mask;
    6260:	69da      	ldr	r2, [r3, #28]
    6262:	4302      	orrs	r2, r0
    6264:	61da      	str	r2, [r3, #28]
    6266:	e7ed      	b.n	6244 <attachInterrupt+0x9c>
			table = isr_table_gpio3;
    6268:	4d0f      	ldr	r5, [pc, #60]	; (62a8 <attachInterrupt+0x100>)
    626a:	e7af      	b.n	61cc <attachInterrupt+0x24>
			uint32_t shift = (index - 16) * 2;
    626c:	3a10      	subs	r2, #16
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    626e:	2503      	movs	r5, #3
    6270:	6919      	ldr	r1, [r3, #16]
			uint32_t shift = (index - 16) * 2;
    6272:	0052      	lsls	r2, r2, #1
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    6274:	4094      	lsls	r4, r2
    6276:	fa05 f202 	lsl.w	r2, r5, r2
    627a:	ea21 0202 	bic.w	r2, r1, r2
    627e:	4322      	orrs	r2, r4
    6280:	611a      	str	r2, [r3, #16]
    6282:	e7df      	b.n	6244 <attachInterrupt+0x9c>
    6284:	20000b7c 	.word	0x20000b7c
    6288:	42008000 	.word	0x42008000
    628c:	20001804 	.word	0x20001804
    6290:	00000021 	.word	0x00000021
    6294:	20001c00 	.word	0x20001c00
    6298:	200003c8 	.word	0x200003c8
    629c:	4200c000 	.word	0x4200c000
    62a0:	20001904 	.word	0x20001904
    62a4:	20001784 	.word	0x20001784
    62a8:	20001884 	.word	0x20001884

000062ac <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    62ac:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    62ae:	f7f9 ff57 	bl	160 <setup>
	while (1) {
		loop();
    62b2:	f7fa f825 	bl	300 <loop>
		yield();
    62b6:	f001 fbc7 	bl	7a48 <yield>
	while (1) {
    62ba:	e7fa      	b.n	62b2 <main+0x6>

000062bc <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    62bc:	4684      	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    62be:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    62c2:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    62c6:	d16d      	bne.n	63a4 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    62c8:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    62ca:	d341      	bcc.n	6350 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    62cc:	f851 3b04 	ldr.w	r3, [r1], #4
    62d0:	f840 3b04 	str.w	r3, [r0], #4
    62d4:	f851 3b04 	ldr.w	r3, [r1], #4
    62d8:	f840 3b04 	str.w	r3, [r0], #4
    62dc:	f851 3b04 	ldr.w	r3, [r1], #4
    62e0:	f840 3b04 	str.w	r3, [r0], #4
    62e4:	f851 3b04 	ldr.w	r3, [r1], #4
    62e8:	f840 3b04 	str.w	r3, [r0], #4
    62ec:	f851 3b04 	ldr.w	r3, [r1], #4
    62f0:	f840 3b04 	str.w	r3, [r0], #4
    62f4:	f851 3b04 	ldr.w	r3, [r1], #4
    62f8:	f840 3b04 	str.w	r3, [r0], #4
    62fc:	f851 3b04 	ldr.w	r3, [r1], #4
    6300:	f840 3b04 	str.w	r3, [r0], #4
    6304:	f851 3b04 	ldr.w	r3, [r1], #4
    6308:	f840 3b04 	str.w	r3, [r0], #4
    630c:	f851 3b04 	ldr.w	r3, [r1], #4
    6310:	f840 3b04 	str.w	r3, [r0], #4
    6314:	f851 3b04 	ldr.w	r3, [r1], #4
    6318:	f840 3b04 	str.w	r3, [r0], #4
    631c:	f851 3b04 	ldr.w	r3, [r1], #4
    6320:	f840 3b04 	str.w	r3, [r0], #4
    6324:	f851 3b04 	ldr.w	r3, [r1], #4
    6328:	f840 3b04 	str.w	r3, [r0], #4
    632c:	f851 3b04 	ldr.w	r3, [r1], #4
    6330:	f840 3b04 	str.w	r3, [r0], #4
    6334:	f851 3b04 	ldr.w	r3, [r1], #4
    6338:	f840 3b04 	str.w	r3, [r0], #4
    633c:	f851 3b04 	ldr.w	r3, [r1], #4
    6340:	f840 3b04 	str.w	r3, [r0], #4
    6344:	f851 3b04 	ldr.w	r3, [r1], #4
    6348:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    634c:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    634e:	d2bd      	bcs.n	62cc <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    6350:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    6352:	d311      	bcc.n	6378 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    6354:	f851 3b04 	ldr.w	r3, [r1], #4
    6358:	f840 3b04 	str.w	r3, [r0], #4
    635c:	f851 3b04 	ldr.w	r3, [r1], #4
    6360:	f840 3b04 	str.w	r3, [r0], #4
    6364:	f851 3b04 	ldr.w	r3, [r1], #4
    6368:	f840 3b04 	str.w	r3, [r0], #4
    636c:	f851 3b04 	ldr.w	r3, [r1], #4
    6370:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    6374:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    6376:	d2ed      	bcs.n	6354 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    6378:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    637a:	d305      	bcc.n	6388 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    637c:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    6380:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    6384:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    6386:	d2f9      	bcs.n	637c <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    6388:	3204      	adds	r2, #4
	beq	.Ldone
    638a:	d008      	beq.n	639e <memcpy+0xe2>

	lsls	r2, r2, #31
    638c:	07d2      	lsls	r2, r2, #31
	itt ne
    638e:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    6390:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    6394:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    6398:	d301      	bcc.n	639e <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    639a:	880b      	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    639c:	8003      	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    639e:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    63a0:	4770      	bx	lr
    63a2:	bf00      	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    63a4:	2a08      	cmp	r2, #8
	blo	.Lbyte_copy
    63a6:	d313      	bcc.n	63d0 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    63a8:	078b      	lsls	r3, r1, #30
	beq	.Ldst_aligned
    63aa:	d08d      	beq.n	62c8 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    63ac:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    63b0:	d08a      	beq.n	62c8 <memcpy+0xc>

	rsb	r3, #4
    63b2:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    63b6:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    63b8:	07db      	lsls	r3, r3, #31
	itt ne
    63ba:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    63bc:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    63c0:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    63c4:	d380      	bcc.n	62c8 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    63c6:	f831 3b02 	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    63ca:	f820 3b02 	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    63ce:	e77b      	b.n	62c8 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    63d0:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    63d2:	d3d9      	bcc.n	6388 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    63d4:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    63d6:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    63da:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    63de:	d2f9      	bcs.n	63d4 <memcpy+0x118>

	ldrb	r3, [r1]
    63e0:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    63e2:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    63e4:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    63e6:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    63e8:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    63ea:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    63ec:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    63ee:	4770      	bx	lr

000063f0 <ultoa>:


char * ultoa(unsigned long val, char *buf, int radix)
{
	unsigned digit;
	int i=0, j;
    63f0:	f101 3cff 	add.w	ip, r1, #4294967295
{
    63f4:	b570      	push	{r4, r5, r6, lr}
	char t;

	while (1) {
		digit = val % radix;
    63f6:	4666      	mov	r6, ip
	int i=0, j;
    63f8:	2400      	movs	r4, #0
    63fa:	e000      	b.n	63fe <ultoa+0xe>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    63fc:	3401      	adds	r4, #1
		digit = val % radix;
    63fe:	fbb0 f5f2 	udiv	r5, r0, r2
    6402:	fb02 0315 	mls	r3, r2, r5, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    6406:	2b09      	cmp	r3, #9
    6408:	f103 0e37 	add.w	lr, r3, #55	; 0x37
    640c:	f103 0330 	add.w	r3, r3, #48	; 0x30
    6410:	fa5f fe8e 	uxtb.w	lr, lr
    6414:	bf98      	it	ls
    6416:	fa5f fe83 	uxtbls.w	lr, r3
		if (val == 0) break;
    641a:	4290      	cmp	r0, r2
		val /= radix;
    641c:	4628      	mov	r0, r5
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    641e:	f806 ef01 	strb.w	lr, [r6, #1]!
		if (val == 0) break;
    6422:	d2eb      	bcs.n	63fc <ultoa+0xc>
	}
	buf[i + 1] = 0;
    6424:	1c63      	adds	r3, r4, #1
    6426:	2200      	movs	r2, #0
    6428:	18c8      	adds	r0, r1, r3
    642a:	54ca      	strb	r2, [r1, r3]
	for (j=0; j < i; j++, i--) {
    642c:	b17c      	cbz	r4, 644e <ultoa+0x5e>
		t = buf[j];
    642e:	4662      	mov	r2, ip
    6430:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
		buf[j] = buf[i];
    6434:	f810 6d01 	ldrb.w	r6, [r0, #-1]!
	for (j=0; j < i; j++, i--) {
    6438:	eba1 030c 	sub.w	r3, r1, ip
    643c:	3202      	adds	r2, #2
		buf[j] = buf[i];
    643e:	f88c 6000 	strb.w	r6, [ip]
	for (j=0; j < i; j++, i--) {
    6442:	3b01      	subs	r3, #1
    6444:	1a52      	subs	r2, r2, r1
		buf[i] = t;
    6446:	7005      	strb	r5, [r0, #0]
	for (j=0; j < i; j++, i--) {
    6448:	4423      	add	r3, r4
    644a:	429a      	cmp	r2, r3
    644c:	dbef      	blt.n	642e <ultoa+0x3e>
	}
	return buf;
}
    644e:	4608      	mov	r0, r1
    6450:	bd70      	pop	{r4, r5, r6, pc}
    6452:	bf00      	nop

00006454 <flexpwmWrite>:

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    6454:	f04f 0c01 	mov.w	ip, #1
    6458:	fa0c fc01 	lsl.w	ip, ip, r1
	uint32_t modulo = p->SM[submodule].VAL1;
    645c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6460:	eb00 1141 	add.w	r1, r0, r1, lsl #5
{
    6464:	b570      	push	{r4, r5, r6, lr}
	uint32_t modulo = p->SM[submodule].VAL1;
    6466:	f8b1 e00e 	ldrh.w	lr, [r1, #14]
	uint16_t mask = 1 << submodule;
    646a:	fa1f f58c 	uxth.w	r5, ip
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    646e:	4c25      	ldr	r4, [pc, #148]	; (6504 <flexpwmWrite+0xb0>)
	uint32_t modulo = p->SM[submodule].VAL1;
    6470:	fa1f fe8e 	uxth.w	lr, lr
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6474:	7824      	ldrb	r4, [r4, #0]
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    6476:	012e      	lsls	r6, r5, #4
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6478:	fb0e 3303 	mla	r3, lr, r3, r3
    647c:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    6480:	40e3      	lsrs	r3, r4
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    6482:	f8b0 4188 	ldrh.w	r4, [r0, #392]	; 0x188
    6486:	4573      	cmp	r3, lr
    6488:	b2a4      	uxth	r4, r4
    648a:	bf28      	it	cs
    648c:	4673      	movcs	r3, lr
    648e:	4334      	orrs	r4, r6
	switch (channel) {
    6490:	2a01      	cmp	r2, #1
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    6492:	f8a0 4188 	strh.w	r4, [r0, #392]	; 0x188
	switch (channel) {
    6496:	d00d      	beq.n	64b4 <flexpwmWrite+0x60>
    6498:	2a02      	cmp	r2, #2
    649a:	d028      	beq.n	64ee <flexpwmWrite+0x9a>
    649c:	b1c2      	cbz	r2, 64d0 <flexpwmWrite+0x7c>
    649e:	f00c 020f 	and.w	r2, ip, #15
	  case 2: // B
		p->SM[submodule].VAL5 = cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
		//printf(" write channel B\n");
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    64a2:	f8b0 c188 	ldrh.w	ip, [r0, #392]	; 0x188
    64a6:	fa1f fc8c 	uxth.w	ip, ip
    64aa:	ea4c 0c02 	orr.w	ip, ip, r2
    64ae:	f8a0 c188 	strh.w	ip, [r0, #392]	; 0x188
}
    64b2:	bd70      	pop	{r4, r5, r6, pc}
		p->SM[submodule].VAL3 = cval;
    64b4:	b29b      	uxth	r3, r3
    64b6:	f00c 020f 	and.w	r2, ip, #15
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    64ba:	022d      	lsls	r5, r5, #8
		p->SM[submodule].VAL3 = cval;
    64bc:	82cb      	strh	r3, [r1, #22]
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    64be:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    64c2:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
    64c6:	b29b      	uxth	r3, r3
    64c8:	432b      	orrs	r3, r5
    64ca:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    64ce:	e7e8      	b.n	64a2 <flexpwmWrite+0x4e>
		p->SM[submodule].VAL0 = modulo - cval;
    64d0:	ebae 0e03 	sub.w	lr, lr, r3
    64d4:	f00c 020f 	and.w	r2, ip, #15
    64d8:	fa1f fe8e 	uxth.w	lr, lr
    64dc:	f8a1 e00a 	strh.w	lr, [r1, #10]
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
    64e0:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    64e4:	b29b      	uxth	r3, r3
    64e6:	4313      	orrs	r3, r2
    64e8:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    64ec:	e7d9      	b.n	64a2 <flexpwmWrite+0x4e>
		p->SM[submodule].VAL5 = cval;
    64ee:	b29b      	uxth	r3, r3
    64f0:	f00c 020f 	and.w	r2, ip, #15
    64f4:	83cb      	strh	r3, [r1, #30]
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
    64f6:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    64fa:	b29b      	uxth	r3, r3
    64fc:	431e      	orrs	r6, r3
    64fe:	f8a0 6180 	strh.w	r6, [r0, #384]	; 0x180
    6502:	e7ce      	b.n	64a2 <flexpwmWrite+0x4e>
    6504:	200019da 	.word	0x200019da

00006508 <analogWrite>:

void analogWrite(uint8_t pin, int val)
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
    6508:	2827      	cmp	r0, #39	; 0x27
    650a:	d84b      	bhi.n	65a4 <analogWrite+0x9c>
{
    650c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    650e:	4d2a      	ldr	r5, [pc, #168]	; (65b8 <analogWrite+0xb0>)
    6510:	4604      	mov	r4, r0
	if (info->type == 1) {
    6512:	f815 2020 	ldrb.w	r2, [r5, r0, lsl #2]
	info = pwm_pin_info + pin;
    6516:	eb05 0580 	add.w	r5, r5, r0, lsl #2
	if (info->type == 1) {
    651a:	2a01      	cmp	r2, #1
    651c:	d02d      	beq.n	657a <analogWrite+0x72>
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
    651e:	2a02      	cmp	r2, #2
    6520:	d13f      	bne.n	65a2 <analogWrite+0x9a>
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    6522:	786b      	ldrb	r3, [r5, #1]
    6524:	f3c3 1001 	ubfx	r0, r3, #4, #2
    6528:	2803      	cmp	r0, #3
    652a:	d03e      	beq.n	65aa <analogWrite+0xa2>
    652c:	4a23      	ldr	r2, [pc, #140]	; (65bc <analogWrite+0xb4>)
    652e:	eb02 3280 	add.w	r2, r2, r0, lsl #14
		  case 0: qtimer = &IMXRT_TMR1; break;
		  case 1: qtimer = &IMXRT_TMR2; break;
		  case 2: qtimer = &IMXRT_TMR3; break;
		  default: qtimer = &IMXRT_TMR4;
		}
		quadtimerWrite(qtimer, info->module & 0x03, val);
    6532:	f003 0c03 	and.w	ip, r3, #3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    6536:	4822      	ldr	r0, [pc, #136]	; (65c0 <analogWrite+0xb8>)
    6538:	b289      	uxth	r1, r1
    653a:	4663      	mov	r3, ip
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    653c:	eb02 1c4c 	add.w	ip, r2, ip, lsl #5
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    6540:	7806      	ldrb	r6, [r0, #0]
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    6542:	f8bc e006 	ldrh.w	lr, [ip, #6]
    6546:	0158      	lsls	r0, r3, #5
    6548:	f8bc 3010 	ldrh.w	r3, [ip, #16]
    654c:	fa1f fe8e 	uxth.w	lr, lr
    6550:	f1ce 1e01 	rsb	lr, lr, #65537	; 0x10001
    6554:	fa1e f383 	uxtah	r3, lr, r3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    6558:	f103 3eff 	add.w	lr, r3, #4294967295
    655c:	fb0e f101 	mul.w	r1, lr, r1
    6560:	40f1      	lsrs	r1, r6
	if (high >= modulo - 1) high = modulo - 2;
    6562:	458e      	cmp	lr, r1
    6564:	d923      	bls.n	65ae <analogWrite+0xa6>
	uint32_t low = modulo - high; // low must 2 or higher
    6566:	1a5b      	subs	r3, r3, r1
	p->CH[submodule].LOAD = 65537 - low;
    6568:	f1c3 0301 	rsb	r3, r3, #1
    656c:	b29b      	uxth	r3, r3
	p->CH[submodule].CMPLD1 = high;
    656e:	b289      	uxth	r1, r1
    6570:	4402      	add	r2, r0
	p->CH[submodule].LOAD = 65537 - low;
    6572:	f8ac 3006 	strh.w	r3, [ip, #6]
	p->CH[submodule].CMPLD1 = high;
    6576:	8211      	strh	r1, [r2, #16]
}
    6578:	e00d      	b.n	6596 <analogWrite+0x8e>
		switch ((info->module >> 4) & 3) {
    657a:	786a      	ldrb	r2, [r5, #1]
    657c:	f3c2 1301 	ubfx	r3, r2, #4, #2
    6580:	2b03      	cmp	r3, #3
    6582:	d010      	beq.n	65a6 <analogWrite+0x9e>
    6584:	480f      	ldr	r0, [pc, #60]	; (65c4 <analogWrite+0xbc>)
    6586:	eb00 3083 	add.w	r0, r0, r3, lsl #14
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
    658a:	b28b      	uxth	r3, r1
    658c:	f002 0103 	and.w	r1, r2, #3
    6590:	78aa      	ldrb	r2, [r5, #2]
    6592:	f7ff ff5f 	bl	6454 <flexpwmWrite>
	} else {
		return;
	}
	*(portConfigRegister(pin)) = info->muxval;
    6596:	4b0c      	ldr	r3, [pc, #48]	; (65c8 <analogWrite+0xc0>)
    6598:	78ea      	ldrb	r2, [r5, #3]
    659a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    659e:	685b      	ldr	r3, [r3, #4]
    65a0:	601a      	str	r2, [r3, #0]
	// TODO: pad config register
}
    65a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    65a4:	4770      	bx	lr
		switch ((info->module >> 4) & 3) {
    65a6:	4809      	ldr	r0, [pc, #36]	; (65cc <analogWrite+0xc4>)
    65a8:	e7ef      	b.n	658a <analogWrite+0x82>
		switch ((info->module >> 4) & 3) {
    65aa:	4a09      	ldr	r2, [pc, #36]	; (65d0 <analogWrite+0xc8>)
    65ac:	e7c1      	b.n	6532 <analogWrite+0x2a>
	if (high >= modulo - 1) high = modulo - 2;
    65ae:	1e99      	subs	r1, r3, #2
    65b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    65b4:	e7db      	b.n	656e <analogWrite+0x66>
    65b6:	bf00      	nop
    65b8:	20000e08 	.word	0x20000e08
    65bc:	401dc000 	.word	0x401dc000
    65c0:	200019da 	.word	0x200019da
    65c4:	403dc000 	.word	0x403dc000
    65c8:	20000b7c 	.word	0x20000b7c
    65cc:	403e8000 	.word	0x403e8000
    65d0:	401e8000 	.word	0x401e8000

000065d4 <flexpwm_init>:
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    65d4:	2300      	movs	r3, #0
	p->FSTS0 = 0x000F; // clear fault status
    65d6:	220f      	movs	r2, #15
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    65d8:	f248 2cb8 	movw	ip, #33464	; 0x82b8
	for (i=0; i < 4; i++) {
    65dc:	4619      	mov	r1, r3
{
    65de:	b510      	push	{r4, lr}
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    65e0:	f44f 4470 	mov.w	r4, #61440	; 0xf000
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    65e4:	f44f 6e80 	mov.w	lr, #1024	; 0x400
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    65e8:	f8a0 418c 	strh.w	r4, [r0, #396]	; 0x18c
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    65ec:	f44f 4460 	mov.w	r4, #57344	; 0xe000
	p->FSTS0 = 0x000F; // clear fault status
    65f0:	f8a0 218e 	strh.w	r2, [r0, #398]	; 0x18e
		p->SM[i].OCTRL = 0;
    65f4:	460a      	mov	r2, r1
	p->FFILT0 = 0;
    65f6:	f8a0 3190 	strh.w	r3, [r0, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    65fa:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    65fe:	b29b      	uxth	r3, r3
    6600:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    6604:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    6608:	eb01 0341 	add.w	r3, r1, r1, lsl #1
	for (i=0; i < 4; i++) {
    660c:	3101      	adds	r1, #1
    660e:	eb00 1343 	add.w	r3, r0, r3, lsl #5
    6612:	2904      	cmp	r1, #4
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    6614:	809c      	strh	r4, [r3, #4]
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    6616:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    661a:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    661c:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    661e:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    6620:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    6622:	f8a3 c00e 	strh.w	ip, [r3, #14]
		p->SM[i].VAL2 = 0;
    6626:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    6628:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    662a:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    662c:	83da      	strh	r2, [r3, #30]
	for (i=0; i < 4; i++) {
    662e:	d1eb      	bne.n	6608 <flexpwm_init+0x34>
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    6630:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    6634:	b29b      	uxth	r3, r3
    6636:	f043 030f 	orr.w	r3, r3, #15
    663a:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    663e:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    6642:	b29b      	uxth	r3, r3
    6644:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    6648:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
}
    664c:	bd10      	pop	{r4, pc}
    664e:	bf00      	nop

00006650 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6650:	4b37      	ldr	r3, [pc, #220]	; (6730 <pwm_init+0xe0>)
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6652:	4a38      	ldr	r2, [pc, #224]	; (6734 <pwm_init+0xe4>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6654:	6f99      	ldr	r1, [r3, #120]	; 0x78
		CCM_CCGR6_QTIMER3(CCM_CCGR_ON) | CCM_CCGR6_QTIMER4(CCM_CCGR_ON);
	flexpwm_init(&IMXRT_FLEXPWM1);
    6656:	4838      	ldr	r0, [pc, #224]	; (6738 <pwm_init+0xe8>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6658:	f441 017f 	orr.w	r1, r1, #16711680	; 0xff0000
{
    665c:	b570      	push	{r4, r5, r6, lr}
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    665e:	6799      	str	r1, [r3, #120]	; 0x78
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6660:	f241 0601 	movw	r6, #4097	; 0x1001
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6664:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6668:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    666c:	f243 0426 	movw	r4, #12326	; 0x3026
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6670:	430a      	orrs	r2, r1
    6672:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	flexpwm_init(&IMXRT_FLEXPWM1);
    6676:	f7ff ffad 	bl	65d4 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM2);
    667a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    667e:	f7ff ffa9 	bl	65d4 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM3);
    6682:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    6686:	f7ff ffa5 	bl	65d4 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM4);
    668a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    668e:	f7ff ffa1 	bl	65d4 <flexpwm_init>
	for (i=0; i < 4; i++) {
    6692:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    6694:	f5a0 1003 	sub.w	r0, r0, #2146304	; 0x20c000
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6698:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CTRL = 0; // stop timer
    669c:	4611      	mov	r1, r2
    669e:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    66a2:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    66a6:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    66a8:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    66aa:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    66ac:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    66ae:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    66b2:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    66b4:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    66b6:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    66ba:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    66bc:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    66be:	d1ee      	bne.n	669e <pwm_init+0x4e>
    66c0:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    66c2:	481e      	ldr	r0, [pc, #120]	; (673c <pwm_init+0xec>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    66c4:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    66c8:	f241 0601 	movw	r6, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    66cc:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    66ce:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    66d2:	f243 0426 	movw	r4, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    66d6:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    66da:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    66de:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    66e0:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    66e2:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    66e4:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    66e6:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    66ea:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    66ec:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    66ee:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    66f2:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    66f4:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    66f6:	d1ee      	bne.n	66d6 <pwm_init+0x86>
    66f8:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    66fa:	4811      	ldr	r0, [pc, #68]	; (6740 <pwm_init+0xf0>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    66fc:	260f      	movs	r6, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    66fe:	f241 0501 	movw	r5, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    6702:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6704:	f645 54c0 	movw	r4, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6708:	f243 0e26 	movw	lr, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    670c:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    6710:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    6714:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6716:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    6718:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    671a:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    671c:	81de      	strh	r6, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    671e:	829d      	strh	r5, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6720:	80dc      	strh	r4, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    6722:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    6726:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6728:	f8a3 e00c 	strh.w	lr, [r3, #12]
	for (i=0; i < 4; i++) {
    672c:	d1ee      	bne.n	670c <pwm_init+0xbc>
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    672e:	bd70      	pop	{r4, r5, r6, pc}
    6730:	400fc000 	.word	0x400fc000
    6734:	fc030000 	.word	0xfc030000
    6738:	403dc000 	.word	0x403dc000
    673c:	401e0000 	.word	0x401e0000
    6740:	401e4000 	.word	0x401e4000

00006744 <unused_interrupt_vector>:
	__disable_irq();
    6744:	b672      	cpsid	i
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    6746:	f3ef 8305 	mrs	r3, IPSR
	info->ipsr = ipsr;
    674a:	4c52      	ldr	r4, [pc, #328]	; (6894 <unused_interrupt_vector+0x150>)
    674c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	asm volatile("tst lr, #4\nite eq\nmrseq %0, msp\nmrsne %0, psp\n" : "=r" (stack) :: "memory");
    6750:	f01e 0f04 	tst.w	lr, #4
    6754:	bf0c      	ite	eq
    6756:	f3ef 8208 	mrseq	r2, MSP
    675a:	f3ef 8209 	mrsne	r2, PSP
	info->cfsr = SCB_CFSR;
    675e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	p = (uint32_t *)info;
    6762:	4e4d      	ldr	r6, [pc, #308]	; (6898 <unused_interrupt_vector+0x154>)
	while (p < end) {
    6764:	4d4d      	ldr	r5, [pc, #308]	; (689c <unused_interrupt_vector+0x158>)
	info->cfsr = SCB_CFSR;
    6766:	f8d3 0d28 	ldr.w	r0, [r3, #3368]	; 0xd28
	info->hfsr = SCB_HFSR;
    676a:	f8d3 1d2c 	ldr.w	r1, [r3, #3372]	; 0xd2c
    676e:	e9c4 0122 	strd	r0, r1, [r4, #136]	; 0x88
	info->mmfar = SCB_MMFAR;
    6772:	f8d3 1d34 	ldr.w	r1, [r3, #3380]	; 0xd34
	info->bfar = SCB_BFAR;
    6776:	f8d3 3d38 	ldr.w	r3, [r3, #3384]	; 0xd38
    677a:	e9c4 1324 	strd	r1, r3, [r4, #144]	; 0x90
	info->ret = stack[6];
    677e:	6993      	ldr	r3, [r2, #24]
    6780:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	info->xpsr = stack[7];
    6784:	69d3      	ldr	r3, [r2, #28]
    6786:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	info->temp = tempmonGetTemp();
    678a:	f000 f8d1 	bl	6930 <tempmonGetTemp>
    678e:	ed84 0a28 	vstr	s0, [r4, #160]	; 0xa0
	info->time = rtc_get();
    6792:	f001 f9c5 	bl	7b20 <rtc_get>
	info->len = sizeof(*info) / 4;
    6796:	210b      	movs	r1, #11
	crc = 0xFFFFFFFF;
    6798:	f04f 32ff 	mov.w	r2, #4294967295
	info->time = rtc_get();
    679c:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
	info->len = sizeof(*info) / 4;
    67a0:	460b      	mov	r3, r1
    67a2:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    67a6:	493e      	ldr	r1, [pc, #248]	; (68a0 <unused_interrupt_vector+0x15c>)
		crc ^= *p++;
    67a8:	1d30      	adds	r0, r6, #4
    67aa:	405a      	eors	r2, r3
    67ac:	2420      	movs	r4, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    67ae:	f002 0301 	and.w	r3, r2, #1
    67b2:	3c01      	subs	r4, #1
    67b4:	fb01 f303 	mul.w	r3, r1, r3
    67b8:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    67bc:	d1f7      	bne.n	67ae <unused_interrupt_vector+0x6a>
	while (p < end) {
    67be:	42a8      	cmp	r0, r5
    67c0:	d002      	beq.n	67c8 <unused_interrupt_vector+0x84>
		crc ^= *p++;
    67c2:	6873      	ldr	r3, [r6, #4]
    67c4:	4606      	mov	r6, r0
    67c6:	e7ef      	b.n	67a8 <unused_interrupt_vector+0x64>
	info->crc = crc;
    67c8:	4b32      	ldr	r3, [pc, #200]	; (6894 <unused_interrupt_vector+0x150>)
    67ca:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    67ce:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    67d2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    67d6:	4930      	ldr	r1, [pc, #192]	; (6898 <unused_interrupt_vector+0x154>)
    67d8:	4a32      	ldr	r2, [pc, #200]	; (68a4 <unused_interrupt_vector+0x160>)
    67da:	f8c3 1f70 	str.w	r1, [r3, #3952]	; 0xf70
    67de:	f8c3 2f70 	str.w	r2, [r3, #3952]	; 0xf70
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    67e2:	f3bf 8f4f 	dsb	sy
	asm("isb");
    67e6:	f3bf 8f6f 	isb	sy
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    67ea:	4a2f      	ldr	r2, [pc, #188]	; (68a8 <unused_interrupt_vector+0x164>)
	PIT_MCR = PIT_MCR_MDIS;
    67ec:	2502      	movs	r5, #2
    67ee:	482f      	ldr	r0, [pc, #188]	; (68ac <unused_interrupt_vector+0x168>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    67f0:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    67f2:	492f      	ldr	r1, [pc, #188]	; (68b0 <unused_interrupt_vector+0x16c>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    67f4:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
    67f8:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    67fa:	6005      	str	r5, [r0, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    67fc:	69d3      	ldr	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    67fe:	482d      	ldr	r0, [pc, #180]	; (68b4 <unused_interrupt_vector+0x170>)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    6800:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    6804:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6808:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    680a:	680b      	ldr	r3, [r1, #0]
    680c:	4283      	cmp	r3, r0
    680e:	d83d      	bhi.n	688c <unused_interrupt_vector+0x148>
	PIT_MCR = 0;
    6810:	4d26      	ldr	r5, [pc, #152]	; (68ac <unused_interrupt_vector+0x168>)
    6812:	2100      	movs	r1, #0
	NVIC_ICER0 = 0xFFFFFFFF;
    6814:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6818:	f04f 32ff 	mov.w	r2, #4294967295
	PIT_MCR = 0;
    681c:	6029      	str	r1, [r5, #0]
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    681e:	2601      	movs	r6, #1
	PIT_TCTRL0 = 0;
    6820:	f8c5 1108 	str.w	r1, [r5, #264]	; 0x108
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    6824:	4924      	ldr	r1, [pc, #144]	; (68b8 <unused_interrupt_vector+0x174>)
    6826:	f8c5 1100 	str.w	r1, [r5, #256]	; 0x100
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    682a:	f8c5 6108 	str.w	r6, [r5, #264]	; 0x108
	NVIC_ICER0 = 0xFFFFFFFF;
    682e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	NVIC_ICER1 = 0xFFFFFFFF;
    6832:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
	NVIC_ICER2 = 0xFFFFFFFF;
    6836:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
	NVIC_ICER3 = 0xFFFFFFFF;
    683a:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	NVIC_ICER4 = 0xFFFFFFFF;
    683e:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
	count = 0;
    6842:	e001      	b.n	6848 <unused_interrupt_vector+0x104>
		usb_isr();
    6844:	f000 f966 	bl	6b14 <usb_isr>
		if (PIT_TFLG0) {
    6848:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    684c:	2b00      	cmp	r3, #0
    684e:	d0f9      	beq.n	6844 <unused_interrupt_vector+0x100>
			if (++count >= 80) break;  // reboot after 8 seconds
    6850:	3401      	adds	r4, #1
			PIT_TFLG0 = 1;
    6852:	f8c5 610c 	str.w	r6, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    6856:	2c4f      	cmp	r4, #79	; 0x4f
    6858:	d9f4      	bls.n	6844 <unused_interrupt_vector+0x100>
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    685a:	4b18      	ldr	r3, [pc, #96]	; (68bc <unused_interrupt_vector+0x178>)
	USB1_USBCMD = USB_USBCMD_RST;
    685c:	2002      	movs	r0, #2
    685e:	4918      	ldr	r1, [pc, #96]	; (68c0 <unused_interrupt_vector+0x17c>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6860:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	USB1_USBCMD = USB_USBCMD_RST;
    6864:	f8c1 0140 	str.w	r0, [r1, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6868:	635a      	str	r2, [r3, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    686a:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    686e:	b93b      	cbnz	r3, 6880 <unused_interrupt_vector+0x13c>
	SRC_GPR5 = 0x0BAD00F1;
    6870:	4814      	ldr	r0, [pc, #80]	; (68c4 <unused_interrupt_vector+0x180>)
    6872:	4915      	ldr	r1, [pc, #84]	; (68c8 <unused_interrupt_vector+0x184>)
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6874:	4a0d      	ldr	r2, [pc, #52]	; (68ac <unused_interrupt_vector+0x168>)
	SRC_GPR5 = 0x0BAD00F1;
    6876:	6301      	str	r1, [r0, #48]	; 0x30
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6878:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    687c:	2b00      	cmp	r3, #0
    687e:	d0fa      	beq.n	6876 <unused_interrupt_vector+0x132>
	SCB_AIRCR = 0x05FA0004;
    6880:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6884:	4a11      	ldr	r2, [pc, #68]	; (68cc <unused_interrupt_vector+0x188>)
    6886:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c
	while (1) ;
    688a:	e7fe      	b.n	688a <unused_interrupt_vector+0x146>
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    688c:	f7ff f856 	bl	593c <set_arm_clock>
    6890:	e7be      	b.n	6810 <unused_interrupt_vector+0xcc>
    6892:	bf00      	nop
    6894:	2027ff00 	.word	0x2027ff00
    6898:	2027ff80 	.word	0x2027ff80
    689c:	2027ffa8 	.word	0x2027ffa8
    68a0:	edb88320 	.word	0xedb88320
    68a4:	2027ffa0 	.word	0x2027ffa0
    68a8:	400fc000 	.word	0x400fc000
    68ac:	40084000 	.word	0x40084000
    68b0:	2000110c 	.word	0x2000110c
    68b4:	0bcd3d80 	.word	0x0bcd3d80
    68b8:	00249f00 	.word	0x00249f00
    68bc:	400d9000 	.word	0x400d9000
    68c0:	402e0000 	.word	0x402e0000
    68c4:	400f8000 	.word	0x400f8000
    68c8:	0bad00f1 	.word	0x0bad00f1
    68cc:	05fa0004 	.word	0x05fa0004

000068d0 <_sbrk>:
char *__brkval = (char *)&_heap_start;

__attribute__((weak))
void * _sbrk(int incr)
{
        char *prev = __brkval;
    68d0:	490a      	ldr	r1, [pc, #40]	; (68fc <_sbrk+0x2c>)
    68d2:	680a      	ldr	r2, [r1, #0]
        if (incr != 0) {
    68d4:	b138      	cbz	r0, 68e6 <_sbrk+0x16>
{
    68d6:	b508      	push	{r3, lr}
                if (prev + incr > (char *)&_heap_end) {
    68d8:	1813      	adds	r3, r2, r0
    68da:	4809      	ldr	r0, [pc, #36]	; (6900 <_sbrk+0x30>)
    68dc:	4283      	cmp	r3, r0
    68de:	d804      	bhi.n	68ea <_sbrk+0x1a>
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    68e0:	4610      	mov	r0, r2
                __brkval = prev + incr;
    68e2:	600b      	str	r3, [r1, #0]
}
    68e4:	bd08      	pop	{r3, pc}
    68e6:	4610      	mov	r0, r2
    68e8:	4770      	bx	lr
                        errno = ENOMEM;
    68ea:	f002 f8cf 	bl	8a8c <__errno>
    68ee:	230c      	movs	r3, #12
                        return (void *)-1;
    68f0:	f04f 32ff 	mov.w	r2, #4294967295
                        errno = ENOMEM;
    68f4:	6003      	str	r3, [r0, #0]
}
    68f6:	4610      	mov	r0, r2
    68f8:	bd08      	pop	{r3, pc}
    68fa:	bf00      	nop
    68fc:	200011e0 	.word	0x200011e0
    6900:	20280000 	.word	0x20280000

00006904 <_read>:

__attribute__((weak))
int _read(int file __attribute__((unused)), char *ptr __attribute__((unused)), int len __attribute__((unused)))
{
	return 0;
}
    6904:	2000      	movs	r0, #0
    6906:	4770      	bx	lr

00006908 <_close>:

__attribute__((weak))
int _close(int fd __attribute__((unused)))
{
	return -1;
}
    6908:	f04f 30ff 	mov.w	r0, #4294967295
    690c:	4770      	bx	lr
    690e:	bf00      	nop

00006910 <_fstat>:
#include <sys/stat.h>

__attribute__((weak))
int _fstat(int fd __attribute__((unused)), struct stat *st)
{
	st->st_mode = S_IFCHR;
    6910:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
    6914:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
    6916:	604b      	str	r3, [r1, #4]
}
    6918:	4770      	bx	lr
    691a:	bf00      	nop

0000691c <_isatty>:

__attribute__((weak))
int _isatty(int fd __attribute__((unused)))
{
	return 1;
}
    691c:	2001      	movs	r0, #1
    691e:	4770      	bx	lr

00006920 <_lseek>:

__attribute__((weak))
int _lseek(int fd __attribute__((unused)), long long offset __attribute__((unused)), int whence __attribute__((unused)))
{
	return -1;
}
    6920:	f04f 30ff 	mov.w	r0, #4294967295
    6924:	4770      	bx	lr
    6926:	bf00      	nop

00006928 <abort>:
}

__attribute__((weak))
void abort(void)
{
	while (1) asm ("WFI");
    6928:	bf30      	wfi
    692a:	e7fd      	b.n	6928 <abort>

0000692c <Panic_Temp_isr>:
  unused_interrupt_vector();
    692c:	f7ff bf0a 	b.w	6744 <unused_interrupt_vector>

00006930 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    6930:	4a12      	ldr	r2, [pc, #72]	; (697c <tempmonGetTemp+0x4c>)
    6932:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    6936:	075b      	lsls	r3, r3, #29
    6938:	d5fb      	bpl.n	6932 <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    693a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    693e:	4810      	ldr	r0, [pc, #64]	; (6980 <tempmonGetTemp+0x50>)
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6940:	f3c3 230b 	ubfx	r3, r3, #8, #12
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6944:	490f      	ldr	r1, [pc, #60]	; (6984 <tempmonGetTemp+0x54>)
    6946:	ed90 7a00 	vldr	s14, [r0]
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    694a:	ee07 3a90 	vmov	s15, r3
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    694e:	ed91 6a00 	vldr	s12, [r1]
    6952:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    6956:	4a0c      	ldr	r2, [pc, #48]	; (6988 <tempmonGetTemp+0x58>)
    6958:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    695c:	4b0b      	ldr	r3, [pc, #44]	; (698c <tempmonGetTemp+0x5c>)
    695e:	edd2 6a00 	vldr	s13, [r2]
    6962:	ee77 7ac7 	vsub.f32	s15, s15, s14
    6966:	ed93 7a00 	vldr	s14, [r3]
    696a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    696e:	ee67 7a86 	vmul.f32	s15, s15, s12
    6972:	ee87 0aa6 	vdiv.f32	s0, s15, s13

    return tmeas;
}
    6976:	ee37 0a40 	vsub.f32	s0, s14, s0
    697a:	4770      	bx	lr
    697c:	400d8100 	.word	0x400d8100
    6980:	2000754c 	.word	0x2000754c
    6984:	20007554 	.word	0x20007554
    6988:	20007558 	.word	0x20007558
    698c:	20007550 	.word	0x20007550

00006990 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    6990:	6b83      	ldr	r3, [r0, #56]	; 0x38
{
    6992:	b4f0      	push	{r4, r5, r6, r7}
	if (endpoint->callback_function) {
    6994:	b11b      	cbz	r3, 699e <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    6996:	6853      	ldr	r3, [r2, #4]
    6998:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    699c:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    699e:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    69a0:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    69a2:	b33c      	cbz	r4, 69f4 <schedule_transfer+0x64>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    69a4:	4b1a      	ldr	r3, [pc, #104]	; (6a10 <schedule_transfer+0x80>)
		last->next = (uint32_t)transfer;
    69a6:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    69a8:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    69ac:	420c      	tst	r4, r1
    69ae:	d11d      	bne.n	69ec <schedule_transfer+0x5c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    69b0:	4e18      	ldr	r6, [pc, #96]	; (6a14 <schedule_transfer+0x84>)
    69b2:	6877      	ldr	r7, [r6, #4]
    69b4:	e004      	b.n	69c0 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    69b6:	6874      	ldr	r4, [r6, #4]
    69b8:	1be4      	subs	r4, r4, r7
    69ba:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    69be:	d20b      	bcs.n	69d8 <schedule_transfer+0x48>
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    69c0:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    69c4:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    69c8:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    69cc:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    69d0:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    69d4:	0464      	lsls	r4, r4, #17
    69d6:	d5ee      	bpl.n	69b6 <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    69d8:	400d      	ands	r5, r1
    69da:	d107      	bne.n	69ec <schedule_transfer+0x5c>
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    69dc:	4c0c      	ldr	r4, [pc, #48]	; (6a10 <schedule_transfer+0x80>)
		endpoint->status = 0;
    69de:	e9c0 2502 	strd	r2, r5, [r0, #8]
		USB1_ENDPTPRIME |= epmask;
    69e2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    69e6:	430b      	orrs	r3, r1
    69e8:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    69ec:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    69ee:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    69f0:	bcf0      	pop	{r4, r5, r6, r7}
    69f2:	4770      	bx	lr
	USB1_ENDPTPRIME |= epmask;
    69f4:	4d06      	ldr	r5, [pc, #24]	; (6a10 <schedule_transfer+0x80>)
	endpoint->status = 0;
    69f6:	e9c0 2402 	strd	r2, r4, [r0, #8]
	USB1_ENDPTPRIME |= epmask;
    69fa:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    69fe:	430b      	orrs	r3, r1
    6a00:	f8c5 31b0 	str.w	r3, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    6a04:	6302      	str	r2, [r0, #48]	; 0x30
	endpoint->last_transfer = transfer;
    6a06:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    6a08:	b662      	cpsie	i
}
    6a0a:	bcf0      	pop	{r4, r5, r6, r7}
    6a0c:	4770      	bx	lr
    6a0e:	bf00      	nop
    6a10:	402e0000 	.word	0x402e0000
    6a14:	e0001000 	.word	0xe0001000

00006a18 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    6a18:	b570      	push	{r4, r5, r6, lr}
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    6a1a:	6b05      	ldr	r5, [r0, #48]	; 0x30
	if (first == NULL) return;
    6a1c:	b19d      	cbz	r5, 6a46 <run_callbacks+0x2e>
    6a1e:	4606      	mov	r6, r0
    6a20:	462a      	mov	r2, r5

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
    6a22:	2400      	movs	r4, #0
    6a24:	e003      	b.n	6a2e <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    6a26:	6812      	ldr	r2, [r2, #0]
		count++;
    6a28:	3401      	adds	r4, #1
		if ((uint32_t)t == 1) {
    6a2a:	2a01      	cmp	r2, #1
    6a2c:	d00c      	beq.n	6a48 <run_callbacks+0x30>
		if (t->status & (1<<7)) {
    6a2e:	6853      	ldr	r3, [r2, #4]
    6a30:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    6a34:	d0f7      	beq.n	6a26 <run_callbacks+0xe>
			ep->first_transfer = t;
    6a36:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    6a38:	b12c      	cbz	r4, 6a46 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
    6a3a:	4628      	mov	r0, r5
		ep->callback_function(first);
    6a3c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
		transfer_t *next = (transfer_t *)first->next;
    6a3e:	682d      	ldr	r5, [r5, #0]
		ep->callback_function(first);
    6a40:	4798      	blx	r3
	while (count) {
    6a42:	3c01      	subs	r4, #1
    6a44:	d1f9      	bne.n	6a3a <run_callbacks+0x22>
		first = next;
		count--;
	}
}
    6a46:	bd70      	pop	{r4, r5, r6, pc}
			ep->last_transfer = NULL;
    6a48:	e9c6 330c 	strd	r3, r3, [r6, #48]	; 0x30
			break;
    6a4c:	e7f4      	b.n	6a38 <run_callbacks+0x20>
    6a4e:	bf00      	nop

00006a50 <endpoint0_transmit.constprop.0>:
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    6a50:	b430      	push	{r4, r5}
	if (len > 0) {
    6a52:	b9d9      	cbnz	r1, 6a8c <endpoint0_transmit.constprop.0+0x3c>
    6a54:	4c1f      	ldr	r4, [pc, #124]	; (6ad4 <endpoint0_transmit.constprop.0+0x84>)
	endpoint0_transfer_ack.next = 1;
    6a56:	4b20      	ldr	r3, [pc, #128]	; (6ad8 <endpoint0_transmit.constprop.0+0x88>)
	endpoint0_transfer_ack.pointer0 = 0;
    6a58:	2100      	movs	r1, #0
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a5a:	4a20      	ldr	r2, [pc, #128]	; (6adc <endpoint0_transmit.constprop.0+0x8c>)
	endpoint0_transfer_ack.next = 1;
    6a5c:	2501      	movs	r5, #1
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a5e:	f04f 1001 	mov.w	r0, #65537	; 0x10001
	endpoint0_transfer_ack.pointer0 = 0;
    6a62:	6099      	str	r1, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6a64:	601d      	str	r5, [r3, #0]
	endpoint_queue_head[0].status = 0;
    6a66:	e9c4 3102 	strd	r3, r1, [r4, #8]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6a6a:	2480      	movs	r4, #128	; 0x80
    6a6c:	605c      	str	r4, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6a6e:	f8c2 01bc 	str.w	r0, [r2, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    6a72:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    6a76:	481a      	ldr	r0, [pc, #104]	; (6ae0 <endpoint0_transmit.constprop.0+0x90>)
	USB1_ENDPTPRIME |= (1<<0);
    6a78:	432b      	orrs	r3, r5
    6a7a:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    6a7e:	6001      	str	r1, [r0, #0]
	while (USB1_ENDPTPRIME) ;
    6a80:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6a84:	2b00      	cmp	r3, #0
    6a86:	d1fb      	bne.n	6a80 <endpoint0_transmit.constprop.0+0x30>
}
    6a88:	bc30      	pop	{r4, r5}
    6a8a:	4770      	bx	lr
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6a8c:	0409      	lsls	r1, r1, #16
		endpoint0_transfer_data.next = 1;
    6a8e:	4b15      	ldr	r3, [pc, #84]	; (6ae4 <endpoint0_transmit.constprop.0+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    6a90:	4c10      	ldr	r4, [pc, #64]	; (6ad4 <endpoint0_transmit.constprop.0+0x84>)
		endpoint0_transfer_data.next = 1;
    6a92:	2501      	movs	r5, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6a94:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    6a98:	6098      	str	r0, [r3, #8]
		USB1_ENDPTPRIME |= (1<<16);
    6a9a:	4a10      	ldr	r2, [pc, #64]	; (6adc <endpoint0_transmit.constprop.0+0x8c>)
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6a9c:	6059      	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6a9e:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
		endpoint0_transfer_data.next = 1;
    6aa2:	601d      	str	r5, [r3, #0]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6aa4:	60d9      	str	r1, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6aa6:	f500 5100 	add.w	r1, r0, #8192	; 0x2000
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    6aaa:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6aac:	6119      	str	r1, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6aae:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6ab2:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6ab6:	6159      	str	r1, [r3, #20]
		endpoint_queue_head[1].status = 0;
    6ab8:	2100      	movs	r1, #0
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6aba:	6198      	str	r0, [r3, #24]
		endpoint_queue_head[1].status = 0;
    6abc:	64e1      	str	r1, [r4, #76]	; 0x4c
		USB1_ENDPTPRIME |= (1<<16);
    6abe:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6ac2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6ac6:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    6aca:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6ace:	2b00      	cmp	r3, #0
    6ad0:	d1fb      	bne.n	6aca <endpoint0_transmit.constprop.0+0x7a>
    6ad2:	e7c0      	b.n	6a56 <endpoint0_transmit.constprop.0+0x6>
    6ad4:	20000000 	.word	0x20000000
    6ad8:	20001ec0 	.word	0x20001ec0
    6adc:	402e0000 	.word	0x402e0000
    6ae0:	200074e0 	.word	0x200074e0
    6ae4:	20001ee0 	.word	0x20001ee0

00006ae8 <usb_stop_sof_interrupts>:
	sof_usage &= ~(1 << interface);
    6ae8:	4908      	ldr	r1, [pc, #32]	; (6b0c <usb_stop_sof_interrupts+0x24>)
    6aea:	2201      	movs	r2, #1
    6aec:	780b      	ldrb	r3, [r1, #0]
    6aee:	fa02 f000 	lsl.w	r0, r2, r0
    6af2:	ea23 0000 	bic.w	r0, r3, r0
    6af6:	7008      	strb	r0, [r1, #0]
	if (sof_usage == 0) {
    6af8:	b930      	cbnz	r0, 6b08 <usb_stop_sof_interrupts+0x20>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    6afa:	4a05      	ldr	r2, [pc, #20]	; (6b10 <usb_stop_sof_interrupts+0x28>)
    6afc:	f8d2 3148 	ldr.w	r3, [r2, #328]	; 0x148
    6b00:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    6b04:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
}
    6b08:	4770      	bx	lr
    6b0a:	bf00      	nop
    6b0c:	20007718 	.word	0x20007718
    6b10:	402e0000 	.word	0x402e0000

00006b14 <usb_isr>:
{
    6b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t status = USB1_USBSTS;
    6b18:	4c97      	ldr	r4, [pc, #604]	; (6d78 <usb_isr+0x264>)
{
    6b1a:	b083      	sub	sp, #12
	uint32_t status = USB1_USBSTS;
    6b1c:	f8d4 7144 	ldr.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    6b20:	07fb      	lsls	r3, r7, #31
	USB1_USBSTS = status;
    6b22:	f8c4 7144 	str.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    6b26:	d553      	bpl.n	6bd0 <usb_isr+0xbc>
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    6b28:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6b2c:	2a00      	cmp	r2, #0
    6b2e:	d04a      	beq.n	6bc6 <usb_isr+0xb2>
    6b30:	4e92      	ldr	r6, [pc, #584]	; (6d7c <usb_isr+0x268>)
    6b32:	f8df a260 	ldr.w	sl, [pc, #608]	; 6d94 <usb_isr+0x280>
		uint32_t addr = (uint32_t)data;
    6b36:	f8df 9274 	ldr.w	r9, [pc, #628]	; 6dac <usb_isr+0x298>
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    6b3a:	f8df b274 	ldr.w	fp, [pc, #628]	; 6db0 <usb_isr+0x29c>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    6b3e:	f8df 8274 	ldr.w	r8, [pc, #628]	; 6db4 <usb_isr+0x2a0>
			USB1_ENDPTSETUPSTAT = setupstatus;
    6b42:	f8c4 21ac 	str.w	r2, [r4, #428]	; 0x1ac
				s.word2 = endpoint_queue_head[0].setup1;
    6b46:	e9d6 200a 	ldrd	r2, r0, [r6, #40]	; 0x28
				USB1_USBCMD |= USB_USBCMD_SUTW;
    6b4a:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6b4e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    6b52:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    6b56:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6b5a:	049d      	lsls	r5, r3, #18
    6b5c:	d5f5      	bpl.n	6b4a <usb_isr+0x36>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    6b5e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6b62:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    6b66:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    6b6a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6b6e:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    6b72:	f8d4 51b4 	ldr.w	r5, [r4, #436]	; 0x1b4
    6b76:	f015 1501 	ands.w	r5, r5, #65537	; 0x10001
    6b7a:	d1fa      	bne.n	6b72 <usb_isr+0x5e>
			endpoint0_notify_mask = 0;
    6b7c:	b293      	uxth	r3, r2
	setup.bothwords = setupdata;
    6b7e:	4684      	mov	ip, r0
			endpoint0_notify_mask = 0;
    6b80:	f8ca 5000 	str.w	r5, [sl]
	switch (setup.wRequestAndType) {
    6b84:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    6b88:	f000 81cf 	beq.w	6f2a <usb_isr+0x416>
    6b8c:	f200 80db 	bhi.w	6d46 <usb_isr+0x232>
    6b90:	f240 3102 	movw	r1, #770	; 0x302
    6b94:	428b      	cmp	r3, r1
    6b96:	f000 81e7 	beq.w	6f68 <usb_isr+0x454>
    6b9a:	f200 809a 	bhi.w	6cd2 <usb_isr+0x1be>
    6b9e:	2b82      	cmp	r3, #130	; 0x82
    6ba0:	f000 81cb 	beq.w	6f3a <usb_isr+0x426>
    6ba4:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    6ba8:	f040 808a 	bne.w	6cc0 <usb_isr+0x1ac>
		if (endpoint > 7) break;
    6bac:	f010 0f78 	tst.w	r0, #120	; 0x78
    6bb0:	b283      	uxth	r3, r0
    6bb2:	f000 8203 	beq.w	6fbc <usb_isr+0x4a8>
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    6bb6:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6bba:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    6bbe:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6bc2:	2a00      	cmp	r2, #0
    6bc4:	d1bd      	bne.n	6b42 <usb_isr+0x2e>
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    6bc6:	4a6c      	ldr	r2, [pc, #432]	; (6d78 <usb_isr+0x264>)
    6bc8:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    6bcc:	2b00      	cmp	r3, #0
    6bce:	d142      	bne.n	6c56 <usb_isr+0x142>
	if (status & USB_USBSTS_URI) { // page 3164
    6bd0:	067e      	lsls	r6, r7, #25
    6bd2:	d516      	bpl.n	6c02 <usb_isr+0xee>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    6bd4:	4b68      	ldr	r3, [pc, #416]	; (6d78 <usb_isr+0x264>)
    6bd6:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
    6bda:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    6bde:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    6be2:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    6be6:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    6bea:	2c00      	cmp	r4, #0
    6bec:	d1fb      	bne.n	6be6 <usb_isr+0xd2>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    6bee:	f04f 32ff 	mov.w	r2, #4294967295
    6bf2:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    6bf6:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
		usb_serial_reset();
    6bfa:	f000 fd29 	bl	7650 <usb_serial_reset>
		endpointN_notify_mask = 0;
    6bfe:	4b60      	ldr	r3, [pc, #384]	; (6d80 <usb_isr+0x26c>)
    6c00:	601c      	str	r4, [r3, #0]
	if (status & USB_USBSTS_TI0) {
    6c02:	01fc      	lsls	r4, r7, #7
    6c04:	d503      	bpl.n	6c0e <usb_isr+0xfa>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    6c06:	4b5f      	ldr	r3, [pc, #380]	; (6d84 <usb_isr+0x270>)
    6c08:	681b      	ldr	r3, [r3, #0]
    6c0a:	b103      	cbz	r3, 6c0e <usb_isr+0xfa>
    6c0c:	4798      	blx	r3
	if (status & USB_USBSTS_TI1) {
    6c0e:	01b8      	lsls	r0, r7, #6
    6c10:	d503      	bpl.n	6c1a <usb_isr+0x106>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    6c12:	4b5d      	ldr	r3, [pc, #372]	; (6d88 <usb_isr+0x274>)
    6c14:	681b      	ldr	r3, [r3, #0]
    6c16:	b103      	cbz	r3, 6c1a <usb_isr+0x106>
    6c18:	4798      	blx	r3
	if (status & USB_USBSTS_PCI) {
    6c1a:	0779      	lsls	r1, r7, #29
    6c1c:	d508      	bpl.n	6c30 <usb_isr+0x11c>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    6c1e:	4b56      	ldr	r3, [pc, #344]	; (6d78 <usb_isr+0x264>)
    6c20:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    6c24:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    6c28:	d047      	beq.n	6cba <usb_isr+0x1a6>
			usb_high_speed = 1;
    6c2a:	4b58      	ldr	r3, [pc, #352]	; (6d8c <usb_isr+0x278>)
    6c2c:	2201      	movs	r2, #1
    6c2e:	701a      	strb	r2, [r3, #0]
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    6c30:	4b51      	ldr	r3, [pc, #324]	; (6d78 <usb_isr+0x264>)
    6c32:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
    6c36:	061a      	lsls	r2, r3, #24
    6c38:	d50a      	bpl.n	6c50 <usb_isr+0x13c>
    6c3a:	063b      	lsls	r3, r7, #24
    6c3c:	d508      	bpl.n	6c50 <usb_isr+0x13c>
		if (usb_reboot_timer) {
    6c3e:	4a54      	ldr	r2, [pc, #336]	; (6d90 <usb_isr+0x27c>)
    6c40:	7813      	ldrb	r3, [r2, #0]
    6c42:	b12b      	cbz	r3, 6c50 <usb_isr+0x13c>
			if (--usb_reboot_timer == 0) {
    6c44:	3b01      	subs	r3, #1
    6c46:	b2db      	uxtb	r3, r3
    6c48:	7013      	strb	r3, [r2, #0]
    6c4a:	2b00      	cmp	r3, #0
    6c4c:	f000 8272 	beq.w	7134 <usb_isr+0x620>
}
    6c50:	b003      	add	sp, #12
    6c52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (completestatus & endpoint0_notify_mask) {
    6c56:	494f      	ldr	r1, [pc, #316]	; (6d94 <usb_isr+0x280>)
			USB1_ENDPTCOMPLETE = completestatus;
    6c58:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			if (completestatus & endpoint0_notify_mask) {
    6c5c:	6808      	ldr	r0, [r1, #0]
    6c5e:	4203      	tst	r3, r0
    6c60:	f040 81d1 	bne.w	7006 <usb_isr+0x4f2>
			completestatus &= endpointN_notify_mask;
    6c64:	4a46      	ldr	r2, [pc, #280]	; (6d80 <usb_isr+0x26c>)
    6c66:	6814      	ldr	r4, [r2, #0]
			if (completestatus) {
    6c68:	401c      	ands	r4, r3
    6c6a:	d0b1      	beq.n	6bd0 <usb_isr+0xbc>
				while (tx) {
    6c6c:	ea5f 4814 	movs.w	r8, r4, lsr #16
    6c70:	d010      	beq.n	6c94 <usb_isr+0x180>
    6c72:	4e42      	ldr	r6, [pc, #264]	; (6d7c <usb_isr+0x268>)
					tx &= ~(1<<p);
    6c74:	f04f 0901 	mov.w	r9, #1
					int p=__builtin_ctz(tx);
    6c78:	fa98 f5a8 	rbit	r5, r8
    6c7c:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    6c80:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					tx &= ~(1<<p);
    6c84:	fa09 f505 	lsl.w	r5, r9, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    6c88:	3040      	adds	r0, #64	; 0x40
    6c8a:	f7ff fec5 	bl	6a18 <run_callbacks>
				while (tx) {
    6c8e:	ea38 0805 	bics.w	r8, r8, r5
    6c92:	d1f1      	bne.n	6c78 <usb_isr+0x164>
				uint32_t rx = completestatus & 0xffff;
    6c94:	b2a4      	uxth	r4, r4
				while(rx) {
    6c96:	2c00      	cmp	r4, #0
    6c98:	d09a      	beq.n	6bd0 <usb_isr+0xbc>
    6c9a:	4e38      	ldr	r6, [pc, #224]	; (6d7c <usb_isr+0x268>)
					rx &= ~(1<<p);
    6c9c:	f04f 0801 	mov.w	r8, #1
					int p=__builtin_ctz(rx);
    6ca0:	fa94 f5a4 	rbit	r5, r4
    6ca4:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2);
    6ca8:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					rx &= ~(1<<p);
    6cac:	fa08 f505 	lsl.w	r5, r8, r5
					run_callbacks(endpoint_queue_head + p * 2);
    6cb0:	f7ff feb2 	bl	6a18 <run_callbacks>
				while(rx) {
    6cb4:	43ac      	bics	r4, r5
    6cb6:	d1f3      	bne.n	6ca0 <usb_isr+0x18c>
    6cb8:	e78a      	b.n	6bd0 <usb_isr+0xbc>
			usb_high_speed = 0;
    6cba:	4a34      	ldr	r2, [pc, #208]	; (6d8c <usb_isr+0x278>)
    6cbc:	7013      	strb	r3, [r2, #0]
    6cbe:	e7b7      	b.n	6c30 <usb_isr+0x11c>
	switch (setup.wRequestAndType) {
    6cc0:	2b80      	cmp	r3, #128	; 0x80
    6cc2:	f47f af78 	bne.w	6bb6 <usb_isr+0xa2>
		reply_buffer[0] = 0;
    6cc6:	4834      	ldr	r0, [pc, #208]	; (6d98 <usb_isr+0x284>)
		endpoint0_transmit(reply_buffer, 2, 0);
    6cc8:	2102      	movs	r1, #2
		reply_buffer[0] = 0;
    6cca:	8005      	strh	r5, [r0, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6ccc:	f7ff fec0 	bl	6a50 <endpoint0_transmit.constprop.0>
		return;
    6cd0:	e775      	b.n	6bbe <usb_isr+0xaa>
	switch (setup.wRequestAndType) {
    6cd2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    6cd6:	f000 810b 	beq.w	6ef0 <usb_isr+0x3dc>
    6cda:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    6cde:	2b01      	cmp	r3, #1
    6ce0:	f63f af69 	bhi.w	6bb6 <usb_isr+0xa2>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6ce4:	4b2d      	ldr	r3, [pc, #180]	; (6d9c <usb_isr+0x288>)
    6ce6:	685d      	ldr	r5, [r3, #4]
    6ce8:	2d00      	cmp	r5, #0
    6cea:	f43f af64 	beq.w	6bb6 <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6cee:	fa1f fc8c 	uxth.w	ip, ip
    6cf2:	ea4f 4e12 	mov.w	lr, r2, lsr #16
    6cf6:	e004      	b.n	6d02 <usb_isr+0x1ee>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6cf8:	691d      	ldr	r5, [r3, #16]
    6cfa:	330c      	adds	r3, #12
    6cfc:	2d00      	cmp	r5, #0
    6cfe:	f43f af5a 	beq.w	6bb6 <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6d02:	881a      	ldrh	r2, [r3, #0]
    6d04:	4572      	cmp	r2, lr
    6d06:	d1f7      	bne.n	6cf8 <usb_isr+0x1e4>
    6d08:	885a      	ldrh	r2, [r3, #2]
    6d0a:	4562      	cmp	r2, ip
    6d0c:	d1f4      	bne.n	6cf8 <usb_isr+0x1e4>
				if ((setup.wValue >> 8) == 3) {
    6d0e:	ea4f 221e 	mov.w	r2, lr, lsr #8
    6d12:	2a03      	cmp	r2, #3
    6d14:	f000 81a5 	beq.w	7062 <usb_isr+0x54e>
					datalen = list->length;
    6d18:	891a      	ldrh	r2, [r3, #8]
				if (datalen > setup.wLength) datalen = setup.wLength;
    6d1a:	0c00      	lsrs	r0, r0, #16
    6d1c:	4282      	cmp	r2, r0
    6d1e:	bf28      	it	cs
    6d20:	4602      	movcs	r2, r0
				if (setup.wValue == 0x200) {
    6d22:	f5be 7f00 	cmp.w	lr, #512	; 0x200
    6d26:	f040 81a1 	bne.w	706c <usb_isr+0x558>
					if (usb_high_speed) src = usb_config_descriptor_480;
    6d2a:	4b18      	ldr	r3, [pc, #96]	; (6d8c <usb_isr+0x278>)
    6d2c:	491c      	ldr	r1, [pc, #112]	; (6da0 <usb_isr+0x28c>)
    6d2e:	7818      	ldrb	r0, [r3, #0]
    6d30:	4b1c      	ldr	r3, [pc, #112]	; (6da4 <usb_isr+0x290>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6d32:	9201      	str	r2, [sp, #4]
    6d34:	2800      	cmp	r0, #0
    6d36:	bf18      	it	ne
    6d38:	4619      	movne	r1, r3
    6d3a:	481b      	ldr	r0, [pc, #108]	; (6da8 <usb_isr+0x294>)
    6d3c:	f7ff fabe 	bl	62bc <memcpy>
    6d40:	4d19      	ldr	r5, [pc, #100]	; (6da8 <usb_isr+0x294>)
    6d42:	9a01      	ldr	r2, [sp, #4]
    6d44:	e1e1      	b.n	710a <usb_isr+0x5f6>
	switch (setup.wRequestAndType) {
    6d46:	f242 2121 	movw	r1, #8737	; 0x2221
    6d4a:	428b      	cmp	r3, r1
    6d4c:	d07c      	beq.n	6e48 <usb_isr+0x334>
    6d4e:	d933      	bls.n	6db8 <usb_isr+0x2a4>
    6d50:	f242 3121 	movw	r1, #8993	; 0x2321
    6d54:	428b      	cmp	r3, r1
    6d56:	f000 8081 	beq.w	6e5c <usb_isr+0x348>
    6d5a:	f64f 01c0 	movw	r1, #63680	; 0xf8c0
    6d5e:	428b      	cmp	r3, r1
    6d60:	f47f af29 	bne.w	6bb6 <usb_isr+0xa2>
		if ((setup.wIndex & 0xFF00) != 0) break; // 1=Genre, 4=Compat ID, 5=Properties
    6d64:	f410 4f7f 	tst.w	r0, #65280	; 0xff00
    6d68:	b283      	uxth	r3, r0
    6d6a:	f47f af24 	bne.w	6bb6 <usb_isr+0xa2>
		setup.wIndex |= 0xEE00; // alter wIndex and treat as normal USB descriptor
    6d6e:	f443 436e 	orr.w	r3, r3, #60928	; 0xee00
    6d72:	f363 0c0f 	bfi	ip, r3, #0, #16
    6d76:	e7b5      	b.n	6ce4 <usb_isr+0x1d0>
    6d78:	402e0000 	.word	0x402e0000
    6d7c:	20000000 	.word	0x20000000
    6d80:	200074e4 	.word	0x200074e4
    6d84:	200076fc 	.word	0x200076fc
    6d88:	20007700 	.word	0x20007700
    6d8c:	2000771e 	.word	0x2000771e
    6d90:	2000771f 	.word	0x2000771f
    6d94:	200074e0 	.word	0x200074e0
    6d98:	20007514 	.word	0x20007514
    6d9c:	20000f44 	.word	0x20000f44
    6da0:	60001b40 	.word	0x60001b40
    6da4:	60001ba4 	.word	0x60001ba4
    6da8:	20200000 	.word	0x20200000
    6dac:	200074d8 	.word	0x200074d8
    6db0:	b8c6cf5d 	.word	0xb8c6cf5d
    6db4:	402e01c0 	.word	0x402e01c0
	switch (setup.wRequestAndType) {
    6db8:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    6dbc:	d066      	beq.n	6e8c <usb_isr+0x378>
    6dbe:	f242 0121 	movw	r1, #8225	; 0x2021
    6dc2:	428b      	cmp	r3, r1
    6dc4:	f47f aef7 	bne.w	6bb6 <usb_isr+0xa2>
		if (setup.wLength != 7) break;
    6dc8:	0c03      	lsrs	r3, r0, #16
    6dca:	2b07      	cmp	r3, #7
    6dcc:	f47f aef3 	bne.w	6bb6 <usb_isr+0xa2>
		endpoint0_transfer_data.next = 1;
    6dd0:	4bb2      	ldr	r3, [pc, #712]	; (709c <usb_isr+0x588>)
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6dd2:	49b3      	ldr	r1, [pc, #716]	; (70a0 <usb_isr+0x58c>)
		endpoint_queue_head[0].status = 0;
    6dd4:	60f5      	str	r5, [r6, #12]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6dd6:	60d9      	str	r1, [r3, #12]
		endpoint0_setupdata.bothwords = setupdata;
    6dd8:	49b2      	ldr	r1, [pc, #712]	; (70a4 <usb_isr+0x590>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    6dda:	60b3      	str	r3, [r6, #8]
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    6ddc:	f8c3 9008 	str.w	r9, [r3, #8]
		endpoint0_setupdata.bothwords = setupdata;
    6de0:	e9c1 2000 	strd	r2, r0, [r1]
		endpoint0_transfer_data.next = 1;
    6de4:	2201      	movs	r2, #1
    6de6:	601a      	str	r2, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6de8:	4aaf      	ldr	r2, [pc, #700]	; (70a8 <usb_isr+0x594>)
    6dea:	605a      	str	r2, [r3, #4]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6dec:	4aaf      	ldr	r2, [pc, #700]	; (70ac <usb_isr+0x598>)
    6dee:	611a      	str	r2, [r3, #16]
		USB1_ENDPTPRIME |= (1<<0);
    6df0:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
    6df4:	f041 0101 	orr.w	r1, r1, #1
    6df8:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6dfc:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6e00:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6e04:	6159      	str	r1, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6e06:	619a      	str	r2, [r3, #24]
		while (USB1_ENDPTPRIME) ;
    6e08:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6e0c:	2b00      	cmp	r3, #0
    6e0e:	d1fb      	bne.n	6e08 <usb_isr+0x2f4>
	endpoint0_transfer_ack.next = 1;
    6e10:	4aa7      	ldr	r2, [pc, #668]	; (70b0 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6e12:	64f3      	str	r3, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6e14:	6093      	str	r3, [r2, #8]
	endpoint0_transfer_ack.next = 1;
    6e16:	2301      	movs	r3, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6e18:	64b2      	str	r2, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6e1a:	6013      	str	r3, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6e1c:	f248 0380 	movw	r3, #32896	; 0x8080
    6e20:	6053      	str	r3, [r2, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6e22:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6e26:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6e2a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6e2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6e32:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    6e36:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    6e3a:	f8ca 3000 	str.w	r3, [sl]
	while (USB1_ENDPTPRIME) ;
    6e3e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6e42:	2b00      	cmp	r3, #0
    6e44:	d1fb      	bne.n	6e3e <usb_isr+0x32a>
    6e46:	e6ba      	b.n	6bbe <usb_isr+0xaa>
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
    6e48:	b280      	uxth	r0, r0
    6e4a:	b938      	cbnz	r0, 6e5c <usb_isr+0x348>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6e4c:	4b99      	ldr	r3, [pc, #612]	; (70b4 <usb_isr+0x5a0>)
			usb_cdc_line_rtsdtr = setup.wValue;
    6e4e:	f3c2 4207 	ubfx	r2, r2, #16, #8
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    6e52:	6819      	ldr	r1, [r3, #0]
    6e54:	4b98      	ldr	r3, [pc, #608]	; (70b8 <usb_isr+0x5a4>)
    6e56:	6019      	str	r1, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    6e58:	4b98      	ldr	r3, [pc, #608]	; (70bc <usb_isr+0x5a8>)
    6e5a:	701a      	strb	r2, [r3, #0]
	endpoint0_transfer_ack.next = 1;
    6e5c:	4b94      	ldr	r3, [pc, #592]	; (70b0 <usb_isr+0x59c>)
	endpoint0_transfer_ack.pointer0 = 0;
    6e5e:	2200      	movs	r2, #0
    6e60:	609a      	str	r2, [r3, #8]
	endpoint_queue_head[1].status = 0;
    6e62:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    6e64:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6e66:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6e68:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6e6a:	2280      	movs	r2, #128	; 0x80
    6e6c:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6e6e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6e72:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6e76:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6e7a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6e7e:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6e82:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6e86:	2b00      	cmp	r3, #0
    6e88:	d1fb      	bne.n	6e82 <usb_isr+0x36e>
    6e8a:	e698      	b.n	6bbe <usb_isr+0xaa>
		usb_configuration = setup.wValue;
    6e8c:	f3c2 4207 	ubfx	r2, r2, #16, #8
    6e90:	4b8b      	ldr	r3, [pc, #556]	; (70c0 <usb_isr+0x5ac>)
    6e92:	701a      	strb	r2, [r3, #0]
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    6e94:	4b8b      	ldr	r3, [pc, #556]	; (70c4 <usb_isr+0x5b0>)
    6e96:	f8c4 31c8 	str.w	r3, [r4, #456]	; 0x1c8
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    6e9a:	4b8b      	ldr	r3, [pc, #556]	; (70c8 <usb_isr+0x5b4>)
    6e9c:	f8c4 31cc 	str.w	r3, [r4, #460]	; 0x1cc
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    6ea0:	4b8a      	ldr	r3, [pc, #552]	; (70cc <usb_isr+0x5b8>)
    6ea2:	f8c4 31d0 	str.w	r3, [r4, #464]	; 0x1d0
		usb_serial_configure();
    6ea6:	f000 fbd5 	bl	7654 <usb_serial_configure>
		memset(endpoint_queue_head + 2, 0, sizeof(endpoint_t) * 2);
    6eaa:	2280      	movs	r2, #128	; 0x80
    6eac:	4629      	mov	r1, r5
    6eae:	4888      	ldr	r0, [pc, #544]	; (70d0 <usb_isr+0x5bc>)
    6eb0:	f001 fcfc 	bl	88ac <memset>
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    6eb4:	4b87      	ldr	r3, [pc, #540]	; (70d4 <usb_isr+0x5c0>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6eb6:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    6eb8:	f8c6 b0a0 	str.w	fp, [r6, #160]	; 0xa0
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    6ebc:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
	endpoint0_transfer_ack.next = 1;
    6ec0:	4b7b      	ldr	r3, [pc, #492]	; (70b0 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6ec2:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6ec4:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.next = 1;
    6ec6:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6ec8:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.pointer0 = 0;
    6eca:	609d      	str	r5, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6ecc:	601a      	str	r2, [r3, #0]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6ece:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6ed2:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6ed6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6eda:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6ede:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    6ee2:	f8ca 5000 	str.w	r5, [sl]
	while (USB1_ENDPTPRIME) ;
    6ee6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6eea:	2b00      	cmp	r3, #0
    6eec:	d1fb      	bne.n	6ee6 <usb_isr+0x3d2>
    6eee:	e666      	b.n	6bbe <usb_isr+0xaa>
	endpoint0_transfer_ack.next = 1;
    6ef0:	4b6f      	ldr	r3, [pc, #444]	; (70b0 <usb_isr+0x59c>)
    6ef2:	2101      	movs	r1, #1
	endpoint_queue_head[1].status = 0;
    6ef4:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    6ef6:	6019      	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6ef8:	2180      	movs	r1, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
    6efa:	609d      	str	r5, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6efc:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6efe:	6059      	str	r1, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6f00:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6f04:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6f08:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6f0c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6f10:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6f14:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6f18:	2b00      	cmp	r3, #0
    6f1a:	d1fb      	bne.n	6f14 <usb_isr+0x400>
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    6f1c:	0c13      	lsrs	r3, r2, #16
    6f1e:	065b      	lsls	r3, r3, #25
    6f20:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    6f24:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
		return;
    6f28:	e649      	b.n	6bbe <usb_isr+0xaa>
		reply_buffer[0] = usb_configuration;
    6f2a:	4b65      	ldr	r3, [pc, #404]	; (70c0 <usb_isr+0x5ac>)
		endpoint0_transmit(reply_buffer, 1, 0);
    6f2c:	2101      	movs	r1, #1
		reply_buffer[0] = usb_configuration;
    6f2e:	486a      	ldr	r0, [pc, #424]	; (70d8 <usb_isr+0x5c4>)
    6f30:	781b      	ldrb	r3, [r3, #0]
    6f32:	7003      	strb	r3, [r0, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    6f34:	f7ff fd8c 	bl	6a50 <endpoint0_transmit.constprop.0>
		return;
    6f38:	e641      	b.n	6bbe <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    6f3a:	b283      	uxth	r3, r0
		if (endpoint > 7) break;
    6f3c:	f010 0078 	ands.w	r0, r0, #120	; 0x78
    6f40:	f47f ae39 	bne.w	6bb6 <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    6f44:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    6f48:	f858 1022 	ldr.w	r1, [r8, r2, lsl #2]
		reply_buffer[0] = 0;
    6f4c:	4a62      	ldr	r2, [pc, #392]	; (70d8 <usb_isr+0x5c4>)
    6f4e:	8010      	strh	r0, [r2, #0]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    6f50:	0618      	lsls	r0, r3, #24
    6f52:	f100 809e 	bmi.w	7092 <usb_isr+0x57e>
    6f56:	07cb      	lsls	r3, r1, #31
    6f58:	d501      	bpl.n	6f5e <usb_isr+0x44a>
			reply_buffer[0] = 1;
    6f5a:	2301      	movs	r3, #1
    6f5c:	7013      	strb	r3, [r2, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6f5e:	2102      	movs	r1, #2
    6f60:	485d      	ldr	r0, [pc, #372]	; (70d8 <usb_isr+0x5c4>)
    6f62:	f7ff fd75 	bl	6a50 <endpoint0_transmit.constprop.0>
		return;
    6f66:	e62a      	b.n	6bbe <usb_isr+0xaa>
		if (endpoint > 7) break;
    6f68:	f010 0f78 	tst.w	r0, #120	; 0x78
    6f6c:	b283      	uxth	r3, r0
    6f6e:	f47f ae22 	bne.w	6bb6 <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    6f72:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    6f76:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    6f7a:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    6f7e:	bf14      	ite	ne
    6f80:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    6f84:	f043 0301 	orreq.w	r3, r3, #1
    6f88:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    6f8c:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    6f8e:	4b48      	ldr	r3, [pc, #288]	; (70b0 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6f90:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6f92:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6f94:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6f96:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6f98:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6f9a:	2280      	movs	r2, #128	; 0x80
    6f9c:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6f9e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6fa2:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6fa6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6faa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6fae:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6fb2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6fb6:	2b00      	cmp	r3, #0
    6fb8:	d1fb      	bne.n	6fb2 <usb_isr+0x49e>
    6fba:	e600      	b.n	6bbe <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    6fbc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    6fc0:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    6fc4:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    6fc8:	bf14      	ite	ne
    6fca:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    6fce:	f023 0301 	biceq.w	r3, r3, #1
    6fd2:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    6fd6:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    6fd8:	4b35      	ldr	r3, [pc, #212]	; (70b0 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6fda:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6fdc:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6fde:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6fe0:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6fe2:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6fe4:	2280      	movs	r2, #128	; 0x80
    6fe6:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6fe8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6fec:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6ff0:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6ff4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6ff8:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    6ffc:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    7000:	2b00      	cmp	r3, #0
    7002:	d1fb      	bne.n	6ffc <usb_isr+0x4e8>
    7004:	e5db      	b.n	6bbe <usb_isr+0xaa>
				endpoint0_notify_mask = 0;
    7006:	2000      	movs	r0, #0
    7008:	6008      	str	r0, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    700a:	4926      	ldr	r1, [pc, #152]	; (70a4 <usb_isr+0x590>)
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    700c:	880c      	ldrh	r4, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    700e:	6848      	ldr	r0, [r1, #4]
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    7010:	f242 0121 	movw	r1, #8225	; 0x2021
    7014:	428c      	cmp	r4, r1
    7016:	f47f ae25 	bne.w	6c64 <usb_isr+0x150>
    701a:	b280      	uxth	r0, r0
    701c:	2800      	cmp	r0, #0
    701e:	f47f ae21 	bne.w	6c64 <usb_isr+0x150>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    7022:	492e      	ldr	r1, [pc, #184]	; (70dc <usb_isr+0x5c8>)
    7024:	4c2e      	ldr	r4, [pc, #184]	; (70e0 <usb_isr+0x5cc>)
    7026:	c903      	ldmia	r1, {r0, r1}
    7028:	80a1      	strh	r1, [r4, #4]
		if (usb_cdc_line_coding[0] == 134) {
    702a:	2886      	cmp	r0, #134	; 0x86
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    702c:	ea4f 4111 	mov.w	r1, r1, lsr #16
    7030:	6020      	str	r0, [r4, #0]
    7032:	71a1      	strb	r1, [r4, #6]
		if (usb_cdc_line_coding[0] == 134) {
    7034:	f47f ae16 	bne.w	6c64 <usb_isr+0x150>
	__disable_irq();
    7038:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    703a:	482a      	ldr	r0, [pc, #168]	; (70e4 <usb_isr+0x5d0>)
    703c:	7801      	ldrb	r1, [r0, #0]
    703e:	f041 0108 	orr.w	r1, r1, #8
    7042:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    7044:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    7048:	060d      	lsls	r5, r1, #24
    704a:	d405      	bmi.n	7058 <usb_isr+0x544>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    704c:	2080      	movs	r0, #128	; 0x80
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    704e:	4301      	orrs	r1, r0
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    7050:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    7054:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	__enable_irq();
    7058:	b662      	cpsie	i
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    705a:	4a23      	ldr	r2, [pc, #140]	; (70e8 <usb_isr+0x5d4>)
    705c:	2150      	movs	r1, #80	; 0x50
    705e:	7011      	strb	r1, [r2, #0]
    7060:	e600      	b.n	6c64 <usb_isr+0x150>
				if (datalen > setup.wLength) datalen = setup.wLength;
    7062:	0c00      	lsrs	r0, r0, #16
					datalen = *(list->addr);
    7064:	782a      	ldrb	r2, [r5, #0]
    7066:	4282      	cmp	r2, r0
    7068:	bf28      	it	cs
    706a:	4602      	movcs	r2, r0
				} else if (setup.wValue == 0x700) {
    706c:	f5be 6fe0 	cmp.w	lr, #1792	; 0x700
    7070:	d144      	bne.n	70fc <usb_isr+0x5e8>
					if (usb_high_speed) src = usb_config_descriptor_12;
    7072:	4b1e      	ldr	r3, [pc, #120]	; (70ec <usb_isr+0x5d8>)
					memcpy(usb_descriptor_buffer, src, datalen);
    7074:	4d1e      	ldr	r5, [pc, #120]	; (70f0 <usb_isr+0x5dc>)
					if (usb_high_speed) src = usb_config_descriptor_12;
    7076:	7818      	ldrb	r0, [r3, #0]
    7078:	491e      	ldr	r1, [pc, #120]	; (70f4 <usb_isr+0x5e0>)
    707a:	4b1f      	ldr	r3, [pc, #124]	; (70f8 <usb_isr+0x5e4>)
					memcpy(usb_descriptor_buffer, src, datalen);
    707c:	9201      	str	r2, [sp, #4]
    707e:	2800      	cmp	r0, #0
    7080:	bf18      	it	ne
    7082:	4619      	movne	r1, r3
    7084:	4628      	mov	r0, r5
    7086:	f7ff f919 	bl	62bc <memcpy>
					usb_descriptor_buffer[1] = 7;
    708a:	2307      	movs	r3, #7
    708c:	706b      	strb	r3, [r5, #1]
    708e:	9a01      	ldr	r2, [sp, #4]
    7090:	e03b      	b.n	710a <usb_isr+0x5f6>
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    7092:	03c9      	lsls	r1, r1, #15
    7094:	f53f af61 	bmi.w	6f5a <usb_isr+0x446>
    7098:	e761      	b.n	6f5e <usb_isr+0x44a>
    709a:	bf00      	nop
    709c:	20001ee0 	.word	0x20001ee0
    70a0:	200084d8 	.word	0x200084d8
    70a4:	20002080 	.word	0x20002080
    70a8:	00070080 	.word	0x00070080
    70ac:	200094d8 	.word	0x200094d8
    70b0:	20001ec0 	.word	0x20001ec0
    70b4:	200075a8 	.word	0x200075a8
    70b8:	200076f8 	.word	0x200076f8
    70bc:	2000771c 	.word	0x2000771c
    70c0:	2000771d 	.word	0x2000771d
    70c4:	00cc0002 	.word	0x00cc0002
    70c8:	000200c8 	.word	0x000200c8
    70cc:	00c80002 	.word	0x00c80002
    70d0:	20000080 	.word	0x20000080
    70d4:	74d59319 	.word	0x74d59319
    70d8:	20007514 	.word	0x20007514
    70dc:	200074d8 	.word	0x200074d8
    70e0:	200076f0 	.word	0x200076f0
    70e4:	20007718 	.word	0x20007718
    70e8:	2000771f 	.word	0x2000771f
    70ec:	2000771e 	.word	0x2000771e
    70f0:	20200000 	.word	0x20200000
    70f4:	60001ba4 	.word	0x60001ba4
    70f8:	60001b40 	.word	0x60001b40
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    70fc:	4629      	mov	r1, r5
    70fe:	4d10      	ldr	r5, [pc, #64]	; (7140 <usb_isr+0x62c>)
    7100:	9201      	str	r2, [sp, #4]
    7102:	4628      	mov	r0, r5
    7104:	f7ff f8da 	bl	62bc <memcpy>
    7108:	9a01      	ldr	r2, [sp, #4]
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    710a:	f025 031f 	bic.w	r3, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    710e:	4415      	add	r5, r2
	asm("dsb");
    7110:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    7114:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    7118:	f8c1 3f70 	str.w	r3, [r1, #3952]	; 0xf70
		location += 32;
    711c:	3320      	adds	r3, #32
	} while (location < end_addr);
    711e:	429d      	cmp	r5, r3
    7120:	d8fa      	bhi.n	7118 <usb_isr+0x604>
	asm("dsb");
    7122:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7126:	f3bf 8f6f 	isb	sy
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    712a:	4805      	ldr	r0, [pc, #20]	; (7140 <usb_isr+0x62c>)
    712c:	4611      	mov	r1, r2
    712e:	f7ff fc8f 	bl	6a50 <endpoint0_transmit.constprop.0>
				return;
    7132:	e544      	b.n	6bbe <usb_isr+0xaa>
				usb_stop_sof_interrupts(NUM_INTERFACE);
    7134:	2003      	movs	r0, #3
    7136:	f7ff fcd7 	bl	6ae8 <usb_stop_sof_interrupts>
				_reboot_Teensyduino_();
    713a:	f006 fe3d 	bl	ddb8 <___reboot_Teensyduino__veneer>
    713e:	bf00      	nop
    7140:	20200000 	.word	0x20200000

00007144 <usb_config_rx>:
{
    7144:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7148:	461f      	mov	r7, r3
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    714a:	1e83      	subs	r3, r0, #2
    714c:	2b02      	cmp	r3, #2
    714e:	d901      	bls.n	7154 <usb_config_rx+0x10>
}
    7150:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    7154:	f8df 904c 	ldr.w	r9, [pc, #76]	; 71a4 <usb_config_rx+0x60>
    7158:	4615      	mov	r5, r2
    715a:	460c      	mov	r4, r1
	memset(qh, 0, sizeof(endpoint_t));
    715c:	223c      	movs	r2, #60	; 0x3c
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    715e:	eb09 18c0 	add.w	r8, r9, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    7162:	4606      	mov	r6, r0
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    7164:	ea4f 1ac0 	mov.w	sl, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    7168:	2100      	movs	r1, #0
    716a:	f108 0004 	add.w	r0, r8, #4
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    716e:	0424      	lsls	r4, r4, #16
	memset(qh, 0, sizeof(endpoint_t));
    7170:	f001 fb9c 	bl	88ac <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    7174:	fab5 f285 	clz	r2, r5
	qh->next = 1; // Terminate bit = 1
    7178:	2301      	movs	r3, #1
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    717a:	0952      	lsrs	r2, r2, #5
    717c:	ea44 7442 	orr.w	r4, r4, r2, lsl #29
	qh->config = config;
    7180:	f849 400a 	str.w	r4, [r9, sl]
	qh->callback_function = callback;
    7184:	f8c8 7038 	str.w	r7, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    7188:	f8c8 3008 	str.w	r3, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << ep);
    718c:	2f00      	cmp	r7, #0
    718e:	d0df      	beq.n	7150 <usb_config_rx+0xc>
    7190:	4a03      	ldr	r2, [pc, #12]	; (71a0 <usb_config_rx+0x5c>)
    7192:	40b3      	lsls	r3, r6
    7194:	6811      	ldr	r1, [r2, #0]
    7196:	430b      	orrs	r3, r1
    7198:	6013      	str	r3, [r2, #0]
}
    719a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    719e:	bf00      	nop
    71a0:	200074e4 	.word	0x200074e4
    71a4:	20000000 	.word	0x20000000

000071a8 <usb_config_tx>:
{
    71a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    71ac:	460d      	mov	r5, r1
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    71ae:	1e81      	subs	r1, r0, #2
    71b0:	2902      	cmp	r1, #2
    71b2:	d901      	bls.n	71b8 <usb_config_tx+0x10>
}
    71b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    71b8:	01c7      	lsls	r7, r0, #7
    71ba:	f8df 904c 	ldr.w	r9, [pc, #76]	; 7208 <usb_config_tx+0x60>
    71be:	4692      	mov	sl, r2
    71c0:	4604      	mov	r4, r0
    71c2:	3740      	adds	r7, #64	; 0x40
	memset(qh, 0, sizeof(endpoint_t));
    71c4:	223c      	movs	r2, #60	; 0x3c
    71c6:	2100      	movs	r1, #0
    71c8:	461e      	mov	r6, r3
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    71ca:	eb09 0807 	add.w	r8, r9, r7
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    71ce:	042d      	lsls	r5, r5, #16
	memset(qh, 0, sizeof(endpoint_t));
    71d0:	f108 0004 	add.w	r0, r8, #4
    71d4:	f001 fb6a 	bl	88ac <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    71d8:	faba f28a 	clz	r2, sl
    71dc:	0952      	lsrs	r2, r2, #5
    71de:	ea45 7242 	orr.w	r2, r5, r2, lsl #29
	qh->config = config;
    71e2:	f849 2007 	str.w	r2, [r9, r7]
	qh->next = 1; // Terminate bit = 1
    71e6:	2201      	movs	r2, #1
	qh->callback_function = callback;
    71e8:	f8c8 6038 	str.w	r6, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    71ec:	f8c8 2008 	str.w	r2, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    71f0:	2e00      	cmp	r6, #0
    71f2:	d0df      	beq.n	71b4 <usb_config_tx+0xc>
    71f4:	4b03      	ldr	r3, [pc, #12]	; (7204 <usb_config_tx+0x5c>)
    71f6:	3410      	adds	r4, #16
    71f8:	6819      	ldr	r1, [r3, #0]
    71fa:	40a2      	lsls	r2, r4
    71fc:	430a      	orrs	r2, r1
    71fe:	601a      	str	r2, [r3, #0]
}
    7200:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7204:	200074e4 	.word	0x200074e4
    7208:	20000000 	.word	0x20000000

0000720c <usb_prepare_transfer>:
	transfer->status = (len << 16) | (1<<7);
    720c:	0412      	lsls	r2, r2, #16
	transfer->pointer0 = addr;
    720e:	6081      	str	r1, [r0, #8]
	transfer->callback_param = param;
    7210:	61c3      	str	r3, [r0, #28]
	transfer->pointer3 = addr + 12288;
    7212:	f501 5340 	add.w	r3, r1, #12288	; 0x3000
	transfer->status = (len << 16) | (1<<7);
    7216:	f042 0280 	orr.w	r2, r2, #128	; 0x80
{
    721a:	b410      	push	{r4}
	transfer->next = 1;
    721c:	2401      	movs	r4, #1
	transfer->status = (len << 16) | (1<<7);
    721e:	6042      	str	r2, [r0, #4]
	transfer->pointer2 = addr + 8192;
    7220:	f501 5200 	add.w	r2, r1, #8192	; 0x2000
	transfer->next = 1;
    7224:	6004      	str	r4, [r0, #0]
	transfer->pointer1 = addr + 4096;
    7226:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
	transfer->pointer4 = addr + 16384;
    722a:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
	transfer->pointer1 = addr + 4096;
    722e:	60c4      	str	r4, [r0, #12]
	transfer->pointer4 = addr + 16384;
    7230:	6181      	str	r1, [r0, #24]
}
    7232:	f85d 4b04 	ldr.w	r4, [sp], #4
	transfer->pointer3 = addr + 12288;
    7236:	e9c0 2304 	strd	r2, r3, [r0, #16]
}
    723a:	4770      	bx	lr

0000723c <usb_transmit>:

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    723c:	1e83      	subs	r3, r0, #2
{
    723e:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    7240:	2b02      	cmp	r3, #2
    7242:	d900      	bls.n	7246 <usb_transmit+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}
    7244:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    7246:	4b06      	ldr	r3, [pc, #24]	; (7260 <usb_transmit+0x24>)
	uint32_t mask = 1 << (endpoint_number + 16);
    7248:	f100 0110 	add.w	r1, r0, #16
    724c:	f04f 0c01 	mov.w	ip, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    7250:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
	schedule_transfer(endpoint, mask, transfer);
    7254:	fa0c f101 	lsl.w	r1, ip, r1
    7258:	3040      	adds	r0, #64	; 0x40
    725a:	f7ff bb99 	b.w	6990 <schedule_transfer>
    725e:	bf00      	nop
    7260:	20000000 	.word	0x20000000

00007264 <usb_receive>:

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    7264:	1e83      	subs	r3, r0, #2
{
    7266:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    7268:	2b02      	cmp	r3, #2
    726a:	d900      	bls.n	726e <usb_receive+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
}
    726c:	4770      	bx	lr
	uint32_t mask = 1 << endpoint_number;
    726e:	2101      	movs	r1, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
    7270:	4b02      	ldr	r3, [pc, #8]	; (727c <usb_receive+0x18>)
	schedule_transfer(endpoint, mask, transfer);
    7272:	4081      	lsls	r1, r0
    7274:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    7278:	f7ff bb8a 	b.w	6990 <schedule_transfer>
    727c:	20000000 	.word	0x20000000

00007280 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    7280:	6840      	ldr	r0, [r0, #4]
#endif
}
    7282:	4770      	bx	lr

00007284 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    7284:	4a12      	ldr	r2, [pc, #72]	; (72d0 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    7286:	4b13      	ldr	r3, [pc, #76]	; (72d4 <usb_init_serialnumber+0x50>)
	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    7288:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    728c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	if (num < 10000000) num = num * 10;
    7290:	4298      	cmp	r0, r3
{
    7292:	b510      	push	{r4, lr}
    7294:	b084      	sub	sp, #16
	if (num < 10000000) num = num * 10;
    7296:	d202      	bcs.n	729e <usb_init_serialnumber+0x1a>
    7298:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    729c:	0040      	lsls	r0, r0, #1
	ultoa(num, buf, 10);
    729e:	4c0e      	ldr	r4, [pc, #56]	; (72d8 <usb_init_serialnumber+0x54>)
    72a0:	a901      	add	r1, sp, #4
    72a2:	220a      	movs	r2, #10
    72a4:	f7ff f8a4 	bl	63f0 <ultoa>
	for (i=0; i<10; i++) {
    72a8:	a901      	add	r1, sp, #4
    72aa:	2300      	movs	r3, #0
    72ac:	4620      	mov	r0, r4
		char c = buf[i];
    72ae:	f811 2b01 	ldrb.w	r2, [r1], #1
	for (i=0; i<10; i++) {
    72b2:	3301      	adds	r3, #1
		if (!c) break;
    72b4:	b13a      	cbz	r2, 72c6 <usb_init_serialnumber+0x42>
	for (i=0; i<10; i++) {
    72b6:	2b0a      	cmp	r3, #10
		usb_string_serial_number_default.wString[i] = c;
    72b8:	f820 2f02 	strh.w	r2, [r0, #2]!
	for (i=0; i<10; i++) {
    72bc:	d1f7      	bne.n	72ae <usb_init_serialnumber+0x2a>
    72be:	2316      	movs	r3, #22
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    72c0:	7023      	strb	r3, [r4, #0]
}
    72c2:	b004      	add	sp, #16
    72c4:	bd10      	pop	{r4, pc}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    72c6:	005b      	lsls	r3, r3, #1
    72c8:	b2db      	uxtb	r3, r3
    72ca:	7023      	strb	r3, [r4, #0]
}
    72cc:	b004      	add	sp, #16
    72ce:	bd10      	pop	{r4, pc}
    72d0:	401f4400 	.word	0x401f4400
    72d4:	00989680 	.word	0x00989680
    72d8:	200019c4 	.word	0x200019c4

000072dc <usb_serial_class::clear()>:
        virtual void clear(void) { usb_serial_flush_input(); }
    72dc:	f000 bad8 	b.w	7890 <usb_serial_flush_input>

000072e0 <usb_serial_class::available()>:
        virtual int available() { return usb_serial_available(); }
    72e0:	f000 baca 	b.w	7878 <usb_serial_available>

000072e4 <usb_serial_class::flush()>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    72e4:	f000 bb66 	b.w	79b4 <usb_serial_flush_output>

000072e8 <usb_serial_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    72e8:	f000 bb3c 	b.w	7964 <usb_serial_write_buffer_free>

000072ec <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    72ec:	4608      	mov	r0, r1
    72ee:	4611      	mov	r1, r2
    72f0:	f000 bb2c 	b.w	794c <usb_serial_write>

000072f4 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    72f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    72f6:	4c14      	ldr	r4, [pc, #80]	; (7348 <rx_queue_transfer+0x54>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    72f8:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    72fc:	4e13      	ldr	r6, [pc, #76]	; (734c <rx_queue_transfer+0x58>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    72fe:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    7302:	eb04 2440 	add.w	r4, r4, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    7306:	4f12      	ldr	r7, [pc, #72]	; (7350 <rx_queue_transfer+0x5c>)
    7308:	eb06 1640 	add.w	r6, r6, r0, lsl #5
{
    730c:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
    730e:	f8c5 218c 	str.w	r2, [r5, #396]	; 0x18c
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    7312:	4621      	mov	r1, r4
    7314:	883a      	ldrh	r2, [r7, #0]
    7316:	4630      	mov	r0, r6
    7318:	f7ff ff78 	bl	720c <usb_prepare_transfer>
	arm_dcache_delete(buffer, rx_packet_size);
    731c:	883b      	ldrh	r3, [r7, #0]
	uint32_t end_addr = (uint32_t)addr + size;
    731e:	4423      	add	r3, r4
	asm("dsb");
    7320:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCIMVAC = location;
    7324:	f8c5 4f5c 	str.w	r4, [r5, #3932]	; 0xf5c
		location += 32;
    7328:	3420      	adds	r4, #32
	} while (location < end_addr);
    732a:	42a3      	cmp	r3, r4
    732c:	d8fa      	bhi.n	7324 <rx_queue_transfer+0x30>
	asm("dsb");
    732e:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7332:	f3bf 8f6f 	isb	sy
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    7336:	2003      	movs	r0, #3
    7338:	4631      	mov	r1, r6
    733a:	f7ff ff93 	bl	7264 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    733e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    7342:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
}
    7346:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7348:	20200080 	.word	0x20200080
    734c:	20001f00 	.word	0x20001f00
    7350:	20007704 	.word	0x20007704

00007354 <rx_event>:

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    7354:	4b24      	ldr	r3, [pc, #144]	; (73e8 <rx_event+0x94>)
{
    7356:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    735a:	881c      	ldrh	r4, [r3, #0]
    735c:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    735e:	69c5      	ldr	r5, [r0, #28]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    7360:	f3c3 430e 	ubfx	r3, r3, #16, #15
    7364:	1ae4      	subs	r4, r4, r3
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    7366:	2c00      	cmp	r4, #0
    7368:	dd24      	ble.n	73b4 <rx_event+0x60>
		// received a packet with data
		uint32_t head = rx_head;
    736a:	4920      	ldr	r1, [pc, #128]	; (73ec <rx_event+0x98>)
		if (head != rx_tail) {
    736c:	4820      	ldr	r0, [pc, #128]	; (73f0 <rx_event+0x9c>)
		uint32_t head = rx_head;
    736e:	780a      	ldrb	r2, [r1, #0]
		if (head != rx_tail) {
    7370:	7800      	ldrb	r0, [r0, #0]
		uint32_t head = rx_head;
    7372:	b2d3      	uxtb	r3, r2
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
    7374:	4e1f      	ldr	r6, [pc, #124]	; (73f4 <rx_event+0xa0>)
		if (head != rx_tail) {
    7376:	4282      	cmp	r2, r0
			uint32_t ii = rx_list[head];
    7378:	481f      	ldr	r0, [pc, #124]	; (73f8 <rx_event+0xa4>)
		if (head != rx_tail) {
    737a:	d007      	beq.n	738c <rx_event+0x38>
			uint32_t ii = rx_list[head];
    737c:	f810 8003 	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    7380:	f836 7018 	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    7384:	f5c7 7200 	rsb	r2, r7, #512	; 0x200
    7388:	4294      	cmp	r4, r2
    738a:	d918      	bls.n	73be <rx_event+0x6a>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    738c:	3301      	adds	r3, #1
		rx_index[i] = 0;
    738e:	2200      	movs	r2, #0
		rx_count[i] = len;
    7390:	f826 4015 	strh.w	r4, [r6, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
    7394:	2b08      	cmp	r3, #8
		rx_index[i] = 0;
    7396:	4e19      	ldr	r6, [pc, #100]	; (73fc <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    7398:	bf88      	it	hi
    739a:	4613      	movhi	r3, r2
		rx_index[i] = 0;
    739c:	f826 2015 	strh.w	r2, [r6, r5, lsl #1]
		rx_list[head] = i;
		rx_head = head;
    73a0:	bf98      	it	ls
    73a2:	b2da      	uxtbls	r2, r3
		rx_list[head] = i;
    73a4:	54c5      	strb	r5, [r0, r3]
		rx_available += len;
    73a6:	4b16      	ldr	r3, [pc, #88]	; (7400 <rx_event+0xac>)
		rx_head = head;
    73a8:	700a      	strb	r2, [r1, #0]
		rx_available += len;
    73aa:	681a      	ldr	r2, [r3, #0]
    73ac:	4414      	add	r4, r2
    73ae:	601c      	str	r4, [r3, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    73b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx_queue_transfer(i);
    73b4:	4628      	mov	r0, r5
}
    73b6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_queue_transfer(i);
    73ba:	f7ff bf9b 	b.w	72f4 <rx_queue_transfer>
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    73be:	eb07 2048 	add.w	r0, r7, r8, lsl #9
    73c2:	4910      	ldr	r1, [pc, #64]	; (7404 <rx_event+0xb0>)
    73c4:	4622      	mov	r2, r4
				rx_count[ii] = count + len;
    73c6:	4427      	add	r7, r4
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    73c8:	4408      	add	r0, r1
    73ca:	eb01 2145 	add.w	r1, r1, r5, lsl #9
    73ce:	f7fe ff75 	bl	62bc <memcpy>
				rx_available += len;
    73d2:	4a0b      	ldr	r2, [pc, #44]	; (7400 <rx_event+0xac>)
				rx_queue_transfer(i);
    73d4:	4628      	mov	r0, r5
				rx_count[ii] = count + len;
    73d6:	f826 7018 	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    73da:	6813      	ldr	r3, [r2, #0]
    73dc:	4423      	add	r3, r4
}
    73de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				rx_available += len;
    73e2:	6013      	str	r3, [r2, #0]
				rx_queue_transfer(i);
    73e4:	f7ff bf86 	b.w	72f4 <rx_queue_transfer>
    73e8:	20007704 	.word	0x20007704
    73ec:	20007716 	.word	0x20007716
    73f0:	20007717 	.word	0x20007717
    73f4:	20007520 	.word	0x20007520
    73f8:	20007540 	.word	0x20007540
    73fc:	20007530 	.word	0x20007530
    7400:	2000751c 	.word	0x2000751c
    7404:	20200080 	.word	0x20200080

00007408 <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    7408:	4b1d      	ldr	r3, [pc, #116]	; (7480 <usb_serial_flush_callback+0x78>)
    740a:	781a      	ldrb	r2, [r3, #0]
    740c:	2a00      	cmp	r2, #0
    740e:	d136      	bne.n	747e <usb_serial_flush_callback+0x76>
	if (!usb_configuration) return;
    7410:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    7414:	4a1b      	ldr	r2, [pc, #108]	; (7484 <usb_serial_flush_callback+0x7c>)
    7416:	7812      	ldrb	r2, [r2, #0]
    7418:	b38a      	cbz	r2, 747e <usb_serial_flush_callback+0x76>
{
    741a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_available == 0) return;
    741e:	4d1a      	ldr	r5, [pc, #104]	; (7488 <usb_serial_flush_callback+0x80>)
    7420:	882a      	ldrh	r2, [r5, #0]
    7422:	b352      	cbz	r2, 747a <usb_serial_flush_callback+0x72>
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    7424:	4e19      	ldr	r6, [pc, #100]	; (748c <usb_serial_flush_callback+0x84>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    7426:	f5c2 6800 	rsb	r8, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    742a:	4f19      	ldr	r7, [pc, #100]	; (7490 <usb_serial_flush_callback+0x88>)
    742c:	7832      	ldrb	r2, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    742e:	4c19      	ldr	r4, [pc, #100]	; (7494 <usb_serial_flush_callback+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    7430:	eb07 1742 	add.w	r7, r7, r2, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    7434:	eb04 24c2 	add.w	r4, r4, r2, lsl #11
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7438:	4642      	mov	r2, r8
    743a:	4638      	mov	r0, r7
    743c:	4621      	mov	r1, r4
    743e:	f7ff fee5 	bl	720c <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    7442:	eb04 0208 	add.w	r2, r4, r8
	asm("dsb");
    7446:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    744a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    744e:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    7452:	3420      	adds	r4, #32
	} while (location < end_addr);
    7454:	42a2      	cmp	r2, r4
    7456:	d8fa      	bhi.n	744e <usb_serial_flush_callback+0x46>
	asm("dsb");
    7458:	f3bf 8f4f 	dsb	sy
	asm("isb");
    745c:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    7460:	2004      	movs	r0, #4
    7462:	4639      	mov	r1, r7
    7464:	f7ff feea 	bl	723c <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    7468:	7833      	ldrb	r3, [r6, #0]
    746a:	3301      	adds	r3, #1
    746c:	b2db      	uxtb	r3, r3
    746e:	2b03      	cmp	r3, #3
    7470:	bf88      	it	hi
    7472:	2300      	movhi	r3, #0
    7474:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    7476:	2300      	movs	r3, #0
    7478:	802b      	strh	r3, [r5, #0]
}
    747a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    747e:	4770      	bx	lr
    7480:	2000771b 	.word	0x2000771b
    7484:	2000771d 	.word	0x2000771d
    7488:	20007706 	.word	0x20007706
    748c:	2000771a 	.word	0x2000771a
    7490:	20002000 	.word	0x20002000
    7494:	20201080 	.word	0x20201080

00007498 <usb_serial_write.part.0>:
int usb_serial_write(const void *buffer, uint32_t size)
    7498:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    749c:	b085      	sub	sp, #20
	while (size > 0) {
    749e:	e9cd 1001 	strd	r1, r0, [sp, #4]
    74a2:	2900      	cmp	r1, #0
    74a4:	f000 80bf 	beq.w	7626 <usb_serial_write.part.0+0x18e>
	uint32_t sent=0;
    74a8:	2300      	movs	r3, #0
    74aa:	4c60      	ldr	r4, [pc, #384]	; (762c <usb_serial_write.part.0+0x194>)
    74ac:	f8df 8198 	ldr.w	r8, [pc, #408]	; 7648 <usb_serial_write.part.0+0x1b0>
    74b0:	f8df a198 	ldr.w	sl, [pc, #408]	; 764c <usb_serial_write.part.0+0x1b4>
				wait_begin_at = systick_millis_count;
    74b4:	4f5e      	ldr	r7, [pc, #376]	; (7630 <usb_serial_write.part.0+0x198>)
	uint32_t sent=0;
    74b6:	9300      	str	r3, [sp, #0]
		tx_noautoflush = 1;
    74b8:	2301      	movs	r3, #1
		transfer_t *xfer = tx_transfer + tx_head;
    74ba:	4a5e      	ldr	r2, [pc, #376]	; (7634 <usb_serial_write.part.0+0x19c>)
		tx_noautoflush = 1;
    74bc:	7023      	strb	r3, [r4, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    74be:	4b5e      	ldr	r3, [pc, #376]	; (7638 <usb_serial_write.part.0+0x1a0>)
    74c0:	7819      	ldrb	r1, [r3, #0]
		while (!tx_available) {
    74c2:	f8b8 3000 	ldrh.w	r3, [r8]
		transfer_t *xfer = tx_transfer + tx_head;
    74c6:	eb02 1941 	add.w	r9, r2, r1, lsl #5
		while (!tx_available) {
    74ca:	2b00      	cmp	r3, #0
    74cc:	f040 80a7 	bne.w	761e <usb_serial_write.part.0+0x186>
		uint32_t wait_begin_at=0;
    74d0:	461e      	mov	r6, r3
		int waiting=0;
    74d2:	461d      	mov	r5, r3
			tx_noautoflush = 0;
    74d4:	469b      	mov	fp, r3
			uint32_t status = usb_transfer_status(xfer);
    74d6:	4648      	mov	r0, r9
    74d8:	f7ff fed2 	bl	7280 <usb_transfer_status>
			if (!(status & 0x80)) {
    74dc:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    74e0:	f000 808c 	beq.w	75fc <usb_serial_write.part.0+0x164>
			asm("dsb" ::: "memory");
    74e4:	f3bf 8f4f 	dsb	sy
			if (transmit_previous_timeout) return sent;
    74e8:	f89a 3000 	ldrb.w	r3, [sl]
			tx_noautoflush = 0;
    74ec:	f884 b000 	strb.w	fp, [r4]
			if (!waiting) {
    74f0:	b905      	cbnz	r5, 74f4 <usb_serial_write.part.0+0x5c>
				wait_begin_at = systick_millis_count;
    74f2:	683e      	ldr	r6, [r7, #0]
			if (transmit_previous_timeout) return sent;
    74f4:	2b00      	cmp	r3, #0
    74f6:	d17d      	bne.n	75f4 <usb_serial_write.part.0+0x15c>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    74f8:	683b      	ldr	r3, [r7, #0]
    74fa:	1b9b      	subs	r3, r3, r6
    74fc:	2b78      	cmp	r3, #120	; 0x78
    74fe:	f200 8087 	bhi.w	7610 <usb_serial_write.part.0+0x178>
			if (!usb_configuration) return sent;
    7502:	4b4e      	ldr	r3, [pc, #312]	; (763c <usb_serial_write.part.0+0x1a4>)
    7504:	781b      	ldrb	r3, [r3, #0]
    7506:	2b00      	cmp	r3, #0
    7508:	d074      	beq.n	75f4 <usb_serial_write.part.0+0x15c>
			yield();
    750a:	f000 fa9d 	bl	7a48 <yield>
			tx_noautoflush = 1;
    750e:	2201      	movs	r2, #1
		while (!tx_available) {
    7510:	f8b8 3000 	ldrh.w	r3, [r8]
    7514:	4615      	mov	r5, r2
			tx_noautoflush = 1;
    7516:	7022      	strb	r2, [r4, #0]
		while (!tx_available) {
    7518:	2b00      	cmp	r3, #0
    751a:	d0dc      	beq.n	74d6 <usb_serial_write.part.0+0x3e>
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    751c:	4a46      	ldr	r2, [pc, #280]	; (7638 <usb_serial_write.part.0+0x1a0>)
    751e:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    7522:	7811      	ldrb	r1, [r2, #0]
    7524:	461a      	mov	r2, r3
    7526:	eb00 20c1 	add.w	r0, r0, r1, lsl #11
    752a:	4d45      	ldr	r5, [pc, #276]	; (7640 <usb_serial_write.part.0+0x1a8>)
    752c:	02c9      	lsls	r1, r1, #11
    752e:	4428      	add	r0, r5
		if (size >= tx_available) {
    7530:	9d01      	ldr	r5, [sp, #4]
    7532:	4295      	cmp	r5, r2
    7534:	d217      	bcs.n	7566 <usb_serial_write.part.0+0xce>
			memcpy(txdata, data, size);
    7536:	9303      	str	r3, [sp, #12]
    7538:	e9dd 5101 	ldrd	r5, r1, [sp, #4]
    753c:	462a      	mov	r2, r5
    753e:	f7fe febd 	bl	62bc <memcpy>
			tx_available -= size;
    7542:	9b03      	ldr	r3, [sp, #12]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    7544:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
			tx_available -= size;
    7548:	1b5b      	subs	r3, r3, r5
    754a:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    754e:	4b3d      	ldr	r3, [pc, #244]	; (7644 <usb_serial_write.part.0+0x1ac>)
    7550:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		asm("dsb" ::: "memory");
    7554:	f3bf 8f4f 	dsb	sy
			sent += size;
    7558:	9800      	ldr	r0, [sp, #0]
		tx_noautoflush = 0;
    755a:	2300      	movs	r3, #0
			sent += size;
    755c:	4428      	add	r0, r5
		tx_noautoflush = 0;
    755e:	7023      	strb	r3, [r4, #0]
}
    7560:	b005      	add	sp, #20
    7562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    7566:	4b36      	ldr	r3, [pc, #216]	; (7640 <usb_serial_write.part.0+0x1a8>)
    7568:	18cd      	adds	r5, r1, r3
			memcpy(txdata, data, tx_available);
    756a:	9902      	ldr	r1, [sp, #8]
    756c:	f7fe fea6 	bl	62bc <memcpy>
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    7570:	2300      	movs	r3, #0
    7572:	f44f 6200 	mov.w	r2, #2048	; 0x800
    7576:	4629      	mov	r1, r5
    7578:	4648      	mov	r0, r9
    757a:	f7ff fe47 	bl	720c <usb_prepare_transfer>
	asm("dsb");
    757e:	f3bf 8f4f 	dsb	sy
    7582:	f105 0220 	add.w	r2, r5, #32
	uint32_t end_addr = (uint32_t)addr + size;
    7586:	f505 6300 	add.w	r3, r5, #2048	; 0x800
    758a:	4293      	cmp	r3, r2
    758c:	bf34      	ite	cc
    758e:	2301      	movcc	r3, #1
    7590:	2340      	movcs	r3, #64	; 0x40
		SCB_CACHE_DCCIMVAC = location;
    7592:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    7596:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    759a:	f8c2 5f70 	str.w	r5, [r2, #3952]	; 0xf70
		location += 32;
    759e:	3520      	adds	r5, #32
	} while (location < end_addr);
    75a0:	42ab      	cmp	r3, r5
    75a2:	d1fa      	bne.n	759a <usb_serial_write.part.0+0x102>
	asm("dsb");
    75a4:	f3bf 8f4f 	dsb	sy
	asm("isb");
    75a8:	f3bf 8f6f 	isb	sy
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    75ac:	2004      	movs	r0, #4
    75ae:	4649      	mov	r1, r9
    75b0:	f7ff fe44 	bl	723c <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    75b4:	4a20      	ldr	r2, [pc, #128]	; (7638 <usb_serial_write.part.0+0x1a0>)
    75b6:	7813      	ldrb	r3, [r2, #0]
    75b8:	3301      	adds	r3, #1
    75ba:	b2db      	uxtb	r3, r3
    75bc:	2b03      	cmp	r3, #3
    75be:	bf84      	itt	hi
    75c0:	2300      	movhi	r3, #0
    75c2:	4a1d      	ldrhi	r2, [pc, #116]	; (7638 <usb_serial_write.part.0+0x1a0>)
    75c4:	7013      	strb	r3, [r2, #0]
			size -= tx_available;
    75c6:	f8b8 3000 	ldrh.w	r3, [r8]
    75ca:	9a01      	ldr	r2, [sp, #4]
    75cc:	1ad1      	subs	r1, r2, r3
			sent += tx_available;
    75ce:	9a00      	ldr	r2, [sp, #0]
    75d0:	441a      	add	r2, r3
			size -= tx_available;
    75d2:	9101      	str	r1, [sp, #4]
			sent += tx_available;
    75d4:	9200      	str	r2, [sp, #0]
			data += tx_available;
    75d6:	9a02      	ldr	r2, [sp, #8]
    75d8:	441a      	add	r2, r3
			tx_available = 0;
    75da:	2300      	movs	r3, #0
			data += tx_available;
    75dc:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = 0;
    75de:	4a19      	ldr	r2, [pc, #100]	; (7644 <usb_serial_write.part.0+0x1ac>)
			tx_available = 0;
    75e0:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = 0;
    75e4:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
		asm("dsb" ::: "memory");
    75e8:	f3bf 8f4f 	dsb	sy
		tx_noautoflush = 0;
    75ec:	7023      	strb	r3, [r4, #0]
	while (size > 0) {
    75ee:	2900      	cmp	r1, #0
    75f0:	f47f af62 	bne.w	74b8 <usb_serial_write.part.0+0x20>
	return sent;
    75f4:	9800      	ldr	r0, [sp, #0]
}
    75f6:	b005      	add	sp, #20
    75f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tx_available = TX_SIZE;
    75fc:	f44f 6200 	mov.w	r2, #2048	; 0x800
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7600:	4b0d      	ldr	r3, [pc, #52]	; (7638 <usb_serial_write.part.0+0x1a0>)
				transmit_previous_timeout = 0;
    7602:	f88a 0000 	strb.w	r0, [sl]
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    7606:	7819      	ldrb	r1, [r3, #0]
				break;
    7608:	4613      	mov	r3, r2
				tx_available = TX_SIZE;
    760a:	f8a8 2000 	strh.w	r2, [r8]
				break;
    760e:	e78a      	b.n	7526 <usb_serial_write.part.0+0x8e>
				transmit_previous_timeout = 1;
    7610:	2301      	movs	r3, #1
				return sent;
    7612:	9800      	ldr	r0, [sp, #0]
				transmit_previous_timeout = 1;
    7614:	f88a 3000 	strb.w	r3, [sl]
}
    7618:	b005      	add	sp, #20
    761a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    761e:	461a      	mov	r2, r3
    7620:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    7624:	e77f      	b.n	7526 <usb_serial_write.part.0+0x8e>
	while (size > 0) {
    7626:	9801      	ldr	r0, [sp, #4]
	return sent;
    7628:	e7e5      	b.n	75f6 <usb_serial_write.part.0+0x15e>
    762a:	bf00      	nop
    762c:	2000771b 	.word	0x2000771b
    7630:	200075a8 	.word	0x200075a8
    7634:	20002000 	.word	0x20002000
    7638:	2000771a 	.word	0x2000771a
    763c:	2000771d 	.word	0x2000771d
    7640:	20201080 	.word	0x20201080
    7644:	402e0000 	.word	0x402e0000
    7648:	20007706 	.word	0x20007706
    764c:	20007719 	.word	0x20007719

00007650 <usb_serial_reset>:
}
    7650:	4770      	bx	lr
    7652:	bf00      	nop

00007654 <usb_serial_configure>:
	if (usb_high_speed) {
    7654:	4b2d      	ldr	r3, [pc, #180]	; (770c <usb_serial_configure+0xb8>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
    7656:	2100      	movs	r1, #0
    7658:	2280      	movs	r2, #128	; 0x80
    765a:	482d      	ldr	r0, [pc, #180]	; (7710 <usb_serial_configure+0xbc>)
{
    765c:	b570      	push	{r4, r5, r6, lr}
	if (usb_high_speed) {
    765e:	781b      	ldrb	r3, [r3, #0]
	tx_head = 0;
    7660:	2400      	movs	r4, #0
		tx_packet_size = CDC_TX_SIZE_480;
    7662:	4d2c      	ldr	r5, [pc, #176]	; (7714 <usb_serial_configure+0xc0>)
	if (usb_high_speed) {
    7664:	428b      	cmp	r3, r1
		rx_packet_size = CDC_RX_SIZE_480;
    7666:	4e2c      	ldr	r6, [pc, #176]	; (7718 <usb_serial_configure+0xc4>)
	if (usb_high_speed) {
    7668:	bf0c      	ite	eq
    766a:	2340      	moveq	r3, #64	; 0x40
    766c:	f44f 7300 	movne.w	r3, #512	; 0x200
		tx_packet_size = CDC_TX_SIZE_480;
    7670:	802b      	strh	r3, [r5, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    7672:	8033      	strh	r3, [r6, #0]
	memset(tx_transfer, 0, sizeof(tx_transfer));
    7674:	f001 f91a 	bl	88ac <memset>
	tx_head = 0;
    7678:	4a28      	ldr	r2, [pc, #160]	; (771c <usb_serial_configure+0xc8>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    767a:	4621      	mov	r1, r4
	tx_available = 0;
    767c:	4b28      	ldr	r3, [pc, #160]	; (7720 <usb_serial_configure+0xcc>)
	tx_head = 0;
    767e:	7014      	strb	r4, [r2, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    7680:	f44f 7280 	mov.w	r2, #256	; 0x100
    7684:	4827      	ldr	r0, [pc, #156]	; (7724 <usb_serial_configure+0xd0>)
	tx_available = 0;
    7686:	801c      	strh	r4, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    7688:	f001 f910 	bl	88ac <memset>
	memset(rx_count, 0, sizeof(rx_count));
    768c:	4a26      	ldr	r2, [pc, #152]	; (7728 <usb_serial_configure+0xd4>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    768e:	2110      	movs	r1, #16
	memset(rx_index, 0, sizeof(rx_index));
    7690:	4b26      	ldr	r3, [pc, #152]	; (772c <usb_serial_configure+0xd8>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    7692:	2002      	movs	r0, #2
	memset(rx_count, 0, sizeof(rx_count));
    7694:	e9c2 4400 	strd	r4, r4, [r2]
    7698:	e9c2 4402 	strd	r4, r4, [r2, #8]
	rx_head = 0;
    769c:	4a24      	ldr	r2, [pc, #144]	; (7730 <usb_serial_configure+0xdc>)
	memset(rx_index, 0, sizeof(rx_index));
    769e:	e9c3 4400 	strd	r4, r4, [r3]
	rx_head = 0;
    76a2:	7014      	strb	r4, [r2, #0]
	rx_available = 0;
    76a4:	4a23      	ldr	r2, [pc, #140]	; (7734 <usb_serial_configure+0xe0>)
	memset(rx_index, 0, sizeof(rx_index));
    76a6:	e9c3 4402 	strd	r4, r4, [r3, #8]
	rx_tail = 0;
    76aa:	4b23      	ldr	r3, [pc, #140]	; (7738 <usb_serial_configure+0xe4>)
    76ac:	701c      	strb	r4, [r3, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    76ae:	4623      	mov	r3, r4
	rx_available = 0;
    76b0:	6014      	str	r4, [r2, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    76b2:	4622      	mov	r2, r4
    76b4:	f7ff fd78 	bl	71a8 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    76b8:	4622      	mov	r2, r4
    76ba:	8831      	ldrh	r1, [r6, #0]
    76bc:	2003      	movs	r0, #3
    76be:	4b1f      	ldr	r3, [pc, #124]	; (773c <usb_serial_configure+0xe8>)
    76c0:	f7ff fd40 	bl	7144 <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    76c4:	4623      	mov	r3, r4
    76c6:	2201      	movs	r2, #1
    76c8:	8829      	ldrh	r1, [r5, #0]
    76ca:	2004      	movs	r0, #4
    76cc:	f7ff fd6c 	bl	71a8 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    76d0:	4620      	mov	r0, r4
    76d2:	3401      	adds	r4, #1
    76d4:	f7ff fe0e 	bl	72f4 <rx_queue_transfer>
    76d8:	2c08      	cmp	r4, #8
    76da:	d1f9      	bne.n	76d0 <usb_serial_configure+0x7c>
	USB1_GPTIMER0CTRL = 0;
    76dc:	4b18      	ldr	r3, [pc, #96]	; (7740 <usb_serial_configure+0xec>)
    76de:	2100      	movs	r1, #0
	USB1_GPTIMER0LD = microseconds - 1;
    76e0:	224a      	movs	r2, #74	; 0x4a
	usb_timer0_callback = callback;
    76e2:	4818      	ldr	r0, [pc, #96]	; (7744 <usb_serial_configure+0xf0>)
    76e4:	4c18      	ldr	r4, [pc, #96]	; (7748 <usb_serial_configure+0xf4>)
    76e6:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    76e8:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    76ec:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    76f0:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
	if (serialEvent) yield_active_check_flags |= YIELD_CHECK_USB_SERIAL;
    76f4:	4915      	ldr	r1, [pc, #84]	; (774c <usb_serial_configure+0xf8>)
	USB1_USBINTR |= USB_USBINTR_TIE0;
    76f6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    76fa:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if (serialEvent) yield_active_check_flags |= YIELD_CHECK_USB_SERIAL;
    76fe:	b121      	cbz	r1, 770a <usb_serial_configure+0xb6>
    7700:	4a13      	ldr	r2, [pc, #76]	; (7750 <usb_serial_configure+0xfc>)
    7702:	7813      	ldrb	r3, [r2, #0]
    7704:	f043 0301 	orr.w	r3, r3, #1
    7708:	7013      	strb	r3, [r2, #0]
}
    770a:	bd70      	pop	{r4, r5, r6, pc}
    770c:	2000771e 	.word	0x2000771e
    7710:	20002000 	.word	0x20002000
    7714:	20007708 	.word	0x20007708
    7718:	20007704 	.word	0x20007704
    771c:	2000771a 	.word	0x2000771a
    7720:	20007706 	.word	0x20007706
    7724:	20001f00 	.word	0x20001f00
    7728:	20007520 	.word	0x20007520
    772c:	20007530 	.word	0x20007530
    7730:	20007716 	.word	0x20007716
    7734:	2000751c 	.word	0x2000751c
    7738:	20007717 	.word	0x20007717
    773c:	00007355 	.word	0x00007355
    7740:	402e0000 	.word	0x402e0000
    7744:	200076fc 	.word	0x200076fc
    7748:	00007409 	.word	0x00007409
    774c:	00000000 	.word	0x00000000
    7750:	20007721 	.word	0x20007721

00007754 <usb_serial_read>:
{
    7754:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
    7758:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    775c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	uint32_t tail = rx_tail;
    7760:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 782c <usb_serial_read+0xd8>
{
    7764:	b083      	sub	sp, #12
	NVIC_DISABLE_IRQ(IRQ_USB1);
    7766:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	while (count < size && tail != rx_head) {
    776a:	468b      	mov	fp, r1
	uint32_t tail = rx_tail;
    776c:	f89a 4000 	ldrb.w	r4, [sl]
	while (count < size && tail != rx_head) {
    7770:	2900      	cmp	r1, #0
    7772:	d04f      	beq.n	7814 <usb_serial_read+0xc0>
    7774:	4680      	mov	r8, r0
    7776:	b2e4      	uxtb	r4, r4
	uint32_t count=0;
    7778:	2700      	movs	r7, #0
		uint32_t avail = rx_count[i] - rx_index[i];
    777a:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 7830 <usb_serial_read+0xdc>
	while (count < size && tail != rx_head) {
    777e:	4b26      	ldr	r3, [pc, #152]	; (7818 <usb_serial_read+0xc4>)
		uint32_t len = size - count;
    7780:	ebab 0207 	sub.w	r2, fp, r7
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    7784:	4925      	ldr	r1, [pc, #148]	; (781c <usb_serial_read+0xc8>)
	while (count < size && tail != rx_head) {
    7786:	781b      	ldrb	r3, [r3, #0]
    7788:	42a3      	cmp	r3, r4
		if (++tail > RX_NUM) tail = 0;
    778a:	f104 0401 	add.w	r4, r4, #1
	while (count < size && tail != rx_head) {
    778e:	d03f      	beq.n	7810 <usb_serial_read+0xbc>
		if (++tail > RX_NUM) tail = 0;
    7790:	2c09      	cmp	r4, #9
		uint32_t i = rx_list[tail];
    7792:	4b23      	ldr	r3, [pc, #140]	; (7820 <usb_serial_read+0xcc>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    7794:	4640      	mov	r0, r8
		if (++tail > RX_NUM) tail = 0;
    7796:	bf28      	it	cs
    7798:	2400      	movcs	r4, #0
		uint32_t i = rx_list[tail];
    779a:	5d1e      	ldrb	r6, [r3, r4]
		uint32_t avail = rx_count[i] - rx_index[i];
    779c:	f839 c016 	ldrh.w	ip, [r9, r6, lsl #1]
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    77a0:	eb0c 2346 	add.w	r3, ip, r6, lsl #9
    77a4:	4419      	add	r1, r3
		uint32_t avail = rx_count[i] - rx_index[i];
    77a6:	4b1f      	ldr	r3, [pc, #124]	; (7824 <usb_serial_read+0xd0>)
    77a8:	f833 5016 	ldrh.w	r5, [r3, r6, lsl #1]
    77ac:	eba5 050c 	sub.w	r5, r5, ip
		if (avail > len) {
    77b0:	42aa      	cmp	r2, r5
    77b2:	d21c      	bcs.n	77ee <usb_serial_read+0x9a>
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    77b4:	eb0c 2c46 	add.w	ip, ip, r6, lsl #9
    77b8:	4918      	ldr	r1, [pc, #96]	; (781c <usb_serial_read+0xc8>)
			rx_available -= len;
    77ba:	4c1b      	ldr	r4, [pc, #108]	; (7828 <usb_serial_read+0xd4>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    77bc:	4461      	add	r1, ip
    77be:	9201      	str	r2, [sp, #4]
    77c0:	f7fe fd7c 	bl	62bc <memcpy>
			rx_available -= len;
    77c4:	6821      	ldr	r1, [r4, #0]
			rx_index[i] += len;
    77c6:	f839 5016 	ldrh.w	r5, [r9, r6, lsl #1]
	return count;
    77ca:	4658      	mov	r0, fp
			rx_index[i] += len;
    77cc:	9a01      	ldr	r2, [sp, #4]
			rx_available -= len;
    77ce:	eba1 010b 	sub.w	r1, r1, fp
			rx_index[i] += len;
    77d2:	442a      	add	r2, r5
			rx_available -= len;
    77d4:	4439      	add	r1, r7
			rx_index[i] += len;
    77d6:	f829 2016 	strh.w	r2, [r9, r6, lsl #1]
			rx_available -= len;
    77da:	6021      	str	r1, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
    77dc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    77e0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    77e4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
}
    77e8:	b003      	add	sp, #12
    77ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    77ee:	462a      	mov	r2, r5
			count += avail;
    77f0:	442f      	add	r7, r5
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    77f2:	f7fe fd63 	bl	62bc <memcpy>
			rx_available -= avail;
    77f6:	490c      	ldr	r1, [pc, #48]	; (7828 <usb_serial_read+0xd4>)
			rx_tail = tail;
    77f8:	b2e3      	uxtb	r3, r4
			rx_queue_transfer(i);
    77fa:	4630      	mov	r0, r6
			rx_available -= avail;
    77fc:	680a      	ldr	r2, [r1, #0]
			p += avail;
    77fe:	44a8      	add	r8, r5
			rx_available -= avail;
    7800:	1b52      	subs	r2, r2, r5
    7802:	600a      	str	r2, [r1, #0]
			rx_tail = tail;
    7804:	f88a 3000 	strb.w	r3, [sl]
			rx_queue_transfer(i);
    7808:	f7ff fd74 	bl	72f4 <rx_queue_transfer>
	while (count < size && tail != rx_head) {
    780c:	45bb      	cmp	fp, r7
    780e:	d8b6      	bhi.n	777e <usb_serial_read+0x2a>
	return count;
    7810:	4638      	mov	r0, r7
    7812:	e7e3      	b.n	77dc <usb_serial_read+0x88>
	while (count < size && tail != rx_head) {
    7814:	4608      	mov	r0, r1
    7816:	e7e1      	b.n	77dc <usb_serial_read+0x88>
    7818:	20007716 	.word	0x20007716
    781c:	20200080 	.word	0x20200080
    7820:	20007540 	.word	0x20007540
    7824:	20007520 	.word	0x20007520
    7828:	2000751c 	.word	0x2000751c
    782c:	20007717 	.word	0x20007717
    7830:	20007530 	.word	0x20007530

00007834 <usb_serial_peekchar>:
	if (tail == rx_head) return -1;
    7834:	4b0b      	ldr	r3, [pc, #44]	; (7864 <usb_serial_peekchar+0x30>)
	uint32_t tail = rx_tail;
    7836:	4a0c      	ldr	r2, [pc, #48]	; (7868 <usb_serial_peekchar+0x34>)
    7838:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) return -1;
    783a:	7819      	ldrb	r1, [r3, #0]
	uint32_t tail = rx_tail;
    783c:	b2d3      	uxtb	r3, r2
	if (tail == rx_head) return -1;
    783e:	428a      	cmp	r2, r1
    7840:	d00d      	beq.n	785e <usb_serial_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    7842:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    7844:	4809      	ldr	r0, [pc, #36]	; (786c <usb_serial_peekchar+0x38>)
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7846:	4a0a      	ldr	r2, [pc, #40]	; (7870 <usb_serial_peekchar+0x3c>)
	if (++tail > RX_NUM) tail = 0;
    7848:	2b09      	cmp	r3, #9
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    784a:	490a      	ldr	r1, [pc, #40]	; (7874 <usb_serial_peekchar+0x40>)
	if (++tail > RX_NUM) tail = 0;
    784c:	bf28      	it	cs
    784e:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    7850:	5cc3      	ldrb	r3, [r0, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7852:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
    7856:	eb02 2343 	add.w	r3, r2, r3, lsl #9
    785a:	5c58      	ldrb	r0, [r3, r1]
    785c:	4770      	bx	lr
	if (tail == rx_head) return -1;
    785e:	f04f 30ff 	mov.w	r0, #4294967295
}
    7862:	4770      	bx	lr
    7864:	20007716 	.word	0x20007716
    7868:	20007717 	.word	0x20007717
    786c:	20007540 	.word	0x20007540
    7870:	20200080 	.word	0x20200080
    7874:	20007530 	.word	0x20007530

00007878 <usb_serial_available>:
	uint32_t n = rx_available;
    7878:	4b04      	ldr	r3, [pc, #16]	; (788c <usb_serial_available+0x14>)
{
    787a:	b510      	push	{r4, lr}
	uint32_t n = rx_available;
    787c:	681c      	ldr	r4, [r3, #0]
	if (n == 0) yield();
    787e:	b10c      	cbz	r4, 7884 <usb_serial_available+0xc>
}
    7880:	4620      	mov	r0, r4
    7882:	bd10      	pop	{r4, pc}
	if (n == 0) yield();
    7884:	f000 f8e0 	bl	7a48 <yield>
}
    7888:	4620      	mov	r0, r4
    788a:	bd10      	pop	{r4, pc}
    788c:	2000751c 	.word	0x2000751c

00007890 <usb_serial_flush_input>:
{
    7890:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t tail = rx_tail;
    7894:	4e14      	ldr	r6, [pc, #80]	; (78e8 <usb_serial_flush_input+0x58>)
	while (tail != rx_head) {
    7896:	4d15      	ldr	r5, [pc, #84]	; (78ec <usb_serial_flush_input+0x5c>)
	uint32_t tail = rx_tail;
    7898:	7833      	ldrb	r3, [r6, #0]
	while (tail != rx_head) {
    789a:	782a      	ldrb	r2, [r5, #0]
    789c:	4293      	cmp	r3, r2
    789e:	d021      	beq.n	78e4 <usb_serial_flush_input+0x54>
    78a0:	b2dc      	uxtb	r4, r3
    78a2:	f8df 9050 	ldr.w	r9, [pc, #80]	; 78f4 <usb_serial_flush_input+0x64>
    78a6:	f8df b050 	ldr.w	fp, [pc, #80]	; 78f8 <usb_serial_flush_input+0x68>
    78aa:	f8df 8050 	ldr.w	r8, [pc, #80]	; 78fc <usb_serial_flush_input+0x6c>
    78ae:	4f10      	ldr	r7, [pc, #64]	; (78f0 <usb_serial_flush_input+0x60>)
		if (++tail > RX_NUM) tail = 0;
    78b0:	3401      	adds	r4, #1
    78b2:	2c08      	cmp	r4, #8
		rx_tail = tail;
    78b4:	fa5f fa84 	uxtb.w	sl, r4
		if (++tail > RX_NUM) tail = 0;
    78b8:	d901      	bls.n	78be <usb_serial_flush_input+0x2e>
    78ba:	2400      	movs	r4, #0
    78bc:	46a2      	mov	sl, r4
		uint32_t i = rx_list[tail];
    78be:	f819 0004 	ldrb.w	r0, [r9, r4]
		rx_available -= rx_count[i] - rx_index[i];
    78c2:	f8db 3000 	ldr.w	r3, [fp]
    78c6:	f838 2010 	ldrh.w	r2, [r8, r0, lsl #1]
    78ca:	f837 1010 	ldrh.w	r1, [r7, r0, lsl #1]
    78ce:	1a52      	subs	r2, r2, r1
    78d0:	1a9b      	subs	r3, r3, r2
    78d2:	f8cb 3000 	str.w	r3, [fp]
		rx_queue_transfer(i);
    78d6:	f7ff fd0d 	bl	72f4 <rx_queue_transfer>
		rx_tail = tail;
    78da:	f886 a000 	strb.w	sl, [r6]
	while (tail != rx_head) {
    78de:	782b      	ldrb	r3, [r5, #0]
    78e0:	42a3      	cmp	r3, r4
    78e2:	d1e5      	bne.n	78b0 <usb_serial_flush_input+0x20>
}
    78e4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    78e8:	20007717 	.word	0x20007717
    78ec:	20007716 	.word	0x20007716
    78f0:	20007530 	.word	0x20007530
    78f4:	20007540 	.word	0x20007540
    78f8:	2000751c 	.word	0x2000751c
    78fc:	20007520 	.word	0x20007520

00007900 <usb_serial_getchar>:
{
    7900:	b500      	push	{lr}
    7902:	b083      	sub	sp, #12
	if (usb_serial_read(&c, 1)) return c;
    7904:	2101      	movs	r1, #1
    7906:	f10d 0007 	add.w	r0, sp, #7
    790a:	f7ff ff23 	bl	7754 <usb_serial_read>
    790e:	b120      	cbz	r0, 791a <usb_serial_getchar+0x1a>
    7910:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
    7914:	b003      	add	sp, #12
    7916:	f85d fb04 	ldr.w	pc, [sp], #4
	return -1;
    791a:	f04f 30ff 	mov.w	r0, #4294967295
    791e:	e7f9      	b.n	7914 <usb_serial_getchar+0x14>

00007920 <usb_serial_putchar>:
	if (!usb_configuration) return 0;
    7920:	4b09      	ldr	r3, [pc, #36]	; (7948 <usb_serial_putchar+0x28>)
{
    7922:	b500      	push	{lr}
    7924:	b083      	sub	sp, #12
	if (!usb_configuration) return 0;
    7926:	781b      	ldrb	r3, [r3, #0]
{
    7928:	f88d 0007 	strb.w	r0, [sp, #7]
	if (!usb_configuration) return 0;
    792c:	b13b      	cbz	r3, 793e <usb_serial_putchar+0x1e>
    792e:	2101      	movs	r1, #1
    7930:	f10d 0007 	add.w	r0, sp, #7
    7934:	f7ff fdb0 	bl	7498 <usb_serial_write.part.0>
}
    7938:	b003      	add	sp, #12
    793a:	f85d fb04 	ldr.w	pc, [sp], #4
    793e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    7942:	b003      	add	sp, #12
    7944:	f85d fb04 	ldr.w	pc, [sp], #4
    7948:	2000771d 	.word	0x2000771d

0000794c <usb_serial_write>:
	if (!usb_configuration) return 0;
    794c:	4b04      	ldr	r3, [pc, #16]	; (7960 <usb_serial_write+0x14>)
    794e:	781b      	ldrb	r3, [r3, #0]
    7950:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    7954:	b10b      	cbz	r3, 795a <usb_serial_write+0xe>
    7956:	f7ff bd9f 	b.w	7498 <usb_serial_write.part.0>
}
    795a:	4610      	mov	r0, r2
    795c:	4770      	bx	lr
    795e:	bf00      	nop
    7960:	2000771d 	.word	0x2000771d

00007964 <usb_serial_write_buffer_free>:
{
    7964:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (uint32_t i=0; i < TX_NUM; i++) {
    7968:	2400      	movs	r4, #0
	tx_noautoflush = 1;
    796a:	f8df 8044 	ldr.w	r8, [pc, #68]	; 79b0 <usb_serial_write_buffer_free+0x4c>
    796e:	2301      	movs	r3, #1
    7970:	4d0d      	ldr	r5, [pc, #52]	; (79a8 <usb_serial_write_buffer_free+0x44>)
	uint32_t sum = 0;
    7972:	4627      	mov	r7, r4
    7974:	4e0d      	ldr	r6, [pc, #52]	; (79ac <usb_serial_write_buffer_free+0x48>)
	tx_noautoflush = 1;
    7976:	f888 3000 	strb.w	r3, [r8]
		if (i == tx_head) continue;
    797a:	7833      	ldrb	r3, [r6, #0]
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    797c:	4628      	mov	r0, r5
	for (uint32_t i=0; i < TX_NUM; i++) {
    797e:	3520      	adds	r5, #32
		if (i == tx_head) continue;
    7980:	42a3      	cmp	r3, r4
	for (uint32_t i=0; i < TX_NUM; i++) {
    7982:	f104 0401 	add.w	r4, r4, #1
		if (i == tx_head) continue;
    7986:	d005      	beq.n	7994 <usb_serial_write_buffer_free+0x30>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    7988:	f7ff fc7a 	bl	7280 <usb_transfer_status>
    798c:	0603      	lsls	r3, r0, #24
    798e:	bf58      	it	pl
    7990:	f507 6700 	addpl.w	r7, r7, #2048	; 0x800
	for (uint32_t i=0; i < TX_NUM; i++) {
    7994:	2c04      	cmp	r4, #4
    7996:	d1f0      	bne.n	797a <usb_serial_write_buffer_free+0x16>
	asm("dsb" ::: "memory");
    7998:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    799c:	2300      	movs	r3, #0
}
    799e:	4638      	mov	r0, r7
	tx_noautoflush = 0;
    79a0:	f888 3000 	strb.w	r3, [r8]
}
    79a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    79a8:	20002000 	.word	0x20002000
    79ac:	2000771a 	.word	0x2000771a
    79b0:	2000771b 	.word	0x2000771b

000079b4 <usb_serial_flush_output>:
{
    79b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!usb_configuration) return;
    79b8:	4b1d      	ldr	r3, [pc, #116]	; (7a30 <usb_serial_flush_output+0x7c>)
    79ba:	781b      	ldrb	r3, [r3, #0]
    79bc:	b113      	cbz	r3, 79c4 <usb_serial_flush_output+0x10>
	if (tx_available == 0) return;
    79be:	4d1d      	ldr	r5, [pc, #116]	; (7a34 <usb_serial_flush_output+0x80>)
    79c0:	882a      	ldrh	r2, [r5, #0]
    79c2:	b90a      	cbnz	r2, 79c8 <usb_serial_flush_output+0x14>
}
    79c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	transfer_t *xfer = tx_transfer + tx_head;
    79c8:	4e1b      	ldr	r6, [pc, #108]	; (7a38 <usb_serial_flush_output+0x84>)
	uint32_t txnum = TX_SIZE - tx_available;
    79ca:	f5c2 6900 	rsb	r9, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    79ce:	491b      	ldr	r1, [pc, #108]	; (7a3c <usb_serial_flush_output+0x88>)
    79d0:	7833      	ldrb	r3, [r6, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    79d2:	464a      	mov	r2, r9
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    79d4:	4c1a      	ldr	r4, [pc, #104]	; (7a40 <usb_serial_flush_output+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    79d6:	eb01 1843 	add.w	r8, r1, r3, lsl #5
	tx_noautoflush = 1;
    79da:	4f1a      	ldr	r7, [pc, #104]	; (7a44 <usb_serial_flush_output+0x90>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    79dc:	eb04 24c3 	add.w	r4, r4, r3, lsl #11
	tx_noautoflush = 1;
    79e0:	2301      	movs	r3, #1
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    79e2:	4640      	mov	r0, r8
	tx_noautoflush = 1;
    79e4:	703b      	strb	r3, [r7, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    79e6:	4621      	mov	r1, r4
    79e8:	2300      	movs	r3, #0
    79ea:	f7ff fc0f 	bl	720c <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    79ee:	eb04 0209 	add.w	r2, r4, r9
	asm("dsb");
    79f2:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    79f6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    79fa:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    79fe:	3420      	adds	r4, #32
	} while (location < end_addr);
    7a00:	42a2      	cmp	r2, r4
    7a02:	d8fa      	bhi.n	79fa <usb_serial_flush_output+0x46>
	asm("dsb");
    7a04:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7a08:	f3bf 8f6f 	isb	sy
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    7a0c:	2004      	movs	r0, #4
    7a0e:	4641      	mov	r1, r8
    7a10:	f7ff fc14 	bl	723c <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    7a14:	7833      	ldrb	r3, [r6, #0]
    7a16:	3301      	adds	r3, #1
    7a18:	b2db      	uxtb	r3, r3
    7a1a:	2b03      	cmp	r3, #3
    7a1c:	bf88      	it	hi
    7a1e:	2300      	movhi	r3, #0
    7a20:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    7a22:	2300      	movs	r3, #0
    7a24:	802b      	strh	r3, [r5, #0]
	asm("dsb" ::: "memory");
    7a26:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    7a2a:	703b      	strb	r3, [r7, #0]
}
    7a2c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7a30:	2000771d 	.word	0x2000771d
    7a34:	20007706 	.word	0x20007706
    7a38:	2000771a 	.word	0x2000771a
    7a3c:	20002000 	.word	0x20002000
    7a40:	20201080 	.word	0x20201080
    7a44:	2000771b 	.word	0x2000771b

00007a48 <yield>:
uint8_t yield_active_check_flags = 0;


void yield(void) __attribute__ ((weak));
void yield(void)
{
    7a48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const uint8_t check_flags = yield_active_check_flags;
    7a4c:	4b2d      	ldr	r3, [pc, #180]	; (7b04 <yield+0xbc>)
    7a4e:	781e      	ldrb	r6, [r3, #0]
	if (!check_flags) return;	// nothing to do
    7a50:	b166      	cbz	r6, 7a6c <yield+0x24>

	// TODO: do nothing if called from interrupt

	static uint8_t running=0;
	if (running) return; // TODO: does this need to be atomic?
    7a52:	4f2d      	ldr	r7, [pc, #180]	; (7b08 <yield+0xc0>)
    7a54:	783b      	ldrb	r3, [r7, #0]
    7a56:	b94b      	cbnz	r3, 7a6c <yield+0x24>
	running = 1;
    7a58:	2301      	movs	r3, #1

	// USB Serial - Add hack to minimize impact...
	if (check_flags & YIELD_CHECK_USB_SERIAL) {
    7a5a:	07f1      	lsls	r1, r6, #31
	running = 1;
    7a5c:	703b      	strb	r3, [r7, #0]
	if (check_flags & YIELD_CHECK_USB_SERIAL) {
    7a5e:	d443      	bmi.n	7ae8 <yield+0xa0>
		if (SerialUSB2.available()) serialEventUSB2();
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    7a60:	07b2      	lsls	r2, r6, #30
    7a62:	d426      	bmi.n	7ab2 <yield+0x6a>
		HardwareSerialIMXRT::processSerialEventsList();
	}

	running = 0;
    7a64:	2300      	movs	r3, #0
    7a66:	703b      	strb	r3, [r7, #0]
	if (check_flags & YIELD_CHECK_EVENT_RESPONDER) {
    7a68:	0773      	lsls	r3, r6, #29
    7a6a:	d401      	bmi.n	7a70 <yield+0x28>
		EventResponder::runFromYield();
	}
};
    7a6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (!firstYield) return;  
    7a70:	4b26      	ldr	r3, [pc, #152]	; (7b0c <yield+0xc4>)
    7a72:	681a      	ldr	r2, [r3, #0]
    7a74:	2a00      	cmp	r2, #0
    7a76:	d0f9      	beq.n	7a6c <yield+0x24>
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    7a78:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    7a7c:	2a00      	cmp	r2, #0
    7a7e:	d1f5      	bne.n	7a6c <yield+0x24>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    7a80:	f3ef 8510 	mrs	r5, PRIMASK
		__disable_irq();
    7a84:	b672      	cpsid	i
		EventResponder *first = firstYield;
    7a86:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    7a88:	2800      	cmp	r0, #0
    7a8a:	d034      	beq.n	7af6 <yield+0xae>
		if (runningFromYield) {
    7a8c:	4c20      	ldr	r4, [pc, #128]	; (7b10 <yield+0xc8>)
    7a8e:	7821      	ldrb	r1, [r4, #0]
    7a90:	2900      	cmp	r1, #0
    7a92:	d130      	bne.n	7af6 <yield+0xae>
		runningFromYield = true;
    7a94:	2201      	movs	r2, #1
    7a96:	7022      	strb	r2, [r4, #0]
		firstYield = first->_next;
    7a98:	6942      	ldr	r2, [r0, #20]
    7a9a:	601a      	str	r2, [r3, #0]
		if (firstYield) {
    7a9c:	2a00      	cmp	r2, #0
    7a9e:	d02e      	beq.n	7afe <yield+0xb6>
			firstYield->_prev = nullptr;
    7aa0:	6191      	str	r1, [r2, #24]
		if (doit) __enable_irq();
    7aa2:	b905      	cbnz	r5, 7aa6 <yield+0x5e>
    7aa4:	b662      	cpsie	i
		first->_triggered = false;
    7aa6:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    7aa8:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
    7aaa:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    7aac:	4798      	blx	r3
		runningFromYield = false;
    7aae:	7025      	strb	r5, [r4, #0]
    7ab0:	e7dc      	b.n	7a6c <yield+0x24>

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7ab2:	f8df 8064 	ldr.w	r8, [pc, #100]	; 7b18 <yield+0xd0>
    7ab6:	f898 3000 	ldrb.w	r3, [r8]
    7aba:	2b00      	cmp	r3, #0
    7abc:	d0d2      	beq.n	7a64 <yield+0x1c>
    7abe:	2500      	movs	r5, #0
    7ac0:	f8df 9058 	ldr.w	r9, [pc, #88]	; 7b1c <yield+0xd4>
    7ac4:	462b      	mov	r3, r5
			s_serials_with_serial_events[i]->doYieldCode();
    7ac6:	f859 4023 	ldr.w	r4, [r9, r3, lsl #2]
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7aca:	3501      	adds	r5, #1
	static HardwareSerialIMXRT 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    7acc:	6823      	ldr	r3, [r4, #0]
    7ace:	4620      	mov	r0, r4
    7ad0:	691b      	ldr	r3, [r3, #16]
    7ad2:	4798      	blx	r3
    7ad4:	b110      	cbz	r0, 7adc <yield+0x94>
    7ad6:	6963      	ldr	r3, [r4, #20]
    7ad8:	689b      	ldr	r3, [r3, #8]
    7ada:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7adc:	f898 2000 	ldrb.w	r2, [r8]
    7ae0:	b2eb      	uxtb	r3, r5
    7ae2:	429a      	cmp	r2, r3
    7ae4:	d8ef      	bhi.n	7ac6 <yield+0x7e>
    7ae6:	e7bd      	b.n	7a64 <yield+0x1c>
        virtual int available() { return usb_serial_available(); }
    7ae8:	f7ff fec6 	bl	7878 <usb_serial_available>
		if (Serial.available()) serialEvent();
    7aec:	2800      	cmp	r0, #0
    7aee:	d0b7      	beq.n	7a60 <yield+0x18>
    7af0:	f3af 8000 	nop.w
    7af4:	e7b4      	b.n	7a60 <yield+0x18>
		if (doit) __enable_irq();
    7af6:	2d00      	cmp	r5, #0
    7af8:	d1b8      	bne.n	7a6c <yield+0x24>
    7afa:	b662      	cpsie	i
    7afc:	e7b6      	b.n	7a6c <yield+0x24>
			lastYield = nullptr;
    7afe:	4b05      	ldr	r3, [pc, #20]	; (7b14 <yield+0xcc>)
    7b00:	601a      	str	r2, [r3, #0]
    7b02:	e7ce      	b.n	7aa2 <yield+0x5a>
    7b04:	20007721 	.word	0x20007721
    7b08:	2000770c 	.word	0x2000770c
    7b0c:	20007328 	.word	0x20007328
    7b10:	2000770a 	.word	0x2000770a
    7b14:	20007334 	.word	0x20007334
    7b18:	2000770b 	.word	0x2000770b
    7b1c:	20007338 	.word	0x20007338

00007b20 <rtc_get>:
	uint32_t hi1 = SNVS_HPRTCMR;
    7b20:	4a07      	ldr	r2, [pc, #28]	; (7b40 <rtc_get+0x20>)
    7b22:	6a50      	ldr	r0, [r2, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
    7b24:	6a93      	ldr	r3, [r2, #40]	; 0x28
		uint32_t hi2 = SNVS_HPRTCMR;
    7b26:	4619      	mov	r1, r3
    7b28:	4684      	mov	ip, r0
    7b2a:	6a50      	ldr	r0, [r2, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    7b2c:	6a93      	ldr	r3, [r2, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    7b2e:	4299      	cmp	r1, r3
    7b30:	d1f9      	bne.n	7b26 <rtc_get+0x6>
    7b32:	4584      	cmp	ip, r0
    7b34:	d1f7      	bne.n	7b26 <rtc_get+0x6>
			return (hi2 << 17) | (lo2 >> 15);
    7b36:	0bdb      	lsrs	r3, r3, #15
}
    7b38:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
    7b3c:	4770      	bx	lr
    7b3e:	bf00      	nop
    7b40:	400d4000 	.word	0x400d4000

00007b44 <_malloc_r>:
    7b44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7b48:	f101 060b 	add.w	r6, r1, #11
    7b4c:	2e16      	cmp	r6, #22
    7b4e:	b083      	sub	sp, #12
    7b50:	4604      	mov	r4, r0
    7b52:	d824      	bhi.n	7b9e <_malloc_r+0x5a>
    7b54:	2910      	cmp	r1, #16
    7b56:	f200 80ba 	bhi.w	7cce <_malloc_r+0x18a>
    7b5a:	f000 faa3 	bl	80a4 <__malloc_lock>
    7b5e:	2610      	movs	r6, #16
    7b60:	2218      	movs	r2, #24
    7b62:	2002      	movs	r0, #2
    7b64:	4fb5      	ldr	r7, [pc, #724]	; (7e3c <_malloc_r+0x2f8>)
    7b66:	443a      	add	r2, r7
    7b68:	f1a2 0108 	sub.w	r1, r2, #8
    7b6c:	6853      	ldr	r3, [r2, #4]
    7b6e:	428b      	cmp	r3, r1
    7b70:	f000 80ba 	beq.w	7ce8 <_malloc_r+0x1a4>
    7b74:	685a      	ldr	r2, [r3, #4]
    7b76:	68d9      	ldr	r1, [r3, #12]
    7b78:	f022 0203 	bic.w	r2, r2, #3
    7b7c:	441a      	add	r2, r3
    7b7e:	689d      	ldr	r5, [r3, #8]
    7b80:	60e9      	str	r1, [r5, #12]
    7b82:	608d      	str	r5, [r1, #8]
    7b84:	6851      	ldr	r1, [r2, #4]
    7b86:	f041 0101 	orr.w	r1, r1, #1
    7b8a:	4620      	mov	r0, r4
    7b8c:	6051      	str	r1, [r2, #4]
    7b8e:	f103 0508 	add.w	r5, r3, #8
    7b92:	f000 fa8d 	bl	80b0 <__malloc_unlock>
    7b96:	4628      	mov	r0, r5
    7b98:	b003      	add	sp, #12
    7b9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7b9e:	f036 0607 	bics.w	r6, r6, #7
    7ba2:	f100 8094 	bmi.w	7cce <_malloc_r+0x18a>
    7ba6:	42b1      	cmp	r1, r6
    7ba8:	f200 8091 	bhi.w	7cce <_malloc_r+0x18a>
    7bac:	f000 fa7a 	bl	80a4 <__malloc_lock>
    7bb0:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
    7bb4:	f0c0 819a 	bcc.w	7eec <_malloc_r+0x3a8>
    7bb8:	0a73      	lsrs	r3, r6, #9
    7bba:	f000 808f 	beq.w	7cdc <_malloc_r+0x198>
    7bbe:	2b04      	cmp	r3, #4
    7bc0:	f200 816f 	bhi.w	7ea2 <_malloc_r+0x35e>
    7bc4:	09b3      	lsrs	r3, r6, #6
    7bc6:	f103 0039 	add.w	r0, r3, #57	; 0x39
    7bca:	f103 0c38 	add.w	ip, r3, #56	; 0x38
    7bce:	00c3      	lsls	r3, r0, #3
    7bd0:	4f9a      	ldr	r7, [pc, #616]	; (7e3c <_malloc_r+0x2f8>)
    7bd2:	443b      	add	r3, r7
    7bd4:	f1a3 0508 	sub.w	r5, r3, #8
    7bd8:	685b      	ldr	r3, [r3, #4]
    7bda:	429d      	cmp	r5, r3
    7bdc:	d106      	bne.n	7bec <_malloc_r+0xa8>
    7bde:	e00c      	b.n	7bfa <_malloc_r+0xb6>
    7be0:	2900      	cmp	r1, #0
    7be2:	f280 8127 	bge.w	7e34 <_malloc_r+0x2f0>
    7be6:	68db      	ldr	r3, [r3, #12]
    7be8:	429d      	cmp	r5, r3
    7bea:	d006      	beq.n	7bfa <_malloc_r+0xb6>
    7bec:	685a      	ldr	r2, [r3, #4]
    7bee:	f022 0203 	bic.w	r2, r2, #3
    7bf2:	1b91      	subs	r1, r2, r6
    7bf4:	290f      	cmp	r1, #15
    7bf6:	ddf3      	ble.n	7be0 <_malloc_r+0x9c>
    7bf8:	4660      	mov	r0, ip
    7bfa:	693d      	ldr	r5, [r7, #16]
    7bfc:	f8df c250 	ldr.w	ip, [pc, #592]	; 7e50 <_malloc_r+0x30c>
    7c00:	4565      	cmp	r5, ip
    7c02:	d07c      	beq.n	7cfe <_malloc_r+0x1ba>
    7c04:	686a      	ldr	r2, [r5, #4]
    7c06:	f022 0203 	bic.w	r2, r2, #3
    7c0a:	1b93      	subs	r3, r2, r6
    7c0c:	2b0f      	cmp	r3, #15
    7c0e:	f300 817b 	bgt.w	7f08 <_malloc_r+0x3c4>
    7c12:	2b00      	cmp	r3, #0
    7c14:	e9c7 cc04 	strd	ip, ip, [r7, #16]
    7c18:	f280 816c 	bge.w	7ef4 <_malloc_r+0x3b0>
    7c1c:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    7c20:	f080 811a 	bcs.w	7e58 <_malloc_r+0x314>
    7c24:	08d3      	lsrs	r3, r2, #3
    7c26:	6879      	ldr	r1, [r7, #4]
    7c28:	3301      	adds	r3, #1
    7c2a:	ea4f 1e52 	mov.w	lr, r2, lsr #5
    7c2e:	2201      	movs	r2, #1
    7c30:	fa02 f20e 	lsl.w	r2, r2, lr
    7c34:	430a      	orrs	r2, r1
    7c36:	f857 e033 	ldr.w	lr, [r7, r3, lsl #3]
    7c3a:	f8c5 e008 	str.w	lr, [r5, #8]
    7c3e:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
    7c42:	3908      	subs	r1, #8
    7c44:	60e9      	str	r1, [r5, #12]
    7c46:	607a      	str	r2, [r7, #4]
    7c48:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
    7c4c:	f8ce 500c 	str.w	r5, [lr, #12]
    7c50:	1083      	asrs	r3, r0, #2
    7c52:	2101      	movs	r1, #1
    7c54:	4099      	lsls	r1, r3
    7c56:	4291      	cmp	r1, r2
    7c58:	d857      	bhi.n	7d0a <_malloc_r+0x1c6>
    7c5a:	4211      	tst	r1, r2
    7c5c:	d106      	bne.n	7c6c <_malloc_r+0x128>
    7c5e:	f020 0003 	bic.w	r0, r0, #3
    7c62:	0049      	lsls	r1, r1, #1
    7c64:	4211      	tst	r1, r2
    7c66:	f100 0004 	add.w	r0, r0, #4
    7c6a:	d0fa      	beq.n	7c62 <_malloc_r+0x11e>
    7c6c:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    7c70:	464d      	mov	r5, r9
    7c72:	4686      	mov	lr, r0
    7c74:	f8d5 800c 	ldr.w	r8, [r5, #12]
    7c78:	4545      	cmp	r5, r8
    7c7a:	d108      	bne.n	7c8e <_malloc_r+0x14a>
    7c7c:	e11d      	b.n	7eba <_malloc_r+0x376>
    7c7e:	2b00      	cmp	r3, #0
    7c80:	f280 8124 	bge.w	7ecc <_malloc_r+0x388>
    7c84:	f8d8 800c 	ldr.w	r8, [r8, #12]
    7c88:	4545      	cmp	r5, r8
    7c8a:	f000 8116 	beq.w	7eba <_malloc_r+0x376>
    7c8e:	f8d8 2004 	ldr.w	r2, [r8, #4]
    7c92:	f022 0203 	bic.w	r2, r2, #3
    7c96:	1b93      	subs	r3, r2, r6
    7c98:	2b0f      	cmp	r3, #15
    7c9a:	ddf0      	ble.n	7c7e <_malloc_r+0x13a>
    7c9c:	4620      	mov	r0, r4
    7c9e:	e9d8 5402 	ldrd	r5, r4, [r8, #8]
    7ca2:	eb08 0106 	add.w	r1, r8, r6
    7ca6:	f046 0601 	orr.w	r6, r6, #1
    7caa:	f8c8 6004 	str.w	r6, [r8, #4]
    7cae:	60ec      	str	r4, [r5, #12]
    7cb0:	60a5      	str	r5, [r4, #8]
    7cb2:	f043 0401 	orr.w	r4, r3, #1
    7cb6:	e9c7 1104 	strd	r1, r1, [r7, #16]
    7cba:	e9c1 cc02 	strd	ip, ip, [r1, #8]
    7cbe:	604c      	str	r4, [r1, #4]
    7cc0:	f848 3002 	str.w	r3, [r8, r2]
    7cc4:	f000 f9f4 	bl	80b0 <__malloc_unlock>
    7cc8:	f108 0508 	add.w	r5, r8, #8
    7ccc:	e002      	b.n	7cd4 <_malloc_r+0x190>
    7cce:	230c      	movs	r3, #12
    7cd0:	6023      	str	r3, [r4, #0]
    7cd2:	2500      	movs	r5, #0
    7cd4:	4628      	mov	r0, r5
    7cd6:	b003      	add	sp, #12
    7cd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7cdc:	f44f 7300 	mov.w	r3, #512	; 0x200
    7ce0:	2040      	movs	r0, #64	; 0x40
    7ce2:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
    7ce6:	e773      	b.n	7bd0 <_malloc_r+0x8c>
    7ce8:	68d3      	ldr	r3, [r2, #12]
    7cea:	429a      	cmp	r2, r3
    7cec:	bf08      	it	eq
    7cee:	3002      	addeq	r0, #2
    7cf0:	f47f af40 	bne.w	7b74 <_malloc_r+0x30>
    7cf4:	693d      	ldr	r5, [r7, #16]
    7cf6:	f8df c158 	ldr.w	ip, [pc, #344]	; 7e50 <_malloc_r+0x30c>
    7cfa:	4565      	cmp	r5, ip
    7cfc:	d182      	bne.n	7c04 <_malloc_r+0xc0>
    7cfe:	687a      	ldr	r2, [r7, #4]
    7d00:	1083      	asrs	r3, r0, #2
    7d02:	2101      	movs	r1, #1
    7d04:	4099      	lsls	r1, r3
    7d06:	4291      	cmp	r1, r2
    7d08:	d9a7      	bls.n	7c5a <_malloc_r+0x116>
    7d0a:	68bd      	ldr	r5, [r7, #8]
    7d0c:	686b      	ldr	r3, [r5, #4]
    7d0e:	f023 0903 	bic.w	r9, r3, #3
    7d12:	454e      	cmp	r6, r9
    7d14:	d803      	bhi.n	7d1e <_malloc_r+0x1da>
    7d16:	eba9 0306 	sub.w	r3, r9, r6
    7d1a:	2b0f      	cmp	r3, #15
    7d1c:	dc7a      	bgt.n	7e14 <_malloc_r+0x2d0>
    7d1e:	f8df b134 	ldr.w	fp, [pc, #308]	; 7e54 <_malloc_r+0x310>
    7d22:	4b47      	ldr	r3, [pc, #284]	; (7e40 <_malloc_r+0x2fc>)
    7d24:	f8db 2000 	ldr.w	r2, [fp]
    7d28:	681b      	ldr	r3, [r3, #0]
    7d2a:	3201      	adds	r2, #1
    7d2c:	4433      	add	r3, r6
    7d2e:	eb05 0a09 	add.w	sl, r5, r9
    7d32:	f000 8133 	beq.w	7f9c <_malloc_r+0x458>
    7d36:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7d3a:	330f      	adds	r3, #15
    7d3c:	f423 687f 	bic.w	r8, r3, #4080	; 0xff0
    7d40:	f028 080f 	bic.w	r8, r8, #15
    7d44:	4641      	mov	r1, r8
    7d46:	4620      	mov	r0, r4
    7d48:	f000 fe78 	bl	8a3c <_sbrk_r>
    7d4c:	1c41      	adds	r1, r0, #1
    7d4e:	4602      	mov	r2, r0
    7d50:	f000 80f3 	beq.w	7f3a <_malloc_r+0x3f6>
    7d54:	4582      	cmp	sl, r0
    7d56:	f200 80ee 	bhi.w	7f36 <_malloc_r+0x3f2>
    7d5a:	4b3a      	ldr	r3, [pc, #232]	; (7e44 <_malloc_r+0x300>)
    7d5c:	6819      	ldr	r1, [r3, #0]
    7d5e:	4441      	add	r1, r8
    7d60:	6019      	str	r1, [r3, #0]
    7d62:	4608      	mov	r0, r1
    7d64:	f000 814e 	beq.w	8004 <_malloc_r+0x4c0>
    7d68:	f8db 1000 	ldr.w	r1, [fp]
    7d6c:	9301      	str	r3, [sp, #4]
    7d6e:	3101      	adds	r1, #1
    7d70:	bf1b      	ittet	ne
    7d72:	eba2 010a 	subne.w	r1, r2, sl
    7d76:	1809      	addne	r1, r1, r0
    7d78:	f8cb 2000 	streq.w	r2, [fp]
    7d7c:	6019      	strne	r1, [r3, #0]
    7d7e:	f012 0b07 	ands.w	fp, r2, #7
    7d82:	f000 8117 	beq.w	7fb4 <_malloc_r+0x470>
    7d86:	f1cb 0108 	rsb	r1, fp, #8
    7d8a:	440a      	add	r2, r1
    7d8c:	f5cb 5180 	rsb	r1, fp, #4096	; 0x1000
    7d90:	4490      	add	r8, r2
    7d92:	3108      	adds	r1, #8
    7d94:	eba1 0108 	sub.w	r1, r1, r8
    7d98:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
    7d9c:	4651      	mov	r1, sl
    7d9e:	4620      	mov	r0, r4
    7da0:	9200      	str	r2, [sp, #0]
    7da2:	f000 fe4b 	bl	8a3c <_sbrk_r>
    7da6:	1c42      	adds	r2, r0, #1
    7da8:	e9dd 2300 	ldrd	r2, r3, [sp]
    7dac:	f000 814f 	beq.w	804e <_malloc_r+0x50a>
    7db0:	1a80      	subs	r0, r0, r2
    7db2:	eb00 080a 	add.w	r8, r0, sl
    7db6:	6819      	ldr	r1, [r3, #0]
    7db8:	60ba      	str	r2, [r7, #8]
    7dba:	f048 0001 	orr.w	r0, r8, #1
    7dbe:	4451      	add	r1, sl
    7dc0:	42bd      	cmp	r5, r7
    7dc2:	6050      	str	r0, [r2, #4]
    7dc4:	6019      	str	r1, [r3, #0]
    7dc6:	f000 8129 	beq.w	801c <_malloc_r+0x4d8>
    7dca:	f1b9 0f0f 	cmp.w	r9, #15
    7dce:	f240 8127 	bls.w	8020 <_malloc_r+0x4dc>
    7dd2:	6868      	ldr	r0, [r5, #4]
    7dd4:	f1a9 0c0c 	sub.w	ip, r9, #12
    7dd8:	f02c 0c07 	bic.w	ip, ip, #7
    7ddc:	f000 0001 	and.w	r0, r0, #1
    7de0:	ea40 000c 	orr.w	r0, r0, ip
    7de4:	6068      	str	r0, [r5, #4]
    7de6:	f04f 0e05 	mov.w	lr, #5
    7dea:	eb05 000c 	add.w	r0, r5, ip
    7dee:	f1bc 0f0f 	cmp.w	ip, #15
    7df2:	e9c0 ee01 	strd	lr, lr, [r0, #4]
    7df6:	f200 8132 	bhi.w	805e <_malloc_r+0x51a>
    7dfa:	6850      	ldr	r0, [r2, #4]
    7dfc:	4615      	mov	r5, r2
    7dfe:	4b12      	ldr	r3, [pc, #72]	; (7e48 <_malloc_r+0x304>)
    7e00:	681a      	ldr	r2, [r3, #0]
    7e02:	428a      	cmp	r2, r1
    7e04:	bf38      	it	cc
    7e06:	6019      	strcc	r1, [r3, #0]
    7e08:	4b10      	ldr	r3, [pc, #64]	; (7e4c <_malloc_r+0x308>)
    7e0a:	681a      	ldr	r2, [r3, #0]
    7e0c:	428a      	cmp	r2, r1
    7e0e:	bf38      	it	cc
    7e10:	6019      	strcc	r1, [r3, #0]
    7e12:	e094      	b.n	7f3e <_malloc_r+0x3fa>
    7e14:	19aa      	adds	r2, r5, r6
    7e16:	f043 0301 	orr.w	r3, r3, #1
    7e1a:	f046 0601 	orr.w	r6, r6, #1
    7e1e:	606e      	str	r6, [r5, #4]
    7e20:	4620      	mov	r0, r4
    7e22:	60ba      	str	r2, [r7, #8]
    7e24:	6053      	str	r3, [r2, #4]
    7e26:	f000 f943 	bl	80b0 <__malloc_unlock>
    7e2a:	3508      	adds	r5, #8
    7e2c:	4628      	mov	r0, r5
    7e2e:	b003      	add	sp, #12
    7e30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e34:	68d9      	ldr	r1, [r3, #12]
    7e36:	441a      	add	r2, r3
    7e38:	e6a1      	b.n	7b7e <_malloc_r+0x3a>
    7e3a:	bf00      	nop
    7e3c:	20001350 	.word	0x20001350
    7e40:	20007394 	.word	0x20007394
    7e44:	20007364 	.word	0x20007364
    7e48:	2000738c 	.word	0x2000738c
    7e4c:	20007390 	.word	0x20007390
    7e50:	20001358 	.word	0x20001358
    7e54:	20001758 	.word	0x20001758
    7e58:	f5b2 6f20 	cmp.w	r2, #2560	; 0xa00
    7e5c:	ea4f 2352 	mov.w	r3, r2, lsr #9
    7e60:	d363      	bcc.n	7f2a <_malloc_r+0x3e6>
    7e62:	2b14      	cmp	r3, #20
    7e64:	f200 80b7 	bhi.w	7fd6 <_malloc_r+0x492>
    7e68:	f103 015c 	add.w	r1, r3, #92	; 0x5c
    7e6c:	00c9      	lsls	r1, r1, #3
    7e6e:	335b      	adds	r3, #91	; 0x5b
    7e70:	eb07 0e01 	add.w	lr, r7, r1
    7e74:	5879      	ldr	r1, [r7, r1]
    7e76:	f1ae 0e08 	sub.w	lr, lr, #8
    7e7a:	458e      	cmp	lr, r1
    7e7c:	f000 8091 	beq.w	7fa2 <_malloc_r+0x45e>
    7e80:	684b      	ldr	r3, [r1, #4]
    7e82:	f023 0303 	bic.w	r3, r3, #3
    7e86:	4293      	cmp	r3, r2
    7e88:	d902      	bls.n	7e90 <_malloc_r+0x34c>
    7e8a:	6889      	ldr	r1, [r1, #8]
    7e8c:	458e      	cmp	lr, r1
    7e8e:	d1f7      	bne.n	7e80 <_malloc_r+0x33c>
    7e90:	f8d1 e00c 	ldr.w	lr, [r1, #12]
    7e94:	687a      	ldr	r2, [r7, #4]
    7e96:	e9c5 1e02 	strd	r1, lr, [r5, #8]
    7e9a:	f8ce 5008 	str.w	r5, [lr, #8]
    7e9e:	60cd      	str	r5, [r1, #12]
    7ea0:	e6d6      	b.n	7c50 <_malloc_r+0x10c>
    7ea2:	2b14      	cmp	r3, #20
    7ea4:	d959      	bls.n	7f5a <_malloc_r+0x416>
    7ea6:	2b54      	cmp	r3, #84	; 0x54
    7ea8:	f200 809d 	bhi.w	7fe6 <_malloc_r+0x4a2>
    7eac:	0b33      	lsrs	r3, r6, #12
    7eae:	f103 006f 	add.w	r0, r3, #111	; 0x6f
    7eb2:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
    7eb6:	00c3      	lsls	r3, r0, #3
    7eb8:	e68a      	b.n	7bd0 <_malloc_r+0x8c>
    7eba:	f10e 0e01 	add.w	lr, lr, #1
    7ebe:	f01e 0f03 	tst.w	lr, #3
    7ec2:	f105 0508 	add.w	r5, r5, #8
    7ec6:	f47f aed5 	bne.w	7c74 <_malloc_r+0x130>
    7eca:	e051      	b.n	7f70 <_malloc_r+0x42c>
    7ecc:	4442      	add	r2, r8
    7ece:	4645      	mov	r5, r8
    7ed0:	6853      	ldr	r3, [r2, #4]
    7ed2:	f8d8 100c 	ldr.w	r1, [r8, #12]
    7ed6:	f043 0301 	orr.w	r3, r3, #1
    7eda:	6053      	str	r3, [r2, #4]
    7edc:	f855 3f08 	ldr.w	r3, [r5, #8]!
    7ee0:	4620      	mov	r0, r4
    7ee2:	60d9      	str	r1, [r3, #12]
    7ee4:	608b      	str	r3, [r1, #8]
    7ee6:	f000 f8e3 	bl	80b0 <__malloc_unlock>
    7eea:	e6f3      	b.n	7cd4 <_malloc_r+0x190>
    7eec:	08f0      	lsrs	r0, r6, #3
    7eee:	f106 0208 	add.w	r2, r6, #8
    7ef2:	e637      	b.n	7b64 <_malloc_r+0x20>
    7ef4:	442a      	add	r2, r5
    7ef6:	4620      	mov	r0, r4
    7ef8:	6853      	ldr	r3, [r2, #4]
    7efa:	f043 0301 	orr.w	r3, r3, #1
    7efe:	6053      	str	r3, [r2, #4]
    7f00:	3508      	adds	r5, #8
    7f02:	f000 f8d5 	bl	80b0 <__malloc_unlock>
    7f06:	e6e5      	b.n	7cd4 <_malloc_r+0x190>
    7f08:	19a9      	adds	r1, r5, r6
    7f0a:	4620      	mov	r0, r4
    7f0c:	f046 0601 	orr.w	r6, r6, #1
    7f10:	f043 0401 	orr.w	r4, r3, #1
    7f14:	606e      	str	r6, [r5, #4]
    7f16:	e9c7 1104 	strd	r1, r1, [r7, #16]
    7f1a:	e9c1 cc02 	strd	ip, ip, [r1, #8]
    7f1e:	604c      	str	r4, [r1, #4]
    7f20:	50ab      	str	r3, [r5, r2]
    7f22:	f000 f8c5 	bl	80b0 <__malloc_unlock>
    7f26:	3508      	adds	r5, #8
    7f28:	e6d4      	b.n	7cd4 <_malloc_r+0x190>
    7f2a:	0993      	lsrs	r3, r2, #6
    7f2c:	f103 0139 	add.w	r1, r3, #57	; 0x39
    7f30:	00c9      	lsls	r1, r1, #3
    7f32:	3338      	adds	r3, #56	; 0x38
    7f34:	e79c      	b.n	7e70 <_malloc_r+0x32c>
    7f36:	42bd      	cmp	r5, r7
    7f38:	d05f      	beq.n	7ffa <_malloc_r+0x4b6>
    7f3a:	68bd      	ldr	r5, [r7, #8]
    7f3c:	6868      	ldr	r0, [r5, #4]
    7f3e:	f020 0803 	bic.w	r8, r0, #3
    7f42:	4546      	cmp	r6, r8
    7f44:	eba8 0306 	sub.w	r3, r8, r6
    7f48:	d802      	bhi.n	7f50 <_malloc_r+0x40c>
    7f4a:	2b0f      	cmp	r3, #15
    7f4c:	f73f af62 	bgt.w	7e14 <_malloc_r+0x2d0>
    7f50:	4620      	mov	r0, r4
    7f52:	f000 f8ad 	bl	80b0 <__malloc_unlock>
    7f56:	2500      	movs	r5, #0
    7f58:	e6bc      	b.n	7cd4 <_malloc_r+0x190>
    7f5a:	f103 005c 	add.w	r0, r3, #92	; 0x5c
    7f5e:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
    7f62:	00c3      	lsls	r3, r0, #3
    7f64:	e634      	b.n	7bd0 <_malloc_r+0x8c>
    7f66:	f859 3908 	ldr.w	r3, [r9], #-8
    7f6a:	454b      	cmp	r3, r9
    7f6c:	f040 8096 	bne.w	809c <_malloc_r+0x558>
    7f70:	f010 0f03 	tst.w	r0, #3
    7f74:	f100 30ff 	add.w	r0, r0, #4294967295
    7f78:	d1f5      	bne.n	7f66 <_malloc_r+0x422>
    7f7a:	687b      	ldr	r3, [r7, #4]
    7f7c:	ea23 0301 	bic.w	r3, r3, r1
    7f80:	607b      	str	r3, [r7, #4]
    7f82:	0049      	lsls	r1, r1, #1
    7f84:	4299      	cmp	r1, r3
    7f86:	f63f aec0 	bhi.w	7d0a <_malloc_r+0x1c6>
    7f8a:	b919      	cbnz	r1, 7f94 <_malloc_r+0x450>
    7f8c:	e6bd      	b.n	7d0a <_malloc_r+0x1c6>
    7f8e:	0049      	lsls	r1, r1, #1
    7f90:	f10e 0e04 	add.w	lr, lr, #4
    7f94:	4219      	tst	r1, r3
    7f96:	d0fa      	beq.n	7f8e <_malloc_r+0x44a>
    7f98:	4670      	mov	r0, lr
    7f9a:	e667      	b.n	7c6c <_malloc_r+0x128>
    7f9c:	f103 0810 	add.w	r8, r3, #16
    7fa0:	e6d0      	b.n	7d44 <_malloc_r+0x200>
    7fa2:	109a      	asrs	r2, r3, #2
    7fa4:	f04f 0801 	mov.w	r8, #1
    7fa8:	687b      	ldr	r3, [r7, #4]
    7faa:	fa08 f202 	lsl.w	r2, r8, r2
    7fae:	431a      	orrs	r2, r3
    7fb0:	607a      	str	r2, [r7, #4]
    7fb2:	e770      	b.n	7e96 <_malloc_r+0x352>
    7fb4:	eb02 0108 	add.w	r1, r2, r8
    7fb8:	4249      	negs	r1, r1
    7fba:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
    7fbe:	4651      	mov	r1, sl
    7fc0:	4620      	mov	r0, r4
    7fc2:	9200      	str	r2, [sp, #0]
    7fc4:	f000 fd3a 	bl	8a3c <_sbrk_r>
    7fc8:	1c43      	adds	r3, r0, #1
    7fca:	e9dd 2300 	ldrd	r2, r3, [sp]
    7fce:	f47f aeef 	bne.w	7db0 <_malloc_r+0x26c>
    7fd2:	46da      	mov	sl, fp
    7fd4:	e6ef      	b.n	7db6 <_malloc_r+0x272>
    7fd6:	2b54      	cmp	r3, #84	; 0x54
    7fd8:	d825      	bhi.n	8026 <_malloc_r+0x4e2>
    7fda:	0b13      	lsrs	r3, r2, #12
    7fdc:	f103 016f 	add.w	r1, r3, #111	; 0x6f
    7fe0:	00c9      	lsls	r1, r1, #3
    7fe2:	336e      	adds	r3, #110	; 0x6e
    7fe4:	e744      	b.n	7e70 <_malloc_r+0x32c>
    7fe6:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    7fea:	d825      	bhi.n	8038 <_malloc_r+0x4f4>
    7fec:	0bf3      	lsrs	r3, r6, #15
    7fee:	f103 0078 	add.w	r0, r3, #120	; 0x78
    7ff2:	f103 0c77 	add.w	ip, r3, #119	; 0x77
    7ff6:	00c3      	lsls	r3, r0, #3
    7ff8:	e5ea      	b.n	7bd0 <_malloc_r+0x8c>
    7ffa:	4b29      	ldr	r3, [pc, #164]	; (80a0 <_malloc_r+0x55c>)
    7ffc:	6818      	ldr	r0, [r3, #0]
    7ffe:	4440      	add	r0, r8
    8000:	6018      	str	r0, [r3, #0]
    8002:	e6b1      	b.n	7d68 <_malloc_r+0x224>
    8004:	f3ca 0c0b 	ubfx	ip, sl, #0, #12
    8008:	f1bc 0f00 	cmp.w	ip, #0
    800c:	f47f aeac 	bne.w	7d68 <_malloc_r+0x224>
    8010:	68bd      	ldr	r5, [r7, #8]
    8012:	44c8      	add	r8, r9
    8014:	f048 0001 	orr.w	r0, r8, #1
    8018:	6068      	str	r0, [r5, #4]
    801a:	e6f0      	b.n	7dfe <_malloc_r+0x2ba>
    801c:	4615      	mov	r5, r2
    801e:	e6ee      	b.n	7dfe <_malloc_r+0x2ba>
    8020:	2301      	movs	r3, #1
    8022:	6053      	str	r3, [r2, #4]
    8024:	e794      	b.n	7f50 <_malloc_r+0x40c>
    8026:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    802a:	d823      	bhi.n	8074 <_malloc_r+0x530>
    802c:	0bd3      	lsrs	r3, r2, #15
    802e:	f103 0178 	add.w	r1, r3, #120	; 0x78
    8032:	00c9      	lsls	r1, r1, #3
    8034:	3377      	adds	r3, #119	; 0x77
    8036:	e71b      	b.n	7e70 <_malloc_r+0x32c>
    8038:	f240 5254 	movw	r2, #1364	; 0x554
    803c:	4293      	cmp	r3, r2
    803e:	d823      	bhi.n	8088 <_malloc_r+0x544>
    8040:	0cb3      	lsrs	r3, r6, #18
    8042:	f103 007d 	add.w	r0, r3, #125	; 0x7d
    8046:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
    804a:	00c3      	lsls	r3, r0, #3
    804c:	e5c0      	b.n	7bd0 <_malloc_r+0x8c>
    804e:	f1ab 0b08 	sub.w	fp, fp, #8
    8052:	44d8      	add	r8, fp
    8054:	eba8 0802 	sub.w	r8, r8, r2
    8058:	f04f 0a00 	mov.w	sl, #0
    805c:	e6ab      	b.n	7db6 <_malloc_r+0x272>
    805e:	f105 0108 	add.w	r1, r5, #8
    8062:	4620      	mov	r0, r4
    8064:	9300      	str	r3, [sp, #0]
    8066:	f000 fe09 	bl	8c7c <_free_r>
    806a:	68bd      	ldr	r5, [r7, #8]
    806c:	9b00      	ldr	r3, [sp, #0]
    806e:	6868      	ldr	r0, [r5, #4]
    8070:	6819      	ldr	r1, [r3, #0]
    8072:	e6c4      	b.n	7dfe <_malloc_r+0x2ba>
    8074:	f240 5154 	movw	r1, #1364	; 0x554
    8078:	428b      	cmp	r3, r1
    807a:	d80b      	bhi.n	8094 <_malloc_r+0x550>
    807c:	0c93      	lsrs	r3, r2, #18
    807e:	f103 017d 	add.w	r1, r3, #125	; 0x7d
    8082:	00c9      	lsls	r1, r1, #3
    8084:	337c      	adds	r3, #124	; 0x7c
    8086:	e6f3      	b.n	7e70 <_malloc_r+0x32c>
    8088:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    808c:	207f      	movs	r0, #127	; 0x7f
    808e:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
    8092:	e59d      	b.n	7bd0 <_malloc_r+0x8c>
    8094:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
    8098:	237e      	movs	r3, #126	; 0x7e
    809a:	e6e9      	b.n	7e70 <_malloc_r+0x32c>
    809c:	687b      	ldr	r3, [r7, #4]
    809e:	e770      	b.n	7f82 <_malloc_r+0x43e>
    80a0:	20007364 	.word	0x20007364

000080a4 <__malloc_lock>:
    80a4:	4801      	ldr	r0, [pc, #4]	; (80ac <__malloc_lock+0x8>)
    80a6:	f000 bd1f 	b.w	8ae8 <__retarget_lock_acquire_recursive>
    80aa:	bf00      	nop
    80ac:	2000735c 	.word	0x2000735c

000080b0 <__malloc_unlock>:
    80b0:	4801      	ldr	r0, [pc, #4]	; (80b8 <__malloc_unlock+0x8>)
    80b2:	f000 bd1b 	b.w	8aec <__retarget_lock_release_recursive>
    80b6:	bf00      	nop
    80b8:	2000735c 	.word	0x2000735c

000080bc <_realloc_r>:
    80bc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    80c0:	4617      	mov	r7, r2
    80c2:	2900      	cmp	r1, #0
    80c4:	f000 8098 	beq.w	81f8 <_realloc_r+0x13c>
    80c8:	460c      	mov	r4, r1
    80ca:	f107 050b 	add.w	r5, r7, #11
    80ce:	4680      	mov	r8, r0
    80d0:	f7ff ffe8 	bl	80a4 <__malloc_lock>
    80d4:	2d16      	cmp	r5, #22
    80d6:	f854 1c04 	ldr.w	r1, [r4, #-4]
    80da:	d85b      	bhi.n	8194 <_realloc_r+0xd8>
    80dc:	2510      	movs	r5, #16
    80de:	462a      	mov	r2, r5
    80e0:	42af      	cmp	r7, r5
    80e2:	d85c      	bhi.n	819e <_realloc_r+0xe2>
    80e4:	f021 0603 	bic.w	r6, r1, #3
    80e8:	4296      	cmp	r6, r2
    80ea:	f1a4 0908 	sub.w	r9, r4, #8
    80ee:	da62      	bge.n	81b6 <_realloc_r+0xfa>
    80f0:	4bbc      	ldr	r3, [pc, #752]	; (83e4 <_realloc_r+0x328>)
    80f2:	f8d3 c008 	ldr.w	ip, [r3, #8]
    80f6:	eb09 0006 	add.w	r0, r9, r6
    80fa:	4584      	cmp	ip, r0
    80fc:	f000 8097 	beq.w	822e <_realloc_r+0x172>
    8100:	f8d0 c004 	ldr.w	ip, [r0, #4]
    8104:	f02c 0301 	bic.w	r3, ip, #1
    8108:	4403      	add	r3, r0
    810a:	685b      	ldr	r3, [r3, #4]
    810c:	07db      	lsls	r3, r3, #31
    810e:	d468      	bmi.n	81e2 <_realloc_r+0x126>
    8110:	f02c 0c03 	bic.w	ip, ip, #3
    8114:	eb06 030c 	add.w	r3, r6, ip
    8118:	4293      	cmp	r3, r2
    811a:	da47      	bge.n	81ac <_realloc_r+0xf0>
    811c:	07cb      	lsls	r3, r1, #31
    811e:	d410      	bmi.n	8142 <_realloc_r+0x86>
    8120:	f854 3c08 	ldr.w	r3, [r4, #-8]
    8124:	eba9 0a03 	sub.w	sl, r9, r3
    8128:	f8da 3004 	ldr.w	r3, [sl, #4]
    812c:	f023 0103 	bic.w	r1, r3, #3
    8130:	448c      	add	ip, r1
    8132:	44b4      	add	ip, r6
    8134:	4594      	cmp	ip, r2
    8136:	f280 8111 	bge.w	835c <_realloc_r+0x2a0>
    813a:	1873      	adds	r3, r6, r1
    813c:	4293      	cmp	r3, r2
    813e:	f280 80e8 	bge.w	8312 <_realloc_r+0x256>
    8142:	4639      	mov	r1, r7
    8144:	4640      	mov	r0, r8
    8146:	f7ff fcfd 	bl	7b44 <_malloc_r>
    814a:	4607      	mov	r7, r0
    814c:	b1e0      	cbz	r0, 8188 <_realloc_r+0xcc>
    814e:	f854 3c04 	ldr.w	r3, [r4, #-4]
    8152:	f023 0301 	bic.w	r3, r3, #1
    8156:	444b      	add	r3, r9
    8158:	f1a0 0208 	sub.w	r2, r0, #8
    815c:	4293      	cmp	r3, r2
    815e:	f000 80d2 	beq.w	8306 <_realloc_r+0x24a>
    8162:	1f32      	subs	r2, r6, #4
    8164:	2a24      	cmp	r2, #36	; 0x24
    8166:	f200 80f5 	bhi.w	8354 <_realloc_r+0x298>
    816a:	2a13      	cmp	r2, #19
    816c:	f200 80ac 	bhi.w	82c8 <_realloc_r+0x20c>
    8170:	4603      	mov	r3, r0
    8172:	4622      	mov	r2, r4
    8174:	6811      	ldr	r1, [r2, #0]
    8176:	6019      	str	r1, [r3, #0]
    8178:	6851      	ldr	r1, [r2, #4]
    817a:	6059      	str	r1, [r3, #4]
    817c:	6892      	ldr	r2, [r2, #8]
    817e:	609a      	str	r2, [r3, #8]
    8180:	4621      	mov	r1, r4
    8182:	4640      	mov	r0, r8
    8184:	f000 fd7a 	bl	8c7c <_free_r>
    8188:	4640      	mov	r0, r8
    818a:	f7ff ff91 	bl	80b0 <__malloc_unlock>
    818e:	4638      	mov	r0, r7
    8190:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8194:	f025 0507 	bic.w	r5, r5, #7
    8198:	2d00      	cmp	r5, #0
    819a:	462a      	mov	r2, r5
    819c:	daa0      	bge.n	80e0 <_realloc_r+0x24>
    819e:	230c      	movs	r3, #12
    81a0:	f8c8 3000 	str.w	r3, [r8]
    81a4:	2700      	movs	r7, #0
    81a6:	4638      	mov	r0, r7
    81a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    81ac:	461e      	mov	r6, r3
    81ae:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
    81b2:	60d3      	str	r3, [r2, #12]
    81b4:	609a      	str	r2, [r3, #8]
    81b6:	1b73      	subs	r3, r6, r5
    81b8:	2b0f      	cmp	r3, #15
    81ba:	d822      	bhi.n	8202 <_realloc_r+0x146>
    81bc:	f8d9 3004 	ldr.w	r3, [r9, #4]
    81c0:	f003 0301 	and.w	r3, r3, #1
    81c4:	4333      	orrs	r3, r6
    81c6:	444e      	add	r6, r9
    81c8:	f8c9 3004 	str.w	r3, [r9, #4]
    81cc:	6873      	ldr	r3, [r6, #4]
    81ce:	f043 0301 	orr.w	r3, r3, #1
    81d2:	6073      	str	r3, [r6, #4]
    81d4:	4640      	mov	r0, r8
    81d6:	4627      	mov	r7, r4
    81d8:	f7ff ff6a 	bl	80b0 <__malloc_unlock>
    81dc:	4638      	mov	r0, r7
    81de:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    81e2:	07c9      	lsls	r1, r1, #31
    81e4:	d4ad      	bmi.n	8142 <_realloc_r+0x86>
    81e6:	f854 3c08 	ldr.w	r3, [r4, #-8]
    81ea:	eba9 0a03 	sub.w	sl, r9, r3
    81ee:	f8da 1004 	ldr.w	r1, [sl, #4]
    81f2:	f021 0103 	bic.w	r1, r1, #3
    81f6:	e7a0      	b.n	813a <_realloc_r+0x7e>
    81f8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    81fc:	4611      	mov	r1, r2
    81fe:	f7ff bca1 	b.w	7b44 <_malloc_r>
    8202:	f8d9 2004 	ldr.w	r2, [r9, #4]
    8206:	eb09 0105 	add.w	r1, r9, r5
    820a:	f002 0201 	and.w	r2, r2, #1
    820e:	444e      	add	r6, r9
    8210:	f043 0301 	orr.w	r3, r3, #1
    8214:	432a      	orrs	r2, r5
    8216:	f8c9 2004 	str.w	r2, [r9, #4]
    821a:	604b      	str	r3, [r1, #4]
    821c:	6873      	ldr	r3, [r6, #4]
    821e:	f043 0301 	orr.w	r3, r3, #1
    8222:	3108      	adds	r1, #8
    8224:	6073      	str	r3, [r6, #4]
    8226:	4640      	mov	r0, r8
    8228:	f000 fd28 	bl	8c7c <_free_r>
    822c:	e7d2      	b.n	81d4 <_realloc_r+0x118>
    822e:	f8dc 0004 	ldr.w	r0, [ip, #4]
    8232:	f020 0b03 	bic.w	fp, r0, #3
    8236:	eb06 0c0b 	add.w	ip, r6, fp
    823a:	f105 0010 	add.w	r0, r5, #16
    823e:	4584      	cmp	ip, r0
    8240:	da4d      	bge.n	82de <_realloc_r+0x222>
    8242:	07c9      	lsls	r1, r1, #31
    8244:	f53f af7d 	bmi.w	8142 <_realloc_r+0x86>
    8248:	f854 1c08 	ldr.w	r1, [r4, #-8]
    824c:	eba9 0a01 	sub.w	sl, r9, r1
    8250:	f8da 1004 	ldr.w	r1, [sl, #4]
    8254:	f021 0103 	bic.w	r1, r1, #3
    8258:	448b      	add	fp, r1
    825a:	44b3      	add	fp, r6
    825c:	4558      	cmp	r0, fp
    825e:	f73f af6c 	bgt.w	813a <_realloc_r+0x7e>
    8262:	4657      	mov	r7, sl
    8264:	f8da 100c 	ldr.w	r1, [sl, #12]
    8268:	f857 0f08 	ldr.w	r0, [r7, #8]!
    826c:	1f32      	subs	r2, r6, #4
    826e:	2a24      	cmp	r2, #36	; 0x24
    8270:	60c1      	str	r1, [r0, #12]
    8272:	6088      	str	r0, [r1, #8]
    8274:	f200 80db 	bhi.w	842e <_realloc_r+0x372>
    8278:	2a13      	cmp	r2, #19
    827a:	f240 80d6 	bls.w	842a <_realloc_r+0x36e>
    827e:	6821      	ldr	r1, [r4, #0]
    8280:	f8ca 1008 	str.w	r1, [sl, #8]
    8284:	6861      	ldr	r1, [r4, #4]
    8286:	f8ca 100c 	str.w	r1, [sl, #12]
    828a:	2a1b      	cmp	r2, #27
    828c:	f200 80df 	bhi.w	844e <_realloc_r+0x392>
    8290:	3408      	adds	r4, #8
    8292:	f10a 0210 	add.w	r2, sl, #16
    8296:	6821      	ldr	r1, [r4, #0]
    8298:	6011      	str	r1, [r2, #0]
    829a:	6861      	ldr	r1, [r4, #4]
    829c:	6051      	str	r1, [r2, #4]
    829e:	68a1      	ldr	r1, [r4, #8]
    82a0:	6091      	str	r1, [r2, #8]
    82a2:	eb0a 0105 	add.w	r1, sl, r5
    82a6:	ebab 0205 	sub.w	r2, fp, r5
    82aa:	f042 0201 	orr.w	r2, r2, #1
    82ae:	6099      	str	r1, [r3, #8]
    82b0:	604a      	str	r2, [r1, #4]
    82b2:	f8da 3004 	ldr.w	r3, [sl, #4]
    82b6:	f003 0301 	and.w	r3, r3, #1
    82ba:	432b      	orrs	r3, r5
    82bc:	4640      	mov	r0, r8
    82be:	f8ca 3004 	str.w	r3, [sl, #4]
    82c2:	f7ff fef5 	bl	80b0 <__malloc_unlock>
    82c6:	e76e      	b.n	81a6 <_realloc_r+0xea>
    82c8:	6823      	ldr	r3, [r4, #0]
    82ca:	6003      	str	r3, [r0, #0]
    82cc:	6863      	ldr	r3, [r4, #4]
    82ce:	6043      	str	r3, [r0, #4]
    82d0:	2a1b      	cmp	r2, #27
    82d2:	d868      	bhi.n	83a6 <_realloc_r+0x2ea>
    82d4:	f104 0208 	add.w	r2, r4, #8
    82d8:	f100 0308 	add.w	r3, r0, #8
    82dc:	e74a      	b.n	8174 <_realloc_r+0xb8>
    82de:	eb09 0205 	add.w	r2, r9, r5
    82e2:	609a      	str	r2, [r3, #8]
    82e4:	ebac 0305 	sub.w	r3, ip, r5
    82e8:	f043 0301 	orr.w	r3, r3, #1
    82ec:	6053      	str	r3, [r2, #4]
    82ee:	f854 3c04 	ldr.w	r3, [r4, #-4]
    82f2:	f003 0301 	and.w	r3, r3, #1
    82f6:	432b      	orrs	r3, r5
    82f8:	4640      	mov	r0, r8
    82fa:	f844 3c04 	str.w	r3, [r4, #-4]
    82fe:	f7ff fed7 	bl	80b0 <__malloc_unlock>
    8302:	4627      	mov	r7, r4
    8304:	e74f      	b.n	81a6 <_realloc_r+0xea>
    8306:	f850 3c04 	ldr.w	r3, [r0, #-4]
    830a:	f023 0303 	bic.w	r3, r3, #3
    830e:	441e      	add	r6, r3
    8310:	e751      	b.n	81b6 <_realloc_r+0xfa>
    8312:	4657      	mov	r7, sl
    8314:	f8da 100c 	ldr.w	r1, [sl, #12]
    8318:	f857 0f08 	ldr.w	r0, [r7, #8]!
    831c:	1f32      	subs	r2, r6, #4
    831e:	2a24      	cmp	r2, #36	; 0x24
    8320:	60c1      	str	r1, [r0, #12]
    8322:	6088      	str	r0, [r1, #8]
    8324:	d84c      	bhi.n	83c0 <_realloc_r+0x304>
    8326:	2a13      	cmp	r2, #19
    8328:	d948      	bls.n	83bc <_realloc_r+0x300>
    832a:	6821      	ldr	r1, [r4, #0]
    832c:	f8ca 1008 	str.w	r1, [sl, #8]
    8330:	6861      	ldr	r1, [r4, #4]
    8332:	f8ca 100c 	str.w	r1, [sl, #12]
    8336:	2a1b      	cmp	r2, #27
    8338:	d856      	bhi.n	83e8 <_realloc_r+0x32c>
    833a:	3408      	adds	r4, #8
    833c:	f10a 0210 	add.w	r2, sl, #16
    8340:	461e      	mov	r6, r3
    8342:	6823      	ldr	r3, [r4, #0]
    8344:	6013      	str	r3, [r2, #0]
    8346:	6863      	ldr	r3, [r4, #4]
    8348:	6053      	str	r3, [r2, #4]
    834a:	68a3      	ldr	r3, [r4, #8]
    834c:	6093      	str	r3, [r2, #8]
    834e:	46d1      	mov	r9, sl
    8350:	463c      	mov	r4, r7
    8352:	e730      	b.n	81b6 <_realloc_r+0xfa>
    8354:	4621      	mov	r1, r4
    8356:	f000 fa2d 	bl	87b4 <memmove>
    835a:	e711      	b.n	8180 <_realloc_r+0xc4>
    835c:	e9d0 1302 	ldrd	r1, r3, [r0, #8]
    8360:	4657      	mov	r7, sl
    8362:	60cb      	str	r3, [r1, #12]
    8364:	6099      	str	r1, [r3, #8]
    8366:	f857 1f08 	ldr.w	r1, [r7, #8]!
    836a:	f8da 300c 	ldr.w	r3, [sl, #12]
    836e:	60cb      	str	r3, [r1, #12]
    8370:	1f32      	subs	r2, r6, #4
    8372:	2a24      	cmp	r2, #36	; 0x24
    8374:	6099      	str	r1, [r3, #8]
    8376:	d82d      	bhi.n	83d4 <_realloc_r+0x318>
    8378:	2a13      	cmp	r2, #19
    837a:	d929      	bls.n	83d0 <_realloc_r+0x314>
    837c:	6823      	ldr	r3, [r4, #0]
    837e:	f8ca 3008 	str.w	r3, [sl, #8]
    8382:	6863      	ldr	r3, [r4, #4]
    8384:	f8ca 300c 	str.w	r3, [sl, #12]
    8388:	2a1b      	cmp	r2, #27
    838a:	d842      	bhi.n	8412 <_realloc_r+0x356>
    838c:	3408      	adds	r4, #8
    838e:	f10a 0310 	add.w	r3, sl, #16
    8392:	6822      	ldr	r2, [r4, #0]
    8394:	601a      	str	r2, [r3, #0]
    8396:	6862      	ldr	r2, [r4, #4]
    8398:	605a      	str	r2, [r3, #4]
    839a:	68a2      	ldr	r2, [r4, #8]
    839c:	609a      	str	r2, [r3, #8]
    839e:	4666      	mov	r6, ip
    83a0:	46d1      	mov	r9, sl
    83a2:	463c      	mov	r4, r7
    83a4:	e707      	b.n	81b6 <_realloc_r+0xfa>
    83a6:	68a3      	ldr	r3, [r4, #8]
    83a8:	6083      	str	r3, [r0, #8]
    83aa:	68e3      	ldr	r3, [r4, #12]
    83ac:	60c3      	str	r3, [r0, #12]
    83ae:	2a24      	cmp	r2, #36	; 0x24
    83b0:	d026      	beq.n	8400 <_realloc_r+0x344>
    83b2:	f104 0210 	add.w	r2, r4, #16
    83b6:	f100 0310 	add.w	r3, r0, #16
    83ba:	e6db      	b.n	8174 <_realloc_r+0xb8>
    83bc:	463a      	mov	r2, r7
    83be:	e7bf      	b.n	8340 <_realloc_r+0x284>
    83c0:	4621      	mov	r1, r4
    83c2:	4638      	mov	r0, r7
    83c4:	461e      	mov	r6, r3
    83c6:	46d1      	mov	r9, sl
    83c8:	f000 f9f4 	bl	87b4 <memmove>
    83cc:	463c      	mov	r4, r7
    83ce:	e6f2      	b.n	81b6 <_realloc_r+0xfa>
    83d0:	463b      	mov	r3, r7
    83d2:	e7de      	b.n	8392 <_realloc_r+0x2d6>
    83d4:	4621      	mov	r1, r4
    83d6:	4638      	mov	r0, r7
    83d8:	4666      	mov	r6, ip
    83da:	46d1      	mov	r9, sl
    83dc:	f000 f9ea 	bl	87b4 <memmove>
    83e0:	463c      	mov	r4, r7
    83e2:	e6e8      	b.n	81b6 <_realloc_r+0xfa>
    83e4:	20001350 	.word	0x20001350
    83e8:	68a1      	ldr	r1, [r4, #8]
    83ea:	f8ca 1010 	str.w	r1, [sl, #16]
    83ee:	68e1      	ldr	r1, [r4, #12]
    83f0:	f8ca 1014 	str.w	r1, [sl, #20]
    83f4:	2a24      	cmp	r2, #36	; 0x24
    83f6:	d020      	beq.n	843a <_realloc_r+0x37e>
    83f8:	3410      	adds	r4, #16
    83fa:	f10a 0218 	add.w	r2, sl, #24
    83fe:	e79f      	b.n	8340 <_realloc_r+0x284>
    8400:	6923      	ldr	r3, [r4, #16]
    8402:	6103      	str	r3, [r0, #16]
    8404:	6961      	ldr	r1, [r4, #20]
    8406:	6141      	str	r1, [r0, #20]
    8408:	f104 0218 	add.w	r2, r4, #24
    840c:	f100 0318 	add.w	r3, r0, #24
    8410:	e6b0      	b.n	8174 <_realloc_r+0xb8>
    8412:	68a3      	ldr	r3, [r4, #8]
    8414:	f8ca 3010 	str.w	r3, [sl, #16]
    8418:	68e3      	ldr	r3, [r4, #12]
    841a:	f8ca 3014 	str.w	r3, [sl, #20]
    841e:	2a24      	cmp	r2, #36	; 0x24
    8420:	d021      	beq.n	8466 <_realloc_r+0x3aa>
    8422:	3410      	adds	r4, #16
    8424:	f10a 0318 	add.w	r3, sl, #24
    8428:	e7b3      	b.n	8392 <_realloc_r+0x2d6>
    842a:	463a      	mov	r2, r7
    842c:	e733      	b.n	8296 <_realloc_r+0x1da>
    842e:	4621      	mov	r1, r4
    8430:	4638      	mov	r0, r7
    8432:	f000 f9bf 	bl	87b4 <memmove>
    8436:	4b16      	ldr	r3, [pc, #88]	; (8490 <_realloc_r+0x3d4>)
    8438:	e733      	b.n	82a2 <_realloc_r+0x1e6>
    843a:	6922      	ldr	r2, [r4, #16]
    843c:	f8ca 2018 	str.w	r2, [sl, #24]
    8440:	6962      	ldr	r2, [r4, #20]
    8442:	f8ca 201c 	str.w	r2, [sl, #28]
    8446:	3418      	adds	r4, #24
    8448:	f10a 0220 	add.w	r2, sl, #32
    844c:	e778      	b.n	8340 <_realloc_r+0x284>
    844e:	68a1      	ldr	r1, [r4, #8]
    8450:	f8ca 1010 	str.w	r1, [sl, #16]
    8454:	68e1      	ldr	r1, [r4, #12]
    8456:	f8ca 1014 	str.w	r1, [sl, #20]
    845a:	2a24      	cmp	r2, #36	; 0x24
    845c:	d00d      	beq.n	847a <_realloc_r+0x3be>
    845e:	3410      	adds	r4, #16
    8460:	f10a 0218 	add.w	r2, sl, #24
    8464:	e717      	b.n	8296 <_realloc_r+0x1da>
    8466:	6923      	ldr	r3, [r4, #16]
    8468:	f8ca 3018 	str.w	r3, [sl, #24]
    846c:	6963      	ldr	r3, [r4, #20]
    846e:	f8ca 301c 	str.w	r3, [sl, #28]
    8472:	3418      	adds	r4, #24
    8474:	f10a 0320 	add.w	r3, sl, #32
    8478:	e78b      	b.n	8392 <_realloc_r+0x2d6>
    847a:	6922      	ldr	r2, [r4, #16]
    847c:	f8ca 2018 	str.w	r2, [sl, #24]
    8480:	6962      	ldr	r2, [r4, #20]
    8482:	f8ca 201c 	str.w	r2, [sl, #28]
    8486:	3418      	adds	r4, #24
    8488:	f10a 0220 	add.w	r2, sl, #32
    848c:	e703      	b.n	8296 <_realloc_r+0x1da>
    848e:	bf00      	nop
    8490:	20001350 	.word	0x20001350

00008494 <stdio_exit_handler>:
    8494:	4a02      	ldr	r2, [pc, #8]	; (84a0 <stdio_exit_handler+0xc>)
    8496:	4903      	ldr	r1, [pc, #12]	; (84a4 <stdio_exit_handler+0x10>)
    8498:	4803      	ldr	r0, [pc, #12]	; (84a8 <stdio_exit_handler+0x14>)
    849a:	f000 b8bb 	b.w	8614 <_fwalk_sglue>
    849e:	bf00      	nop
    84a0:	20001760 	.word	0x20001760
    84a4:	0000b18d 	.word	0x0000b18d
    84a8:	20000fe8 	.word	0x20000fe8

000084ac <cleanup_stdio>:
    84ac:	4b0c      	ldr	r3, [pc, #48]	; (84e0 <cleanup_stdio+0x34>)
    84ae:	6841      	ldr	r1, [r0, #4]
    84b0:	4299      	cmp	r1, r3
    84b2:	b510      	push	{r4, lr}
    84b4:	4604      	mov	r4, r0
    84b6:	d001      	beq.n	84bc <cleanup_stdio+0x10>
    84b8:	f002 fe68 	bl	b18c <_fclose_r>
    84bc:	68a1      	ldr	r1, [r4, #8]
    84be:	4b09      	ldr	r3, [pc, #36]	; (84e4 <cleanup_stdio+0x38>)
    84c0:	4299      	cmp	r1, r3
    84c2:	d002      	beq.n	84ca <cleanup_stdio+0x1e>
    84c4:	4620      	mov	r0, r4
    84c6:	f002 fe61 	bl	b18c <_fclose_r>
    84ca:	68e1      	ldr	r1, [r4, #12]
    84cc:	4b06      	ldr	r3, [pc, #24]	; (84e8 <cleanup_stdio+0x3c>)
    84ce:	4299      	cmp	r1, r3
    84d0:	d004      	beq.n	84dc <cleanup_stdio+0x30>
    84d2:	4620      	mov	r0, r4
    84d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    84d8:	f002 be58 	b.w	b18c <_fclose_r>
    84dc:	bd10      	pop	{r4, pc}
    84de:	bf00      	nop
    84e0:	20007398 	.word	0x20007398
    84e4:	20007400 	.word	0x20007400
    84e8:	20007468 	.word	0x20007468

000084ec <global_stdio_init.part.0>:
    84ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    84f0:	4c2a      	ldr	r4, [pc, #168]	; (859c <global_stdio_init.part.0+0xb0>)
    84f2:	4b2b      	ldr	r3, [pc, #172]	; (85a0 <global_stdio_init.part.0+0xb4>)
    84f4:	482b      	ldr	r0, [pc, #172]	; (85a4 <global_stdio_init.part.0+0xb8>)
    84f6:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 85b8 <global_stdio_init.part.0+0xcc>
    84fa:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 85bc <global_stdio_init.part.0+0xd0>
    84fe:	4f2a      	ldr	r7, [pc, #168]	; (85a8 <global_stdio_init.part.0+0xbc>)
    8500:	6018      	str	r0, [r3, #0]
    8502:	2500      	movs	r5, #0
    8504:	2304      	movs	r3, #4
    8506:	2208      	movs	r2, #8
    8508:	4629      	mov	r1, r5
    850a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    850e:	4e27      	ldr	r6, [pc, #156]	; (85ac <global_stdio_init.part.0+0xc0>)
    8510:	6665      	str	r5, [r4, #100]	; 0x64
    8512:	e9c4 5302 	strd	r5, r3, [r4, #8]
    8516:	e9c4 5500 	strd	r5, r5, [r4]
    851a:	e9c4 5504 	strd	r5, r5, [r4, #16]
    851e:	61a5      	str	r5, [r4, #24]
    8520:	f000 f9c4 	bl	88ac <memset>
    8524:	4b22      	ldr	r3, [pc, #136]	; (85b0 <global_stdio_init.part.0+0xc4>)
    8526:	6763      	str	r3, [r4, #116]	; 0x74
    8528:	2208      	movs	r2, #8
    852a:	4629      	mov	r1, r5
    852c:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    8530:	e9c4 4907 	strd	r4, r9, [r4, #28]
    8534:	e9c4 8709 	strd	r8, r7, [r4, #36]	; 0x24
    8538:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
    853c:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
    8540:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
    8544:	6725      	str	r5, [r4, #112]	; 0x70
    8546:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    854a:	62e6      	str	r6, [r4, #44]	; 0x2c
    854c:	f000 f9ae 	bl	88ac <memset>
    8550:	4b18      	ldr	r3, [pc, #96]	; (85b4 <global_stdio_init.part.0+0xc8>)
    8552:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
    8556:	4629      	mov	r1, r5
    8558:	f104 0368 	add.w	r3, r4, #104	; 0x68
    855c:	2208      	movs	r2, #8
    855e:	f504 7096 	add.w	r0, r4, #300	; 0x12c
    8562:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    8566:	e9c4 9822 	strd	r9, r8, [r4, #136]	; 0x88
    856a:	e9c4 7624 	strd	r7, r6, [r4, #144]	; 0x90
    856e:	e9c4 5534 	strd	r5, r5, [r4, #208]	; 0xd0
    8572:	e9c4 5538 	strd	r5, r5, [r4, #224]	; 0xe0
    8576:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
    857a:	f8c4 50d8 	str.w	r5, [r4, #216]	; 0xd8
    857e:	f8c4 50e8 	str.w	r5, [r4, #232]	; 0xe8
    8582:	f000 f993 	bl	88ac <memset>
    8586:	f104 03d0 	add.w	r3, r4, #208	; 0xd0
    858a:	e9c4 983c 	strd	r9, r8, [r4, #240]	; 0xf0
    858e:	e9c4 763e 	strd	r7, r6, [r4, #248]	; 0xf8
    8592:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
    8596:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    859a:	bf00      	nop
    859c:	20007398 	.word	0x20007398
    85a0:	200074d0 	.word	0x200074d0
    85a4:	00008495 	.word	0x00008495
    85a8:	000086c1 	.word	0x000086c1
    85ac:	000086e1 	.word	0x000086e1
    85b0:	00010009 	.word	0x00010009
    85b4:	00020012 	.word	0x00020012
    85b8:	0000865d 	.word	0x0000865d
    85bc:	00008681 	.word	0x00008681

000085c0 <__sinit>:
    85c0:	b510      	push	{r4, lr}
    85c2:	4604      	mov	r4, r0
    85c4:	480a      	ldr	r0, [pc, #40]	; (85f0 <__sinit+0x30>)
    85c6:	f000 fa8f 	bl	8ae8 <__retarget_lock_acquire_recursive>
    85ca:	6b63      	ldr	r3, [r4, #52]	; 0x34
    85cc:	b923      	cbnz	r3, 85d8 <__sinit+0x18>
    85ce:	4b09      	ldr	r3, [pc, #36]	; (85f4 <__sinit+0x34>)
    85d0:	4a09      	ldr	r2, [pc, #36]	; (85f8 <__sinit+0x38>)
    85d2:	681b      	ldr	r3, [r3, #0]
    85d4:	6362      	str	r2, [r4, #52]	; 0x34
    85d6:	b123      	cbz	r3, 85e2 <__sinit+0x22>
    85d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    85dc:	4804      	ldr	r0, [pc, #16]	; (85f0 <__sinit+0x30>)
    85de:	f000 ba85 	b.w	8aec <__retarget_lock_release_recursive>
    85e2:	f7ff ff83 	bl	84ec <global_stdio_init.part.0>
    85e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    85ea:	4801      	ldr	r0, [pc, #4]	; (85f0 <__sinit+0x30>)
    85ec:	f000 ba7e 	b.w	8aec <__retarget_lock_release_recursive>
    85f0:	20007360 	.word	0x20007360
    85f4:	200074d0 	.word	0x200074d0
    85f8:	000084ad 	.word	0x000084ad

000085fc <__sfp_lock_acquire>:
    85fc:	4801      	ldr	r0, [pc, #4]	; (8604 <__sfp_lock_acquire+0x8>)
    85fe:	f000 ba73 	b.w	8ae8 <__retarget_lock_acquire_recursive>
    8602:	bf00      	nop
    8604:	20007360 	.word	0x20007360

00008608 <__sfp_lock_release>:
    8608:	4801      	ldr	r0, [pc, #4]	; (8610 <__sfp_lock_release+0x8>)
    860a:	f000 ba6f 	b.w	8aec <__retarget_lock_release_recursive>
    860e:	bf00      	nop
    8610:	20007360 	.word	0x20007360

00008614 <_fwalk_sglue>:
    8614:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8618:	4680      	mov	r8, r0
    861a:	460f      	mov	r7, r1
    861c:	4616      	mov	r6, r2
    861e:	f04f 0900 	mov.w	r9, #0
    8622:	e9d6 5401 	ldrd	r5, r4, [r6, #4]
    8626:	3d01      	subs	r5, #1
    8628:	d411      	bmi.n	864e <_fwalk_sglue+0x3a>
    862a:	89a3      	ldrh	r3, [r4, #12]
    862c:	2b01      	cmp	r3, #1
    862e:	f105 35ff 	add.w	r5, r5, #4294967295
    8632:	d908      	bls.n	8646 <_fwalk_sglue+0x32>
    8634:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
    8638:	3301      	adds	r3, #1
    863a:	4621      	mov	r1, r4
    863c:	d003      	beq.n	8646 <_fwalk_sglue+0x32>
    863e:	4640      	mov	r0, r8
    8640:	47b8      	blx	r7
    8642:	ea49 0900 	orr.w	r9, r9, r0
    8646:	1c6b      	adds	r3, r5, #1
    8648:	f104 0468 	add.w	r4, r4, #104	; 0x68
    864c:	d1ed      	bne.n	862a <_fwalk_sglue+0x16>
    864e:	6836      	ldr	r6, [r6, #0]
    8650:	2e00      	cmp	r6, #0
    8652:	d1e6      	bne.n	8622 <_fwalk_sglue+0xe>
    8654:	4648      	mov	r0, r9
    8656:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    865a:	bf00      	nop

0000865c <__sread>:
    865c:	b510      	push	{r4, lr}
    865e:	460c      	mov	r4, r1
    8660:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    8664:	f000 f9d4 	bl	8a10 <_read_r>
    8668:	2800      	cmp	r0, #0
    866a:	db03      	blt.n	8674 <__sread+0x18>
    866c:	6d23      	ldr	r3, [r4, #80]	; 0x50
    866e:	4403      	add	r3, r0
    8670:	6523      	str	r3, [r4, #80]	; 0x50
    8672:	bd10      	pop	{r4, pc}
    8674:	89a3      	ldrh	r3, [r4, #12]
    8676:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    867a:	81a3      	strh	r3, [r4, #12]
    867c:	bd10      	pop	{r4, pc}
    867e:	bf00      	nop

00008680 <__swrite>:
    8680:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8684:	460c      	mov	r4, r1
    8686:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
    868a:	461f      	mov	r7, r3
    868c:	05cb      	lsls	r3, r1, #23
    868e:	4605      	mov	r5, r0
    8690:	4616      	mov	r6, r2
    8692:	d40b      	bmi.n	86ac <__swrite+0x2c>
    8694:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
    8698:	81a1      	strh	r1, [r4, #12]
    869a:	463b      	mov	r3, r7
    869c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    86a0:	4632      	mov	r2, r6
    86a2:	4628      	mov	r0, r5
    86a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    86a8:	f000 b9da 	b.w	8a60 <_write_r>
    86ac:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    86b0:	2302      	movs	r3, #2
    86b2:	2200      	movs	r2, #0
    86b4:	f000 f996 	bl	89e4 <_lseek_r>
    86b8:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
    86bc:	e7ea      	b.n	8694 <__swrite+0x14>
    86be:	bf00      	nop

000086c0 <__sseek>:
    86c0:	b510      	push	{r4, lr}
    86c2:	460c      	mov	r4, r1
    86c4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    86c8:	f000 f98c 	bl	89e4 <_lseek_r>
    86cc:	89a3      	ldrh	r3, [r4, #12]
    86ce:	1c42      	adds	r2, r0, #1
    86d0:	bf0e      	itee	eq
    86d2:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    86d6:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    86da:	6520      	strne	r0, [r4, #80]	; 0x50
    86dc:	81a3      	strh	r3, [r4, #12]
    86de:	bd10      	pop	{r4, pc}

000086e0 <__sclose>:
    86e0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    86e4:	f000 b96c 	b.w	89c0 <_close_r>

000086e8 <_vdprintf_r>:
    86e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    86ea:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    86ee:	af04      	add	r7, sp, #16
    86f0:	9300      	str	r3, [sp, #0]
    86f2:	4613      	mov	r3, r2
    86f4:	f44f 7200 	mov.w	r2, #512	; 0x200
    86f8:	460e      	mov	r6, r1
    86fa:	9203      	str	r2, [sp, #12]
    86fc:	4639      	mov	r1, r7
    86fe:	aa03      	add	r2, sp, #12
    8700:	4605      	mov	r5, r0
    8702:	f000 f825 	bl	8750 <_vasnprintf_r>
    8706:	b188      	cbz	r0, 872c <_vdprintf_r+0x44>
    8708:	4604      	mov	r4, r0
    870a:	4602      	mov	r2, r0
    870c:	9b03      	ldr	r3, [sp, #12]
    870e:	4631      	mov	r1, r6
    8710:	4628      	mov	r0, r5
    8712:	f000 f9a5 	bl	8a60 <_write_r>
    8716:	42bc      	cmp	r4, r7
    8718:	9003      	str	r0, [sp, #12]
    871a:	d004      	beq.n	8726 <_vdprintf_r+0x3e>
    871c:	4628      	mov	r0, r5
    871e:	4621      	mov	r1, r4
    8720:	f000 faac 	bl	8c7c <_free_r>
    8724:	9803      	ldr	r0, [sp, #12]
    8726:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    872a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    872c:	f04f 30ff 	mov.w	r0, #4294967295
    8730:	e7f9      	b.n	8726 <_vdprintf_r+0x3e>
    8732:	bf00      	nop

00008734 <vdprintf>:
    8734:	b410      	push	{r4}
    8736:	4c05      	ldr	r4, [pc, #20]	; (874c <vdprintf+0x18>)
    8738:	4684      	mov	ip, r0
    873a:	4613      	mov	r3, r2
    873c:	6820      	ldr	r0, [r4, #0]
    873e:	f85d 4b04 	ldr.w	r4, [sp], #4
    8742:	460a      	mov	r2, r1
    8744:	4661      	mov	r1, ip
    8746:	f7ff bfcf 	b.w	86e8 <_vdprintf_r>
    874a:	bf00      	nop
    874c:	2000176c 	.word	0x2000176c

00008750 <_vasnprintf_r>:
    8750:	b530      	push	{r4, r5, lr}
    8752:	6814      	ldr	r4, [r2, #0]
    8754:	4615      	mov	r5, r2
    8756:	b09b      	sub	sp, #108	; 0x6c
    8758:	461a      	mov	r2, r3
    875a:	b109      	cbz	r1, 8760 <_vasnprintf_r+0x10>
    875c:	2c00      	cmp	r4, #0
    875e:	d119      	bne.n	8794 <_vasnprintf_r+0x44>
    8760:	2100      	movs	r1, #0
    8762:	f44f 7322 	mov.w	r3, #648	; 0x288
    8766:	f8ad 300c 	strh.w	r3, [sp, #12]
    876a:	9100      	str	r1, [sp, #0]
    876c:	9104      	str	r1, [sp, #16]
    876e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8772:	9102      	str	r1, [sp, #8]
    8774:	9105      	str	r1, [sp, #20]
    8776:	f8ad 300e 	strh.w	r3, [sp, #14]
    877a:	4669      	mov	r1, sp
    877c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    877e:	f000 ff63 	bl	9648 <_svfprintf_r>
    8782:	2800      	cmp	r0, #0
    8784:	db13      	blt.n	87ae <_vasnprintf_r+0x5e>
    8786:	9b00      	ldr	r3, [sp, #0]
    8788:	6028      	str	r0, [r5, #0]
    878a:	2200      	movs	r2, #0
    878c:	701a      	strb	r2, [r3, #0]
    878e:	9804      	ldr	r0, [sp, #16]
    8790:	b01b      	add	sp, #108	; 0x6c
    8792:	bd30      	pop	{r4, r5, pc}
    8794:	f44f 63c1 	mov.w	r3, #1544	; 0x608
    8798:	9100      	str	r1, [sp, #0]
    879a:	9104      	str	r1, [sp, #16]
    879c:	f8ad 300c 	strh.w	r3, [sp, #12]
    87a0:	4621      	mov	r1, r4
    87a2:	dae4      	bge.n	876e <_vasnprintf_r+0x1e>
    87a4:	238b      	movs	r3, #139	; 0x8b
    87a6:	6003      	str	r3, [r0, #0]
    87a8:	2000      	movs	r0, #0
    87aa:	b01b      	add	sp, #108	; 0x6c
    87ac:	bd30      	pop	{r4, r5, pc}
    87ae:	2000      	movs	r0, #0
    87b0:	e7ee      	b.n	8790 <_vasnprintf_r+0x40>
    87b2:	bf00      	nop

000087b4 <memmove>:
    87b4:	4288      	cmp	r0, r1
    87b6:	d90d      	bls.n	87d4 <memmove+0x20>
    87b8:	188b      	adds	r3, r1, r2
    87ba:	4283      	cmp	r3, r0
    87bc:	d90a      	bls.n	87d4 <memmove+0x20>
    87be:	eb00 0c02 	add.w	ip, r0, r2
    87c2:	b1ba      	cbz	r2, 87f4 <memmove+0x40>
    87c4:	4662      	mov	r2, ip
    87c6:	f813 cd01 	ldrb.w	ip, [r3, #-1]!
    87ca:	f802 cd01 	strb.w	ip, [r2, #-1]!
    87ce:	4299      	cmp	r1, r3
    87d0:	d1f9      	bne.n	87c6 <memmove+0x12>
    87d2:	4770      	bx	lr
    87d4:	2a0f      	cmp	r2, #15
    87d6:	d80e      	bhi.n	87f6 <memmove+0x42>
    87d8:	4603      	mov	r3, r0
    87da:	f102 3cff 	add.w	ip, r2, #4294967295
    87de:	b14a      	cbz	r2, 87f4 <memmove+0x40>
    87e0:	f10c 0c01 	add.w	ip, ip, #1
    87e4:	3b01      	subs	r3, #1
    87e6:	448c      	add	ip, r1
    87e8:	f811 2b01 	ldrb.w	r2, [r1], #1
    87ec:	f803 2f01 	strb.w	r2, [r3, #1]!
    87f0:	4561      	cmp	r1, ip
    87f2:	d1f9      	bne.n	87e8 <memmove+0x34>
    87f4:	4770      	bx	lr
    87f6:	ea40 0301 	orr.w	r3, r0, r1
    87fa:	079b      	lsls	r3, r3, #30
    87fc:	d150      	bne.n	88a0 <memmove+0xec>
    87fe:	f1a2 0310 	sub.w	r3, r2, #16
    8802:	b570      	push	{r4, r5, r6, lr}
    8804:	f101 0c20 	add.w	ip, r1, #32
    8808:	f023 050f 	bic.w	r5, r3, #15
    880c:	f101 0e10 	add.w	lr, r1, #16
    8810:	f100 0410 	add.w	r4, r0, #16
    8814:	44ac      	add	ip, r5
    8816:	091b      	lsrs	r3, r3, #4
    8818:	f85e 5c10 	ldr.w	r5, [lr, #-16]
    881c:	f844 5c10 	str.w	r5, [r4, #-16]
    8820:	f85e 5c0c 	ldr.w	r5, [lr, #-12]
    8824:	f844 5c0c 	str.w	r5, [r4, #-12]
    8828:	f85e 5c08 	ldr.w	r5, [lr, #-8]
    882c:	f844 5c08 	str.w	r5, [r4, #-8]
    8830:	f85e 5c04 	ldr.w	r5, [lr, #-4]
    8834:	f844 5c04 	str.w	r5, [r4, #-4]
    8838:	f10e 0e10 	add.w	lr, lr, #16
    883c:	45e6      	cmp	lr, ip
    883e:	f104 0410 	add.w	r4, r4, #16
    8842:	d1e9      	bne.n	8818 <memmove+0x64>
    8844:	3301      	adds	r3, #1
    8846:	f012 0f0c 	tst.w	r2, #12
    884a:	eb01 1103 	add.w	r1, r1, r3, lsl #4
    884e:	f002 040f 	and.w	r4, r2, #15
    8852:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    8856:	d027      	beq.n	88a8 <memmove+0xf4>
    8858:	3c04      	subs	r4, #4
    885a:	f024 0603 	bic.w	r6, r4, #3
    885e:	ea4f 0c94 	mov.w	ip, r4, lsr #2
    8862:	441e      	add	r6, r3
    8864:	1f1c      	subs	r4, r3, #4
    8866:	468e      	mov	lr, r1
    8868:	f85e 5b04 	ldr.w	r5, [lr], #4
    886c:	f844 5f04 	str.w	r5, [r4, #4]!
    8870:	42b4      	cmp	r4, r6
    8872:	d1f9      	bne.n	8868 <memmove+0xb4>
    8874:	f10c 0401 	add.w	r4, ip, #1
    8878:	f002 0203 	and.w	r2, r2, #3
    887c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    8880:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    8884:	f102 3cff 	add.w	ip, r2, #4294967295
    8888:	b14a      	cbz	r2, 889e <memmove+0xea>
    888a:	f10c 0c01 	add.w	ip, ip, #1
    888e:	3b01      	subs	r3, #1
    8890:	448c      	add	ip, r1
    8892:	f811 2b01 	ldrb.w	r2, [r1], #1
    8896:	f803 2f01 	strb.w	r2, [r3, #1]!
    889a:	4561      	cmp	r1, ip
    889c:	d1f9      	bne.n	8892 <memmove+0xde>
    889e:	bd70      	pop	{r4, r5, r6, pc}
    88a0:	f102 3cff 	add.w	ip, r2, #4294967295
    88a4:	4603      	mov	r3, r0
    88a6:	e79b      	b.n	87e0 <memmove+0x2c>
    88a8:	4622      	mov	r2, r4
    88aa:	e7eb      	b.n	8884 <memmove+0xd0>

000088ac <memset>:
    88ac:	0783      	lsls	r3, r0, #30
    88ae:	b530      	push	{r4, r5, lr}
    88b0:	d048      	beq.n	8944 <memset+0x98>
    88b2:	1e54      	subs	r4, r2, #1
    88b4:	2a00      	cmp	r2, #0
    88b6:	d03f      	beq.n	8938 <memset+0x8c>
    88b8:	b2ca      	uxtb	r2, r1
    88ba:	4603      	mov	r3, r0
    88bc:	e001      	b.n	88c2 <memset+0x16>
    88be:	3c01      	subs	r4, #1
    88c0:	d33a      	bcc.n	8938 <memset+0x8c>
    88c2:	f803 2b01 	strb.w	r2, [r3], #1
    88c6:	079d      	lsls	r5, r3, #30
    88c8:	d1f9      	bne.n	88be <memset+0x12>
    88ca:	2c03      	cmp	r4, #3
    88cc:	d92d      	bls.n	892a <memset+0x7e>
    88ce:	b2cd      	uxtb	r5, r1
    88d0:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    88d4:	2c0f      	cmp	r4, #15
    88d6:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    88da:	d936      	bls.n	894a <memset+0x9e>
    88dc:	f1a4 0210 	sub.w	r2, r4, #16
    88e0:	f022 0c0f 	bic.w	ip, r2, #15
    88e4:	f103 0e20 	add.w	lr, r3, #32
    88e8:	44e6      	add	lr, ip
    88ea:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    88ee:	f103 0210 	add.w	r2, r3, #16
    88f2:	e942 5504 	strd	r5, r5, [r2, #-16]
    88f6:	e942 5502 	strd	r5, r5, [r2, #-8]
    88fa:	3210      	adds	r2, #16
    88fc:	4572      	cmp	r2, lr
    88fe:	d1f8      	bne.n	88f2 <memset+0x46>
    8900:	f10c 0201 	add.w	r2, ip, #1
    8904:	f014 0f0c 	tst.w	r4, #12
    8908:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    890c:	f004 0c0f 	and.w	ip, r4, #15
    8910:	d013      	beq.n	893a <memset+0x8e>
    8912:	f1ac 0304 	sub.w	r3, ip, #4
    8916:	f023 0303 	bic.w	r3, r3, #3
    891a:	3304      	adds	r3, #4
    891c:	4413      	add	r3, r2
    891e:	f842 5b04 	str.w	r5, [r2], #4
    8922:	4293      	cmp	r3, r2
    8924:	d1fb      	bne.n	891e <memset+0x72>
    8926:	f00c 0403 	and.w	r4, ip, #3
    892a:	b12c      	cbz	r4, 8938 <memset+0x8c>
    892c:	b2c9      	uxtb	r1, r1
    892e:	441c      	add	r4, r3
    8930:	f803 1b01 	strb.w	r1, [r3], #1
    8934:	429c      	cmp	r4, r3
    8936:	d1fb      	bne.n	8930 <memset+0x84>
    8938:	bd30      	pop	{r4, r5, pc}
    893a:	4664      	mov	r4, ip
    893c:	4613      	mov	r3, r2
    893e:	2c00      	cmp	r4, #0
    8940:	d1f4      	bne.n	892c <memset+0x80>
    8942:	e7f9      	b.n	8938 <memset+0x8c>
    8944:	4603      	mov	r3, r0
    8946:	4614      	mov	r4, r2
    8948:	e7bf      	b.n	88ca <memset+0x1e>
    894a:	461a      	mov	r2, r3
    894c:	46a4      	mov	ip, r4
    894e:	e7e0      	b.n	8912 <memset+0x66>

00008950 <strncpy>:
    8950:	ea40 0301 	orr.w	r3, r0, r1
    8954:	079b      	lsls	r3, r3, #30
    8956:	b530      	push	{r4, r5, lr}
    8958:	d101      	bne.n	895e <strncpy+0xe>
    895a:	2a03      	cmp	r2, #3
    895c:	d80f      	bhi.n	897e <strncpy+0x2e>
    895e:	4684      	mov	ip, r0
    8960:	f101 3eff 	add.w	lr, r1, #4294967295
    8964:	e007      	b.n	8976 <strncpy+0x26>
    8966:	f81e 1f01 	ldrb.w	r1, [lr, #1]!
    896a:	f803 1b01 	strb.w	r1, [r3], #1
    896e:	1e54      	subs	r4, r2, #1
    8970:	b1c1      	cbz	r1, 89a4 <strncpy+0x54>
    8972:	469c      	mov	ip, r3
    8974:	4622      	mov	r2, r4
    8976:	4663      	mov	r3, ip
    8978:	2a00      	cmp	r2, #0
    897a:	d1f4      	bne.n	8966 <strncpy+0x16>
    897c:	bd30      	pop	{r4, r5, pc}
    897e:	460b      	mov	r3, r1
    8980:	4684      	mov	ip, r0
    8982:	4619      	mov	r1, r3
    8984:	f853 5b04 	ldr.w	r5, [r3], #4
    8988:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
    898c:	ea24 0405 	bic.w	r4, r4, r5
    8990:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
    8994:	d1e4      	bne.n	8960 <strncpy+0x10>
    8996:	3a04      	subs	r2, #4
    8998:	2a03      	cmp	r2, #3
    899a:	f84c 5b04 	str.w	r5, [ip], #4
    899e:	4619      	mov	r1, r3
    89a0:	d8ef      	bhi.n	8982 <strncpy+0x32>
    89a2:	e7dd      	b.n	8960 <strncpy+0x10>
    89a4:	4494      	add	ip, r2
    89a6:	2c00      	cmp	r4, #0
    89a8:	d0e8      	beq.n	897c <strncpy+0x2c>
    89aa:	f803 1b01 	strb.w	r1, [r3], #1
    89ae:	4563      	cmp	r3, ip
    89b0:	d1fb      	bne.n	89aa <strncpy+0x5a>
    89b2:	bd30      	pop	{r4, r5, pc}

000089b4 <__locale_mb_cur_max>:
    89b4:	4b01      	ldr	r3, [pc, #4]	; (89bc <__locale_mb_cur_max+0x8>)
    89b6:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
    89ba:	4770      	bx	lr
    89bc:	200011e4 	.word	0x200011e4

000089c0 <_close_r>:
    89c0:	b538      	push	{r3, r4, r5, lr}
    89c2:	4d07      	ldr	r5, [pc, #28]	; (89e0 <_close_r+0x20>)
    89c4:	2200      	movs	r2, #0
    89c6:	4604      	mov	r4, r0
    89c8:	4608      	mov	r0, r1
    89ca:	602a      	str	r2, [r5, #0]
    89cc:	f7fd ff9c 	bl	6908 <_close>
    89d0:	1c43      	adds	r3, r0, #1
    89d2:	d000      	beq.n	89d6 <_close_r+0x16>
    89d4:	bd38      	pop	{r3, r4, r5, pc}
    89d6:	682b      	ldr	r3, [r5, #0]
    89d8:	2b00      	cmp	r3, #0
    89da:	d0fb      	beq.n	89d4 <_close_r+0x14>
    89dc:	6023      	str	r3, [r4, #0]
    89de:	bd38      	pop	{r3, r4, r5, pc}
    89e0:	200074e8 	.word	0x200074e8

000089e4 <_lseek_r>:
    89e4:	b538      	push	{r3, r4, r5, lr}
    89e6:	460c      	mov	r4, r1
    89e8:	4d08      	ldr	r5, [pc, #32]	; (8a0c <_lseek_r+0x28>)
    89ea:	4684      	mov	ip, r0
    89ec:	4611      	mov	r1, r2
    89ee:	4620      	mov	r0, r4
    89f0:	461a      	mov	r2, r3
    89f2:	2300      	movs	r3, #0
    89f4:	602b      	str	r3, [r5, #0]
    89f6:	4664      	mov	r4, ip
    89f8:	f7fd ff92 	bl	6920 <_lseek>
    89fc:	1c43      	adds	r3, r0, #1
    89fe:	d000      	beq.n	8a02 <_lseek_r+0x1e>
    8a00:	bd38      	pop	{r3, r4, r5, pc}
    8a02:	682b      	ldr	r3, [r5, #0]
    8a04:	2b00      	cmp	r3, #0
    8a06:	d0fb      	beq.n	8a00 <_lseek_r+0x1c>
    8a08:	6023      	str	r3, [r4, #0]
    8a0a:	bd38      	pop	{r3, r4, r5, pc}
    8a0c:	200074e8 	.word	0x200074e8

00008a10 <_read_r>:
    8a10:	b538      	push	{r3, r4, r5, lr}
    8a12:	460c      	mov	r4, r1
    8a14:	4d08      	ldr	r5, [pc, #32]	; (8a38 <_read_r+0x28>)
    8a16:	4684      	mov	ip, r0
    8a18:	4611      	mov	r1, r2
    8a1a:	4620      	mov	r0, r4
    8a1c:	461a      	mov	r2, r3
    8a1e:	2300      	movs	r3, #0
    8a20:	602b      	str	r3, [r5, #0]
    8a22:	4664      	mov	r4, ip
    8a24:	f7fd ff6e 	bl	6904 <_read>
    8a28:	1c43      	adds	r3, r0, #1
    8a2a:	d000      	beq.n	8a2e <_read_r+0x1e>
    8a2c:	bd38      	pop	{r3, r4, r5, pc}
    8a2e:	682b      	ldr	r3, [r5, #0]
    8a30:	2b00      	cmp	r3, #0
    8a32:	d0fb      	beq.n	8a2c <_read_r+0x1c>
    8a34:	6023      	str	r3, [r4, #0]
    8a36:	bd38      	pop	{r3, r4, r5, pc}
    8a38:	200074e8 	.word	0x200074e8

00008a3c <_sbrk_r>:
    8a3c:	b538      	push	{r3, r4, r5, lr}
    8a3e:	4d07      	ldr	r5, [pc, #28]	; (8a5c <_sbrk_r+0x20>)
    8a40:	2200      	movs	r2, #0
    8a42:	4604      	mov	r4, r0
    8a44:	4608      	mov	r0, r1
    8a46:	602a      	str	r2, [r5, #0]
    8a48:	f7fd ff42 	bl	68d0 <_sbrk>
    8a4c:	1c43      	adds	r3, r0, #1
    8a4e:	d000      	beq.n	8a52 <_sbrk_r+0x16>
    8a50:	bd38      	pop	{r3, r4, r5, pc}
    8a52:	682b      	ldr	r3, [r5, #0]
    8a54:	2b00      	cmp	r3, #0
    8a56:	d0fb      	beq.n	8a50 <_sbrk_r+0x14>
    8a58:	6023      	str	r3, [r4, #0]
    8a5a:	bd38      	pop	{r3, r4, r5, pc}
    8a5c:	200074e8 	.word	0x200074e8

00008a60 <_write_r>:
    8a60:	b538      	push	{r3, r4, r5, lr}
    8a62:	460c      	mov	r4, r1
    8a64:	4d08      	ldr	r5, [pc, #32]	; (8a88 <_write_r+0x28>)
    8a66:	4684      	mov	ip, r0
    8a68:	4611      	mov	r1, r2
    8a6a:	4620      	mov	r0, r4
    8a6c:	461a      	mov	r2, r3
    8a6e:	2300      	movs	r3, #0
    8a70:	602b      	str	r3, [r5, #0]
    8a72:	4664      	mov	r4, ip
    8a74:	f7fc feea 	bl	584c <_write>
    8a78:	1c43      	adds	r3, r0, #1
    8a7a:	d000      	beq.n	8a7e <_write_r+0x1e>
    8a7c:	bd38      	pop	{r3, r4, r5, pc}
    8a7e:	682b      	ldr	r3, [r5, #0]
    8a80:	2b00      	cmp	r3, #0
    8a82:	d0fb      	beq.n	8a7c <_write_r+0x1c>
    8a84:	6023      	str	r3, [r4, #0]
    8a86:	bd38      	pop	{r3, r4, r5, pc}
    8a88:	200074e8 	.word	0x200074e8

00008a8c <__errno>:
    8a8c:	4b01      	ldr	r3, [pc, #4]	; (8a94 <__errno+0x8>)
    8a8e:	6818      	ldr	r0, [r3, #0]
    8a90:	4770      	bx	lr
    8a92:	bf00      	nop
    8a94:	2000176c 	.word	0x2000176c

00008a98 <__libc_init_array>:
    8a98:	b570      	push	{r4, r5, r6, lr}
    8a9a:	4e0d      	ldr	r6, [pc, #52]	; (8ad0 <__libc_init_array+0x38>)
    8a9c:	4d0d      	ldr	r5, [pc, #52]	; (8ad4 <__libc_init_array+0x3c>)
    8a9e:	1b76      	subs	r6, r6, r5
    8aa0:	10b6      	asrs	r6, r6, #2
    8aa2:	d006      	beq.n	8ab2 <__libc_init_array+0x1a>
    8aa4:	2400      	movs	r4, #0
    8aa6:	f855 3b04 	ldr.w	r3, [r5], #4
    8aaa:	3401      	adds	r4, #1
    8aac:	4798      	blx	r3
    8aae:	42a6      	cmp	r6, r4
    8ab0:	d1f9      	bne.n	8aa6 <__libc_init_array+0xe>
    8ab2:	4e09      	ldr	r6, [pc, #36]	; (8ad8 <__libc_init_array+0x40>)
    8ab4:	4d09      	ldr	r5, [pc, #36]	; (8adc <__libc_init_array+0x44>)
    8ab6:	1b76      	subs	r6, r6, r5
    8ab8:	f005 f97a 	bl	ddb0 <___init_veneer>
    8abc:	10b6      	asrs	r6, r6, #2
    8abe:	d006      	beq.n	8ace <__libc_init_array+0x36>
    8ac0:	2400      	movs	r4, #0
    8ac2:	f855 3b04 	ldr.w	r3, [r5], #4
    8ac6:	3401      	adds	r4, #1
    8ac8:	4798      	blx	r3
    8aca:	42a6      	cmp	r6, r4
    8acc:	d1f9      	bne.n	8ac2 <__libc_init_array+0x2a>
    8ace:	bd70      	pop	{r4, r5, r6, pc}
    8ad0:	60001af0 	.word	0x60001af0
    8ad4:	60001af0 	.word	0x60001af0
    8ad8:	60001b0c 	.word	0x60001b0c
    8adc:	60001af0 	.word	0x60001af0

00008ae0 <__retarget_lock_init_recursive>:
    8ae0:	4770      	bx	lr
    8ae2:	bf00      	nop

00008ae4 <__retarget_lock_close_recursive>:
    8ae4:	4770      	bx	lr
    8ae6:	bf00      	nop

00008ae8 <__retarget_lock_acquire_recursive>:
    8ae8:	4770      	bx	lr
    8aea:	bf00      	nop

00008aec <__retarget_lock_release_recursive>:
    8aec:	4770      	bx	lr
    8aee:	bf00      	nop
	...

00008b00 <strlen>:
    8b00:	f890 f000 	pld	[r0]
    8b04:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    8b08:	f020 0107 	bic.w	r1, r0, #7
    8b0c:	f06f 0c00 	mvn.w	ip, #0
    8b10:	f010 0407 	ands.w	r4, r0, #7
    8b14:	f891 f020 	pld	[r1, #32]
    8b18:	f040 8049 	bne.w	8bae <strlen+0xae>
    8b1c:	f04f 0400 	mov.w	r4, #0
    8b20:	f06f 0007 	mvn.w	r0, #7
    8b24:	e9d1 2300 	ldrd	r2, r3, [r1]
    8b28:	f891 f040 	pld	[r1, #64]	; 0x40
    8b2c:	f100 0008 	add.w	r0, r0, #8
    8b30:	fa82 f24c 	uadd8	r2, r2, ip
    8b34:	faa4 f28c 	sel	r2, r4, ip
    8b38:	fa83 f34c 	uadd8	r3, r3, ip
    8b3c:	faa2 f38c 	sel	r3, r2, ip
    8b40:	bb4b      	cbnz	r3, 8b96 <strlen+0x96>
    8b42:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    8b46:	fa82 f24c 	uadd8	r2, r2, ip
    8b4a:	f100 0008 	add.w	r0, r0, #8
    8b4e:	faa4 f28c 	sel	r2, r4, ip
    8b52:	fa83 f34c 	uadd8	r3, r3, ip
    8b56:	faa2 f38c 	sel	r3, r2, ip
    8b5a:	b9e3      	cbnz	r3, 8b96 <strlen+0x96>
    8b5c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    8b60:	fa82 f24c 	uadd8	r2, r2, ip
    8b64:	f100 0008 	add.w	r0, r0, #8
    8b68:	faa4 f28c 	sel	r2, r4, ip
    8b6c:	fa83 f34c 	uadd8	r3, r3, ip
    8b70:	faa2 f38c 	sel	r3, r2, ip
    8b74:	b97b      	cbnz	r3, 8b96 <strlen+0x96>
    8b76:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    8b7a:	f101 0120 	add.w	r1, r1, #32
    8b7e:	fa82 f24c 	uadd8	r2, r2, ip
    8b82:	f100 0008 	add.w	r0, r0, #8
    8b86:	faa4 f28c 	sel	r2, r4, ip
    8b8a:	fa83 f34c 	uadd8	r3, r3, ip
    8b8e:	faa2 f38c 	sel	r3, r2, ip
    8b92:	2b00      	cmp	r3, #0
    8b94:	d0c6      	beq.n	8b24 <strlen+0x24>
    8b96:	2a00      	cmp	r2, #0
    8b98:	bf04      	itt	eq
    8b9a:	3004      	addeq	r0, #4
    8b9c:	461a      	moveq	r2, r3
    8b9e:	ba12      	rev	r2, r2
    8ba0:	fab2 f282 	clz	r2, r2
    8ba4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    8ba8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    8bac:	4770      	bx	lr
    8bae:	e9d1 2300 	ldrd	r2, r3, [r1]
    8bb2:	f004 0503 	and.w	r5, r4, #3
    8bb6:	f1c4 0000 	rsb	r0, r4, #0
    8bba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    8bbe:	f014 0f04 	tst.w	r4, #4
    8bc2:	f891 f040 	pld	[r1, #64]	; 0x40
    8bc6:	fa0c f505 	lsl.w	r5, ip, r5
    8bca:	ea62 0205 	orn	r2, r2, r5
    8bce:	bf1c      	itt	ne
    8bd0:	ea63 0305 	ornne	r3, r3, r5
    8bd4:	4662      	movne	r2, ip
    8bd6:	f04f 0400 	mov.w	r4, #0
    8bda:	e7a9      	b.n	8b30 <strlen+0x30>

00008bdc <_malloc_trim_r>:
    8bdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8bde:	4f24      	ldr	r7, [pc, #144]	; (8c70 <_malloc_trim_r+0x94>)
    8be0:	460c      	mov	r4, r1
    8be2:	4606      	mov	r6, r0
    8be4:	f7ff fa5e 	bl	80a4 <__malloc_lock>
    8be8:	68bb      	ldr	r3, [r7, #8]
    8bea:	685d      	ldr	r5, [r3, #4]
    8bec:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
    8bf0:	310f      	adds	r1, #15
    8bf2:	f025 0503 	bic.w	r5, r5, #3
    8bf6:	194b      	adds	r3, r1, r5
    8bf8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
    8bfc:	f023 030f 	bic.w	r3, r3, #15
    8c00:	f5a3 5480 	sub.w	r4, r3, #4096	; 0x1000
    8c04:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    8c08:	db07      	blt.n	8c1a <_malloc_trim_r+0x3e>
    8c0a:	2100      	movs	r1, #0
    8c0c:	4630      	mov	r0, r6
    8c0e:	f7ff ff15 	bl	8a3c <_sbrk_r>
    8c12:	68bb      	ldr	r3, [r7, #8]
    8c14:	442b      	add	r3, r5
    8c16:	4298      	cmp	r0, r3
    8c18:	d004      	beq.n	8c24 <_malloc_trim_r+0x48>
    8c1a:	4630      	mov	r0, r6
    8c1c:	f7ff fa48 	bl	80b0 <__malloc_unlock>
    8c20:	2000      	movs	r0, #0
    8c22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8c24:	4261      	negs	r1, r4
    8c26:	4630      	mov	r0, r6
    8c28:	f7ff ff08 	bl	8a3c <_sbrk_r>
    8c2c:	3001      	adds	r0, #1
    8c2e:	d00d      	beq.n	8c4c <_malloc_trim_r+0x70>
    8c30:	4a10      	ldr	r2, [pc, #64]	; (8c74 <_malloc_trim_r+0x98>)
    8c32:	68bb      	ldr	r3, [r7, #8]
    8c34:	1b2d      	subs	r5, r5, r4
    8c36:	f045 0501 	orr.w	r5, r5, #1
    8c3a:	605d      	str	r5, [r3, #4]
    8c3c:	6813      	ldr	r3, [r2, #0]
    8c3e:	4630      	mov	r0, r6
    8c40:	1b1b      	subs	r3, r3, r4
    8c42:	6013      	str	r3, [r2, #0]
    8c44:	f7ff fa34 	bl	80b0 <__malloc_unlock>
    8c48:	2001      	movs	r0, #1
    8c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8c4c:	2100      	movs	r1, #0
    8c4e:	4630      	mov	r0, r6
    8c50:	f7ff fef4 	bl	8a3c <_sbrk_r>
    8c54:	68ba      	ldr	r2, [r7, #8]
    8c56:	1a83      	subs	r3, r0, r2
    8c58:	2b0f      	cmp	r3, #15
    8c5a:	ddde      	ble.n	8c1a <_malloc_trim_r+0x3e>
    8c5c:	f043 0301 	orr.w	r3, r3, #1
    8c60:	6053      	str	r3, [r2, #4]
    8c62:	4b05      	ldr	r3, [pc, #20]	; (8c78 <_malloc_trim_r+0x9c>)
    8c64:	4903      	ldr	r1, [pc, #12]	; (8c74 <_malloc_trim_r+0x98>)
    8c66:	681b      	ldr	r3, [r3, #0]
    8c68:	1ac0      	subs	r0, r0, r3
    8c6a:	6008      	str	r0, [r1, #0]
    8c6c:	e7d5      	b.n	8c1a <_malloc_trim_r+0x3e>
    8c6e:	bf00      	nop
    8c70:	20001350 	.word	0x20001350
    8c74:	20007364 	.word	0x20007364
    8c78:	20001758 	.word	0x20001758

00008c7c <_free_r>:
    8c7c:	2900      	cmp	r1, #0
    8c7e:	d061      	beq.n	8d44 <_free_r+0xc8>
    8c80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8c82:	460c      	mov	r4, r1
    8c84:	4606      	mov	r6, r0
    8c86:	f7ff fa0d 	bl	80a4 <__malloc_lock>
    8c8a:	f854 2c04 	ldr.w	r2, [r4, #-4]
    8c8e:	4f7b      	ldr	r7, [pc, #492]	; (8e7c <_free_r+0x200>)
    8c90:	f1a4 0508 	sub.w	r5, r4, #8
    8c94:	f022 0101 	bic.w	r1, r2, #1
    8c98:	eb05 0c01 	add.w	ip, r5, r1
    8c9c:	68b8      	ldr	r0, [r7, #8]
    8c9e:	f8dc 3004 	ldr.w	r3, [ip, #4]
    8ca2:	4560      	cmp	r0, ip
    8ca4:	f023 0303 	bic.w	r3, r3, #3
    8ca8:	f000 808b 	beq.w	8dc2 <_free_r+0x146>
    8cac:	07d2      	lsls	r2, r2, #31
    8cae:	f8cc 3004 	str.w	r3, [ip, #4]
    8cb2:	d432      	bmi.n	8d1a <_free_r+0x9e>
    8cb4:	f854 2c08 	ldr.w	r2, [r4, #-8]
    8cb8:	1aad      	subs	r5, r5, r2
    8cba:	4411      	add	r1, r2
    8cbc:	68aa      	ldr	r2, [r5, #8]
    8cbe:	f107 0008 	add.w	r0, r7, #8
    8cc2:	4282      	cmp	r2, r0
    8cc4:	d06a      	beq.n	8d9c <_free_r+0x120>
    8cc6:	eb0c 0403 	add.w	r4, ip, r3
    8cca:	f8d4 e004 	ldr.w	lr, [r4, #4]
    8cce:	68ec      	ldr	r4, [r5, #12]
    8cd0:	60d4      	str	r4, [r2, #12]
    8cd2:	f01e 0f01 	tst.w	lr, #1
    8cd6:	60a2      	str	r2, [r4, #8]
    8cd8:	f000 8097 	beq.w	8e0a <_free_r+0x18e>
    8cdc:	f041 0301 	orr.w	r3, r1, #1
    8ce0:	606b      	str	r3, [r5, #4]
    8ce2:	f8cc 1000 	str.w	r1, [ip]
    8ce6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    8cea:	d235      	bcs.n	8d58 <_free_r+0xdc>
    8cec:	6878      	ldr	r0, [r7, #4]
    8cee:	08cb      	lsrs	r3, r1, #3
    8cf0:	2201      	movs	r2, #1
    8cf2:	0949      	lsrs	r1, r1, #5
    8cf4:	3301      	adds	r3, #1
    8cf6:	408a      	lsls	r2, r1
    8cf8:	4302      	orrs	r2, r0
    8cfa:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
    8cfe:	607a      	str	r2, [r7, #4]
    8d00:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    8d04:	3a08      	subs	r2, #8
    8d06:	e9c5 1202 	strd	r1, r2, [r5, #8]
    8d0a:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
    8d0e:	60cd      	str	r5, [r1, #12]
    8d10:	4630      	mov	r0, r6
    8d12:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8d16:	f7ff b9cb 	b.w	80b0 <__malloc_unlock>
    8d1a:	eb0c 0203 	add.w	r2, ip, r3
    8d1e:	6852      	ldr	r2, [r2, #4]
    8d20:	07d0      	lsls	r0, r2, #31
    8d22:	d410      	bmi.n	8d46 <_free_r+0xca>
    8d24:	4419      	add	r1, r3
    8d26:	f107 0008 	add.w	r0, r7, #8
    8d2a:	f8dc 3008 	ldr.w	r3, [ip, #8]
    8d2e:	4283      	cmp	r3, r0
    8d30:	d073      	beq.n	8e1a <_free_r+0x19e>
    8d32:	f8dc 200c 	ldr.w	r2, [ip, #12]
    8d36:	60da      	str	r2, [r3, #12]
    8d38:	6093      	str	r3, [r2, #8]
    8d3a:	f041 0301 	orr.w	r3, r1, #1
    8d3e:	606b      	str	r3, [r5, #4]
    8d40:	5069      	str	r1, [r5, r1]
    8d42:	e7d0      	b.n	8ce6 <_free_r+0x6a>
    8d44:	4770      	bx	lr
    8d46:	f041 0301 	orr.w	r3, r1, #1
    8d4a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    8d4e:	f844 3c04 	str.w	r3, [r4, #-4]
    8d52:	f8cc 1000 	str.w	r1, [ip]
    8d56:	d3c9      	bcc.n	8cec <_free_r+0x70>
    8d58:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
    8d5c:	ea4f 2351 	mov.w	r3, r1, lsr #9
    8d60:	d248      	bcs.n	8df4 <_free_r+0x178>
    8d62:	098b      	lsrs	r3, r1, #6
    8d64:	f103 0039 	add.w	r0, r3, #57	; 0x39
    8d68:	f103 0238 	add.w	r2, r3, #56	; 0x38
    8d6c:	00c3      	lsls	r3, r0, #3
    8d6e:	18f8      	adds	r0, r7, r3
    8d70:	58fb      	ldr	r3, [r7, r3]
    8d72:	3808      	subs	r0, #8
    8d74:	4298      	cmp	r0, r3
    8d76:	d059      	beq.n	8e2c <_free_r+0x1b0>
    8d78:	685a      	ldr	r2, [r3, #4]
    8d7a:	f022 0203 	bic.w	r2, r2, #3
    8d7e:	428a      	cmp	r2, r1
    8d80:	d902      	bls.n	8d88 <_free_r+0x10c>
    8d82:	689b      	ldr	r3, [r3, #8]
    8d84:	4298      	cmp	r0, r3
    8d86:	d1f7      	bne.n	8d78 <_free_r+0xfc>
    8d88:	68d8      	ldr	r0, [r3, #12]
    8d8a:	e9c5 3002 	strd	r3, r0, [r5, #8]
    8d8e:	6085      	str	r5, [r0, #8]
    8d90:	60dd      	str	r5, [r3, #12]
    8d92:	4630      	mov	r0, r6
    8d94:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8d98:	f7ff b98a 	b.w	80b0 <__malloc_unlock>
    8d9c:	eb0c 0203 	add.w	r2, ip, r3
    8da0:	6852      	ldr	r2, [r2, #4]
    8da2:	07d2      	lsls	r2, r2, #31
    8da4:	d463      	bmi.n	8e6e <_free_r+0x1f2>
    8da6:	440b      	add	r3, r1
    8da8:	e9dc 1202 	ldrd	r1, r2, [ip, #8]
    8dac:	60ca      	str	r2, [r1, #12]
    8dae:	6091      	str	r1, [r2, #8]
    8db0:	f043 0201 	orr.w	r2, r3, #1
    8db4:	606a      	str	r2, [r5, #4]
    8db6:	4630      	mov	r0, r6
    8db8:	50eb      	str	r3, [r5, r3]
    8dba:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8dbe:	f7ff b977 	b.w	80b0 <__malloc_unlock>
    8dc2:	440b      	add	r3, r1
    8dc4:	07d1      	lsls	r1, r2, #31
    8dc6:	d407      	bmi.n	8dd8 <_free_r+0x15c>
    8dc8:	f854 2c08 	ldr.w	r2, [r4, #-8]
    8dcc:	1aad      	subs	r5, r5, r2
    8dce:	4413      	add	r3, r2
    8dd0:	e9d5 1202 	ldrd	r1, r2, [r5, #8]
    8dd4:	60ca      	str	r2, [r1, #12]
    8dd6:	6091      	str	r1, [r2, #8]
    8dd8:	f043 0201 	orr.w	r2, r3, #1
    8ddc:	606a      	str	r2, [r5, #4]
    8dde:	4a28      	ldr	r2, [pc, #160]	; (8e80 <_free_r+0x204>)
    8de0:	60bd      	str	r5, [r7, #8]
    8de2:	6812      	ldr	r2, [r2, #0]
    8de4:	429a      	cmp	r2, r3
    8de6:	d893      	bhi.n	8d10 <_free_r+0x94>
    8de8:	4b26      	ldr	r3, [pc, #152]	; (8e84 <_free_r+0x208>)
    8dea:	4630      	mov	r0, r6
    8dec:	6819      	ldr	r1, [r3, #0]
    8dee:	f7ff fef5 	bl	8bdc <_malloc_trim_r>
    8df2:	e78d      	b.n	8d10 <_free_r+0x94>
    8df4:	2b14      	cmp	r3, #20
    8df6:	d90a      	bls.n	8e0e <_free_r+0x192>
    8df8:	2b54      	cmp	r3, #84	; 0x54
    8dfa:	d81f      	bhi.n	8e3c <_free_r+0x1c0>
    8dfc:	0b0b      	lsrs	r3, r1, #12
    8dfe:	f103 006f 	add.w	r0, r3, #111	; 0x6f
    8e02:	f103 026e 	add.w	r2, r3, #110	; 0x6e
    8e06:	00c3      	lsls	r3, r0, #3
    8e08:	e7b1      	b.n	8d6e <_free_r+0xf2>
    8e0a:	4419      	add	r1, r3
    8e0c:	e78d      	b.n	8d2a <_free_r+0xae>
    8e0e:	f103 005c 	add.w	r0, r3, #92	; 0x5c
    8e12:	f103 025b 	add.w	r2, r3, #91	; 0x5b
    8e16:	00c3      	lsls	r3, r0, #3
    8e18:	e7a9      	b.n	8d6e <_free_r+0xf2>
    8e1a:	f041 0301 	orr.w	r3, r1, #1
    8e1e:	e9c7 5504 	strd	r5, r5, [r7, #16]
    8e22:	e9c5 0002 	strd	r0, r0, [r5, #8]
    8e26:	606b      	str	r3, [r5, #4]
    8e28:	5069      	str	r1, [r5, r1]
    8e2a:	e771      	b.n	8d10 <_free_r+0x94>
    8e2c:	6879      	ldr	r1, [r7, #4]
    8e2e:	1092      	asrs	r2, r2, #2
    8e30:	2401      	movs	r4, #1
    8e32:	fa04 f202 	lsl.w	r2, r4, r2
    8e36:	430a      	orrs	r2, r1
    8e38:	607a      	str	r2, [r7, #4]
    8e3a:	e7a6      	b.n	8d8a <_free_r+0x10e>
    8e3c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    8e40:	d806      	bhi.n	8e50 <_free_r+0x1d4>
    8e42:	0bcb      	lsrs	r3, r1, #15
    8e44:	f103 0078 	add.w	r0, r3, #120	; 0x78
    8e48:	f103 0277 	add.w	r2, r3, #119	; 0x77
    8e4c:	00c3      	lsls	r3, r0, #3
    8e4e:	e78e      	b.n	8d6e <_free_r+0xf2>
    8e50:	f240 5254 	movw	r2, #1364	; 0x554
    8e54:	4293      	cmp	r3, r2
    8e56:	d806      	bhi.n	8e66 <_free_r+0x1ea>
    8e58:	0c8b      	lsrs	r3, r1, #18
    8e5a:	f103 007d 	add.w	r0, r3, #125	; 0x7d
    8e5e:	f103 027c 	add.w	r2, r3, #124	; 0x7c
    8e62:	00c3      	lsls	r3, r0, #3
    8e64:	e783      	b.n	8d6e <_free_r+0xf2>
    8e66:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    8e6a:	227e      	movs	r2, #126	; 0x7e
    8e6c:	e77f      	b.n	8d6e <_free_r+0xf2>
    8e6e:	f041 0301 	orr.w	r3, r1, #1
    8e72:	606b      	str	r3, [r5, #4]
    8e74:	f8cc 1000 	str.w	r1, [ip]
    8e78:	e74a      	b.n	8d10 <_free_r+0x94>
    8e7a:	bf00      	nop
    8e7c:	20001350 	.word	0x20001350
    8e80:	2000175c 	.word	0x2000175c
    8e84:	20007394 	.word	0x20007394

00008e88 <__ascii_mbtowc>:
    8e88:	b082      	sub	sp, #8
    8e8a:	b149      	cbz	r1, 8ea0 <__ascii_mbtowc+0x18>
    8e8c:	b15a      	cbz	r2, 8ea6 <__ascii_mbtowc+0x1e>
    8e8e:	b16b      	cbz	r3, 8eac <__ascii_mbtowc+0x24>
    8e90:	7813      	ldrb	r3, [r2, #0]
    8e92:	600b      	str	r3, [r1, #0]
    8e94:	7812      	ldrb	r2, [r2, #0]
    8e96:	1e10      	subs	r0, r2, #0
    8e98:	bf18      	it	ne
    8e9a:	2001      	movne	r0, #1
    8e9c:	b002      	add	sp, #8
    8e9e:	4770      	bx	lr
    8ea0:	a901      	add	r1, sp, #4
    8ea2:	2a00      	cmp	r2, #0
    8ea4:	d1f3      	bne.n	8e8e <__ascii_mbtowc+0x6>
    8ea6:	4610      	mov	r0, r2
    8ea8:	b002      	add	sp, #8
    8eaa:	4770      	bx	lr
    8eac:	f06f 0001 	mvn.w	r0, #1
    8eb0:	e7f4      	b.n	8e9c <__ascii_mbtowc+0x14>
    8eb2:	bf00      	nop

00008eb4 <_Balloc>:
    8eb4:	6c43      	ldr	r3, [r0, #68]	; 0x44
    8eb6:	b570      	push	{r4, r5, r6, lr}
    8eb8:	4605      	mov	r5, r0
    8eba:	460c      	mov	r4, r1
    8ebc:	b14b      	cbz	r3, 8ed2 <_Balloc+0x1e>
    8ebe:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    8ec2:	b180      	cbz	r0, 8ee6 <_Balloc+0x32>
    8ec4:	6802      	ldr	r2, [r0, #0]
    8ec6:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    8eca:	2300      	movs	r3, #0
    8ecc:	e9c0 3303 	strd	r3, r3, [r0, #12]
    8ed0:	bd70      	pop	{r4, r5, r6, pc}
    8ed2:	2221      	movs	r2, #33	; 0x21
    8ed4:	2104      	movs	r1, #4
    8ed6:	f002 fb2f 	bl	b538 <_calloc_r>
    8eda:	4603      	mov	r3, r0
    8edc:	6468      	str	r0, [r5, #68]	; 0x44
    8ede:	2800      	cmp	r0, #0
    8ee0:	d1ed      	bne.n	8ebe <_Balloc+0xa>
    8ee2:	2000      	movs	r0, #0
    8ee4:	bd70      	pop	{r4, r5, r6, pc}
    8ee6:	2101      	movs	r1, #1
    8ee8:	fa01 f604 	lsl.w	r6, r1, r4
    8eec:	1d72      	adds	r2, r6, #5
    8eee:	0092      	lsls	r2, r2, #2
    8ef0:	4628      	mov	r0, r5
    8ef2:	f002 fb21 	bl	b538 <_calloc_r>
    8ef6:	2800      	cmp	r0, #0
    8ef8:	d0f3      	beq.n	8ee2 <_Balloc+0x2e>
    8efa:	e9c0 4601 	strd	r4, r6, [r0, #4]
    8efe:	e7e4      	b.n	8eca <_Balloc+0x16>

00008f00 <_Bfree>:
    8f00:	b131      	cbz	r1, 8f10 <_Bfree+0x10>
    8f02:	6c43      	ldr	r3, [r0, #68]	; 0x44
    8f04:	684a      	ldr	r2, [r1, #4]
    8f06:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    8f0a:	6008      	str	r0, [r1, #0]
    8f0c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    8f10:	4770      	bx	lr
    8f12:	bf00      	nop

00008f14 <__multadd>:
    8f14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8f18:	690e      	ldr	r6, [r1, #16]
    8f1a:	4680      	mov	r8, r0
    8f1c:	460f      	mov	r7, r1
    8f1e:	461d      	mov	r5, r3
    8f20:	f101 0e14 	add.w	lr, r1, #20
    8f24:	2000      	movs	r0, #0
    8f26:	f8de 1000 	ldr.w	r1, [lr]
    8f2a:	b28c      	uxth	r4, r1
    8f2c:	fb02 5304 	mla	r3, r2, r4, r5
    8f30:	0c09      	lsrs	r1, r1, #16
    8f32:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    8f36:	fb02 cc01 	mla	ip, r2, r1, ip
    8f3a:	3001      	adds	r0, #1
    8f3c:	b29c      	uxth	r4, r3
    8f3e:	eb04 440c 	add.w	r4, r4, ip, lsl #16
    8f42:	4286      	cmp	r6, r0
    8f44:	f84e 4b04 	str.w	r4, [lr], #4
    8f48:	ea4f 451c 	mov.w	r5, ip, lsr #16
    8f4c:	dceb      	bgt.n	8f26 <__multadd+0x12>
    8f4e:	b13d      	cbz	r5, 8f60 <__multadd+0x4c>
    8f50:	68bb      	ldr	r3, [r7, #8]
    8f52:	42b3      	cmp	r3, r6
    8f54:	dd07      	ble.n	8f66 <__multadd+0x52>
    8f56:	eb07 0386 	add.w	r3, r7, r6, lsl #2
    8f5a:	3601      	adds	r6, #1
    8f5c:	615d      	str	r5, [r3, #20]
    8f5e:	613e      	str	r6, [r7, #16]
    8f60:	4638      	mov	r0, r7
    8f62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8f66:	6879      	ldr	r1, [r7, #4]
    8f68:	4640      	mov	r0, r8
    8f6a:	3101      	adds	r1, #1
    8f6c:	f7ff ffa2 	bl	8eb4 <_Balloc>
    8f70:	4604      	mov	r4, r0
    8f72:	b1b0      	cbz	r0, 8fa2 <__multadd+0x8e>
    8f74:	693a      	ldr	r2, [r7, #16]
    8f76:	3202      	adds	r2, #2
    8f78:	f107 010c 	add.w	r1, r7, #12
    8f7c:	0092      	lsls	r2, r2, #2
    8f7e:	300c      	adds	r0, #12
    8f80:	f7fd f99c 	bl	62bc <memcpy>
    8f84:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    8f88:	687a      	ldr	r2, [r7, #4]
    8f8a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    8f8e:	6039      	str	r1, [r7, #0]
    8f90:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
    8f94:	4627      	mov	r7, r4
    8f96:	eb07 0386 	add.w	r3, r7, r6, lsl #2
    8f9a:	3601      	adds	r6, #1
    8f9c:	615d      	str	r5, [r3, #20]
    8f9e:	613e      	str	r6, [r7, #16]
    8fa0:	e7de      	b.n	8f60 <__multadd+0x4c>
    8fa2:	4b03      	ldr	r3, [pc, #12]	; (8fb0 <__multadd+0x9c>)
    8fa4:	4803      	ldr	r0, [pc, #12]	; (8fb4 <__multadd+0xa0>)
    8fa6:	4622      	mov	r2, r4
    8fa8:	21ba      	movs	r1, #186	; 0xba
    8faa:	f002 faa5 	bl	b4f8 <__assert_func>
    8fae:	bf00      	nop
    8fb0:	2000093c 	.word	0x2000093c
    8fb4:	20000950 	.word	0x20000950

00008fb8 <__hi0bits>:
    8fb8:	0c03      	lsrs	r3, r0, #16
    8fba:	041b      	lsls	r3, r3, #16
    8fbc:	b9d3      	cbnz	r3, 8ff4 <__hi0bits+0x3c>
    8fbe:	0400      	lsls	r0, r0, #16
    8fc0:	2310      	movs	r3, #16
    8fc2:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    8fc6:	bf04      	itt	eq
    8fc8:	0200      	lsleq	r0, r0, #8
    8fca:	3308      	addeq	r3, #8
    8fcc:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    8fd0:	bf04      	itt	eq
    8fd2:	0100      	lsleq	r0, r0, #4
    8fd4:	3304      	addeq	r3, #4
    8fd6:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    8fda:	bf04      	itt	eq
    8fdc:	0080      	lsleq	r0, r0, #2
    8fde:	3302      	addeq	r3, #2
    8fe0:	2800      	cmp	r0, #0
    8fe2:	db05      	blt.n	8ff0 <__hi0bits+0x38>
    8fe4:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
    8fe8:	f103 0301 	add.w	r3, r3, #1
    8fec:	bf08      	it	eq
    8fee:	2320      	moveq	r3, #32
    8ff0:	4618      	mov	r0, r3
    8ff2:	4770      	bx	lr
    8ff4:	2300      	movs	r3, #0
    8ff6:	e7e4      	b.n	8fc2 <__hi0bits+0xa>

00008ff8 <__lo0bits>:
    8ff8:	6803      	ldr	r3, [r0, #0]
    8ffa:	f013 0207 	ands.w	r2, r3, #7
    8ffe:	d008      	beq.n	9012 <__lo0bits+0x1a>
    9000:	07d9      	lsls	r1, r3, #31
    9002:	d41f      	bmi.n	9044 <__lo0bits+0x4c>
    9004:	079a      	lsls	r2, r3, #30
    9006:	d522      	bpl.n	904e <__lo0bits+0x56>
    9008:	085b      	lsrs	r3, r3, #1
    900a:	6003      	str	r3, [r0, #0]
    900c:	2201      	movs	r2, #1
    900e:	4610      	mov	r0, r2
    9010:	4770      	bx	lr
    9012:	b299      	uxth	r1, r3
    9014:	b909      	cbnz	r1, 901a <__lo0bits+0x22>
    9016:	0c1b      	lsrs	r3, r3, #16
    9018:	2210      	movs	r2, #16
    901a:	b2d9      	uxtb	r1, r3
    901c:	b909      	cbnz	r1, 9022 <__lo0bits+0x2a>
    901e:	3208      	adds	r2, #8
    9020:	0a1b      	lsrs	r3, r3, #8
    9022:	0719      	lsls	r1, r3, #28
    9024:	bf04      	itt	eq
    9026:	091b      	lsreq	r3, r3, #4
    9028:	3204      	addeq	r2, #4
    902a:	0799      	lsls	r1, r3, #30
    902c:	bf04      	itt	eq
    902e:	089b      	lsreq	r3, r3, #2
    9030:	3202      	addeq	r2, #2
    9032:	07d9      	lsls	r1, r3, #31
    9034:	d403      	bmi.n	903e <__lo0bits+0x46>
    9036:	085b      	lsrs	r3, r3, #1
    9038:	f102 0201 	add.w	r2, r2, #1
    903c:	d005      	beq.n	904a <__lo0bits+0x52>
    903e:	6003      	str	r3, [r0, #0]
    9040:	4610      	mov	r0, r2
    9042:	4770      	bx	lr
    9044:	2200      	movs	r2, #0
    9046:	4610      	mov	r0, r2
    9048:	4770      	bx	lr
    904a:	2220      	movs	r2, #32
    904c:	e7df      	b.n	900e <__lo0bits+0x16>
    904e:	089b      	lsrs	r3, r3, #2
    9050:	2202      	movs	r2, #2
    9052:	6003      	str	r3, [r0, #0]
    9054:	4610      	mov	r0, r2
    9056:	4770      	bx	lr

00009058 <__i2b>:
    9058:	b538      	push	{r3, r4, r5, lr}
    905a:	6c43      	ldr	r3, [r0, #68]	; 0x44
    905c:	4604      	mov	r4, r0
    905e:	460d      	mov	r5, r1
    9060:	b14b      	cbz	r3, 9076 <__i2b+0x1e>
    9062:	6858      	ldr	r0, [r3, #4]
    9064:	b1b0      	cbz	r0, 9094 <__i2b+0x3c>
    9066:	6802      	ldr	r2, [r0, #0]
    9068:	605a      	str	r2, [r3, #4]
    906a:	2200      	movs	r2, #0
    906c:	2301      	movs	r3, #1
    906e:	e9c0 3504 	strd	r3, r5, [r0, #16]
    9072:	60c2      	str	r2, [r0, #12]
    9074:	bd38      	pop	{r3, r4, r5, pc}
    9076:	2221      	movs	r2, #33	; 0x21
    9078:	2104      	movs	r1, #4
    907a:	f002 fa5d 	bl	b538 <_calloc_r>
    907e:	4603      	mov	r3, r0
    9080:	6460      	str	r0, [r4, #68]	; 0x44
    9082:	2800      	cmp	r0, #0
    9084:	d1ed      	bne.n	9062 <__i2b+0xa>
    9086:	4b09      	ldr	r3, [pc, #36]	; (90ac <__i2b+0x54>)
    9088:	4809      	ldr	r0, [pc, #36]	; (90b0 <__i2b+0x58>)
    908a:	2200      	movs	r2, #0
    908c:	f240 1145 	movw	r1, #325	; 0x145
    9090:	f002 fa32 	bl	b4f8 <__assert_func>
    9094:	221c      	movs	r2, #28
    9096:	2101      	movs	r1, #1
    9098:	4620      	mov	r0, r4
    909a:	f002 fa4d 	bl	b538 <_calloc_r>
    909e:	2800      	cmp	r0, #0
    90a0:	d0f1      	beq.n	9086 <__i2b+0x2e>
    90a2:	2201      	movs	r2, #1
    90a4:	2302      	movs	r3, #2
    90a6:	e9c0 2301 	strd	r2, r3, [r0, #4]
    90aa:	e7de      	b.n	906a <__i2b+0x12>
    90ac:	2000093c 	.word	0x2000093c
    90b0:	20000950 	.word	0x20000950

000090b4 <__multiply>:
    90b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    90b8:	690e      	ldr	r6, [r1, #16]
    90ba:	6915      	ldr	r5, [r2, #16]
    90bc:	42ae      	cmp	r6, r5
    90be:	b085      	sub	sp, #20
    90c0:	4688      	mov	r8, r1
    90c2:	4614      	mov	r4, r2
    90c4:	db05      	blt.n	90d2 <__multiply+0x1e>
    90c6:	462a      	mov	r2, r5
    90c8:	4623      	mov	r3, r4
    90ca:	4635      	mov	r5, r6
    90cc:	460c      	mov	r4, r1
    90ce:	4616      	mov	r6, r2
    90d0:	4698      	mov	r8, r3
    90d2:	68a3      	ldr	r3, [r4, #8]
    90d4:	6861      	ldr	r1, [r4, #4]
    90d6:	19af      	adds	r7, r5, r6
    90d8:	42bb      	cmp	r3, r7
    90da:	bfb8      	it	lt
    90dc:	3101      	addlt	r1, #1
    90de:	f7ff fee9 	bl	8eb4 <_Balloc>
    90e2:	9001      	str	r0, [sp, #4]
    90e4:	2800      	cmp	r0, #0
    90e6:	f000 8087 	beq.w	91f8 <__multiply+0x144>
    90ea:	9b01      	ldr	r3, [sp, #4]
    90ec:	f103 0914 	add.w	r9, r3, #20
    90f0:	eb09 0a87 	add.w	sl, r9, r7, lsl #2
    90f4:	45d1      	cmp	r9, sl
    90f6:	d205      	bcs.n	9104 <__multiply+0x50>
    90f8:	464b      	mov	r3, r9
    90fa:	2200      	movs	r2, #0
    90fc:	f843 2b04 	str.w	r2, [r3], #4
    9100:	459a      	cmp	sl, r3
    9102:	d8fb      	bhi.n	90fc <__multiply+0x48>
    9104:	f108 0814 	add.w	r8, r8, #20
    9108:	eb08 0b86 	add.w	fp, r8, r6, lsl #2
    910c:	f104 0314 	add.w	r3, r4, #20
    9110:	45d8      	cmp	r8, fp
    9112:	461a      	mov	r2, r3
    9114:	eb03 0585 	add.w	r5, r3, r5, lsl #2
    9118:	d25f      	bcs.n	91da <__multiply+0x126>
    911a:	1b2b      	subs	r3, r5, r4
    911c:	3b15      	subs	r3, #21
    911e:	f023 0303 	bic.w	r3, r3, #3
    9122:	3304      	adds	r3, #4
    9124:	3415      	adds	r4, #21
    9126:	42a5      	cmp	r5, r4
    9128:	bf38      	it	cc
    912a:	2304      	movcc	r3, #4
    912c:	e9cd a702 	strd	sl, r7, [sp, #8]
    9130:	46ac      	mov	ip, r5
    9132:	461f      	mov	r7, r3
    9134:	4692      	mov	sl, r2
    9136:	e005      	b.n	9144 <__multiply+0x90>
    9138:	0c09      	lsrs	r1, r1, #16
    913a:	d129      	bne.n	9190 <__multiply+0xdc>
    913c:	45c3      	cmp	fp, r8
    913e:	f109 0904 	add.w	r9, r9, #4
    9142:	d948      	bls.n	91d6 <__multiply+0x122>
    9144:	f858 1b04 	ldr.w	r1, [r8], #4
    9148:	b28d      	uxth	r5, r1
    914a:	2d00      	cmp	r5, #0
    914c:	d0f4      	beq.n	9138 <__multiply+0x84>
    914e:	4656      	mov	r6, sl
    9150:	464c      	mov	r4, r9
    9152:	2300      	movs	r3, #0
    9154:	f856 1b04 	ldr.w	r1, [r6], #4
    9158:	6822      	ldr	r2, [r4, #0]
    915a:	fa1f fe81 	uxth.w	lr, r1
    915e:	b290      	uxth	r0, r2
    9160:	0c09      	lsrs	r1, r1, #16
    9162:	fb05 000e 	mla	r0, r5, lr, r0
    9166:	0c12      	lsrs	r2, r2, #16
    9168:	4403      	add	r3, r0
    916a:	fb05 2201 	mla	r2, r5, r1, r2
    916e:	eb02 4213 	add.w	r2, r2, r3, lsr #16
    9172:	b29b      	uxth	r3, r3
    9174:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    9178:	45b4      	cmp	ip, r6
    917a:	f844 3b04 	str.w	r3, [r4], #4
    917e:	ea4f 4312 	mov.w	r3, r2, lsr #16
    9182:	d8e7      	bhi.n	9154 <__multiply+0xa0>
    9184:	f849 3007 	str.w	r3, [r9, r7]
    9188:	f858 1c04 	ldr.w	r1, [r8, #-4]
    918c:	0c09      	lsrs	r1, r1, #16
    918e:	d0d5      	beq.n	913c <__multiply+0x88>
    9190:	f8d9 3000 	ldr.w	r3, [r9]
    9194:	4650      	mov	r0, sl
    9196:	461a      	mov	r2, r3
    9198:	464c      	mov	r4, r9
    919a:	2600      	movs	r6, #0
    919c:	8805      	ldrh	r5, [r0, #0]
    919e:	0c12      	lsrs	r2, r2, #16
    91a0:	fb01 2205 	mla	r2, r1, r5, r2
    91a4:	4416      	add	r6, r2
    91a6:	b29b      	uxth	r3, r3
    91a8:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    91ac:	f844 3b04 	str.w	r3, [r4], #4
    91b0:	f850 5b04 	ldr.w	r5, [r0], #4
    91b4:	6822      	ldr	r2, [r4, #0]
    91b6:	0c2d      	lsrs	r5, r5, #16
    91b8:	b293      	uxth	r3, r2
    91ba:	fb01 3305 	mla	r3, r1, r5, r3
    91be:	eb03 4316 	add.w	r3, r3, r6, lsr #16
    91c2:	4584      	cmp	ip, r0
    91c4:	ea4f 4613 	mov.w	r6, r3, lsr #16
    91c8:	d8e8      	bhi.n	919c <__multiply+0xe8>
    91ca:	45c3      	cmp	fp, r8
    91cc:	f849 3007 	str.w	r3, [r9, r7]
    91d0:	f109 0904 	add.w	r9, r9, #4
    91d4:	d8b6      	bhi.n	9144 <__multiply+0x90>
    91d6:	e9dd a702 	ldrd	sl, r7, [sp, #8]
    91da:	2f00      	cmp	r7, #0
    91dc:	dc02      	bgt.n	91e4 <__multiply+0x130>
    91de:	e005      	b.n	91ec <__multiply+0x138>
    91e0:	3f01      	subs	r7, #1
    91e2:	d003      	beq.n	91ec <__multiply+0x138>
    91e4:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
    91e8:	2b00      	cmp	r3, #0
    91ea:	d0f9      	beq.n	91e0 <__multiply+0x12c>
    91ec:	9b01      	ldr	r3, [sp, #4]
    91ee:	4618      	mov	r0, r3
    91f0:	611f      	str	r7, [r3, #16]
    91f2:	b005      	add	sp, #20
    91f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    91f8:	4b03      	ldr	r3, [pc, #12]	; (9208 <__multiply+0x154>)
    91fa:	4804      	ldr	r0, [pc, #16]	; (920c <__multiply+0x158>)
    91fc:	9a01      	ldr	r2, [sp, #4]
    91fe:	f44f 71b1 	mov.w	r1, #354	; 0x162
    9202:	f002 f979 	bl	b4f8 <__assert_func>
    9206:	bf00      	nop
    9208:	2000093c 	.word	0x2000093c
    920c:	20000950 	.word	0x20000950

00009210 <__pow5mult>:
    9210:	f012 0303 	ands.w	r3, r2, #3
    9214:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9218:	4614      	mov	r4, r2
    921a:	4606      	mov	r6, r0
    921c:	d132      	bne.n	9284 <__pow5mult+0x74>
    921e:	460d      	mov	r5, r1
    9220:	10a4      	asrs	r4, r4, #2
    9222:	d020      	beq.n	9266 <__pow5mult+0x56>
    9224:	f8d6 8040 	ldr.w	r8, [r6, #64]	; 0x40
    9228:	f1b8 0f00 	cmp.w	r8, #0
    922c:	d033      	beq.n	9296 <__pow5mult+0x86>
    922e:	07e3      	lsls	r3, r4, #31
    9230:	f04f 0700 	mov.w	r7, #0
    9234:	d407      	bmi.n	9246 <__pow5mult+0x36>
    9236:	1064      	asrs	r4, r4, #1
    9238:	d015      	beq.n	9266 <__pow5mult+0x56>
    923a:	f8d8 0000 	ldr.w	r0, [r8]
    923e:	b1a8      	cbz	r0, 926c <__pow5mult+0x5c>
    9240:	4680      	mov	r8, r0
    9242:	07e3      	lsls	r3, r4, #31
    9244:	d5f7      	bpl.n	9236 <__pow5mult+0x26>
    9246:	4642      	mov	r2, r8
    9248:	4629      	mov	r1, r5
    924a:	4630      	mov	r0, r6
    924c:	f7ff ff32 	bl	90b4 <__multiply>
    9250:	b1b5      	cbz	r5, 9280 <__pow5mult+0x70>
    9252:	6869      	ldr	r1, [r5, #4]
    9254:	6c73      	ldr	r3, [r6, #68]	; 0x44
    9256:	1064      	asrs	r4, r4, #1
    9258:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
    925c:	602a      	str	r2, [r5, #0]
    925e:	f843 5021 	str.w	r5, [r3, r1, lsl #2]
    9262:	4605      	mov	r5, r0
    9264:	d1e9      	bne.n	923a <__pow5mult+0x2a>
    9266:	4628      	mov	r0, r5
    9268:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    926c:	4642      	mov	r2, r8
    926e:	4641      	mov	r1, r8
    9270:	4630      	mov	r0, r6
    9272:	f7ff ff1f 	bl	90b4 <__multiply>
    9276:	f8c8 0000 	str.w	r0, [r8]
    927a:	6007      	str	r7, [r0, #0]
    927c:	4680      	mov	r8, r0
    927e:	e7e0      	b.n	9242 <__pow5mult+0x32>
    9280:	4605      	mov	r5, r0
    9282:	e7d8      	b.n	9236 <__pow5mult+0x26>
    9284:	3b01      	subs	r3, #1
    9286:	4a0f      	ldr	r2, [pc, #60]	; (92c4 <__pow5mult+0xb4>)
    9288:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    928c:	2300      	movs	r3, #0
    928e:	f7ff fe41 	bl	8f14 <__multadd>
    9292:	4605      	mov	r5, r0
    9294:	e7c4      	b.n	9220 <__pow5mult+0x10>
    9296:	2101      	movs	r1, #1
    9298:	4630      	mov	r0, r6
    929a:	f7ff fe0b 	bl	8eb4 <_Balloc>
    929e:	4680      	mov	r8, r0
    92a0:	b140      	cbz	r0, 92b4 <__pow5mult+0xa4>
    92a2:	2301      	movs	r3, #1
    92a4:	f240 2271 	movw	r2, #625	; 0x271
    92a8:	e9c0 3204 	strd	r3, r2, [r0, #16]
    92ac:	2300      	movs	r3, #0
    92ae:	6430      	str	r0, [r6, #64]	; 0x40
    92b0:	6003      	str	r3, [r0, #0]
    92b2:	e7bc      	b.n	922e <__pow5mult+0x1e>
    92b4:	4b04      	ldr	r3, [pc, #16]	; (92c8 <__pow5mult+0xb8>)
    92b6:	4805      	ldr	r0, [pc, #20]	; (92cc <__pow5mult+0xbc>)
    92b8:	4642      	mov	r2, r8
    92ba:	f240 1145 	movw	r1, #325	; 0x145
    92be:	f002 f91b 	bl	b4f8 <__assert_func>
    92c2:	bf00      	nop
    92c4:	20000dfc 	.word	0x20000dfc
    92c8:	2000093c 	.word	0x2000093c
    92cc:	20000950 	.word	0x20000950

000092d0 <__lshift>:
    92d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    92d4:	460d      	mov	r5, r1
    92d6:	4614      	mov	r4, r2
    92d8:	692f      	ldr	r7, [r5, #16]
    92da:	68ab      	ldr	r3, [r5, #8]
    92dc:	6849      	ldr	r1, [r1, #4]
    92de:	eb07 1762 	add.w	r7, r7, r2, asr #5
    92e2:	1c7e      	adds	r6, r7, #1
    92e4:	429e      	cmp	r6, r3
    92e6:	4680      	mov	r8, r0
    92e8:	ea4f 1962 	mov.w	r9, r2, asr #5
    92ec:	dd04      	ble.n	92f8 <__lshift+0x28>
    92ee:	005b      	lsls	r3, r3, #1
    92f0:	429e      	cmp	r6, r3
    92f2:	f101 0101 	add.w	r1, r1, #1
    92f6:	dcfa      	bgt.n	92ee <__lshift+0x1e>
    92f8:	4640      	mov	r0, r8
    92fa:	f7ff fddb 	bl	8eb4 <_Balloc>
    92fe:	4684      	mov	ip, r0
    9300:	2800      	cmp	r0, #0
    9302:	d052      	beq.n	93aa <__lshift+0xda>
    9304:	f1b9 0f00 	cmp.w	r9, #0
    9308:	f100 0214 	add.w	r2, r0, #20
    930c:	dd0e      	ble.n	932c <__lshift+0x5c>
    930e:	f109 0105 	add.w	r1, r9, #5
    9312:	ea4f 0e81 	mov.w	lr, r1, lsl #2
    9316:	4613      	mov	r3, r2
    9318:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    931c:	2000      	movs	r0, #0
    931e:	f843 0b04 	str.w	r0, [r3], #4
    9322:	428b      	cmp	r3, r1
    9324:	d1fb      	bne.n	931e <__lshift+0x4e>
    9326:	f1ae 0314 	sub.w	r3, lr, #20
    932a:	441a      	add	r2, r3
    932c:	6929      	ldr	r1, [r5, #16]
    932e:	f105 0314 	add.w	r3, r5, #20
    9332:	f014 0e1f 	ands.w	lr, r4, #31
    9336:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    933a:	d02e      	beq.n	939a <__lshift+0xca>
    933c:	f1ce 0920 	rsb	r9, lr, #32
    9340:	4610      	mov	r0, r2
    9342:	f04f 0a00 	mov.w	sl, #0
    9346:	681c      	ldr	r4, [r3, #0]
    9348:	fa04 f40e 	lsl.w	r4, r4, lr
    934c:	ea44 040a 	orr.w	r4, r4, sl
    9350:	f840 4b04 	str.w	r4, [r0], #4
    9354:	f853 4b04 	ldr.w	r4, [r3], #4
    9358:	4299      	cmp	r1, r3
    935a:	fa24 fa09 	lsr.w	sl, r4, r9
    935e:	d8f2      	bhi.n	9346 <__lshift+0x76>
    9360:	1b4b      	subs	r3, r1, r5
    9362:	3b15      	subs	r3, #21
    9364:	f023 0303 	bic.w	r3, r3, #3
    9368:	3304      	adds	r3, #4
    936a:	f105 0015 	add.w	r0, r5, #21
    936e:	4281      	cmp	r1, r0
    9370:	bf38      	it	cc
    9372:	2304      	movcc	r3, #4
    9374:	f1ba 0f00 	cmp.w	sl, #0
    9378:	bf18      	it	ne
    937a:	4637      	movne	r7, r6
    937c:	f842 a003 	str.w	sl, [r2, r3]
    9380:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    9384:	686a      	ldr	r2, [r5, #4]
    9386:	f8cc 7010 	str.w	r7, [ip, #16]
    938a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    938e:	6029      	str	r1, [r5, #0]
    9390:	4660      	mov	r0, ip
    9392:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
    9396:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    939a:	3a04      	subs	r2, #4
    939c:	f853 0b04 	ldr.w	r0, [r3], #4
    93a0:	f842 0f04 	str.w	r0, [r2, #4]!
    93a4:	4299      	cmp	r1, r3
    93a6:	d8f9      	bhi.n	939c <__lshift+0xcc>
    93a8:	e7ea      	b.n	9380 <__lshift+0xb0>
    93aa:	4b03      	ldr	r3, [pc, #12]	; (93b8 <__lshift+0xe8>)
    93ac:	4803      	ldr	r0, [pc, #12]	; (93bc <__lshift+0xec>)
    93ae:	4662      	mov	r2, ip
    93b0:	f44f 71ef 	mov.w	r1, #478	; 0x1de
    93b4:	f002 f8a0 	bl	b4f8 <__assert_func>
    93b8:	2000093c 	.word	0x2000093c
    93bc:	20000950 	.word	0x20000950

000093c0 <__mcmp>:
    93c0:	690b      	ldr	r3, [r1, #16]
    93c2:	4684      	mov	ip, r0
    93c4:	6900      	ldr	r0, [r0, #16]
    93c6:	1ac0      	subs	r0, r0, r3
    93c8:	d116      	bne.n	93f8 <__mcmp+0x38>
    93ca:	f10c 0c14 	add.w	ip, ip, #20
    93ce:	3114      	adds	r1, #20
    93d0:	eb0c 0283 	add.w	r2, ip, r3, lsl #2
    93d4:	b410      	push	{r4}
    93d6:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    93da:	e001      	b.n	93e0 <__mcmp+0x20>
    93dc:	4594      	cmp	ip, r2
    93de:	d208      	bcs.n	93f2 <__mcmp+0x32>
    93e0:	f852 4d04 	ldr.w	r4, [r2, #-4]!
    93e4:	f853 1d04 	ldr.w	r1, [r3, #-4]!
    93e8:	428c      	cmp	r4, r1
    93ea:	d0f7      	beq.n	93dc <__mcmp+0x1c>
    93ec:	d205      	bcs.n	93fa <__mcmp+0x3a>
    93ee:	f04f 30ff 	mov.w	r0, #4294967295
    93f2:	f85d 4b04 	ldr.w	r4, [sp], #4
    93f6:	4770      	bx	lr
    93f8:	4770      	bx	lr
    93fa:	2001      	movs	r0, #1
    93fc:	f85d 4b04 	ldr.w	r4, [sp], #4
    9400:	4770      	bx	lr
    9402:	bf00      	nop

00009404 <__mdiff>:
    9404:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9408:	690f      	ldr	r7, [r1, #16]
    940a:	6913      	ldr	r3, [r2, #16]
    940c:	1aff      	subs	r7, r7, r3
    940e:	2f00      	cmp	r7, #0
    9410:	460e      	mov	r6, r1
    9412:	4690      	mov	r8, r2
    9414:	d17f      	bne.n	9516 <__mdiff+0x112>
    9416:	f101 0514 	add.w	r5, r1, #20
    941a:	3214      	adds	r2, #20
    941c:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    9420:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    9424:	e001      	b.n	942a <__mdiff+0x26>
    9426:	429d      	cmp	r5, r3
    9428:	d278      	bcs.n	951c <__mdiff+0x118>
    942a:	f853 1d04 	ldr.w	r1, [r3, #-4]!
    942e:	f852 4d04 	ldr.w	r4, [r2, #-4]!
    9432:	42a1      	cmp	r1, r4
    9434:	d0f7      	beq.n	9426 <__mdiff+0x22>
    9436:	d369      	bcc.n	950c <__mdiff+0x108>
    9438:	6871      	ldr	r1, [r6, #4]
    943a:	f7ff fd3b 	bl	8eb4 <_Balloc>
    943e:	4681      	mov	r9, r0
    9440:	2800      	cmp	r0, #0
    9442:	d077      	beq.n	9534 <__mdiff+0x130>
    9444:	6935      	ldr	r5, [r6, #16]
    9446:	f8d8 2010 	ldr.w	r2, [r8, #16]
    944a:	60c7      	str	r7, [r0, #12]
    944c:	f108 0e14 	add.w	lr, r8, #20
    9450:	f106 0014 	add.w	r0, r6, #20
    9454:	f109 0a14 	add.w	sl, r9, #20
    9458:	f106 0110 	add.w	r1, r6, #16
    945c:	eb0e 0282 	add.w	r2, lr, r2, lsl #2
    9460:	eb00 0785 	add.w	r7, r0, r5, lsl #2
    9464:	4656      	mov	r6, sl
    9466:	f04f 0c00 	mov.w	ip, #0
    946a:	f85e 4b04 	ldr.w	r4, [lr], #4
    946e:	f851 bf04 	ldr.w	fp, [r1, #4]!
    9472:	b2a3      	uxth	r3, r4
    9474:	fa1c fc8b 	uxtah	ip, ip, fp
    9478:	ebac 0303 	sub.w	r3, ip, r3
    947c:	ea4f 4c14 	mov.w	ip, r4, lsr #16
    9480:	ebcc 4c1b 	rsb	ip, ip, fp, lsr #16
    9484:	eb0c 4c23 	add.w	ip, ip, r3, asr #16
    9488:	b29b      	uxth	r3, r3
    948a:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
    948e:	4572      	cmp	r2, lr
    9490:	f846 3b04 	str.w	r3, [r6], #4
    9494:	ea4f 4c2c 	mov.w	ip, ip, asr #16
    9498:	d8e7      	bhi.n	946a <__mdiff+0x66>
    949a:	eba2 0108 	sub.w	r1, r2, r8
    949e:	3915      	subs	r1, #21
    94a0:	f108 0815 	add.w	r8, r8, #21
    94a4:	4542      	cmp	r2, r8
    94a6:	f021 0403 	bic.w	r4, r1, #3
    94aa:	f104 0404 	add.w	r4, r4, #4
    94ae:	bf38      	it	cc
    94b0:	2404      	movcc	r4, #4
    94b2:	4420      	add	r0, r4
    94b4:	f021 0203 	bic.w	r2, r1, #3
    94b8:	bf38      	it	cc
    94ba:	2200      	movcc	r2, #0
    94bc:	4287      	cmp	r7, r0
    94be:	4452      	add	r2, sl
    94c0:	4454      	add	r4, sl
    94c2:	d918      	bls.n	94f6 <__mdiff+0xf2>
    94c4:	4626      	mov	r6, r4
    94c6:	4601      	mov	r1, r0
    94c8:	f851 3b04 	ldr.w	r3, [r1], #4
    94cc:	fa1c fc83 	uxtah	ip, ip, r3
    94d0:	ea4f 422c 	mov.w	r2, ip, asr #16
    94d4:	eb02 4213 	add.w	r2, r2, r3, lsr #16
    94d8:	fa1f fc8c 	uxth.w	ip, ip
    94dc:	ea4c 4302 	orr.w	r3, ip, r2, lsl #16
    94e0:	428f      	cmp	r7, r1
    94e2:	f846 3b04 	str.w	r3, [r6], #4
    94e6:	ea4f 4c22 	mov.w	ip, r2, asr #16
    94ea:	d8ed      	bhi.n	94c8 <__mdiff+0xc4>
    94ec:	3f01      	subs	r7, #1
    94ee:	1a3f      	subs	r7, r7, r0
    94f0:	f027 0703 	bic.w	r7, r7, #3
    94f4:	19e2      	adds	r2, r4, r7
    94f6:	b923      	cbnz	r3, 9502 <__mdiff+0xfe>
    94f8:	f852 3d04 	ldr.w	r3, [r2, #-4]!
    94fc:	3d01      	subs	r5, #1
    94fe:	2b00      	cmp	r3, #0
    9500:	d0fa      	beq.n	94f8 <__mdiff+0xf4>
    9502:	f8c9 5010 	str.w	r5, [r9, #16]
    9506:	4648      	mov	r0, r9
    9508:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    950c:	4633      	mov	r3, r6
    950e:	2701      	movs	r7, #1
    9510:	4646      	mov	r6, r8
    9512:	4698      	mov	r8, r3
    9514:	e790      	b.n	9438 <__mdiff+0x34>
    9516:	dbf9      	blt.n	950c <__mdiff+0x108>
    9518:	2700      	movs	r7, #0
    951a:	e78d      	b.n	9438 <__mdiff+0x34>
    951c:	2100      	movs	r1, #0
    951e:	f7ff fcc9 	bl	8eb4 <_Balloc>
    9522:	4681      	mov	r9, r0
    9524:	b168      	cbz	r0, 9542 <__mdiff+0x13e>
    9526:	2201      	movs	r2, #1
    9528:	2300      	movs	r3, #0
    952a:	e9c9 2304 	strd	r2, r3, [r9, #16]
    952e:	4648      	mov	r0, r9
    9530:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9534:	4b06      	ldr	r3, [pc, #24]	; (9550 <__mdiff+0x14c>)
    9536:	4807      	ldr	r0, [pc, #28]	; (9554 <__mdiff+0x150>)
    9538:	464a      	mov	r2, r9
    953a:	f240 2145 	movw	r1, #581	; 0x245
    953e:	f001 ffdb 	bl	b4f8 <__assert_func>
    9542:	4b03      	ldr	r3, [pc, #12]	; (9550 <__mdiff+0x14c>)
    9544:	4803      	ldr	r0, [pc, #12]	; (9554 <__mdiff+0x150>)
    9546:	464a      	mov	r2, r9
    9548:	f240 2137 	movw	r1, #567	; 0x237
    954c:	f001 ffd4 	bl	b4f8 <__assert_func>
    9550:	2000093c 	.word	0x2000093c
    9554:	20000950 	.word	0x20000950

00009558 <__d2b>:
    9558:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    955c:	4688      	mov	r8, r1
    955e:	b083      	sub	sp, #12
    9560:	2101      	movs	r1, #1
    9562:	ec57 6b10 	vmov	r6, r7, d0
    9566:	4615      	mov	r5, r2
    9568:	f7ff fca4 	bl	8eb4 <_Balloc>
    956c:	4604      	mov	r4, r0
    956e:	2800      	cmp	r0, #0
    9570:	d051      	beq.n	9616 <__d2b+0xbe>
    9572:	f3c7 590a 	ubfx	r9, r7, #20, #11
    9576:	f3c7 0313 	ubfx	r3, r7, #0, #20
    957a:	f1b9 0f00 	cmp.w	r9, #0
    957e:	d001      	beq.n	9584 <__d2b+0x2c>
    9580:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    9584:	2e00      	cmp	r6, #0
    9586:	9301      	str	r3, [sp, #4]
    9588:	d118      	bne.n	95bc <__d2b+0x64>
    958a:	a801      	add	r0, sp, #4
    958c:	f7ff fd34 	bl	8ff8 <__lo0bits>
    9590:	9a01      	ldr	r2, [sp, #4]
    9592:	6162      	str	r2, [r4, #20]
    9594:	2201      	movs	r2, #1
    9596:	f100 0320 	add.w	r3, r0, #32
    959a:	6122      	str	r2, [r4, #16]
    959c:	f1b9 0f00 	cmp.w	r9, #0
    95a0:	d025      	beq.n	95ee <__d2b+0x96>
    95a2:	f2a9 4933 	subw	r9, r9, #1075	; 0x433
    95a6:	eb09 0203 	add.w	r2, r9, r3
    95aa:	4620      	mov	r0, r4
    95ac:	f1c3 0335 	rsb	r3, r3, #53	; 0x35
    95b0:	f8c8 2000 	str.w	r2, [r8]
    95b4:	602b      	str	r3, [r5, #0]
    95b6:	b003      	add	sp, #12
    95b8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    95bc:	4668      	mov	r0, sp
    95be:	9600      	str	r6, [sp, #0]
    95c0:	f7ff fd1a 	bl	8ff8 <__lo0bits>
    95c4:	4603      	mov	r3, r0
    95c6:	b310      	cbz	r0, 960e <__d2b+0xb6>
    95c8:	e9dd 0200 	ldrd	r0, r2, [sp]
    95cc:	f1c3 0120 	rsb	r1, r3, #32
    95d0:	fa02 f101 	lsl.w	r1, r2, r1
    95d4:	4301      	orrs	r1, r0
    95d6:	40da      	lsrs	r2, r3
    95d8:	6161      	str	r1, [r4, #20]
    95da:	9201      	str	r2, [sp, #4]
    95dc:	2a00      	cmp	r2, #0
    95de:	61a2      	str	r2, [r4, #24]
    95e0:	bf14      	ite	ne
    95e2:	2202      	movne	r2, #2
    95e4:	2201      	moveq	r2, #1
    95e6:	6122      	str	r2, [r4, #16]
    95e8:	f1b9 0f00 	cmp.w	r9, #0
    95ec:	d1d9      	bne.n	95a2 <__d2b+0x4a>
    95ee:	f2a3 4332 	subw	r3, r3, #1074	; 0x432
    95f2:	f8c8 3000 	str.w	r3, [r8]
    95f6:	eb04 0382 	add.w	r3, r4, r2, lsl #2
    95fa:	6918      	ldr	r0, [r3, #16]
    95fc:	f7ff fcdc 	bl	8fb8 <__hi0bits>
    9600:	ebc0 1342 	rsb	r3, r0, r2, lsl #5
    9604:	4620      	mov	r0, r4
    9606:	602b      	str	r3, [r5, #0]
    9608:	b003      	add	sp, #12
    960a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    960e:	9a00      	ldr	r2, [sp, #0]
    9610:	6162      	str	r2, [r4, #20]
    9612:	9a01      	ldr	r2, [sp, #4]
    9614:	e7e2      	b.n	95dc <__d2b+0x84>
    9616:	4b03      	ldr	r3, [pc, #12]	; (9624 <__d2b+0xcc>)
    9618:	4803      	ldr	r0, [pc, #12]	; (9628 <__d2b+0xd0>)
    961a:	4622      	mov	r2, r4
    961c:	f240 310f 	movw	r1, #783	; 0x30f
    9620:	f001 ff6a 	bl	b4f8 <__assert_func>
    9624:	2000093c 	.word	0x2000093c
    9628:	20000950 	.word	0x20000950

0000962c <__ascii_wctomb>:
    962c:	b149      	cbz	r1, 9642 <__ascii_wctomb+0x16>
    962e:	2aff      	cmp	r2, #255	; 0xff
    9630:	d802      	bhi.n	9638 <__ascii_wctomb+0xc>
    9632:	700a      	strb	r2, [r1, #0]
    9634:	2001      	movs	r0, #1
    9636:	4770      	bx	lr
    9638:	238a      	movs	r3, #138	; 0x8a
    963a:	6003      	str	r3, [r0, #0]
    963c:	f04f 30ff 	mov.w	r0, #4294967295
    9640:	4770      	bx	lr
    9642:	4608      	mov	r0, r1
    9644:	4770      	bx	lr
    9646:	bf00      	nop

00009648 <_svfprintf_r>:
    9648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    964c:	ed2d 8b08 	vpush	{d8-d11}
    9650:	b0d1      	sub	sp, #324	; 0x144
    9652:	460c      	mov	r4, r1
    9654:	ee0b 1a10 	vmov	s22, r1
    9658:	4690      	mov	r8, r2
    965a:	9308      	str	r3, [sp, #32]
    965c:	4683      	mov	fp, r0
    965e:	f001 febb 	bl	b3d8 <_localeconv_r>
    9662:	6803      	ldr	r3, [r0, #0]
    9664:	9312      	str	r3, [sp, #72]	; 0x48
    9666:	4618      	mov	r0, r3
    9668:	f7ff fa4a 	bl	8b00 <strlen>
    966c:	af20      	add	r7, sp, #128	; 0x80
    966e:	9010      	str	r0, [sp, #64]	; 0x40
    9670:	2208      	movs	r2, #8
    9672:	2100      	movs	r1, #0
    9674:	4638      	mov	r0, r7
    9676:	f7ff f919 	bl	88ac <memset>
    967a:	89a3      	ldrh	r3, [r4, #12]
    967c:	061b      	lsls	r3, r3, #24
    967e:	d503      	bpl.n	9688 <_svfprintf_r+0x40>
    9680:	6923      	ldr	r3, [r4, #16]
    9682:	2b00      	cmp	r3, #0
    9684:	f000 8755 	beq.w	a532 <_svfprintf_r+0xeea>
    9688:	2300      	movs	r3, #0
    968a:	ed9f 8b83 	vldr	d8, [pc, #524]	; 9898 <_svfprintf_r+0x250>
    968e:	ed9f 9b84 	vldr	d9, [pc, #528]	; 98a0 <_svfprintf_r+0x258>
    9692:	e9cd 3325 	strd	r3, r3, [sp, #148]	; 0x94
    9696:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
    969a:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
    969e:	aa27      	add	r2, sp, #156	; 0x9c
    96a0:	930e      	str	r3, [sp, #56]	; 0x38
    96a2:	9224      	str	r2, [sp, #144]	; 0x90
    96a4:	4692      	mov	sl, r2
    96a6:	9311      	str	r3, [sp, #68]	; 0x44
    96a8:	9304      	str	r3, [sp, #16]
    96aa:	4644      	mov	r4, r8
    96ac:	46a1      	mov	r9, r4
    96ae:	4b7e      	ldr	r3, [pc, #504]	; (98a8 <_svfprintf_r+0x260>)
    96b0:	f8d3 50e4 	ldr.w	r5, [r3, #228]	; 0xe4
    96b4:	f7ff f97e 	bl	89b4 <__locale_mb_cur_max>
    96b8:	464a      	mov	r2, r9
    96ba:	4603      	mov	r3, r0
    96bc:	a91c      	add	r1, sp, #112	; 0x70
    96be:	9700      	str	r7, [sp, #0]
    96c0:	4658      	mov	r0, fp
    96c2:	47a8      	blx	r5
    96c4:	2800      	cmp	r0, #0
    96c6:	f000 80b0 	beq.w	982a <_svfprintf_r+0x1e2>
    96ca:	f2c0 80a6 	blt.w	981a <_svfprintf_r+0x1d2>
    96ce:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96d0:	2a25      	cmp	r2, #37	; 0x25
    96d2:	4603      	mov	r3, r0
    96d4:	d001      	beq.n	96da <_svfprintf_r+0x92>
    96d6:	4499      	add	r9, r3
    96d8:	e7e9      	b.n	96ae <_svfprintf_r+0x66>
    96da:	ebb9 0504 	subs.w	r5, r9, r4
    96de:	4606      	mov	r6, r0
    96e0:	f040 80a7 	bne.w	9832 <_svfprintf_r+0x1ea>
    96e4:	2300      	movs	r3, #0
    96e6:	f04f 32ff 	mov.w	r2, #4294967295
    96ea:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    96ee:	4698      	mov	r8, r3
    96f0:	9306      	str	r3, [sp, #24]
    96f2:	f109 0901 	add.w	r9, r9, #1
    96f6:	f899 3000 	ldrb.w	r3, [r9]
    96fa:	9203      	str	r2, [sp, #12]
    96fc:	252b      	movs	r5, #43	; 0x2b
    96fe:	2620      	movs	r6, #32
    9700:	f109 0901 	add.w	r9, r9, #1
    9704:	f1a3 0220 	sub.w	r2, r3, #32
    9708:	2a5a      	cmp	r2, #90	; 0x5a
    970a:	f200 80cf 	bhi.w	98ac <_svfprintf_r+0x264>
    970e:	e8df f012 	tbh	[pc, r2, lsl #1]
    9712:	02e8      	.short	0x02e8
    9714:	00cd00cd 	.word	0x00cd00cd
    9718:	00cd02e3 	.word	0x00cd02e3
    971c:	00cd00cd 	.word	0x00cd00cd
    9720:	00cd006a 	.word	0x00cd006a
    9724:	020500cd 	.word	0x020500cd
    9728:	00cd0284 	.word	0x00cd0284
    972c:	02c90210 	.word	0x02c90210
    9730:	02bd00cd 	.word	0x02bd00cd
    9734:	005b005b 	.word	0x005b005b
    9738:	005b005b 	.word	0x005b005b
    973c:	005b005b 	.word	0x005b005b
    9740:	005b005b 	.word	0x005b005b
    9744:	00cd005b 	.word	0x00cd005b
    9748:	00cd00cd 	.word	0x00cd00cd
    974c:	00cd00cd 	.word	0x00cd00cd
    9750:	00cd00cd 	.word	0x00cd00cd
    9754:	00cd0153 	.word	0x00cd0153
    9758:	021a0183 	.word	0x021a0183
    975c:	01530153 	.word	0x01530153
    9760:	00cd0153 	.word	0x00cd0153
    9764:	00cd00cd 	.word	0x00cd00cd
    9768:	021500cd 	.word	0x021500cd
    976c:	00cd00cd 	.word	0x00cd00cd
    9770:	00cd0296 	.word	0x00cd0296
    9774:	00cd00cd 	.word	0x00cd00cd
    9778:	00cd01ab 	.word	0x00cd01ab
    977c:	00cd02aa 	.word	0x00cd02aa
    9780:	06e300cd 	.word	0x06e300cd
    9784:	00cd00cd 	.word	0x00cd00cd
    9788:	00cd00cd 	.word	0x00cd00cd
    978c:	00cd00cd 	.word	0x00cd00cd
    9790:	00cd00cd 	.word	0x00cd00cd
    9794:	00cd0153 	.word	0x00cd0153
    9798:	01de0183 	.word	0x01de0183
    979c:	01530153 	.word	0x01530153
    97a0:	02770153 	.word	0x02770153
    97a4:	007f01de 	.word	0x007f01de
    97a8:	028900cd 	.word	0x028900cd
    97ac:	025f00cd 	.word	0x025f00cd
    97b0:	022f06e0 	.word	0x022f06e0
    97b4:	00cd007f 	.word	0x00cd007f
    97b8:	007c01ab 	.word	0x007c01ab
    97bc:	00cd06b8 	.word	0x00cd06b8
    97c0:	06bd00cd 	.word	0x06bd00cd
    97c4:	007c00cd 	.word	0x007c00cd
    97c8:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    97cc:	2100      	movs	r1, #0
    97ce:	f819 3b01 	ldrb.w	r3, [r9], #1
    97d2:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    97d6:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    97da:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    97de:	2a09      	cmp	r2, #9
    97e0:	d9f5      	bls.n	97ce <_svfprintf_r+0x186>
    97e2:	9106      	str	r1, [sp, #24]
    97e4:	e78e      	b.n	9704 <_svfprintf_r+0xbc>
    97e6:	4658      	mov	r0, fp
    97e8:	f001 fdf6 	bl	b3d8 <_localeconv_r>
    97ec:	6843      	ldr	r3, [r0, #4]
    97ee:	9315      	str	r3, [sp, #84]	; 0x54
    97f0:	4618      	mov	r0, r3
    97f2:	f7ff f985 	bl	8b00 <strlen>
    97f6:	9016      	str	r0, [sp, #88]	; 0x58
    97f8:	4658      	mov	r0, fp
    97fa:	f001 fded 	bl	b3d8 <_localeconv_r>
    97fe:	6883      	ldr	r3, [r0, #8]
    9800:	9313      	str	r3, [sp, #76]	; 0x4c
    9802:	9b16      	ldr	r3, [sp, #88]	; 0x58
    9804:	2b00      	cmp	r3, #0
    9806:	f040 862d 	bne.w	a464 <_svfprintf_r+0xe1c>
    980a:	f899 3000 	ldrb.w	r3, [r9]
    980e:	e777      	b.n	9700 <_svfprintf_r+0xb8>
    9810:	f899 3000 	ldrb.w	r3, [r9]
    9814:	f048 0820 	orr.w	r8, r8, #32
    9818:	e772      	b.n	9700 <_svfprintf_r+0xb8>
    981a:	2208      	movs	r2, #8
    981c:	2100      	movs	r1, #0
    981e:	4638      	mov	r0, r7
    9820:	f7ff f844 	bl	88ac <memset>
    9824:	2301      	movs	r3, #1
    9826:	4499      	add	r9, r3
    9828:	e741      	b.n	96ae <_svfprintf_r+0x66>
    982a:	ebb9 0504 	subs.w	r5, r9, r4
    982e:	4606      	mov	r6, r0
    9830:	d011      	beq.n	9856 <_svfprintf_r+0x20e>
    9832:	9b26      	ldr	r3, [sp, #152]	; 0x98
    9834:	442b      	add	r3, r5
    9836:	9326      	str	r3, [sp, #152]	; 0x98
    9838:	9b25      	ldr	r3, [sp, #148]	; 0x94
    983a:	3301      	adds	r3, #1
    983c:	2b07      	cmp	r3, #7
    983e:	e9ca 4500 	strd	r4, r5, [sl]
    9842:	9325      	str	r3, [sp, #148]	; 0x94
    9844:	dc1c      	bgt.n	9880 <_svfprintf_r+0x238>
    9846:	f10a 0a08 	add.w	sl, sl, #8
    984a:	9b04      	ldr	r3, [sp, #16]
    984c:	442b      	add	r3, r5
    984e:	9304      	str	r3, [sp, #16]
    9850:	2e00      	cmp	r6, #0
    9852:	f47f af47 	bne.w	96e4 <_svfprintf_r+0x9c>
    9856:	9b26      	ldr	r3, [sp, #152]	; 0x98
    9858:	2b00      	cmp	r3, #0
    985a:	f041 820b 	bne.w	ac74 <_svfprintf_r+0x162c>
    985e:	ee1b 3a10 	vmov	r3, s22
    9862:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    9866:	f013 0f40 	tst.w	r3, #64	; 0x40
    986a:	9b04      	ldr	r3, [sp, #16]
    986c:	bf18      	it	ne
    986e:	f04f 33ff 	movne.w	r3, #4294967295
    9872:	9304      	str	r3, [sp, #16]
    9874:	9804      	ldr	r0, [sp, #16]
    9876:	b051      	add	sp, #324	; 0x144
    9878:	ecbd 8b08 	vpop	{d8-d11}
    987c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9880:	ee1b 1a10 	vmov	r1, s22
    9884:	aa24      	add	r2, sp, #144	; 0x90
    9886:	4658      	mov	r0, fp
    9888:	f002 fde2 	bl	c450 <__ssprint_r>
    988c:	2800      	cmp	r0, #0
    988e:	d1e6      	bne.n	985e <_svfprintf_r+0x216>
    9890:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9894:	e7d9      	b.n	984a <_svfprintf_r+0x202>
    9896:	bf00      	nop
	...
    98a0:	ffffffff 	.word	0xffffffff
    98a4:	7fefffff 	.word	0x7fefffff
    98a8:	200011e4 	.word	0x200011e4
    98ac:	930b      	str	r3, [sp, #44]	; 0x2c
    98ae:	2b00      	cmp	r3, #0
    98b0:	d0d1      	beq.n	9856 <_svfprintf_r+0x20e>
    98b2:	2100      	movs	r1, #0
    98b4:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
    98b8:	f88d 30dc 	strb.w	r3, [sp, #220]	; 0xdc
    98bc:	2301      	movs	r3, #1
    98be:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    98c2:	9302      	str	r3, [sp, #8]
    98c4:	9107      	str	r1, [sp, #28]
    98c6:	9305      	str	r3, [sp, #20]
    98c8:	9103      	str	r1, [sp, #12]
    98ca:	910f      	str	r1, [sp, #60]	; 0x3c
    98cc:	ac37      	add	r4, sp, #220	; 0xdc
    98ce:	f018 0302 	ands.w	r3, r8, #2
    98d2:	9309      	str	r3, [sp, #36]	; 0x24
    98d4:	d002      	beq.n	98dc <_svfprintf_r+0x294>
    98d6:	9b02      	ldr	r3, [sp, #8]
    98d8:	3302      	adds	r3, #2
    98da:	9302      	str	r3, [sp, #8]
    98dc:	f018 0384 	ands.w	r3, r8, #132	; 0x84
    98e0:	930a      	str	r3, [sp, #40]	; 0x28
    98e2:	d105      	bne.n	98f0 <_svfprintf_r+0x2a8>
    98e4:	9b06      	ldr	r3, [sp, #24]
    98e6:	9a02      	ldr	r2, [sp, #8]
    98e8:	1a9d      	subs	r5, r3, r2
    98ea:	2d00      	cmp	r5, #0
    98ec:	f300 8369 	bgt.w	9fc2 <_svfprintf_r+0x97a>
    98f0:	9a26      	ldr	r2, [sp, #152]	; 0x98
    98f2:	b189      	cbz	r1, 9918 <_svfprintf_r+0x2d0>
    98f4:	9925      	ldr	r1, [sp, #148]	; 0x94
    98f6:	f10d 0067 	add.w	r0, sp, #103	; 0x67
    98fa:	3101      	adds	r1, #1
    98fc:	3201      	adds	r2, #1
    98fe:	f8ca 0000 	str.w	r0, [sl]
    9902:	2907      	cmp	r1, #7
    9904:	f04f 0001 	mov.w	r0, #1
    9908:	9226      	str	r2, [sp, #152]	; 0x98
    990a:	9125      	str	r1, [sp, #148]	; 0x94
    990c:	f8ca 0004 	str.w	r0, [sl, #4]
    9910:	f300 83a2 	bgt.w	a058 <_svfprintf_r+0xa10>
    9914:	f10a 0a08 	add.w	sl, sl, #8
    9918:	9b09      	ldr	r3, [sp, #36]	; 0x24
    991a:	b183      	cbz	r3, 993e <_svfprintf_r+0x2f6>
    991c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    991e:	a91a      	add	r1, sp, #104	; 0x68
    9920:	3301      	adds	r3, #1
    9922:	3202      	adds	r2, #2
    9924:	f8ca 1000 	str.w	r1, [sl]
    9928:	2b07      	cmp	r3, #7
    992a:	f04f 0102 	mov.w	r1, #2
    992e:	9226      	str	r2, [sp, #152]	; 0x98
    9930:	9325      	str	r3, [sp, #148]	; 0x94
    9932:	f8ca 1004 	str.w	r1, [sl, #4]
    9936:	f300 83a3 	bgt.w	a080 <_svfprintf_r+0xa38>
    993a:	f10a 0a08 	add.w	sl, sl, #8
    993e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9940:	2b80      	cmp	r3, #128	; 0x80
    9942:	f000 826c 	beq.w	9e1e <_svfprintf_r+0x7d6>
    9946:	9b03      	ldr	r3, [sp, #12]
    9948:	9905      	ldr	r1, [sp, #20]
    994a:	1a5d      	subs	r5, r3, r1
    994c:	2d00      	cmp	r5, #0
    994e:	f300 82a5 	bgt.w	9e9c <_svfprintf_r+0x854>
    9952:	f418 7f80 	tst.w	r8, #256	; 0x100
    9956:	f040 820d 	bne.w	9d74 <_svfprintf_r+0x72c>
    995a:	9b05      	ldr	r3, [sp, #20]
    995c:	f8ca 3004 	str.w	r3, [sl, #4]
    9960:	441a      	add	r2, r3
    9962:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9964:	f8ca 4000 	str.w	r4, [sl]
    9968:	3301      	adds	r3, #1
    996a:	2b07      	cmp	r3, #7
    996c:	9226      	str	r2, [sp, #152]	; 0x98
    996e:	9325      	str	r3, [sp, #148]	; 0x94
    9970:	f300 831b 	bgt.w	9faa <_svfprintf_r+0x962>
    9974:	f10a 0a08 	add.w	sl, sl, #8
    9978:	f018 0f04 	tst.w	r8, #4
    997c:	d005      	beq.n	998a <_svfprintf_r+0x342>
    997e:	9b06      	ldr	r3, [sp, #24]
    9980:	9902      	ldr	r1, [sp, #8]
    9982:	1a5c      	subs	r4, r3, r1
    9984:	2c00      	cmp	r4, #0
    9986:	f300 8388 	bgt.w	a09a <_svfprintf_r+0xa52>
    998a:	9b04      	ldr	r3, [sp, #16]
    998c:	9906      	ldr	r1, [sp, #24]
    998e:	9802      	ldr	r0, [sp, #8]
    9990:	4281      	cmp	r1, r0
    9992:	bfac      	ite	ge
    9994:	185b      	addge	r3, r3, r1
    9996:	181b      	addlt	r3, r3, r0
    9998:	9304      	str	r3, [sp, #16]
    999a:	2a00      	cmp	r2, #0
    999c:	f040 82b0 	bne.w	9f00 <_svfprintf_r+0x8b8>
    99a0:	2300      	movs	r3, #0
    99a2:	9325      	str	r3, [sp, #148]	; 0x94
    99a4:	9b07      	ldr	r3, [sp, #28]
    99a6:	b11b      	cbz	r3, 99b0 <_svfprintf_r+0x368>
    99a8:	9907      	ldr	r1, [sp, #28]
    99aa:	4658      	mov	r0, fp
    99ac:	f7ff f966 	bl	8c7c <_free_r>
    99b0:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    99b4:	464c      	mov	r4, r9
    99b6:	e679      	b.n	96ac <_svfprintf_r+0x64>
    99b8:	930b      	str	r3, [sp, #44]	; 0x2c
    99ba:	9b08      	ldr	r3, [sp, #32]
    99bc:	3307      	adds	r3, #7
    99be:	f023 0307 	bic.w	r3, r3, #7
    99c2:	ecb3 8b02 	vldmia	r3!, {d8}
    99c6:	eeb0 7bc8 	vabs.f64	d7, d8
    99ca:	eeb4 7b49 	vcmp.f64	d7, d9
    99ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    99d2:	9308      	str	r3, [sp, #32]
    99d4:	f340 84e9 	ble.w	a3aa <_svfprintf_r+0xd62>
    99d8:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    99dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    99e0:	f101 8059 	bmi.w	aa96 <_svfprintf_r+0x144e>
    99e4:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    99e8:	4cab      	ldr	r4, [pc, #684]	; (9c98 <_svfprintf_r+0x650>)
    99ea:	4bac      	ldr	r3, [pc, #688]	; (9c9c <_svfprintf_r+0x654>)
    99ec:	f028 0880 	bic.w	r8, r8, #128	; 0x80
    99f0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    99f2:	2a47      	cmp	r2, #71	; 0x47
    99f4:	bfc8      	it	gt
    99f6:	461c      	movgt	r4, r3
    99f8:	2300      	movs	r3, #0
    99fa:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    99fe:	2203      	movs	r2, #3
    9a00:	9307      	str	r3, [sp, #28]
    9a02:	9202      	str	r2, [sp, #8]
    9a04:	9205      	str	r2, [sp, #20]
    9a06:	9303      	str	r3, [sp, #12]
    9a08:	930f      	str	r3, [sp, #60]	; 0x3c
    9a0a:	2900      	cmp	r1, #0
    9a0c:	f43f af5f 	beq.w	98ce <_svfprintf_r+0x286>
    9a10:	9b02      	ldr	r3, [sp, #8]
    9a12:	3301      	adds	r3, #1
    9a14:	9302      	str	r3, [sp, #8]
    9a16:	e75a      	b.n	98ce <_svfprintf_r+0x286>
    9a18:	2b43      	cmp	r3, #67	; 0x43
    9a1a:	930b      	str	r3, [sp, #44]	; 0x2c
    9a1c:	d003      	beq.n	9a26 <_svfprintf_r+0x3de>
    9a1e:	f018 0f10 	tst.w	r8, #16
    9a22:	f000 855d 	beq.w	a4e0 <_svfprintf_r+0xe98>
    9a26:	9d08      	ldr	r5, [sp, #32]
    9a28:	2208      	movs	r2, #8
    9a2a:	2100      	movs	r1, #0
    9a2c:	a822      	add	r0, sp, #136	; 0x88
    9a2e:	ac37      	add	r4, sp, #220	; 0xdc
    9a30:	f7fe ff3c 	bl	88ac <memset>
    9a34:	ab22      	add	r3, sp, #136	; 0x88
    9a36:	f855 2b04 	ldr.w	r2, [r5], #4
    9a3a:	4621      	mov	r1, r4
    9a3c:	4658      	mov	r0, fp
    9a3e:	f002 fcc1 	bl	c3c4 <_wcrtomb_r>
    9a42:	4603      	mov	r3, r0
    9a44:	3301      	adds	r3, #1
    9a46:	9005      	str	r0, [sp, #20]
    9a48:	f001 82ee 	beq.w	b028 <_svfprintf_r+0x19e0>
    9a4c:	9b05      	ldr	r3, [sp, #20]
    9a4e:	9508      	str	r5, [sp, #32]
    9a50:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9a54:	9302      	str	r3, [sp, #8]
    9a56:	2100      	movs	r1, #0
    9a58:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
    9a5c:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    9a60:	9107      	str	r1, [sp, #28]
    9a62:	9103      	str	r1, [sp, #12]
    9a64:	910f      	str	r1, [sp, #60]	; 0x3c
    9a66:	e732      	b.n	98ce <_svfprintf_r+0x286>
    9a68:	930b      	str	r3, [sp, #44]	; 0x2c
    9a6a:	9b08      	ldr	r3, [sp, #32]
    9a6c:	461a      	mov	r2, r3
    9a6e:	2300      	movs	r3, #0
    9a70:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    9a74:	4613      	mov	r3, r2
    9a76:	f853 4b04 	ldr.w	r4, [r3], #4
    9a7a:	9308      	str	r3, [sp, #32]
    9a7c:	2c00      	cmp	r4, #0
    9a7e:	f000 8548 	beq.w	a512 <_svfprintf_r+0xeca>
    9a82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9a84:	2b53      	cmp	r3, #83	; 0x53
    9a86:	f000 86ec 	beq.w	a862 <_svfprintf_r+0x121a>
    9a8a:	f018 0310 	ands.w	r3, r8, #16
    9a8e:	930c      	str	r3, [sp, #48]	; 0x30
    9a90:	f040 86e7 	bne.w	a862 <_svfprintf_r+0x121a>
    9a94:	9b03      	ldr	r3, [sp, #12]
    9a96:	1c5d      	adds	r5, r3, #1
    9a98:	f001 80e5 	beq.w	ac66 <_svfprintf_r+0x161e>
    9a9c:	990c      	ldr	r1, [sp, #48]	; 0x30
    9a9e:	461a      	mov	r2, r3
    9aa0:	4620      	mov	r0, r4
    9aa2:	f001 fc9d 	bl	b3e0 <memchr>
    9aa6:	9007      	str	r0, [sp, #28]
    9aa8:	2800      	cmp	r0, #0
    9aaa:	f001 8328 	beq.w	b0fe <_svfprintf_r+0x1ab6>
    9aae:	9b07      	ldr	r3, [sp, #28]
    9ab0:	1b1a      	subs	r2, r3, r4
    9ab2:	9205      	str	r2, [sp, #20]
    9ab4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9ab6:	9303      	str	r3, [sp, #12]
    9ab8:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    9abc:	930f      	str	r3, [sp, #60]	; 0x3c
    9abe:	930d      	str	r3, [sp, #52]	; 0x34
    9ac0:	9307      	str	r3, [sp, #28]
    9ac2:	2373      	movs	r3, #115	; 0x73
    9ac4:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    9ac8:	9202      	str	r2, [sp, #8]
    9aca:	930b      	str	r3, [sp, #44]	; 0x2c
    9acc:	e79d      	b.n	9a0a <_svfprintf_r+0x3c2>
    9ace:	f018 0f20 	tst.w	r8, #32
    9ad2:	930b      	str	r3, [sp, #44]	; 0x2c
    9ad4:	9b08      	ldr	r3, [sp, #32]
    9ad6:	d03d      	beq.n	9b54 <_svfprintf_r+0x50c>
    9ad8:	3307      	adds	r3, #7
    9ada:	f023 0307 	bic.w	r3, r3, #7
    9ade:	461a      	mov	r2, r3
    9ae0:	4611      	mov	r1, r2
    9ae2:	685b      	ldr	r3, [r3, #4]
    9ae4:	f851 2b08 	ldr.w	r2, [r1], #8
    9ae8:	9108      	str	r1, [sp, #32]
    9aea:	4619      	mov	r1, r3
    9aec:	2b00      	cmp	r3, #0
    9aee:	f2c0 840c 	blt.w	a30a <_svfprintf_r+0xcc2>
    9af2:	9b03      	ldr	r3, [sp, #12]
    9af4:	3301      	adds	r3, #1
    9af6:	f000 829e 	beq.w	a036 <_svfprintf_r+0x9ee>
    9afa:	f028 0080 	bic.w	r0, r8, #128	; 0x80
    9afe:	ea52 0301 	orrs.w	r3, r2, r1
    9b02:	9002      	str	r0, [sp, #8]
    9b04:	f040 8299 	bne.w	a03a <_svfprintf_r+0x9f2>
    9b08:	9b03      	ldr	r3, [sp, #12]
    9b0a:	2b00      	cmp	r3, #0
    9b0c:	f040 829a 	bne.w	a044 <_svfprintf_r+0x9fc>
    9b10:	4680      	mov	r8, r0
    9b12:	2300      	movs	r3, #0
    9b14:	9303      	str	r3, [sp, #12]
    9b16:	9305      	str	r3, [sp, #20]
    9b18:	ac50      	add	r4, sp, #320	; 0x140
    9b1a:	e106      	b.n	9d2a <_svfprintf_r+0x6e2>
    9b1c:	9b08      	ldr	r3, [sp, #32]
    9b1e:	f853 2b04 	ldr.w	r2, [r3], #4
    9b22:	9206      	str	r2, [sp, #24]
    9b24:	2a00      	cmp	r2, #0
    9b26:	f280 8419 	bge.w	a35c <_svfprintf_r+0xd14>
    9b2a:	9a06      	ldr	r2, [sp, #24]
    9b2c:	9308      	str	r3, [sp, #32]
    9b2e:	4252      	negs	r2, r2
    9b30:	9206      	str	r2, [sp, #24]
    9b32:	f899 3000 	ldrb.w	r3, [r9]
    9b36:	f048 0804 	orr.w	r8, r8, #4
    9b3a:	e5e1      	b.n	9700 <_svfprintf_r+0xb8>
    9b3c:	f899 3000 	ldrb.w	r3, [r9]
    9b40:	f048 0808 	orr.w	r8, r8, #8
    9b44:	e5dc      	b.n	9700 <_svfprintf_r+0xb8>
    9b46:	f048 0810 	orr.w	r8, r8, #16
    9b4a:	f018 0f20 	tst.w	r8, #32
    9b4e:	930b      	str	r3, [sp, #44]	; 0x2c
    9b50:	9b08      	ldr	r3, [sp, #32]
    9b52:	d1c1      	bne.n	9ad8 <_svfprintf_r+0x490>
    9b54:	f018 0f10 	tst.w	r8, #16
    9b58:	f040 840b 	bne.w	a372 <_svfprintf_r+0xd2a>
    9b5c:	f018 0f40 	tst.w	r8, #64	; 0x40
    9b60:	f000 8403 	beq.w	a36a <_svfprintf_r+0xd22>
    9b64:	f933 2b04 	ldrsh.w	r2, [r3], #4
    9b68:	9308      	str	r3, [sp, #32]
    9b6a:	17d1      	asrs	r1, r2, #31
    9b6c:	460b      	mov	r3, r1
    9b6e:	e7bd      	b.n	9aec <_svfprintf_r+0x4a4>
    9b70:	9b08      	ldr	r3, [sp, #32]
    9b72:	f048 0202 	orr.w	r2, r8, #2
    9b76:	9202      	str	r2, [sp, #8]
    9b78:	f853 2b04 	ldr.w	r2, [r3], #4
    9b7c:	9308      	str	r3, [sp, #32]
    9b7e:	f647 0330 	movw	r3, #30768	; 0x7830
    9b82:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    9b86:	2078      	movs	r0, #120	; 0x78
    9b88:	4b45      	ldr	r3, [pc, #276]	; (9ca0 <_svfprintf_r+0x658>)
    9b8a:	9311      	str	r3, [sp, #68]	; 0x44
    9b8c:	2100      	movs	r1, #0
    9b8e:	2302      	movs	r3, #2
    9b90:	900b      	str	r0, [sp, #44]	; 0x2c
    9b92:	2000      	movs	r0, #0
    9b94:	9c03      	ldr	r4, [sp, #12]
    9b96:	f88d 0067 	strb.w	r0, [sp, #103]	; 0x67
    9b9a:	1c60      	adds	r0, r4, #1
    9b9c:	f000 80ad 	beq.w	9cfa <_svfprintf_r+0x6b2>
    9ba0:	9802      	ldr	r0, [sp, #8]
    9ba2:	f020 0880 	bic.w	r8, r0, #128	; 0x80
    9ba6:	ea52 0001 	orrs.w	r0, r2, r1
    9baa:	f040 80a4 	bne.w	9cf6 <_svfprintf_r+0x6ae>
    9bae:	2c00      	cmp	r4, #0
    9bb0:	f040 86ae 	bne.w	a910 <_svfprintf_r+0x12c8>
    9bb4:	2b00      	cmp	r3, #0
    9bb6:	d1ac      	bne.n	9b12 <_svfprintf_r+0x4ca>
    9bb8:	9b02      	ldr	r3, [sp, #8]
    9bba:	f013 0301 	ands.w	r3, r3, #1
    9bbe:	9305      	str	r3, [sp, #20]
    9bc0:	f000 83d1 	beq.w	a366 <_svfprintf_r+0xd1e>
    9bc4:	2330      	movs	r3, #48	; 0x30
    9bc6:	f88d 313f 	strb.w	r3, [sp, #319]	; 0x13f
    9bca:	f20d 143f 	addw	r4, sp, #319	; 0x13f
    9bce:	e0ac      	b.n	9d2a <_svfprintf_r+0x6e2>
    9bd0:	f018 0f20 	tst.w	r8, #32
    9bd4:	f040 83d4 	bne.w	a380 <_svfprintf_r+0xd38>
    9bd8:	f018 0f10 	tst.w	r8, #16
    9bdc:	f040 869f 	bne.w	a91e <_svfprintf_r+0x12d6>
    9be0:	f018 0f40 	tst.w	r8, #64	; 0x40
    9be4:	f040 8797 	bne.w	ab16 <_svfprintf_r+0x14ce>
    9be8:	f418 7f00 	tst.w	r8, #512	; 0x200
    9bec:	f000 8697 	beq.w	a91e <_svfprintf_r+0x12d6>
    9bf0:	9b08      	ldr	r3, [sp, #32]
    9bf2:	9904      	ldr	r1, [sp, #16]
    9bf4:	f853 2b04 	ldr.w	r2, [r3], #4
    9bf8:	9308      	str	r3, [sp, #32]
    9bfa:	7011      	strb	r1, [r2, #0]
    9bfc:	464c      	mov	r4, r9
    9bfe:	e555      	b.n	96ac <_svfprintf_r+0x64>
    9c00:	f899 3000 	ldrb.w	r3, [r9]
    9c04:	2b68      	cmp	r3, #104	; 0x68
    9c06:	bf03      	ittte	eq
    9c08:	f899 3001 	ldrbeq.w	r3, [r9, #1]
    9c0c:	f448 7800 	orreq.w	r8, r8, #512	; 0x200
    9c10:	f109 0901 	addeq.w	r9, r9, #1
    9c14:	f048 0840 	orrne.w	r8, r8, #64	; 0x40
    9c18:	e572      	b.n	9700 <_svfprintf_r+0xb8>
    9c1a:	f899 3000 	ldrb.w	r3, [r9]
    9c1e:	f88d 5067 	strb.w	r5, [sp, #103]	; 0x67
    9c22:	e56d      	b.n	9700 <_svfprintf_r+0xb8>
    9c24:	f899 3000 	ldrb.w	r3, [r9]
    9c28:	2b6c      	cmp	r3, #108	; 0x6c
    9c2a:	bf03      	ittte	eq
    9c2c:	f899 3001 	ldrbeq.w	r3, [r9, #1]
    9c30:	f048 0820 	orreq.w	r8, r8, #32
    9c34:	f109 0901 	addeq.w	r9, r9, #1
    9c38:	f048 0810 	orrne.w	r8, r8, #16
    9c3c:	e560      	b.n	9700 <_svfprintf_r+0xb8>
    9c3e:	930b      	str	r3, [sp, #44]	; 0x2c
    9c40:	f048 0810 	orr.w	r8, r8, #16
    9c44:	f018 0120 	ands.w	r1, r8, #32
    9c48:	f000 8351 	beq.w	a2ee <_svfprintf_r+0xca6>
    9c4c:	9b08      	ldr	r3, [sp, #32]
    9c4e:	3307      	adds	r3, #7
    9c50:	f023 0307 	bic.w	r3, r3, #7
    9c54:	6859      	ldr	r1, [r3, #4]
    9c56:	f853 2b08 	ldr.w	r2, [r3], #8
    9c5a:	9308      	str	r3, [sp, #32]
    9c5c:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
    9c60:	9302      	str	r3, [sp, #8]
    9c62:	2300      	movs	r3, #0
    9c64:	e795      	b.n	9b92 <_svfprintf_r+0x54a>
    9c66:	930b      	str	r3, [sp, #44]	; 0x2c
    9c68:	f048 0310 	orr.w	r3, r8, #16
    9c6c:	9302      	str	r3, [sp, #8]
    9c6e:	9b02      	ldr	r3, [sp, #8]
    9c70:	f013 0120 	ands.w	r1, r3, #32
    9c74:	f000 8329 	beq.w	a2ca <_svfprintf_r+0xc82>
    9c78:	9b08      	ldr	r3, [sp, #32]
    9c7a:	3307      	adds	r3, #7
    9c7c:	f023 0307 	bic.w	r3, r3, #7
    9c80:	6859      	ldr	r1, [r3, #4]
    9c82:	f853 2b08 	ldr.w	r2, [r3], #8
    9c86:	9308      	str	r3, [sp, #32]
    9c88:	2301      	movs	r3, #1
    9c8a:	e782      	b.n	9b92 <_svfprintf_r+0x54a>
    9c8c:	f899 3000 	ldrb.w	r3, [r9]
    9c90:	f048 0880 	orr.w	r8, r8, #128	; 0x80
    9c94:	e534      	b.n	9700 <_svfprintf_r+0xb8>
    9c96:	bf00      	nop
    9c98:	20000b1c 	.word	0x20000b1c
    9c9c:	20000b20 	.word	0x20000b20
    9ca0:	20000b2c 	.word	0x20000b2c
    9ca4:	4649      	mov	r1, r9
    9ca6:	f811 3b01 	ldrb.w	r3, [r1], #1
    9caa:	2b2a      	cmp	r3, #42	; 0x2a
    9cac:	f001 8249 	beq.w	b142 <_svfprintf_r+0x1afa>
    9cb0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    9cb4:	2a09      	cmp	r2, #9
    9cb6:	4689      	mov	r9, r1
    9cb8:	bf98      	it	ls
    9cba:	2100      	movls	r1, #0
    9cbc:	f201 8144 	bhi.w	af48 <_svfprintf_r+0x1900>
    9cc0:	f819 3b01 	ldrb.w	r3, [r9], #1
    9cc4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    9cc8:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    9ccc:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    9cd0:	2a09      	cmp	r2, #9
    9cd2:	d9f5      	bls.n	9cc0 <_svfprintf_r+0x678>
    9cd4:	9103      	str	r1, [sp, #12]
    9cd6:	e515      	b.n	9704 <_svfprintf_r+0xbc>
    9cd8:	f899 3000 	ldrb.w	r3, [r9]
    9cdc:	f048 0801 	orr.w	r8, r8, #1
    9ce0:	e50e      	b.n	9700 <_svfprintf_r+0xb8>
    9ce2:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    9ce6:	2b00      	cmp	r3, #0
    9ce8:	f47f ad8f 	bne.w	980a <_svfprintf_r+0x1c2>
    9cec:	f899 3000 	ldrb.w	r3, [r9]
    9cf0:	f88d 6067 	strb.w	r6, [sp, #103]	; 0x67
    9cf4:	e504      	b.n	9700 <_svfprintf_r+0xb8>
    9cf6:	f8cd 8008 	str.w	r8, [sp, #8]
    9cfa:	2b01      	cmp	r3, #1
    9cfc:	f000 819d 	beq.w	a03a <_svfprintf_r+0x9f2>
    9d00:	2b02      	cmp	r3, #2
    9d02:	ac50      	add	r4, sp, #320	; 0x140
    9d04:	d120      	bne.n	9d48 <_svfprintf_r+0x700>
    9d06:	9811      	ldr	r0, [sp, #68]	; 0x44
    9d08:	f002 030f 	and.w	r3, r2, #15
    9d0c:	0912      	lsrs	r2, r2, #4
    9d0e:	5cc3      	ldrb	r3, [r0, r3]
    9d10:	f804 3d01 	strb.w	r3, [r4, #-1]!
    9d14:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
    9d18:	0909      	lsrs	r1, r1, #4
    9d1a:	ea52 0301 	orrs.w	r3, r2, r1
    9d1e:	d1f3      	bne.n	9d08 <_svfprintf_r+0x6c0>
    9d20:	ab50      	add	r3, sp, #320	; 0x140
    9d22:	1b1b      	subs	r3, r3, r4
    9d24:	f8dd 8008 	ldr.w	r8, [sp, #8]
    9d28:	9305      	str	r3, [sp, #20]
    9d2a:	9a05      	ldr	r2, [sp, #20]
    9d2c:	9803      	ldr	r0, [sp, #12]
    9d2e:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    9d32:	4282      	cmp	r2, r0
    9d34:	f04f 0300 	mov.w	r3, #0
    9d38:	bfb8      	it	lt
    9d3a:	4602      	movlt	r2, r0
    9d3c:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    9d40:	9307      	str	r3, [sp, #28]
    9d42:	9202      	str	r2, [sp, #8]
    9d44:	930f      	str	r3, [sp, #60]	; 0x3c
    9d46:	e660      	b.n	9a0a <_svfprintf_r+0x3c2>
    9d48:	f002 0307 	and.w	r3, r2, #7
    9d4c:	08d2      	lsrs	r2, r2, #3
    9d4e:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
    9d52:	08c9      	lsrs	r1, r1, #3
    9d54:	3330      	adds	r3, #48	; 0x30
    9d56:	ea52 0501 	orrs.w	r5, r2, r1
    9d5a:	4620      	mov	r0, r4
    9d5c:	f804 3d01 	strb.w	r3, [r4, #-1]!
    9d60:	d1f2      	bne.n	9d48 <_svfprintf_r+0x700>
    9d62:	9a02      	ldr	r2, [sp, #8]
    9d64:	07d1      	lsls	r1, r2, #31
    9d66:	f100 824d 	bmi.w	a204 <_svfprintf_r+0xbbc>
    9d6a:	ab50      	add	r3, sp, #320	; 0x140
    9d6c:	1b1b      	subs	r3, r3, r4
    9d6e:	4690      	mov	r8, r2
    9d70:	9305      	str	r3, [sp, #20]
    9d72:	e7da      	b.n	9d2a <_svfprintf_r+0x6e2>
    9d74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9d76:	2b65      	cmp	r3, #101	; 0x65
    9d78:	f340 80d4 	ble.w	9f24 <_svfprintf_r+0x8dc>
    9d7c:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9d80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9d84:	f040 81c1 	bne.w	a10a <_svfprintf_r+0xac2>
    9d88:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9d8a:	49ba      	ldr	r1, [pc, #744]	; (a074 <_svfprintf_r+0xa2c>)
    9d8c:	f8ca 1000 	str.w	r1, [sl]
    9d90:	3301      	adds	r3, #1
    9d92:	3201      	adds	r2, #1
    9d94:	2101      	movs	r1, #1
    9d96:	2b07      	cmp	r3, #7
    9d98:	9226      	str	r2, [sp, #152]	; 0x98
    9d9a:	9325      	str	r3, [sp, #148]	; 0x94
    9d9c:	f8ca 1004 	str.w	r1, [sl, #4]
    9da0:	f300 8551 	bgt.w	a846 <_svfprintf_r+0x11fe>
    9da4:	f10a 0a08 	add.w	sl, sl, #8
    9da8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9daa:	990e      	ldr	r1, [sp, #56]	; 0x38
    9dac:	428b      	cmp	r3, r1
    9dae:	f280 82d0 	bge.w	a352 <_svfprintf_r+0xd0a>
    9db2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    9db4:	9912      	ldr	r1, [sp, #72]	; 0x48
    9db6:	441a      	add	r2, r3
    9db8:	e9ca 1300 	strd	r1, r3, [sl]
    9dbc:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9dbe:	9226      	str	r2, [sp, #152]	; 0x98
    9dc0:	3301      	adds	r3, #1
    9dc2:	2b07      	cmp	r3, #7
    9dc4:	9325      	str	r3, [sp, #148]	; 0x94
    9dc6:	f300 8397 	bgt.w	a4f8 <_svfprintf_r+0xeb0>
    9dca:	f10a 0a08 	add.w	sl, sl, #8
    9dce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9dd0:	1e5c      	subs	r4, r3, #1
    9dd2:	2c00      	cmp	r4, #0
    9dd4:	f77f add0 	ble.w	9978 <_svfprintf_r+0x330>
    9dd8:	2c10      	cmp	r4, #16
    9dda:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9ddc:	f340 856e 	ble.w	a8bc <_svfprintf_r+0x1274>
    9de0:	ee1b 6a10 	vmov	r6, s22
    9de4:	2510      	movs	r5, #16
    9de6:	e005      	b.n	9df4 <_svfprintf_r+0x7ac>
    9de8:	f10a 0a08 	add.w	sl, sl, #8
    9dec:	3c10      	subs	r4, #16
    9dee:	2c10      	cmp	r4, #16
    9df0:	f340 8564 	ble.w	a8bc <_svfprintf_r+0x1274>
    9df4:	3301      	adds	r3, #1
    9df6:	49a0      	ldr	r1, [pc, #640]	; (a078 <_svfprintf_r+0xa30>)
    9df8:	3210      	adds	r2, #16
    9dfa:	2b07      	cmp	r3, #7
    9dfc:	e9ca 1500 	strd	r1, r5, [sl]
    9e00:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9e04:	ddf0      	ble.n	9de8 <_svfprintf_r+0x7a0>
    9e06:	aa24      	add	r2, sp, #144	; 0x90
    9e08:	4631      	mov	r1, r6
    9e0a:	4658      	mov	r0, fp
    9e0c:	f002 fb20 	bl	c450 <__ssprint_r>
    9e10:	2800      	cmp	r0, #0
    9e12:	d17e      	bne.n	9f12 <_svfprintf_r+0x8ca>
    9e14:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    9e18:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9e1c:	e7e6      	b.n	9dec <_svfprintf_r+0x7a4>
    9e1e:	9b06      	ldr	r3, [sp, #24]
    9e20:	9902      	ldr	r1, [sp, #8]
    9e22:	1a5d      	subs	r5, r3, r1
    9e24:	2d00      	cmp	r5, #0
    9e26:	f77f ad8e 	ble.w	9946 <_svfprintf_r+0x2fe>
    9e2a:	2d10      	cmp	r5, #16
    9e2c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9e2e:	dd21      	ble.n	9e74 <_svfprintf_r+0x82c>
    9e30:	9409      	str	r4, [sp, #36]	; 0x24
    9e32:	2610      	movs	r6, #16
    9e34:	ee1b 4a10 	vmov	r4, s22
    9e38:	e004      	b.n	9e44 <_svfprintf_r+0x7fc>
    9e3a:	3d10      	subs	r5, #16
    9e3c:	2d10      	cmp	r5, #16
    9e3e:	f10a 0a08 	add.w	sl, sl, #8
    9e42:	dd16      	ble.n	9e72 <_svfprintf_r+0x82a>
    9e44:	3301      	adds	r3, #1
    9e46:	498c      	ldr	r1, [pc, #560]	; (a078 <_svfprintf_r+0xa30>)
    9e48:	3210      	adds	r2, #16
    9e4a:	2b07      	cmp	r3, #7
    9e4c:	e9ca 1600 	strd	r1, r6, [sl]
    9e50:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9e54:	ddf1      	ble.n	9e3a <_svfprintf_r+0x7f2>
    9e56:	aa24      	add	r2, sp, #144	; 0x90
    9e58:	4621      	mov	r1, r4
    9e5a:	4658      	mov	r0, fp
    9e5c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9e60:	f002 faf6 	bl	c450 <__ssprint_r>
    9e64:	2800      	cmp	r0, #0
    9e66:	d154      	bne.n	9f12 <_svfprintf_r+0x8ca>
    9e68:	3d10      	subs	r5, #16
    9e6a:	2d10      	cmp	r5, #16
    9e6c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    9e70:	dce8      	bgt.n	9e44 <_svfprintf_r+0x7fc>
    9e72:	9c09      	ldr	r4, [sp, #36]	; 0x24
    9e74:	4980      	ldr	r1, [pc, #512]	; (a078 <_svfprintf_r+0xa30>)
    9e76:	f8ca 5004 	str.w	r5, [sl, #4]
    9e7a:	3301      	adds	r3, #1
    9e7c:	442a      	add	r2, r5
    9e7e:	2b07      	cmp	r3, #7
    9e80:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9e84:	f8ca 1000 	str.w	r1, [sl]
    9e88:	f300 8526 	bgt.w	a8d8 <_svfprintf_r+0x1290>
    9e8c:	9b03      	ldr	r3, [sp, #12]
    9e8e:	9905      	ldr	r1, [sp, #20]
    9e90:	1a5d      	subs	r5, r3, r1
    9e92:	2d00      	cmp	r5, #0
    9e94:	f10a 0a08 	add.w	sl, sl, #8
    9e98:	f77f ad5b 	ble.w	9952 <_svfprintf_r+0x30a>
    9e9c:	2d10      	cmp	r5, #16
    9e9e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9ea0:	dd1f      	ble.n	9ee2 <_svfprintf_r+0x89a>
    9ea2:	4651      	mov	r1, sl
    9ea4:	2610      	movs	r6, #16
    9ea6:	ee1b aa10 	vmov	sl, s22
    9eaa:	e004      	b.n	9eb6 <_svfprintf_r+0x86e>
    9eac:	3d10      	subs	r5, #16
    9eae:	2d10      	cmp	r5, #16
    9eb0:	f101 0108 	add.w	r1, r1, #8
    9eb4:	dd14      	ble.n	9ee0 <_svfprintf_r+0x898>
    9eb6:	3301      	adds	r3, #1
    9eb8:	486f      	ldr	r0, [pc, #444]	; (a078 <_svfprintf_r+0xa30>)
    9eba:	3210      	adds	r2, #16
    9ebc:	2b07      	cmp	r3, #7
    9ebe:	e9c1 0600 	strd	r0, r6, [r1]
    9ec2:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9ec6:	ddf1      	ble.n	9eac <_svfprintf_r+0x864>
    9ec8:	aa24      	add	r2, sp, #144	; 0x90
    9eca:	4651      	mov	r1, sl
    9ecc:	4658      	mov	r0, fp
    9ece:	f002 fabf 	bl	c450 <__ssprint_r>
    9ed2:	b9f0      	cbnz	r0, 9f12 <_svfprintf_r+0x8ca>
    9ed4:	3d10      	subs	r5, #16
    9ed6:	2d10      	cmp	r5, #16
    9ed8:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    9edc:	a927      	add	r1, sp, #156	; 0x9c
    9ede:	dcea      	bgt.n	9eb6 <_svfprintf_r+0x86e>
    9ee0:	468a      	mov	sl, r1
    9ee2:	3301      	adds	r3, #1
    9ee4:	4964      	ldr	r1, [pc, #400]	; (a078 <_svfprintf_r+0xa30>)
    9ee6:	f8ca 5004 	str.w	r5, [sl, #4]
    9eea:	442a      	add	r2, r5
    9eec:	2b07      	cmp	r3, #7
    9eee:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9ef2:	f8ca 1000 	str.w	r1, [sl]
    9ef6:	f300 81da 	bgt.w	a2ae <_svfprintf_r+0xc66>
    9efa:	f10a 0a08 	add.w	sl, sl, #8
    9efe:	e528      	b.n	9952 <_svfprintf_r+0x30a>
    9f00:	ee1b 1a10 	vmov	r1, s22
    9f04:	aa24      	add	r2, sp, #144	; 0x90
    9f06:	4658      	mov	r0, fp
    9f08:	f002 faa2 	bl	c450 <__ssprint_r>
    9f0c:	2800      	cmp	r0, #0
    9f0e:	f43f ad47 	beq.w	99a0 <_svfprintf_r+0x358>
    9f12:	9b07      	ldr	r3, [sp, #28]
    9f14:	2b00      	cmp	r3, #0
    9f16:	f43f aca2 	beq.w	985e <_svfprintf_r+0x216>
    9f1a:	9907      	ldr	r1, [sp, #28]
    9f1c:	4658      	mov	r0, fp
    9f1e:	f7fe fead 	bl	8c7c <_free_r>
    9f22:	e49c      	b.n	985e <_svfprintf_r+0x216>
    9f24:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9f26:	2b01      	cmp	r3, #1
    9f28:	f340 817a 	ble.w	a220 <_svfprintf_r+0xbd8>
    9f2c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9f2e:	f8ca 4000 	str.w	r4, [sl]
    9f32:	3301      	adds	r3, #1
    9f34:	3201      	adds	r2, #1
    9f36:	2101      	movs	r1, #1
    9f38:	2b07      	cmp	r3, #7
    9f3a:	9226      	str	r2, [sp, #152]	; 0x98
    9f3c:	9325      	str	r3, [sp, #148]	; 0x94
    9f3e:	f8ca 1004 	str.w	r1, [sl, #4]
    9f42:	f300 81f8 	bgt.w	a336 <_svfprintf_r+0xcee>
    9f46:	f10a 0a08 	add.w	sl, sl, #8
    9f4a:	9910      	ldr	r1, [sp, #64]	; 0x40
    9f4c:	9812      	ldr	r0, [sp, #72]	; 0x48
    9f4e:	3301      	adds	r3, #1
    9f50:	440a      	add	r2, r1
    9f52:	2b07      	cmp	r3, #7
    9f54:	e9ca 0100 	strd	r0, r1, [sl]
    9f58:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9f5c:	f300 81dd 	bgt.w	a31a <_svfprintf_r+0xcd2>
    9f60:	f10a 0a08 	add.w	sl, sl, #8
    9f64:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9f68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9f6c:	f000 8177 	beq.w	a25e <_svfprintf_r+0xc16>
    9f70:	990e      	ldr	r1, [sp, #56]	; 0x38
    9f72:	3301      	adds	r3, #1
    9f74:	3901      	subs	r1, #1
    9f76:	3401      	adds	r4, #1
    9f78:	440a      	add	r2, r1
    9f7a:	2b07      	cmp	r3, #7
    9f7c:	f8ca 4000 	str.w	r4, [sl]
    9f80:	9325      	str	r3, [sp, #148]	; 0x94
    9f82:	f8ca 1004 	str.w	r1, [sl, #4]
    9f86:	9226      	str	r2, [sp, #152]	; 0x98
    9f88:	f300 815b 	bgt.w	a242 <_svfprintf_r+0xbfa>
    9f8c:	f10a 0a08 	add.w	sl, sl, #8
    9f90:	9914      	ldr	r1, [sp, #80]	; 0x50
    9f92:	f8ca 1004 	str.w	r1, [sl, #4]
    9f96:	3301      	adds	r3, #1
    9f98:	440a      	add	r2, r1
    9f9a:	2b07      	cmp	r3, #7
    9f9c:	a91e      	add	r1, sp, #120	; 0x78
    9f9e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9fa2:	f8ca 1000 	str.w	r1, [sl]
    9fa6:	f77f ace5 	ble.w	9974 <_svfprintf_r+0x32c>
    9faa:	ee1b 1a10 	vmov	r1, s22
    9fae:	aa24      	add	r2, sp, #144	; 0x90
    9fb0:	4658      	mov	r0, fp
    9fb2:	f002 fa4d 	bl	c450 <__ssprint_r>
    9fb6:	2800      	cmp	r0, #0
    9fb8:	d1ab      	bne.n	9f12 <_svfprintf_r+0x8ca>
    9fba:	9a26      	ldr	r2, [sp, #152]	; 0x98
    9fbc:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9fc0:	e4da      	b.n	9978 <_svfprintf_r+0x330>
    9fc2:	2d10      	cmp	r5, #16
    9fc4:	e9dd 1225 	ldrd	r1, r2, [sp, #148]	; 0x94
    9fc8:	4e2c      	ldr	r6, [pc, #176]	; (a07c <_svfprintf_r+0xa34>)
    9fca:	dd24      	ble.n	a016 <_svfprintf_r+0x9ce>
    9fcc:	9417      	str	r4, [sp, #92]	; 0x5c
    9fce:	2310      	movs	r3, #16
    9fd0:	ee1b 4a10 	vmov	r4, s22
    9fd4:	4608      	mov	r0, r1
    9fd6:	e004      	b.n	9fe2 <_svfprintf_r+0x99a>
    9fd8:	3d10      	subs	r5, #16
    9fda:	2d10      	cmp	r5, #16
    9fdc:	f10a 0a08 	add.w	sl, sl, #8
    9fe0:	dd17      	ble.n	a012 <_svfprintf_r+0x9ca>
    9fe2:	3001      	adds	r0, #1
    9fe4:	3210      	adds	r2, #16
    9fe6:	2807      	cmp	r0, #7
    9fe8:	e9ca 6300 	strd	r6, r3, [sl]
    9fec:	e9cd 0225 	strd	r0, r2, [sp, #148]	; 0x94
    9ff0:	ddf2      	ble.n	9fd8 <_svfprintf_r+0x990>
    9ff2:	aa24      	add	r2, sp, #144	; 0x90
    9ff4:	4621      	mov	r1, r4
    9ff6:	4658      	mov	r0, fp
    9ff8:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9ffc:	f002 fa28 	bl	c450 <__ssprint_r>
    a000:	2800      	cmp	r0, #0
    a002:	d186      	bne.n	9f12 <_svfprintf_r+0x8ca>
    a004:	3d10      	subs	r5, #16
    a006:	2d10      	cmp	r5, #16
    a008:	e9dd 0225 	ldrd	r0, r2, [sp, #148]	; 0x94
    a00c:	f04f 0310 	mov.w	r3, #16
    a010:	dce7      	bgt.n	9fe2 <_svfprintf_r+0x99a>
    a012:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    a014:	4601      	mov	r1, r0
    a016:	3101      	adds	r1, #1
    a018:	442a      	add	r2, r5
    a01a:	2907      	cmp	r1, #7
    a01c:	e9cd 1225 	strd	r1, r2, [sp, #148]	; 0x94
    a020:	f8ca 6000 	str.w	r6, [sl]
    a024:	f8ca 5004 	str.w	r5, [sl, #4]
    a028:	f300 83bd 	bgt.w	a7a6 <_svfprintf_r+0x115e>
    a02c:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    a030:	f10a 0a08 	add.w	sl, sl, #8
    a034:	e45d      	b.n	98f2 <_svfprintf_r+0x2aa>
    a036:	f8cd 8008 	str.w	r8, [sp, #8]
    a03a:	2a0a      	cmp	r2, #10
    a03c:	f171 0300 	sbcs.w	r3, r1, #0
    a040:	f080 8345 	bcs.w	a6ce <_svfprintf_r+0x1086>
    a044:	3230      	adds	r2, #48	; 0x30
    a046:	2301      	movs	r3, #1
    a048:	f8dd 8008 	ldr.w	r8, [sp, #8]
    a04c:	f88d 213f 	strb.w	r2, [sp, #319]	; 0x13f
    a050:	9305      	str	r3, [sp, #20]
    a052:	f20d 143f 	addw	r4, sp, #319	; 0x13f
    a056:	e668      	b.n	9d2a <_svfprintf_r+0x6e2>
    a058:	ee1b 1a10 	vmov	r1, s22
    a05c:	aa24      	add	r2, sp, #144	; 0x90
    a05e:	4658      	mov	r0, fp
    a060:	f002 f9f6 	bl	c450 <__ssprint_r>
    a064:	2800      	cmp	r0, #0
    a066:	f47f af54 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a06a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a06c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a070:	e452      	b.n	9918 <_svfprintf_r+0x2d0>
    a072:	bf00      	nop
    a074:	20000524 	.word	0x20000524
    a078:	20000fc8 	.word	0x20000fc8
    a07c:	20000b5c 	.word	0x20000b5c
    a080:	ee1b 1a10 	vmov	r1, s22
    a084:	aa24      	add	r2, sp, #144	; 0x90
    a086:	4658      	mov	r0, fp
    a088:	f002 f9e2 	bl	c450 <__ssprint_r>
    a08c:	2800      	cmp	r0, #0
    a08e:	f47f af40 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a092:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a094:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a098:	e451      	b.n	993e <_svfprintf_r+0x2f6>
    a09a:	2c10      	cmp	r4, #16
    a09c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a09e:	4ebe      	ldr	r6, [pc, #760]	; (a398 <_svfprintf_r+0xd50>)
    a0a0:	dd1f      	ble.n	a0e2 <_svfprintf_r+0xa9a>
    a0a2:	ee1b 8a10 	vmov	r8, s22
    a0a6:	2510      	movs	r5, #16
    a0a8:	e004      	b.n	a0b4 <_svfprintf_r+0xa6c>
    a0aa:	3c10      	subs	r4, #16
    a0ac:	2c10      	cmp	r4, #16
    a0ae:	f10a 0a08 	add.w	sl, sl, #8
    a0b2:	dd16      	ble.n	a0e2 <_svfprintf_r+0xa9a>
    a0b4:	3301      	adds	r3, #1
    a0b6:	3210      	adds	r2, #16
    a0b8:	2b07      	cmp	r3, #7
    a0ba:	e9ca 6500 	strd	r6, r5, [sl]
    a0be:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a0c2:	ddf2      	ble.n	a0aa <_svfprintf_r+0xa62>
    a0c4:	aa24      	add	r2, sp, #144	; 0x90
    a0c6:	4641      	mov	r1, r8
    a0c8:	4658      	mov	r0, fp
    a0ca:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a0ce:	f002 f9bf 	bl	c450 <__ssprint_r>
    a0d2:	2800      	cmp	r0, #0
    a0d4:	f47f af1d 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a0d8:	3c10      	subs	r4, #16
    a0da:	2c10      	cmp	r4, #16
    a0dc:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a0e0:	dce8      	bgt.n	a0b4 <_svfprintf_r+0xa6c>
    a0e2:	3301      	adds	r3, #1
    a0e4:	4422      	add	r2, r4
    a0e6:	2b07      	cmp	r3, #7
    a0e8:	e9ca 6400 	strd	r6, r4, [sl]
    a0ec:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a0f0:	f77f ac4b 	ble.w	998a <_svfprintf_r+0x342>
    a0f4:	ee1b 1a10 	vmov	r1, s22
    a0f8:	aa24      	add	r2, sp, #144	; 0x90
    a0fa:	4658      	mov	r0, fp
    a0fc:	f002 f9a8 	bl	c450 <__ssprint_r>
    a100:	2800      	cmp	r0, #0
    a102:	f47f af06 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a106:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a108:	e43f      	b.n	998a <_svfprintf_r+0x342>
    a10a:	991b      	ldr	r1, [sp, #108]	; 0x6c
    a10c:	2900      	cmp	r1, #0
    a10e:	f340 835a 	ble.w	a7c6 <_svfprintf_r+0x117e>
    a112:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    a114:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a116:	429e      	cmp	r6, r3
    a118:	bfa8      	it	ge
    a11a:	461e      	movge	r6, r3
    a11c:	2e00      	cmp	r6, #0
    a11e:	dd0b      	ble.n	a138 <_svfprintf_r+0xaf0>
    a120:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a122:	3301      	adds	r3, #1
    a124:	4432      	add	r2, r6
    a126:	2b07      	cmp	r3, #7
    a128:	e9ca 4600 	strd	r4, r6, [sl]
    a12c:	9226      	str	r2, [sp, #152]	; 0x98
    a12e:	9325      	str	r3, [sp, #148]	; 0x94
    a130:	f300 8689 	bgt.w	ae46 <_svfprintf_r+0x17fe>
    a134:	f10a 0a08 	add.w	sl, sl, #8
    a138:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    a13a:	2e00      	cmp	r6, #0
    a13c:	bfa8      	it	ge
    a13e:	1bad      	subge	r5, r5, r6
    a140:	2d00      	cmp	r5, #0
    a142:	f300 8203 	bgt.w	a54c <_svfprintf_r+0xf04>
    a146:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a148:	f418 6f80 	tst.w	r8, #1024	; 0x400
    a14c:	4423      	add	r3, r4
    a14e:	9305      	str	r3, [sp, #20]
    a150:	f040 821f 	bne.w	a592 <_svfprintf_r+0xf4a>
    a154:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a156:	990e      	ldr	r1, [sp, #56]	; 0x38
    a158:	428b      	cmp	r3, r1
    a15a:	db03      	blt.n	a164 <_svfprintf_r+0xb1c>
    a15c:	f018 0f01 	tst.w	r8, #1
    a160:	f000 84cf 	beq.w	ab02 <_svfprintf_r+0x14ba>
    a164:	9910      	ldr	r1, [sp, #64]	; 0x40
    a166:	9812      	ldr	r0, [sp, #72]	; 0x48
    a168:	440a      	add	r2, r1
    a16a:	e9ca 0100 	strd	r0, r1, [sl]
    a16e:	9925      	ldr	r1, [sp, #148]	; 0x94
    a170:	9226      	str	r2, [sp, #152]	; 0x98
    a172:	3101      	adds	r1, #1
    a174:	2907      	cmp	r1, #7
    a176:	9125      	str	r1, [sp, #148]	; 0x94
    a178:	f300 86a5 	bgt.w	aec6 <_svfprintf_r+0x187e>
    a17c:	f10a 0a08 	add.w	sl, sl, #8
    a180:	990e      	ldr	r1, [sp, #56]	; 0x38
    a182:	1865      	adds	r5, r4, r1
    a184:	1acc      	subs	r4, r1, r3
    a186:	9b05      	ldr	r3, [sp, #20]
    a188:	1aed      	subs	r5, r5, r3
    a18a:	42a5      	cmp	r5, r4
    a18c:	bfa8      	it	ge
    a18e:	4625      	movge	r5, r4
    a190:	2d00      	cmp	r5, #0
    a192:	dd0d      	ble.n	a1b0 <_svfprintf_r+0xb68>
    a194:	f8ca 3000 	str.w	r3, [sl]
    a198:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a19a:	f8ca 5004 	str.w	r5, [sl, #4]
    a19e:	3301      	adds	r3, #1
    a1a0:	442a      	add	r2, r5
    a1a2:	2b07      	cmp	r3, #7
    a1a4:	9226      	str	r2, [sp, #152]	; 0x98
    a1a6:	9325      	str	r3, [sp, #148]	; 0x94
    a1a8:	f300 86bb 	bgt.w	af22 <_svfprintf_r+0x18da>
    a1ac:	f10a 0a08 	add.w	sl, sl, #8
    a1b0:	2d00      	cmp	r5, #0
    a1b2:	bfa8      	it	ge
    a1b4:	1b64      	subge	r4, r4, r5
    a1b6:	2c00      	cmp	r4, #0
    a1b8:	f77f abde 	ble.w	9978 <_svfprintf_r+0x330>
    a1bc:	2c10      	cmp	r4, #16
    a1be:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a1c0:	f340 837c 	ble.w	a8bc <_svfprintf_r+0x1274>
    a1c4:	ee1b 6a10 	vmov	r6, s22
    a1c8:	2510      	movs	r5, #16
    a1ca:	e005      	b.n	a1d8 <_svfprintf_r+0xb90>
    a1cc:	f10a 0a08 	add.w	sl, sl, #8
    a1d0:	3c10      	subs	r4, #16
    a1d2:	2c10      	cmp	r4, #16
    a1d4:	f340 8372 	ble.w	a8bc <_svfprintf_r+0x1274>
    a1d8:	3301      	adds	r3, #1
    a1da:	4970      	ldr	r1, [pc, #448]	; (a39c <_svfprintf_r+0xd54>)
    a1dc:	3210      	adds	r2, #16
    a1de:	2b07      	cmp	r3, #7
    a1e0:	e9ca 1500 	strd	r1, r5, [sl]
    a1e4:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a1e8:	ddf0      	ble.n	a1cc <_svfprintf_r+0xb84>
    a1ea:	aa24      	add	r2, sp, #144	; 0x90
    a1ec:	4631      	mov	r1, r6
    a1ee:	4658      	mov	r0, fp
    a1f0:	f002 f92e 	bl	c450 <__ssprint_r>
    a1f4:	2800      	cmp	r0, #0
    a1f6:	f47f ae8c 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a1fa:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a1fe:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a202:	e7e5      	b.n	a1d0 <_svfprintf_r+0xb88>
    a204:	2b30      	cmp	r3, #48	; 0x30
    a206:	f43f ad8b 	beq.w	9d20 <_svfprintf_r+0x6d8>
    a20a:	2330      	movs	r3, #48	; 0x30
    a20c:	3802      	subs	r0, #2
    a20e:	f804 3c01 	strb.w	r3, [r4, #-1]
    a212:	ab50      	add	r3, sp, #320	; 0x140
    a214:	1a1b      	subs	r3, r3, r0
    a216:	f8dd 8008 	ldr.w	r8, [sp, #8]
    a21a:	9305      	str	r3, [sp, #20]
    a21c:	4604      	mov	r4, r0
    a21e:	e584      	b.n	9d2a <_svfprintf_r+0x6e2>
    a220:	f018 0f01 	tst.w	r8, #1
    a224:	f47f ae82 	bne.w	9f2c <_svfprintf_r+0x8e4>
    a228:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a22a:	f8ca 4000 	str.w	r4, [sl]
    a22e:	3301      	adds	r3, #1
    a230:	3201      	adds	r2, #1
    a232:	2101      	movs	r1, #1
    a234:	2b07      	cmp	r3, #7
    a236:	9226      	str	r2, [sp, #152]	; 0x98
    a238:	9325      	str	r3, [sp, #148]	; 0x94
    a23a:	f8ca 1004 	str.w	r1, [sl, #4]
    a23e:	f77f aea5 	ble.w	9f8c <_svfprintf_r+0x944>
    a242:	ee1b 1a10 	vmov	r1, s22
    a246:	aa24      	add	r2, sp, #144	; 0x90
    a248:	4658      	mov	r0, fp
    a24a:	f002 f901 	bl	c450 <__ssprint_r>
    a24e:	2800      	cmp	r0, #0
    a250:	f47f ae5f 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a254:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a258:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a25c:	e698      	b.n	9f90 <_svfprintf_r+0x948>
    a25e:	990e      	ldr	r1, [sp, #56]	; 0x38
    a260:	1e4c      	subs	r4, r1, #1
    a262:	2c00      	cmp	r4, #0
    a264:	f77f ae94 	ble.w	9f90 <_svfprintf_r+0x948>
    a268:	2c10      	cmp	r4, #16
    a26a:	f340 8361 	ble.w	a930 <_svfprintf_r+0x12e8>
    a26e:	ee1b 6a10 	vmov	r6, s22
    a272:	2510      	movs	r5, #16
    a274:	e005      	b.n	a282 <_svfprintf_r+0xc3a>
    a276:	f10a 0a08 	add.w	sl, sl, #8
    a27a:	3c10      	subs	r4, #16
    a27c:	2c10      	cmp	r4, #16
    a27e:	f340 8357 	ble.w	a930 <_svfprintf_r+0x12e8>
    a282:	3301      	adds	r3, #1
    a284:	4945      	ldr	r1, [pc, #276]	; (a39c <_svfprintf_r+0xd54>)
    a286:	3210      	adds	r2, #16
    a288:	2b07      	cmp	r3, #7
    a28a:	e9ca 1500 	strd	r1, r5, [sl]
    a28e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a292:	ddf0      	ble.n	a276 <_svfprintf_r+0xc2e>
    a294:	aa24      	add	r2, sp, #144	; 0x90
    a296:	4631      	mov	r1, r6
    a298:	4658      	mov	r0, fp
    a29a:	f002 f8d9 	bl	c450 <__ssprint_r>
    a29e:	2800      	cmp	r0, #0
    a2a0:	f47f ae37 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a2a4:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a2a8:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a2ac:	e7e5      	b.n	a27a <_svfprintf_r+0xc32>
    a2ae:	ee1b 1a10 	vmov	r1, s22
    a2b2:	aa24      	add	r2, sp, #144	; 0x90
    a2b4:	4658      	mov	r0, fp
    a2b6:	f002 f8cb 	bl	c450 <__ssprint_r>
    a2ba:	2800      	cmp	r0, #0
    a2bc:	f47f ae29 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a2c0:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a2c2:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a2c6:	f7ff bb44 	b.w	9952 <_svfprintf_r+0x30a>
    a2ca:	9b02      	ldr	r3, [sp, #8]
    a2cc:	f013 0310 	ands.w	r3, r3, #16
    a2d0:	f040 80c1 	bne.w	a456 <_svfprintf_r+0xe0e>
    a2d4:	9a02      	ldr	r2, [sp, #8]
    a2d6:	f012 0240 	ands.w	r2, r2, #64	; 0x40
    a2da:	f000 837a 	beq.w	a9d2 <_svfprintf_r+0x138a>
    a2de:	9808      	ldr	r0, [sp, #32]
    a2e0:	f850 2b04 	ldr.w	r2, [r0], #4
    a2e4:	9008      	str	r0, [sp, #32]
    a2e6:	4619      	mov	r1, r3
    a2e8:	b292      	uxth	r2, r2
    a2ea:	2301      	movs	r3, #1
    a2ec:	e451      	b.n	9b92 <_svfprintf_r+0x54a>
    a2ee:	f018 0310 	ands.w	r3, r8, #16
    a2f2:	d155      	bne.n	a3a0 <_svfprintf_r+0xd58>
    a2f4:	f018 0240 	ands.w	r2, r8, #64	; 0x40
    a2f8:	f000 835d 	beq.w	a9b6 <_svfprintf_r+0x136e>
    a2fc:	9808      	ldr	r0, [sp, #32]
    a2fe:	f850 2b04 	ldr.w	r2, [r0], #4
    a302:	9008      	str	r0, [sp, #32]
    a304:	4619      	mov	r1, r3
    a306:	b292      	uxth	r2, r2
    a308:	e4a8      	b.n	9c5c <_svfprintf_r+0x614>
    a30a:	4252      	negs	r2, r2
    a30c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a310:	f8cd 8008 	str.w	r8, [sp, #8]
    a314:	202d      	movs	r0, #45	; 0x2d
    a316:	2301      	movs	r3, #1
    a318:	e43c      	b.n	9b94 <_svfprintf_r+0x54c>
    a31a:	ee1b 1a10 	vmov	r1, s22
    a31e:	aa24      	add	r2, sp, #144	; 0x90
    a320:	4658      	mov	r0, fp
    a322:	f002 f895 	bl	c450 <__ssprint_r>
    a326:	2800      	cmp	r0, #0
    a328:	f47f adf3 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a32c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a330:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a334:	e616      	b.n	9f64 <_svfprintf_r+0x91c>
    a336:	ee1b 1a10 	vmov	r1, s22
    a33a:	aa24      	add	r2, sp, #144	; 0x90
    a33c:	4658      	mov	r0, fp
    a33e:	f002 f887 	bl	c450 <__ssprint_r>
    a342:	2800      	cmp	r0, #0
    a344:	f47f ade5 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a348:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a34c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a350:	e5fb      	b.n	9f4a <_svfprintf_r+0x902>
    a352:	f018 0f01 	tst.w	r8, #1
    a356:	f43f ab0f 	beq.w	9978 <_svfprintf_r+0x330>
    a35a:	e52a      	b.n	9db2 <_svfprintf_r+0x76a>
    a35c:	9308      	str	r3, [sp, #32]
    a35e:	f899 3000 	ldrb.w	r3, [r9]
    a362:	f7ff b9cd 	b.w	9700 <_svfprintf_r+0xb8>
    a366:	ac50      	add	r4, sp, #320	; 0x140
    a368:	e4df      	b.n	9d2a <_svfprintf_r+0x6e2>
    a36a:	f418 7f00 	tst.w	r8, #512	; 0x200
    a36e:	f040 83db 	bne.w	ab28 <_svfprintf_r+0x14e0>
    a372:	f853 2b04 	ldr.w	r2, [r3], #4
    a376:	9308      	str	r3, [sp, #32]
    a378:	17d1      	asrs	r1, r2, #31
    a37a:	460b      	mov	r3, r1
    a37c:	f7ff bbb6 	b.w	9aec <_svfprintf_r+0x4a4>
    a380:	9b08      	ldr	r3, [sp, #32]
    a382:	9804      	ldr	r0, [sp, #16]
    a384:	f853 1b04 	ldr.w	r1, [r3], #4
    a388:	9308      	str	r3, [sp, #32]
    a38a:	17c2      	asrs	r2, r0, #31
    a38c:	e9c1 0200 	strd	r0, r2, [r1]
    a390:	464c      	mov	r4, r9
    a392:	f7ff b98b 	b.w	96ac <_svfprintf_r+0x64>
    a396:	bf00      	nop
    a398:	20000b5c 	.word	0x20000b5c
    a39c:	20000fc8 	.word	0x20000fc8
    a3a0:	9b08      	ldr	r3, [sp, #32]
    a3a2:	f853 2b04 	ldr.w	r2, [r3], #4
    a3a6:	9308      	str	r3, [sp, #32]
    a3a8:	e458      	b.n	9c5c <_svfprintf_r+0x614>
    a3aa:	eeb4 8b48 	vcmp.f64	d8, d8
    a3ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a3b2:	f180 8694 	bvs.w	b0de <_svfprintf_r+0x1a96>
    a3b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a3b8:	2b61      	cmp	r3, #97	; 0x61
    a3ba:	f000 8552 	beq.w	ae62 <_svfprintf_r+0x181a>
    a3be:	2b41      	cmp	r3, #65	; 0x41
    a3c0:	f000 85c0 	beq.w	af44 <_svfprintf_r+0x18fc>
    a3c4:	9b03      	ldr	r3, [sp, #12]
    a3c6:	3301      	adds	r3, #1
    a3c8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a3ca:	f023 0520 	bic.w	r5, r3, #32
    a3ce:	f000 8480 	beq.w	acd2 <_svfprintf_r+0x168a>
    a3d2:	2d47      	cmp	r5, #71	; 0x47
    a3d4:	d104      	bne.n	a3e0 <_svfprintf_r+0xd98>
    a3d6:	9b03      	ldr	r3, [sp, #12]
    a3d8:	2b00      	cmp	r3, #0
    a3da:	bf08      	it	eq
    a3dc:	2301      	moveq	r3, #1
    a3de:	9303      	str	r3, [sp, #12]
    a3e0:	ee18 3a90 	vmov	r3, s17
    a3e4:	2b00      	cmp	r3, #0
    a3e6:	f448 7280 	orr.w	r2, r8, #256	; 0x100
    a3ea:	4646      	mov	r6, r8
    a3ec:	f2c0 8618 	blt.w	b020 <_svfprintf_r+0x19d8>
    a3f0:	eeb0 ab48 	vmov.f64	d10, d8
    a3f4:	2300      	movs	r3, #0
    a3f6:	4690      	mov	r8, r2
    a3f8:	9309      	str	r3, [sp, #36]	; 0x24
    a3fa:	9307      	str	r3, [sp, #28]
    a3fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a3fe:	3b41      	subs	r3, #65	; 0x41
    a400:	2b25      	cmp	r3, #37	; 0x25
    a402:	f200 8398 	bhi.w	ab36 <_svfprintf_r+0x14ee>
    a406:	e8df f013 	tbh	[pc, r3, lsl #1]
    a40a:	046f      	.short	0x046f
    a40c:	03960396 	.word	0x03960396
    a410:	04680396 	.word	0x04680396
    a414:	0396046c 	.word	0x0396046c
    a418:	03960396 	.word	0x03960396
    a41c:	03960396 	.word	0x03960396
    a420:	03960396 	.word	0x03960396
    a424:	03960396 	.word	0x03960396
    a428:	03960396 	.word	0x03960396
    a42c:	03960396 	.word	0x03960396
    a430:	03960396 	.word	0x03960396
    a434:	03960396 	.word	0x03960396
    a438:	03960396 	.word	0x03960396
    a43c:	03960396 	.word	0x03960396
    a440:	03960396 	.word	0x03960396
    a444:	03960396 	.word	0x03960396
    a448:	03960396 	.word	0x03960396
    a44c:	03960396 	.word	0x03960396
    a450:	04680396 	.word	0x04680396
    a454:	046c      	.short	0x046c
    a456:	9b08      	ldr	r3, [sp, #32]
    a458:	f853 2b04 	ldr.w	r2, [r3], #4
    a45c:	9308      	str	r3, [sp, #32]
    a45e:	2301      	movs	r3, #1
    a460:	f7ff bb97 	b.w	9b92 <_svfprintf_r+0x54a>
    a464:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    a466:	2b00      	cmp	r3, #0
    a468:	f43f a9cf 	beq.w	980a <_svfprintf_r+0x1c2>
    a46c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    a46e:	781b      	ldrb	r3, [r3, #0]
    a470:	2b00      	cmp	r3, #0
    a472:	f43f a9ca 	beq.w	980a <_svfprintf_r+0x1c2>
    a476:	f899 3000 	ldrb.w	r3, [r9]
    a47a:	f448 6880 	orr.w	r8, r8, #1024	; 0x400
    a47e:	f7ff b93f 	b.w	9700 <_svfprintf_r+0xb8>
    a482:	930b      	str	r3, [sp, #44]	; 0x2c
    a484:	f8cd 8008 	str.w	r8, [sp, #8]
    a488:	f7ff bbf1 	b.w	9c6e <_svfprintf_r+0x626>
    a48c:	930b      	str	r3, [sp, #44]	; 0x2c
    a48e:	4b9a      	ldr	r3, [pc, #616]	; (a6f8 <_svfprintf_r+0x10b0>)
    a490:	9311      	str	r3, [sp, #68]	; 0x44
    a492:	f018 0120 	ands.w	r1, r8, #32
    a496:	f000 8105 	beq.w	a6a4 <_svfprintf_r+0x105c>
    a49a:	9b08      	ldr	r3, [sp, #32]
    a49c:	3307      	adds	r3, #7
    a49e:	f023 0307 	bic.w	r3, r3, #7
    a4a2:	6859      	ldr	r1, [r3, #4]
    a4a4:	f853 2b08 	ldr.w	r2, [r3], #8
    a4a8:	9308      	str	r3, [sp, #32]
    a4aa:	f018 0f01 	tst.w	r8, #1
    a4ae:	d00a      	beq.n	a4c6 <_svfprintf_r+0xe7e>
    a4b0:	ea52 0301 	orrs.w	r3, r2, r1
    a4b4:	d007      	beq.n	a4c6 <_svfprintf_r+0xe7e>
    a4b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a4b8:	f88d 3069 	strb.w	r3, [sp, #105]	; 0x69
    a4bc:	2330      	movs	r3, #48	; 0x30
    a4be:	f048 0802 	orr.w	r8, r8, #2
    a4c2:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
    a4c6:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
    a4ca:	9302      	str	r3, [sp, #8]
    a4cc:	2302      	movs	r3, #2
    a4ce:	f7ff bb60 	b.w	9b92 <_svfprintf_r+0x54a>
    a4d2:	930b      	str	r3, [sp, #44]	; 0x2c
    a4d4:	f7ff bbb6 	b.w	9c44 <_svfprintf_r+0x5fc>
    a4d8:	930b      	str	r3, [sp, #44]	; 0x2c
    a4da:	4b88      	ldr	r3, [pc, #544]	; (a6fc <_svfprintf_r+0x10b4>)
    a4dc:	9311      	str	r3, [sp, #68]	; 0x44
    a4de:	e7d8      	b.n	a492 <_svfprintf_r+0xe4a>
    a4e0:	9b08      	ldr	r3, [sp, #32]
    a4e2:	2101      	movs	r1, #1
    a4e4:	f853 2b04 	ldr.w	r2, [r3], #4
    a4e8:	9102      	str	r1, [sp, #8]
    a4ea:	f88d 20dc 	strb.w	r2, [sp, #220]	; 0xdc
    a4ee:	9308      	str	r3, [sp, #32]
    a4f0:	9105      	str	r1, [sp, #20]
    a4f2:	ac37      	add	r4, sp, #220	; 0xdc
    a4f4:	f7ff baaf 	b.w	9a56 <_svfprintf_r+0x40e>
    a4f8:	ee1b 1a10 	vmov	r1, s22
    a4fc:	aa24      	add	r2, sp, #144	; 0x90
    a4fe:	4658      	mov	r0, fp
    a500:	f001 ffa6 	bl	c450 <__ssprint_r>
    a504:	2800      	cmp	r0, #0
    a506:	f47f ad04 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a50a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a50c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a510:	e45d      	b.n	9dce <_svfprintf_r+0x786>
    a512:	9b03      	ldr	r3, [sp, #12]
    a514:	9407      	str	r4, [sp, #28]
    a516:	2b06      	cmp	r3, #6
    a518:	4622      	mov	r2, r4
    a51a:	bf28      	it	cs
    a51c:	2306      	movcs	r3, #6
    a51e:	9403      	str	r4, [sp, #12]
    a520:	4621      	mov	r1, r4
    a522:	e9cd 220c 	strd	r2, r2, [sp, #48]	; 0x30
    a526:	4c76      	ldr	r4, [pc, #472]	; (a700 <_svfprintf_r+0x10b8>)
    a528:	9302      	str	r3, [sp, #8]
    a52a:	9305      	str	r3, [sp, #20]
    a52c:	920f      	str	r2, [sp, #60]	; 0x3c
    a52e:	f7ff ba6c 	b.w	9a0a <_svfprintf_r+0x3c2>
    a532:	2140      	movs	r1, #64	; 0x40
    a534:	4658      	mov	r0, fp
    a536:	f7fd fb05 	bl	7b44 <_malloc_r>
    a53a:	6020      	str	r0, [r4, #0]
    a53c:	6120      	str	r0, [r4, #16]
    a53e:	2800      	cmp	r0, #0
    a540:	f000 860f 	beq.w	b162 <_svfprintf_r+0x1b1a>
    a544:	2340      	movs	r3, #64	; 0x40
    a546:	6163      	str	r3, [r4, #20]
    a548:	f7ff b89e 	b.w	9688 <_svfprintf_r+0x40>
    a54c:	2d10      	cmp	r5, #16
    a54e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a550:	f340 825d 	ble.w	aa0e <_svfprintf_r+0x13c6>
    a554:	4651      	mov	r1, sl
    a556:	2610      	movs	r6, #16
    a558:	ee1b aa10 	vmov	sl, s22
    a55c:	e004      	b.n	a568 <_svfprintf_r+0xf20>
    a55e:	3108      	adds	r1, #8
    a560:	3d10      	subs	r5, #16
    a562:	2d10      	cmp	r5, #16
    a564:	f340 8252 	ble.w	aa0c <_svfprintf_r+0x13c4>
    a568:	3301      	adds	r3, #1
    a56a:	4866      	ldr	r0, [pc, #408]	; (a704 <_svfprintf_r+0x10bc>)
    a56c:	3210      	adds	r2, #16
    a56e:	2b07      	cmp	r3, #7
    a570:	e9c1 0600 	strd	r0, r6, [r1]
    a574:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a578:	ddf1      	ble.n	a55e <_svfprintf_r+0xf16>
    a57a:	aa24      	add	r2, sp, #144	; 0x90
    a57c:	4651      	mov	r1, sl
    a57e:	4658      	mov	r0, fp
    a580:	f001 ff66 	bl	c450 <__ssprint_r>
    a584:	2800      	cmp	r0, #0
    a586:	f47f acc4 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a58a:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a58e:	a927      	add	r1, sp, #156	; 0x9c
    a590:	e7e6      	b.n	a560 <_svfprintf_r+0xf18>
    a592:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a594:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    a598:	18e3      	adds	r3, r4, r3
    a59a:	9303      	str	r3, [sp, #12]
    a59c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a59e:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
    a5a2:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    a5a4:	9d05      	ldr	r5, [sp, #20]
    a5a6:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
    a5aa:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    a5ae:	940b      	str	r4, [sp, #44]	; 0x2c
    a5b0:	ee1b 1a10 	vmov	r1, s22
    a5b4:	4650      	mov	r0, sl
    a5b6:	2b00      	cmp	r3, #0
    a5b8:	d034      	beq.n	a624 <_svfprintf_r+0xfdc>
    a5ba:	f1b8 0f00 	cmp.w	r8, #0
    a5be:	d135      	bne.n	a62c <_svfprintf_r+0xfe4>
    a5c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a5c2:	3b01      	subs	r3, #1
    a5c4:	3e01      	subs	r6, #1
    a5c6:	930d      	str	r3, [sp, #52]	; 0x34
    a5c8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a5ca:	e9c0 3900 	strd	r3, r9, [r0]
    a5ce:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a5d0:	3301      	adds	r3, #1
    a5d2:	444a      	add	r2, r9
    a5d4:	2b07      	cmp	r3, #7
    a5d6:	9226      	str	r2, [sp, #152]	; 0x98
    a5d8:	9325      	str	r3, [sp, #148]	; 0x94
    a5da:	dc6c      	bgt.n	a6b6 <_svfprintf_r+0x106e>
    a5dc:	3008      	adds	r0, #8
    a5de:	9b03      	ldr	r3, [sp, #12]
    a5e0:	f896 c000 	ldrb.w	ip, [r6]
    a5e4:	1b5b      	subs	r3, r3, r5
    a5e6:	4563      	cmp	r3, ip
    a5e8:	bfa8      	it	ge
    a5ea:	4663      	movge	r3, ip
    a5ec:	2b00      	cmp	r3, #0
    a5ee:	469a      	mov	sl, r3
    a5f0:	dd0c      	ble.n	a60c <_svfprintf_r+0xfc4>
    a5f2:	9c25      	ldr	r4, [sp, #148]	; 0x94
    a5f4:	3401      	adds	r4, #1
    a5f6:	441a      	add	r2, r3
    a5f8:	2c07      	cmp	r4, #7
    a5fa:	e9c0 5300 	strd	r5, r3, [r0]
    a5fe:	9226      	str	r2, [sp, #152]	; 0x98
    a600:	9425      	str	r4, [sp, #148]	; 0x94
    a602:	f300 8177 	bgt.w	a8f4 <_svfprintf_r+0x12ac>
    a606:	f896 c000 	ldrb.w	ip, [r6]
    a60a:	3008      	adds	r0, #8
    a60c:	f1ba 0f00 	cmp.w	sl, #0
    a610:	bfac      	ite	ge
    a612:	ebac 040a 	subge.w	r4, ip, sl
    a616:	4664      	movlt	r4, ip
    a618:	2c00      	cmp	r4, #0
    a61a:	dc0a      	bgt.n	a632 <_svfprintf_r+0xfea>
    a61c:	4465      	add	r5, ip
    a61e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a620:	2b00      	cmp	r3, #0
    a622:	d1ca      	bne.n	a5ba <_svfprintf_r+0xf72>
    a624:	f1b8 0f00 	cmp.w	r8, #0
    a628:	f000 83ac 	beq.w	ad84 <_svfprintf_r+0x173c>
    a62c:	f108 38ff 	add.w	r8, r8, #4294967295
    a630:	e7ca      	b.n	a5c8 <_svfprintf_r+0xf80>
    a632:	2c10      	cmp	r4, #16
    a634:	f8dd c094 	ldr.w	ip, [sp, #148]	; 0x94
    a638:	dd24      	ble.n	a684 <_svfprintf_r+0x103c>
    a63a:	9505      	str	r5, [sp, #20]
    a63c:	f04f 0a10 	mov.w	sl, #16
    a640:	4663      	mov	r3, ip
    a642:	460d      	mov	r5, r1
    a644:	e004      	b.n	a650 <_svfprintf_r+0x1008>
    a646:	3c10      	subs	r4, #16
    a648:	2c10      	cmp	r4, #16
    a64a:	f100 0008 	add.w	r0, r0, #8
    a64e:	dd16      	ble.n	a67e <_svfprintf_r+0x1036>
    a650:	3301      	adds	r3, #1
    a652:	492c      	ldr	r1, [pc, #176]	; (a704 <_svfprintf_r+0x10bc>)
    a654:	3210      	adds	r2, #16
    a656:	2b07      	cmp	r3, #7
    a658:	e9c0 1a00 	strd	r1, sl, [r0]
    a65c:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a660:	ddf1      	ble.n	a646 <_svfprintf_r+0xffe>
    a662:	aa24      	add	r2, sp, #144	; 0x90
    a664:	4629      	mov	r1, r5
    a666:	4658      	mov	r0, fp
    a668:	f001 fef2 	bl	c450 <__ssprint_r>
    a66c:	2800      	cmp	r0, #0
    a66e:	f47f ac50 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a672:	3c10      	subs	r4, #16
    a674:	2c10      	cmp	r4, #16
    a676:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a67a:	a827      	add	r0, sp, #156	; 0x9c
    a67c:	dce8      	bgt.n	a650 <_svfprintf_r+0x1008>
    a67e:	4629      	mov	r1, r5
    a680:	9d05      	ldr	r5, [sp, #20]
    a682:	469c      	mov	ip, r3
    a684:	f10c 0301 	add.w	r3, ip, #1
    a688:	4422      	add	r2, r4
    a68a:	6044      	str	r4, [r0, #4]
    a68c:	2b07      	cmp	r3, #7
    a68e:	4c1d      	ldr	r4, [pc, #116]	; (a704 <_svfprintf_r+0x10bc>)
    a690:	6004      	str	r4, [r0, #0]
    a692:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a696:	f300 83c6 	bgt.w	ae26 <_svfprintf_r+0x17de>
    a69a:	f896 c000 	ldrb.w	ip, [r6]
    a69e:	3008      	adds	r0, #8
    a6a0:	4465      	add	r5, ip
    a6a2:	e7bc      	b.n	a61e <_svfprintf_r+0xfd6>
    a6a4:	f018 0310 	ands.w	r3, r8, #16
    a6a8:	f000 80c2 	beq.w	a830 <_svfprintf_r+0x11e8>
    a6ac:	9b08      	ldr	r3, [sp, #32]
    a6ae:	f853 2b04 	ldr.w	r2, [r3], #4
    a6b2:	9308      	str	r3, [sp, #32]
    a6b4:	e6f9      	b.n	a4aa <_svfprintf_r+0xe62>
    a6b6:	aa24      	add	r2, sp, #144	; 0x90
    a6b8:	4658      	mov	r0, fp
    a6ba:	9105      	str	r1, [sp, #20]
    a6bc:	f001 fec8 	bl	c450 <__ssprint_r>
    a6c0:	2800      	cmp	r0, #0
    a6c2:	f47f ac26 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a6c6:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a6c8:	9905      	ldr	r1, [sp, #20]
    a6ca:	a827      	add	r0, sp, #156	; 0x9c
    a6cc:	e787      	b.n	a5de <_svfprintf_r+0xf96>
    a6ce:	9802      	ldr	r0, [sp, #8]
    a6d0:	f8cd a01c 	str.w	sl, [sp, #28]
    a6d4:	ac50      	add	r4, sp, #320	; 0x140
    a6d6:	f400 6080 	and.w	r0, r0, #1024	; 0x400
    a6da:	2500      	movs	r5, #0
    a6dc:	ee0a ba10 	vmov	s20, fp
    a6e0:	4b09      	ldr	r3, [pc, #36]	; (a708 <_svfprintf_r+0x10c0>)
    a6e2:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    a6e6:	f8cd 9014 	str.w	r9, [sp, #20]
    a6ea:	46a3      	mov	fp, r4
    a6ec:	f04f 0805 	mov.w	r8, #5
    a6f0:	46ac      	mov	ip, r5
    a6f2:	4604      	mov	r4, r0
    a6f4:	e010      	b.n	a718 <_svfprintf_r+0x10d0>
    a6f6:	bf00      	nop
    a6f8:	20000b2c 	.word	0x20000b2c
    a6fc:	20000b40 	.word	0x20000b40
    a700:	20000b54 	.word	0x20000b54
    a704:	20000fc8 	.word	0x20000fc8
    a708:	cccccccd 	.word	0xcccccccd
    a70c:	2a0a      	cmp	r2, #10
    a70e:	f171 0100 	sbcs.w	r1, r1, #0
    a712:	d336      	bcc.n	a782 <_svfprintf_r+0x113a>
    a714:	464a      	mov	r2, r9
    a716:	4631      	mov	r1, r6
    a718:	1850      	adds	r0, r2, r1
    a71a:	f140 0000 	adc.w	r0, r0, #0
    a71e:	fba3 5600 	umull	r5, r6, r3, r0
    a722:	f026 0503 	bic.w	r5, r6, #3
    a726:	eb05 0596 	add.w	r5, r5, r6, lsr #2
    a72a:	1b40      	subs	r0, r0, r5
    a72c:	1a15      	subs	r5, r2, r0
    a72e:	f04f 36cc 	mov.w	r6, #3435973836	; 0xcccccccc
    a732:	f161 0e00 	sbc.w	lr, r1, #0
    a736:	fb06 f605 	mul.w	r6, r6, r5
    a73a:	fba5 9503 	umull	r9, r5, r5, r3
    a73e:	fb03 660e 	mla	r6, r3, lr, r6
    a742:	f009 0e01 	and.w	lr, r9, #1
    a746:	442e      	add	r6, r5
    a748:	fbae 5e08 	umull	r5, lr, lr, r8
    a74c:	182d      	adds	r5, r5, r0
    a74e:	ea4f 0959 	mov.w	r9, r9, lsr #1
    a752:	3530      	adds	r5, #48	; 0x30
    a754:	f80b 5c01 	strb.w	r5, [fp, #-1]
    a758:	ea49 79c6 	orr.w	r9, r9, r6, lsl #31
    a75c:	f10c 0c01 	add.w	ip, ip, #1
    a760:	f10b 3bff 	add.w	fp, fp, #4294967295
    a764:	0876      	lsrs	r6, r6, #1
    a766:	2c00      	cmp	r4, #0
    a768:	d0d0      	beq.n	a70c <_svfprintf_r+0x10c4>
    a76a:	f89a 0000 	ldrb.w	r0, [sl]
    a76e:	4584      	cmp	ip, r0
    a770:	d1cc      	bne.n	a70c <_svfprintf_r+0x10c4>
    a772:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    a776:	d0c9      	beq.n	a70c <_svfprintf_r+0x10c4>
    a778:	2a0a      	cmp	r2, #10
    a77a:	f171 0100 	sbcs.w	r1, r1, #0
    a77e:	f080 818f 	bcs.w	aaa0 <_svfprintf_r+0x1458>
    a782:	465c      	mov	r4, fp
    a784:	ab50      	add	r3, sp, #320	; 0x140
    a786:	1b1b      	subs	r3, r3, r4
    a788:	f8dd 9014 	ldr.w	r9, [sp, #20]
    a78c:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    a790:	ee1a ba10 	vmov	fp, s20
    a794:	f8dd a01c 	ldr.w	sl, [sp, #28]
    a798:	f8dd 8008 	ldr.w	r8, [sp, #8]
    a79c:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
    a7a0:	9305      	str	r3, [sp, #20]
    a7a2:	f7ff bac2 	b.w	9d2a <_svfprintf_r+0x6e2>
    a7a6:	ee1b 1a10 	vmov	r1, s22
    a7aa:	aa24      	add	r2, sp, #144	; 0x90
    a7ac:	4658      	mov	r0, fp
    a7ae:	f001 fe4f 	bl	c450 <__ssprint_r>
    a7b2:	2800      	cmp	r0, #0
    a7b4:	f47f abad 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a7b8:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    a7bc:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a7be:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a7c2:	f7ff b896 	b.w	98f2 <_svfprintf_r+0x2aa>
    a7c6:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a7c8:	48be      	ldr	r0, [pc, #760]	; (aac4 <_svfprintf_r+0x147c>)
    a7ca:	f8ca 0000 	str.w	r0, [sl]
    a7ce:	3301      	adds	r3, #1
    a7d0:	3201      	adds	r2, #1
    a7d2:	2001      	movs	r0, #1
    a7d4:	2b07      	cmp	r3, #7
    a7d6:	9226      	str	r2, [sp, #152]	; 0x98
    a7d8:	9325      	str	r3, [sp, #148]	; 0x94
    a7da:	f8ca 0004 	str.w	r0, [sl, #4]
    a7de:	f300 8177 	bgt.w	aad0 <_svfprintf_r+0x1488>
    a7e2:	f10a 0a08 	add.w	sl, sl, #8
    a7e6:	2900      	cmp	r1, #0
    a7e8:	f040 80af 	bne.w	a94a <_svfprintf_r+0x1302>
    a7ec:	990e      	ldr	r1, [sp, #56]	; 0x38
    a7ee:	f008 0301 	and.w	r3, r8, #1
    a7f2:	430b      	orrs	r3, r1
    a7f4:	f43f a8c0 	beq.w	9978 <_svfprintf_r+0x330>
    a7f8:	9b10      	ldr	r3, [sp, #64]	; 0x40
    a7fa:	9912      	ldr	r1, [sp, #72]	; 0x48
    a7fc:	441a      	add	r2, r3
    a7fe:	e9ca 1300 	strd	r1, r3, [sl]
    a802:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a804:	9226      	str	r2, [sp, #152]	; 0x98
    a806:	3301      	adds	r3, #1
    a808:	2b07      	cmp	r3, #7
    a80a:	9325      	str	r3, [sp, #148]	; 0x94
    a80c:	f300 8252 	bgt.w	acb4 <_svfprintf_r+0x166c>
    a810:	f10a 0a08 	add.w	sl, sl, #8
    a814:	990e      	ldr	r1, [sp, #56]	; 0x38
    a816:	f8ca 4000 	str.w	r4, [sl]
    a81a:	3301      	adds	r3, #1
    a81c:	440a      	add	r2, r1
    a81e:	2b07      	cmp	r3, #7
    a820:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a824:	f8ca 1004 	str.w	r1, [sl, #4]
    a828:	f77f a8a4 	ble.w	9974 <_svfprintf_r+0x32c>
    a82c:	f7ff bbbd 	b.w	9faa <_svfprintf_r+0x962>
    a830:	f018 0240 	ands.w	r2, r8, #64	; 0x40
    a834:	f000 80dd 	beq.w	a9f2 <_svfprintf_r+0x13aa>
    a838:	9808      	ldr	r0, [sp, #32]
    a83a:	f850 2b04 	ldr.w	r2, [r0], #4
    a83e:	9008      	str	r0, [sp, #32]
    a840:	4619      	mov	r1, r3
    a842:	b292      	uxth	r2, r2
    a844:	e631      	b.n	a4aa <_svfprintf_r+0xe62>
    a846:	ee1b 1a10 	vmov	r1, s22
    a84a:	aa24      	add	r2, sp, #144	; 0x90
    a84c:	4658      	mov	r0, fp
    a84e:	f001 fdff 	bl	c450 <__ssprint_r>
    a852:	2800      	cmp	r0, #0
    a854:	f47f ab5d 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a858:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a85a:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a85e:	f7ff baa3 	b.w	9da8 <_svfprintf_r+0x760>
    a862:	ae22      	add	r6, sp, #136	; 0x88
    a864:	2208      	movs	r2, #8
    a866:	2100      	movs	r1, #0
    a868:	4630      	mov	r0, r6
    a86a:	941d      	str	r4, [sp, #116]	; 0x74
    a86c:	f7fe f81e 	bl	88ac <memset>
    a870:	9b03      	ldr	r3, [sp, #12]
    a872:	1c5a      	adds	r2, r3, #1
    a874:	f000 80db 	beq.w	aa2e <_svfprintf_r+0x13e6>
    a878:	2500      	movs	r5, #0
    a87a:	f8cd 9008 	str.w	r9, [sp, #8]
    a87e:	f8cd 801c 	str.w	r8, [sp, #28]
    a882:	4699      	mov	r9, r3
    a884:	46a8      	mov	r8, r5
    a886:	e00c      	b.n	a8a2 <_svfprintf_r+0x125a>
    a888:	a937      	add	r1, sp, #220	; 0xdc
    a88a:	4658      	mov	r0, fp
    a88c:	f001 fd9a 	bl	c3c4 <_wcrtomb_r>
    a890:	1c43      	adds	r3, r0, #1
    a892:	4440      	add	r0, r8
    a894:	f000 83c8 	beq.w	b028 <_svfprintf_r+0x19e0>
    a898:	4548      	cmp	r0, r9
    a89a:	dc08      	bgt.n	a8ae <_svfprintf_r+0x1266>
    a89c:	f000 8418 	beq.w	b0d0 <_svfprintf_r+0x1a88>
    a8a0:	4680      	mov	r8, r0
    a8a2:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    a8a4:	5952      	ldr	r2, [r2, r5]
    a8a6:	4633      	mov	r3, r6
    a8a8:	3504      	adds	r5, #4
    a8aa:	2a00      	cmp	r2, #0
    a8ac:	d1ec      	bne.n	a888 <_svfprintf_r+0x1240>
    a8ae:	f8cd 8014 	str.w	r8, [sp, #20]
    a8b2:	f8dd 9008 	ldr.w	r9, [sp, #8]
    a8b6:	f8dd 801c 	ldr.w	r8, [sp, #28]
    a8ba:	e0c5      	b.n	aa48 <_svfprintf_r+0x1400>
    a8bc:	3301      	adds	r3, #1
    a8be:	4982      	ldr	r1, [pc, #520]	; (aac8 <_svfprintf_r+0x1480>)
    a8c0:	f8ca 4004 	str.w	r4, [sl, #4]
    a8c4:	4422      	add	r2, r4
    a8c6:	2b07      	cmp	r3, #7
    a8c8:	f8ca 1000 	str.w	r1, [sl]
    a8cc:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a8d0:	f77f a850 	ble.w	9974 <_svfprintf_r+0x32c>
    a8d4:	f7ff bb69 	b.w	9faa <_svfprintf_r+0x962>
    a8d8:	ee1b 1a10 	vmov	r1, s22
    a8dc:	aa24      	add	r2, sp, #144	; 0x90
    a8de:	4658      	mov	r0, fp
    a8e0:	f001 fdb6 	bl	c450 <__ssprint_r>
    a8e4:	2800      	cmp	r0, #0
    a8e6:	f47f ab14 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a8ea:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a8ec:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a8f0:	f7ff b829 	b.w	9946 <_svfprintf_r+0x2fe>
    a8f4:	aa24      	add	r2, sp, #144	; 0x90
    a8f6:	4658      	mov	r0, fp
    a8f8:	9105      	str	r1, [sp, #20]
    a8fa:	f001 fda9 	bl	c450 <__ssprint_r>
    a8fe:	2800      	cmp	r0, #0
    a900:	f47f ab07 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a904:	f896 c000 	ldrb.w	ip, [r6]
    a908:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a90a:	9905      	ldr	r1, [sp, #20]
    a90c:	a827      	add	r0, sp, #156	; 0x9c
    a90e:	e67d      	b.n	a60c <_svfprintf_r+0xfc4>
    a910:	2b01      	cmp	r3, #1
    a912:	f8cd 8008 	str.w	r8, [sp, #8]
    a916:	f47f a9f3 	bne.w	9d00 <_svfprintf_r+0x6b8>
    a91a:	f7ff bb93 	b.w	a044 <_svfprintf_r+0x9fc>
    a91e:	9b08      	ldr	r3, [sp, #32]
    a920:	9904      	ldr	r1, [sp, #16]
    a922:	f853 2b04 	ldr.w	r2, [r3], #4
    a926:	464c      	mov	r4, r9
    a928:	6011      	str	r1, [r2, #0]
    a92a:	9308      	str	r3, [sp, #32]
    a92c:	f7fe bebe 	b.w	96ac <_svfprintf_r+0x64>
    a930:	3301      	adds	r3, #1
    a932:	4965      	ldr	r1, [pc, #404]	; (aac8 <_svfprintf_r+0x1480>)
    a934:	f8ca 4004 	str.w	r4, [sl, #4]
    a938:	4422      	add	r2, r4
    a93a:	2b07      	cmp	r3, #7
    a93c:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a940:	f8ca 1000 	str.w	r1, [sl]
    a944:	f77f ab22 	ble.w	9f8c <_svfprintf_r+0x944>
    a948:	e47b      	b.n	a242 <_svfprintf_r+0xbfa>
    a94a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    a94c:	9812      	ldr	r0, [sp, #72]	; 0x48
    a94e:	441a      	add	r2, r3
    a950:	e9ca 0300 	strd	r0, r3, [sl]
    a954:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a956:	9226      	str	r2, [sp, #152]	; 0x98
    a958:	3301      	adds	r3, #1
    a95a:	2b07      	cmp	r3, #7
    a95c:	9325      	str	r3, [sp, #148]	; 0x94
    a95e:	f300 81a9 	bgt.w	acb4 <_svfprintf_r+0x166c>
    a962:	f10a 0a08 	add.w	sl, sl, #8
    a966:	2900      	cmp	r1, #0
    a968:	f6bf af54 	bge.w	a814 <_svfprintf_r+0x11cc>
    a96c:	424d      	negs	r5, r1
    a96e:	3110      	adds	r1, #16
    a970:	f280 830f 	bge.w	af92 <_svfprintf_r+0x194a>
    a974:	ee1b 1a10 	vmov	r1, s22
    a978:	2610      	movs	r6, #16
    a97a:	e005      	b.n	a988 <_svfprintf_r+0x1340>
    a97c:	f10a 0a08 	add.w	sl, sl, #8
    a980:	3d10      	subs	r5, #16
    a982:	2d10      	cmp	r5, #16
    a984:	f340 8305 	ble.w	af92 <_svfprintf_r+0x194a>
    a988:	3301      	adds	r3, #1
    a98a:	484f      	ldr	r0, [pc, #316]	; (aac8 <_svfprintf_r+0x1480>)
    a98c:	3210      	adds	r2, #16
    a98e:	2b07      	cmp	r3, #7
    a990:	e9ca 0600 	strd	r0, r6, [sl]
    a994:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a998:	ddf0      	ble.n	a97c <_svfprintf_r+0x1334>
    a99a:	aa24      	add	r2, sp, #144	; 0x90
    a99c:	4658      	mov	r0, fp
    a99e:	9103      	str	r1, [sp, #12]
    a9a0:	f001 fd56 	bl	c450 <__ssprint_r>
    a9a4:	2800      	cmp	r0, #0
    a9a6:	f47f aab4 	bne.w	9f12 <_svfprintf_r+0x8ca>
    a9aa:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a9ae:	9903      	ldr	r1, [sp, #12]
    a9b0:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a9b4:	e7e4      	b.n	a980 <_svfprintf_r+0x1338>
    a9b6:	9b08      	ldr	r3, [sp, #32]
    a9b8:	f418 7100 	ands.w	r1, r8, #512	; 0x200
    a9bc:	bf1a      	itte	ne
    a9be:	4611      	movne	r1, r2
    a9c0:	f853 2b04 	ldrne.w	r2, [r3], #4
    a9c4:	f853 2b04 	ldreq.w	r2, [r3], #4
    a9c8:	9308      	str	r3, [sp, #32]
    a9ca:	bf18      	it	ne
    a9cc:	b2d2      	uxtbne	r2, r2
    a9ce:	f7ff b945 	b.w	9c5c <_svfprintf_r+0x614>
    a9d2:	9b02      	ldr	r3, [sp, #8]
    a9d4:	f413 7100 	ands.w	r1, r3, #512	; 0x200
    a9d8:	9b08      	ldr	r3, [sp, #32]
    a9da:	bf1a      	itte	ne
    a9dc:	4611      	movne	r1, r2
    a9de:	f853 2b04 	ldrne.w	r2, [r3], #4
    a9e2:	f853 2b04 	ldreq.w	r2, [r3], #4
    a9e6:	9308      	str	r3, [sp, #32]
    a9e8:	bf18      	it	ne
    a9ea:	b2d2      	uxtbne	r2, r2
    a9ec:	2301      	movs	r3, #1
    a9ee:	f7ff b8d0 	b.w	9b92 <_svfprintf_r+0x54a>
    a9f2:	9b08      	ldr	r3, [sp, #32]
    a9f4:	f418 7100 	ands.w	r1, r8, #512	; 0x200
    a9f8:	bf1a      	itte	ne
    a9fa:	4611      	movne	r1, r2
    a9fc:	f853 2b04 	ldrne.w	r2, [r3], #4
    aa00:	f853 2b04 	ldreq.w	r2, [r3], #4
    aa04:	9308      	str	r3, [sp, #32]
    aa06:	bf18      	it	ne
    aa08:	b2d2      	uxtbne	r2, r2
    aa0a:	e54e      	b.n	a4aa <_svfprintf_r+0xe62>
    aa0c:	468a      	mov	sl, r1
    aa0e:	3301      	adds	r3, #1
    aa10:	492d      	ldr	r1, [pc, #180]	; (aac8 <_svfprintf_r+0x1480>)
    aa12:	f8ca 5004 	str.w	r5, [sl, #4]
    aa16:	442a      	add	r2, r5
    aa18:	2b07      	cmp	r3, #7
    aa1a:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    aa1e:	f8ca 1000 	str.w	r1, [sl]
    aa22:	f300 8139 	bgt.w	ac98 <_svfprintf_r+0x1650>
    aa26:	f10a 0a08 	add.w	sl, sl, #8
    aa2a:	f7ff bb8c 	b.w	a146 <_svfprintf_r+0xafe>
    aa2e:	2300      	movs	r3, #0
    aa30:	4619      	mov	r1, r3
    aa32:	9600      	str	r6, [sp, #0]
    aa34:	aa1d      	add	r2, sp, #116	; 0x74
    aa36:	4658      	mov	r0, fp
    aa38:	f001 fcea 	bl	c410 <_wcsrtombs_r>
    aa3c:	4603      	mov	r3, r0
    aa3e:	3301      	adds	r3, #1
    aa40:	9005      	str	r0, [sp, #20]
    aa42:	f000 82f1 	beq.w	b028 <_svfprintf_r+0x19e0>
    aa46:	941d      	str	r4, [sp, #116]	; 0x74
    aa48:	9b05      	ldr	r3, [sp, #20]
    aa4a:	2b00      	cmp	r3, #0
    aa4c:	d04e      	beq.n	aaec <_svfprintf_r+0x14a4>
    aa4e:	2b63      	cmp	r3, #99	; 0x63
    aa50:	f300 8118 	bgt.w	ac84 <_svfprintf_r+0x163c>
    aa54:	2300      	movs	r3, #0
    aa56:	9307      	str	r3, [sp, #28]
    aa58:	ac37      	add	r4, sp, #220	; 0xdc
    aa5a:	2208      	movs	r2, #8
    aa5c:	2100      	movs	r1, #0
    aa5e:	4630      	mov	r0, r6
    aa60:	f7fd ff24 	bl	88ac <memset>
    aa64:	9d05      	ldr	r5, [sp, #20]
    aa66:	9600      	str	r6, [sp, #0]
    aa68:	462b      	mov	r3, r5
    aa6a:	aa1d      	add	r2, sp, #116	; 0x74
    aa6c:	4621      	mov	r1, r4
    aa6e:	4658      	mov	r0, fp
    aa70:	f001 fcce 	bl	c410 <_wcsrtombs_r>
    aa74:	4285      	cmp	r5, r0
    aa76:	f040 837c 	bne.w	b172 <_svfprintf_r+0x1b2a>
    aa7a:	9a05      	ldr	r2, [sp, #20]
    aa7c:	2300      	movs	r3, #0
    aa7e:	54a3      	strb	r3, [r4, r2]
    aa80:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    aa84:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    aa88:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    aa8c:	9303      	str	r3, [sp, #12]
    aa8e:	9202      	str	r2, [sp, #8]
    aa90:	930f      	str	r3, [sp, #60]	; 0x3c
    aa92:	f7fe bfba 	b.w	9a0a <_svfprintf_r+0x3c2>
    aa96:	212d      	movs	r1, #45	; 0x2d
    aa98:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    aa9c:	f7fe bfa4 	b.w	99e8 <_svfprintf_r+0x3a0>
    aaa0:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aaa2:	9915      	ldr	r1, [sp, #84]	; 0x54
    aaa4:	ebab 0b03 	sub.w	fp, fp, r3
    aaa8:	461a      	mov	r2, r3
    aaaa:	4658      	mov	r0, fp
    aaac:	f7fd ff50 	bl	8950 <strncpy>
    aab0:	f89a 2001 	ldrb.w	r2, [sl, #1]
    aab4:	4b05      	ldr	r3, [pc, #20]	; (aacc <_svfprintf_r+0x1484>)
    aab6:	b10a      	cbz	r2, aabc <_svfprintf_r+0x1474>
    aab8:	f10a 0a01 	add.w	sl, sl, #1
    aabc:	f04f 0c00 	mov.w	ip, #0
    aac0:	e628      	b.n	a714 <_svfprintf_r+0x10cc>
    aac2:	bf00      	nop
    aac4:	20000524 	.word	0x20000524
    aac8:	20000fc8 	.word	0x20000fc8
    aacc:	cccccccd 	.word	0xcccccccd
    aad0:	ee1b 1a10 	vmov	r1, s22
    aad4:	aa24      	add	r2, sp, #144	; 0x90
    aad6:	4658      	mov	r0, fp
    aad8:	f001 fcba 	bl	c450 <__ssprint_r>
    aadc:	2800      	cmp	r0, #0
    aade:	f47f aa18 	bne.w	9f12 <_svfprintf_r+0x8ca>
    aae2:	991b      	ldr	r1, [sp, #108]	; 0x6c
    aae4:	9a26      	ldr	r2, [sp, #152]	; 0x98
    aae6:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    aaea:	e67c      	b.n	a7e6 <_svfprintf_r+0x119e>
    aaec:	9b05      	ldr	r3, [sp, #20]
    aaee:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    aaf2:	930f      	str	r3, [sp, #60]	; 0x3c
    aaf4:	e9cd 3302 	strd	r3, r3, [sp, #8]
    aaf8:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    aafc:	9307      	str	r3, [sp, #28]
    aafe:	f7fe bf84 	b.w	9a0a <_svfprintf_r+0x3c2>
    ab02:	990e      	ldr	r1, [sp, #56]	; 0x38
    ab04:	9805      	ldr	r0, [sp, #20]
    ab06:	1865      	adds	r5, r4, r1
    ab08:	1a2d      	subs	r5, r5, r0
    ab0a:	1acc      	subs	r4, r1, r3
    ab0c:	42a5      	cmp	r5, r4
    ab0e:	bfa8      	it	ge
    ab10:	4625      	movge	r5, r4
    ab12:	f7ff bb4d 	b.w	a1b0 <_svfprintf_r+0xb68>
    ab16:	9b08      	ldr	r3, [sp, #32]
    ab18:	9904      	ldr	r1, [sp, #16]
    ab1a:	f853 2b04 	ldr.w	r2, [r3], #4
    ab1e:	9308      	str	r3, [sp, #32]
    ab20:	8011      	strh	r1, [r2, #0]
    ab22:	464c      	mov	r4, r9
    ab24:	f7fe bdc2 	b.w	96ac <_svfprintf_r+0x64>
    ab28:	f913 2b04 	ldrsb.w	r2, [r3], #4
    ab2c:	9308      	str	r3, [sp, #32]
    ab2e:	17d1      	asrs	r1, r2, #31
    ab30:	460b      	mov	r3, r1
    ab32:	f7fe bfdb 	b.w	9aec <_svfprintf_r+0x4a4>
    ab36:	9a03      	ldr	r2, [sp, #12]
    ab38:	2102      	movs	r1, #2
    ab3a:	ab22      	add	r3, sp, #136	; 0x88
    ab3c:	9301      	str	r3, [sp, #4]
    ab3e:	ab1d      	add	r3, sp, #116	; 0x74
    ab40:	9300      	str	r3, [sp, #0]
    ab42:	4658      	mov	r0, fp
    ab44:	ab1b      	add	r3, sp, #108	; 0x6c
    ab46:	eeb0 0b4a 	vmov.f64	d0, d10
    ab4a:	9202      	str	r2, [sp, #8]
    ab4c:	f000 fdc4 	bl	b6d8 <_dtoa_r>
    ab50:	2d47      	cmp	r5, #71	; 0x47
    ab52:	9a02      	ldr	r2, [sp, #8]
    ab54:	4604      	mov	r4, r0
    ab56:	f000 8161 	beq.w	ae1c <_svfprintf_r+0x17d4>
    ab5a:	2d46      	cmp	r5, #70	; 0x46
    ab5c:	4410      	add	r0, r2
    ab5e:	d105      	bne.n	ab6c <_svfprintf_r+0x1524>
    ab60:	7823      	ldrb	r3, [r4, #0]
    ab62:	2b30      	cmp	r3, #48	; 0x30
    ab64:	f000 826f 	beq.w	b046 <_svfprintf_r+0x19fe>
    ab68:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    ab6a:	4410      	add	r0, r2
    ab6c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    ab70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ab74:	f040 8146 	bne.w	ae04 <_svfprintf_r+0x17bc>
    ab78:	4603      	mov	r3, r0
    ab7a:	1b1b      	subs	r3, r3, r4
    ab7c:	930e      	str	r3, [sp, #56]	; 0x38
    ab7e:	2d47      	cmp	r5, #71	; 0x47
    ab80:	f000 8110 	beq.w	ada4 <_svfprintf_r+0x175c>
    ab84:	2d46      	cmp	r5, #70	; 0x46
    ab86:	f000 81b5 	beq.w	aef4 <_svfprintf_r+0x18ac>
    ab8a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    ab8c:	930c      	str	r3, [sp, #48]	; 0x30
    ab8e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ab90:	2d41      	cmp	r5, #65	; 0x41
    ab92:	f103 33ff 	add.w	r3, r3, #4294967295
    ab96:	931b      	str	r3, [sp, #108]	; 0x6c
    ab98:	f000 81e5 	beq.w	af66 <_svfprintf_r+0x191e>
    ab9c:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
    aba0:	2100      	movs	r1, #0
    aba2:	2b00      	cmp	r3, #0
    aba4:	bfb8      	it	lt
    aba6:	9b0c      	ldrlt	r3, [sp, #48]	; 0x30
    aba8:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    abac:	bfba      	itte	lt
    abae:	f1c3 0301 	rsblt	r3, r3, #1
    abb2:	222d      	movlt	r2, #45	; 0x2d
    abb4:	222b      	movge	r2, #43	; 0x2b
    abb6:	2b09      	cmp	r3, #9
    abb8:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
    abbc:	f340 81da 	ble.w	af74 <_svfprintf_r+0x192c>
    abc0:	f10d 058f 	add.w	r5, sp, #143	; 0x8f
    abc4:	f8df c41c 	ldr.w	ip, [pc, #1052]	; afe4 <_svfprintf_r+0x199c>
    abc8:	462a      	mov	r2, r5
    abca:	4610      	mov	r0, r2
    abcc:	fb8c 2103 	smull	r2, r1, ip, r3
    abd0:	17da      	asrs	r2, r3, #31
    abd2:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    abd6:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    abda:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
    abde:	3130      	adds	r1, #48	; 0x30
    abe0:	f800 1c01 	strb.w	r1, [r0, #-1]
    abe4:	4619      	mov	r1, r3
    abe6:	2963      	cmp	r1, #99	; 0x63
    abe8:	4613      	mov	r3, r2
    abea:	f100 32ff 	add.w	r2, r0, #4294967295
    abee:	dcec      	bgt.n	abca <_svfprintf_r+0x1582>
    abf0:	3330      	adds	r3, #48	; 0x30
    abf2:	b2d9      	uxtb	r1, r3
    abf4:	1e83      	subs	r3, r0, #2
    abf6:	429d      	cmp	r5, r3
    abf8:	f802 1c01 	strb.w	r1, [r2, #-1]
    abfc:	f240 828b 	bls.w	b116 <_svfprintf_r+0x1ace>
    ac00:	4613      	mov	r3, r2
    ac02:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
    ac06:	e001      	b.n	ac0c <_svfprintf_r+0x15c4>
    ac08:	f813 1b01 	ldrb.w	r1, [r3], #1
    ac0c:	f802 1b01 	strb.w	r1, [r2], #1
    ac10:	429d      	cmp	r5, r3
    ac12:	d1f9      	bne.n	ac08 <_svfprintf_r+0x15c0>
    ac14:	f10d 0391 	add.w	r3, sp, #145	; 0x91
    ac18:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
    ac1c:	1a1b      	subs	r3, r3, r0
    ac1e:	4413      	add	r3, r2
    ac20:	aa1e      	add	r2, sp, #120	; 0x78
    ac22:	1a9b      	subs	r3, r3, r2
    ac24:	9314      	str	r3, [sp, #80]	; 0x50
    ac26:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ac28:	9a14      	ldr	r2, [sp, #80]	; 0x50
    ac2a:	2b01      	cmp	r3, #1
    ac2c:	441a      	add	r2, r3
    ac2e:	9205      	str	r2, [sp, #20]
    ac30:	f340 8203 	ble.w	b03a <_svfprintf_r+0x19f2>
    ac34:	9b05      	ldr	r3, [sp, #20]
    ac36:	9a10      	ldr	r2, [sp, #64]	; 0x40
    ac38:	4413      	add	r3, r2
    ac3a:	9305      	str	r3, [sp, #20]
    ac3c:	f426 6380 	bic.w	r3, r6, #1024	; 0x400
    ac40:	9a05      	ldr	r2, [sp, #20]
    ac42:	f443 7880 	orr.w	r8, r3, #256	; 0x100
    ac46:	2300      	movs	r3, #0
    ac48:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    ac4c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    ac50:	930f      	str	r3, [sp, #60]	; 0x3c
    ac52:	9202      	str	r2, [sp, #8]
    ac54:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ac56:	2b00      	cmp	r3, #0
    ac58:	f040 80b1 	bne.w	adbe <_svfprintf_r+0x1776>
    ac5c:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    ac60:	9303      	str	r3, [sp, #12]
    ac62:	f7fe bed2 	b.w	9a0a <_svfprintf_r+0x3c2>
    ac66:	4620      	mov	r0, r4
    ac68:	f7fd ff4a 	bl	8b00 <strlen>
    ac6c:	4602      	mov	r2, r0
    ac6e:	9005      	str	r0, [sp, #20]
    ac70:	f7fe bf20 	b.w	9ab4 <_svfprintf_r+0x46c>
    ac74:	ee1b 1a10 	vmov	r1, s22
    ac78:	aa24      	add	r2, sp, #144	; 0x90
    ac7a:	4658      	mov	r0, fp
    ac7c:	f001 fbe8 	bl	c450 <__ssprint_r>
    ac80:	f7fe bded 	b.w	985e <_svfprintf_r+0x216>
    ac84:	1c59      	adds	r1, r3, #1
    ac86:	4658      	mov	r0, fp
    ac88:	f7fc ff5c 	bl	7b44 <_malloc_r>
    ac8c:	4604      	mov	r4, r0
    ac8e:	2800      	cmp	r0, #0
    ac90:	f000 81ca 	beq.w	b028 <_svfprintf_r+0x19e0>
    ac94:	9007      	str	r0, [sp, #28]
    ac96:	e6e0      	b.n	aa5a <_svfprintf_r+0x1412>
    ac98:	ee1b 1a10 	vmov	r1, s22
    ac9c:	aa24      	add	r2, sp, #144	; 0x90
    ac9e:	4658      	mov	r0, fp
    aca0:	f001 fbd6 	bl	c450 <__ssprint_r>
    aca4:	2800      	cmp	r0, #0
    aca6:	f47f a934 	bne.w	9f12 <_svfprintf_r+0x8ca>
    acaa:	9a26      	ldr	r2, [sp, #152]	; 0x98
    acac:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    acb0:	f7ff ba49 	b.w	a146 <_svfprintf_r+0xafe>
    acb4:	ee1b 1a10 	vmov	r1, s22
    acb8:	aa24      	add	r2, sp, #144	; 0x90
    acba:	4658      	mov	r0, fp
    acbc:	f001 fbc8 	bl	c450 <__ssprint_r>
    acc0:	2800      	cmp	r0, #0
    acc2:	f47f a926 	bne.w	9f12 <_svfprintf_r+0x8ca>
    acc6:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    acca:	991b      	ldr	r1, [sp, #108]	; 0x6c
    accc:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    acd0:	e649      	b.n	a966 <_svfprintf_r+0x131e>
    acd2:	2306      	movs	r3, #6
    acd4:	9303      	str	r3, [sp, #12]
    acd6:	f7ff bb83 	b.w	a3e0 <_svfprintf_r+0xd98>
    acda:	9b03      	ldr	r3, [sp, #12]
    acdc:	2102      	movs	r1, #2
    acde:	1c5a      	adds	r2, r3, #1
    ace0:	e72b      	b.n	ab3a <_svfprintf_r+0x14f2>
    ace2:	9a03      	ldr	r2, [sp, #12]
    ace4:	2103      	movs	r1, #3
    ace6:	e728      	b.n	ab3a <_svfprintf_r+0x14f2>
    ace8:	a81b      	add	r0, sp, #108	; 0x6c
    acea:	eeb0 0b4a 	vmov.f64	d0, d10
    acee:	f000 fbc7 	bl	b480 <frexp>
    acf2:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
    acf6:	ee20 0b07 	vmul.f64	d0, d0, d7
    acfa:	eeb5 0b40 	vcmp.f64	d0, #0.0
    acfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad02:	d101      	bne.n	ad08 <_svfprintf_r+0x16c0>
    ad04:	2301      	movs	r3, #1
    ad06:	931b      	str	r3, [sp, #108]	; 0x6c
    ad08:	48b3      	ldr	r0, [pc, #716]	; (afd8 <_svfprintf_r+0x1990>)
    ad0a:	9b03      	ldr	r3, [sp, #12]
    ad0c:	eeb3 5b00 	vmov.f64	d5, #48	; 0x41800000  16.0
    ad10:	3b01      	subs	r3, #1
    ad12:	4622      	mov	r2, r4
    ad14:	e004      	b.n	ad20 <_svfprintf_r+0x16d8>
    ad16:	eeb5 0b40 	vcmp.f64	d0, #0.0
    ad1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad1e:	d013      	beq.n	ad48 <_svfprintf_r+0x1700>
    ad20:	ee20 0b05 	vmul.f64	d0, d0, d5
    ad24:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    ad28:	f1b3 3fff 	cmp.w	r3, #4294967295
    ad2c:	ee17 1a90 	vmov	r1, s15
    ad30:	5c41      	ldrb	r1, [r0, r1]
    ad32:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    ad36:	4694      	mov	ip, r2
    ad38:	ee30 0b46 	vsub.f64	d0, d0, d6
    ad3c:	f802 1b01 	strb.w	r1, [r2], #1
    ad40:	4619      	mov	r1, r3
    ad42:	f103 33ff 	add.w	r3, r3, #4294967295
    ad46:	d1e6      	bne.n	ad16 <_svfprintf_r+0x16ce>
    ad48:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    ad4c:	eeb4 0bc6 	vcmpe.f64	d0, d6
    ad50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad54:	f300 8148 	bgt.w	afe8 <_svfprintf_r+0x19a0>
    ad58:	eeb4 0b46 	vcmp.f64	d0, d6
    ad5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad60:	d104      	bne.n	ad6c <_svfprintf_r+0x1724>
    ad62:	ee17 3a90 	vmov	r3, s15
    ad66:	07db      	lsls	r3, r3, #31
    ad68:	f100 813e 	bmi.w	afe8 <_svfprintf_r+0x19a0>
    ad6c:	2900      	cmp	r1, #0
    ad6e:	db06      	blt.n	ad7e <_svfprintf_r+0x1736>
    ad70:	1c4b      	adds	r3, r1, #1
    ad72:	4413      	add	r3, r2
    ad74:	2130      	movs	r1, #48	; 0x30
    ad76:	f802 1b01 	strb.w	r1, [r2], #1
    ad7a:	4293      	cmp	r3, r2
    ad7c:	d1fb      	bne.n	ad76 <_svfprintf_r+0x172e>
    ad7e:	1b13      	subs	r3, r2, r4
    ad80:	930e      	str	r3, [sp, #56]	; 0x38
    ad82:	e6fc      	b.n	ab7e <_svfprintf_r+0x1536>
    ad84:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    ad86:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ad88:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    ad8c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    ad90:	9613      	str	r6, [sp, #76]	; 0x4c
    ad92:	18e3      	adds	r3, r4, r3
    ad94:	429d      	cmp	r5, r3
    ad96:	4629      	mov	r1, r5
    ad98:	bf28      	it	cs
    ad9a:	4619      	movcs	r1, r3
    ad9c:	4682      	mov	sl, r0
    ad9e:	9105      	str	r1, [sp, #20]
    ada0:	f7ff b9d8 	b.w	a154 <_svfprintf_r+0xb0c>
    ada4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    ada6:	930c      	str	r3, [sp, #48]	; 0x30
    ada8:	1cda      	adds	r2, r3, #3
    adaa:	db02      	blt.n	adb2 <_svfprintf_r+0x176a>
    adac:	9a03      	ldr	r2, [sp, #12]
    adae:	4293      	cmp	r3, r2
    adb0:	dd0c      	ble.n	adcc <_svfprintf_r+0x1784>
    adb2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    adb4:	3b02      	subs	r3, #2
    adb6:	930b      	str	r3, [sp, #44]	; 0x2c
    adb8:	f023 0520 	bic.w	r5, r3, #32
    adbc:	e6e7      	b.n	ab8e <_svfprintf_r+0x1546>
    adbe:	212d      	movs	r1, #45	; 0x2d
    adc0:	2300      	movs	r3, #0
    adc2:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    adc6:	9303      	str	r3, [sp, #12]
    adc8:	f7fe be22 	b.w	9a10 <_svfprintf_r+0x3c8>
    adcc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    adce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    add0:	4293      	cmp	r3, r2
    add2:	f2c0 80bd 	blt.w	af50 <_svfprintf_r+0x1908>
    add6:	07f0      	lsls	r0, r6, #31
    add8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    adda:	f140 8132 	bpl.w	b042 <_svfprintf_r+0x19fa>
    adde:	9a10      	ldr	r2, [sp, #64]	; 0x40
    ade0:	4413      	add	r3, r2
    ade2:	9305      	str	r3, [sp, #20]
    ade4:	0571      	lsls	r1, r6, #21
    ade6:	d503      	bpl.n	adf0 <_svfprintf_r+0x17a8>
    ade8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    adea:	2b00      	cmp	r3, #0
    adec:	f300 8135 	bgt.w	b05a <_svfprintf_r+0x1a12>
    adf0:	9b05      	ldr	r3, [sp, #20]
    adf2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    adf6:	9302      	str	r3, [sp, #8]
    adf8:	2367      	movs	r3, #103	; 0x67
    adfa:	930b      	str	r3, [sp, #44]	; 0x2c
    adfc:	2300      	movs	r3, #0
    adfe:	930f      	str	r3, [sp, #60]	; 0x3c
    ae00:	930d      	str	r3, [sp, #52]	; 0x34
    ae02:	e727      	b.n	ac54 <_svfprintf_r+0x160c>
    ae04:	9b22      	ldr	r3, [sp, #136]	; 0x88
    ae06:	4283      	cmp	r3, r0
    ae08:	f4bf aeb7 	bcs.w	ab7a <_svfprintf_r+0x1532>
    ae0c:	2130      	movs	r1, #48	; 0x30
    ae0e:	1c5a      	adds	r2, r3, #1
    ae10:	9222      	str	r2, [sp, #136]	; 0x88
    ae12:	7019      	strb	r1, [r3, #0]
    ae14:	9b22      	ldr	r3, [sp, #136]	; 0x88
    ae16:	4298      	cmp	r0, r3
    ae18:	d8f9      	bhi.n	ae0e <_svfprintf_r+0x17c6>
    ae1a:	e6ae      	b.n	ab7a <_svfprintf_r+0x1532>
    ae1c:	07f3      	lsls	r3, r6, #31
    ae1e:	f100 80a7 	bmi.w	af70 <_svfprintf_r+0x1928>
    ae22:	9b22      	ldr	r3, [sp, #136]	; 0x88
    ae24:	e6a9      	b.n	ab7a <_svfprintf_r+0x1532>
    ae26:	aa24      	add	r2, sp, #144	; 0x90
    ae28:	4658      	mov	r0, fp
    ae2a:	9105      	str	r1, [sp, #20]
    ae2c:	f001 fb10 	bl	c450 <__ssprint_r>
    ae30:	2800      	cmp	r0, #0
    ae32:	f47f a86e 	bne.w	9f12 <_svfprintf_r+0x8ca>
    ae36:	f896 c000 	ldrb.w	ip, [r6]
    ae3a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    ae3c:	9905      	ldr	r1, [sp, #20]
    ae3e:	a827      	add	r0, sp, #156	; 0x9c
    ae40:	4465      	add	r5, ip
    ae42:	f7ff bbec 	b.w	a61e <_svfprintf_r+0xfd6>
    ae46:	ee1b 1a10 	vmov	r1, s22
    ae4a:	aa24      	add	r2, sp, #144	; 0x90
    ae4c:	4658      	mov	r0, fp
    ae4e:	f001 faff 	bl	c450 <__ssprint_r>
    ae52:	2800      	cmp	r0, #0
    ae54:	f47f a85d 	bne.w	9f12 <_svfprintf_r+0x8ca>
    ae58:	9a26      	ldr	r2, [sp, #152]	; 0x98
    ae5a:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    ae5e:	f7ff b96b 	b.w	a138 <_svfprintf_r+0xaf0>
    ae62:	2378      	movs	r3, #120	; 0x78
    ae64:	f88d 3069 	strb.w	r3, [sp, #105]	; 0x69
    ae68:	2330      	movs	r3, #48	; 0x30
    ae6a:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
    ae6e:	9b03      	ldr	r3, [sp, #12]
    ae70:	2b63      	cmp	r3, #99	; 0x63
    ae72:	f048 0602 	orr.w	r6, r8, #2
    ae76:	f300 80a6 	bgt.w	afc6 <_svfprintf_r+0x197e>
    ae7a:	2300      	movs	r3, #0
    ae7c:	9307      	str	r3, [sp, #28]
    ae7e:	ac37      	add	r4, sp, #220	; 0xdc
    ae80:	ee18 3a90 	vmov	r3, s17
    ae84:	2b00      	cmp	r3, #0
    ae86:	f448 7881 	orr.w	r8, r8, #258	; 0x102
    ae8a:	db2b      	blt.n	aee4 <_svfprintf_r+0x189c>
    ae8c:	eeb0 ab48 	vmov.f64	d10, d8
    ae90:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ae92:	f023 0520 	bic.w	r5, r3, #32
    ae96:	2300      	movs	r3, #0
    ae98:	9309      	str	r3, [sp, #36]	; 0x24
    ae9a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ae9c:	2b61      	cmp	r3, #97	; 0x61
    ae9e:	f47f aaad 	bne.w	a3fc <_svfprintf_r+0xdb4>
    aea2:	eeb0 0b4a 	vmov.f64	d0, d10
    aea6:	a81b      	add	r0, sp, #108	; 0x6c
    aea8:	f000 faea 	bl	b480 <frexp>
    aeac:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
    aeb0:	ee20 0b07 	vmul.f64	d0, d0, d7
    aeb4:	eeb5 0b40 	vcmp.f64	d0, #0.0
    aeb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    aebc:	d101      	bne.n	aec2 <_svfprintf_r+0x187a>
    aebe:	2301      	movs	r3, #1
    aec0:	931b      	str	r3, [sp, #108]	; 0x6c
    aec2:	4846      	ldr	r0, [pc, #280]	; (afdc <_svfprintf_r+0x1994>)
    aec4:	e721      	b.n	ad0a <_svfprintf_r+0x16c2>
    aec6:	ee1b 1a10 	vmov	r1, s22
    aeca:	aa24      	add	r2, sp, #144	; 0x90
    aecc:	4658      	mov	r0, fp
    aece:	f001 fabf 	bl	c450 <__ssprint_r>
    aed2:	2800      	cmp	r0, #0
    aed4:	f47f a81d 	bne.w	9f12 <_svfprintf_r+0x8ca>
    aed8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    aeda:	9a26      	ldr	r2, [sp, #152]	; 0x98
    aedc:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    aee0:	f7ff b94e 	b.w	a180 <_svfprintf_r+0xb38>
    aee4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aee6:	f023 0520 	bic.w	r5, r3, #32
    aeea:	232d      	movs	r3, #45	; 0x2d
    aeec:	9309      	str	r3, [sp, #36]	; 0x24
    aeee:	eeb1 ab48 	vneg.f64	d10, d8
    aef2:	e7d2      	b.n	ae9a <_svfprintf_r+0x1852>
    aef4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    aef6:	920c      	str	r2, [sp, #48]	; 0x30
    aef8:	2a00      	cmp	r2, #0
    aefa:	f006 0301 	and.w	r3, r6, #1
    aefe:	f340 810d 	ble.w	b11c <_svfprintf_r+0x1ad4>
    af02:	9903      	ldr	r1, [sp, #12]
    af04:	430b      	orrs	r3, r1
    af06:	f040 80cf 	bne.w	b0a8 <_svfprintf_r+0x1a60>
    af0a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    af0c:	9305      	str	r3, [sp, #20]
    af0e:	2366      	movs	r3, #102	; 0x66
    af10:	930b      	str	r3, [sp, #44]	; 0x2c
    af12:	0572      	lsls	r2, r6, #21
    af14:	f100 80a3 	bmi.w	b05e <_svfprintf_r+0x1a16>
    af18:	9b05      	ldr	r3, [sp, #20]
    af1a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    af1e:	9302      	str	r3, [sp, #8]
    af20:	e76c      	b.n	adfc <_svfprintf_r+0x17b4>
    af22:	ee1b 1a10 	vmov	r1, s22
    af26:	aa24      	add	r2, sp, #144	; 0x90
    af28:	4658      	mov	r0, fp
    af2a:	f001 fa91 	bl	c450 <__ssprint_r>
    af2e:	2800      	cmp	r0, #0
    af30:	f47e afef 	bne.w	9f12 <_svfprintf_r+0x8ca>
    af34:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
    af36:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    af38:	9a26      	ldr	r2, [sp, #152]	; 0x98
    af3a:	1b1c      	subs	r4, r3, r4
    af3c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    af40:	f7ff b936 	b.w	a1b0 <_svfprintf_r+0xb68>
    af44:	2358      	movs	r3, #88	; 0x58
    af46:	e78d      	b.n	ae64 <_svfprintf_r+0x181c>
    af48:	2200      	movs	r2, #0
    af4a:	9203      	str	r2, [sp, #12]
    af4c:	f7fe bbda 	b.w	9704 <_svfprintf_r+0xbc>
    af50:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    af52:	9a10      	ldr	r2, [sp, #64]	; 0x40
    af54:	189a      	adds	r2, r3, r2
    af56:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    af58:	9205      	str	r2, [sp, #20]
    af5a:	2b00      	cmp	r3, #0
    af5c:	f340 80ab 	ble.w	b0b6 <_svfprintf_r+0x1a6e>
    af60:	2367      	movs	r3, #103	; 0x67
    af62:	930b      	str	r3, [sp, #44]	; 0x2c
    af64:	e7d5      	b.n	af12 <_svfprintf_r+0x18ca>
    af66:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    af68:	320f      	adds	r2, #15
    af6a:	b2d2      	uxtb	r2, r2
    af6c:	2101      	movs	r1, #1
    af6e:	e618      	b.n	aba2 <_svfprintf_r+0x155a>
    af70:	18a0      	adds	r0, r4, r2
    af72:	e5fb      	b.n	ab6c <_svfprintf_r+0x1524>
    af74:	2900      	cmp	r1, #0
    af76:	f040 80a8 	bne.w	b0ca <_svfprintf_r+0x1a82>
    af7a:	2230      	movs	r2, #48	; 0x30
    af7c:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
    af80:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
    af84:	3330      	adds	r3, #48	; 0x30
    af86:	f802 3b01 	strb.w	r3, [r2], #1
    af8a:	ab1e      	add	r3, sp, #120	; 0x78
    af8c:	1ad3      	subs	r3, r2, r3
    af8e:	9314      	str	r3, [sp, #80]	; 0x50
    af90:	e649      	b.n	ac26 <_svfprintf_r+0x15de>
    af92:	3301      	adds	r3, #1
    af94:	4912      	ldr	r1, [pc, #72]	; (afe0 <_svfprintf_r+0x1998>)
    af96:	f8ca 5004 	str.w	r5, [sl, #4]
    af9a:	442a      	add	r2, r5
    af9c:	2b07      	cmp	r3, #7
    af9e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    afa2:	f8ca 1000 	str.w	r1, [sl]
    afa6:	f77f ac33 	ble.w	a810 <_svfprintf_r+0x11c8>
    afaa:	ee1b 1a10 	vmov	r1, s22
    afae:	aa24      	add	r2, sp, #144	; 0x90
    afb0:	4658      	mov	r0, fp
    afb2:	f001 fa4d 	bl	c450 <__ssprint_r>
    afb6:	2800      	cmp	r0, #0
    afb8:	f47e afab 	bne.w	9f12 <_svfprintf_r+0x8ca>
    afbc:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    afc0:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    afc4:	e426      	b.n	a814 <_svfprintf_r+0x11cc>
    afc6:	1c59      	adds	r1, r3, #1
    afc8:	4658      	mov	r0, fp
    afca:	f7fc fdbb 	bl	7b44 <_malloc_r>
    afce:	4604      	mov	r4, r0
    afd0:	b350      	cbz	r0, b028 <_svfprintf_r+0x19e0>
    afd2:	9007      	str	r0, [sp, #28]
    afd4:	e754      	b.n	ae80 <_svfprintf_r+0x1838>
    afd6:	bf00      	nop
    afd8:	20000b40 	.word	0x20000b40
    afdc:	20000b2c 	.word	0x20000b2c
    afe0:	20000fc8 	.word	0x20000fc8
    afe4:	66666667 	.word	0x66666667
    afe8:	f8cd c088 	str.w	ip, [sp, #136]	; 0x88
    afec:	f812 1c01 	ldrb.w	r1, [r2, #-1]
    aff0:	f890 c00f 	ldrb.w	ip, [r0, #15]
    aff4:	4561      	cmp	r1, ip
    aff6:	4613      	mov	r3, r2
    aff8:	d10a      	bne.n	b010 <_svfprintf_r+0x19c8>
    affa:	f04f 0e30 	mov.w	lr, #48	; 0x30
    affe:	f803 ec01 	strb.w	lr, [r3, #-1]
    b002:	9b22      	ldr	r3, [sp, #136]	; 0x88
    b004:	1e59      	subs	r1, r3, #1
    b006:	9122      	str	r1, [sp, #136]	; 0x88
    b008:	f813 1c01 	ldrb.w	r1, [r3, #-1]
    b00c:	458c      	cmp	ip, r1
    b00e:	d0f6      	beq.n	affe <_svfprintf_r+0x19b6>
    b010:	2939      	cmp	r1, #57	; 0x39
    b012:	bf16      	itet	ne
    b014:	3101      	addne	r1, #1
    b016:	7a81      	ldrbeq	r1, [r0, #10]
    b018:	b2c9      	uxtbne	r1, r1
    b01a:	f803 1c01 	strb.w	r1, [r3, #-1]
    b01e:	e6ae      	b.n	ad7e <_svfprintf_r+0x1736>
    b020:	2300      	movs	r3, #0
    b022:	4690      	mov	r8, r2
    b024:	9307      	str	r3, [sp, #28]
    b026:	e760      	b.n	aeea <_svfprintf_r+0x18a2>
    b028:	ee1b 2a10 	vmov	r2, s22
    b02c:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
    b030:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b034:	8193      	strh	r3, [r2, #12]
    b036:	f7fe bc16 	b.w	9866 <_svfprintf_r+0x21e>
    b03a:	07f5      	lsls	r5, r6, #31
    b03c:	f57f adfe 	bpl.w	ac3c <_svfprintf_r+0x15f4>
    b040:	e5f8      	b.n	ac34 <_svfprintf_r+0x15ec>
    b042:	9305      	str	r3, [sp, #20]
    b044:	e6ce      	b.n	ade4 <_svfprintf_r+0x179c>
    b046:	eeb5 ab40 	vcmp.f64	d10, #0.0
    b04a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b04e:	f43f ad8b 	beq.w	ab68 <_svfprintf_r+0x1520>
    b052:	f1c2 0201 	rsb	r2, r2, #1
    b056:	921b      	str	r2, [sp, #108]	; 0x6c
    b058:	e587      	b.n	ab6a <_svfprintf_r+0x1522>
    b05a:	2367      	movs	r3, #103	; 0x67
    b05c:	930b      	str	r3, [sp, #44]	; 0x2c
    b05e:	9913      	ldr	r1, [sp, #76]	; 0x4c
    b060:	780b      	ldrb	r3, [r1, #0]
    b062:	2bff      	cmp	r3, #255	; 0xff
    b064:	d079      	beq.n	b15a <_svfprintf_r+0x1b12>
    b066:	2500      	movs	r5, #0
    b068:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    b06a:	4628      	mov	r0, r5
    b06c:	e003      	b.n	b076 <_svfprintf_r+0x1a2e>
    b06e:	3001      	adds	r0, #1
    b070:	3101      	adds	r1, #1
    b072:	2bff      	cmp	r3, #255	; 0xff
    b074:	d008      	beq.n	b088 <_svfprintf_r+0x1a40>
    b076:	4293      	cmp	r3, r2
    b078:	da06      	bge.n	b088 <_svfprintf_r+0x1a40>
    b07a:	1ad2      	subs	r2, r2, r3
    b07c:	784b      	ldrb	r3, [r1, #1]
    b07e:	2b00      	cmp	r3, #0
    b080:	d1f5      	bne.n	b06e <_svfprintf_r+0x1a26>
    b082:	780b      	ldrb	r3, [r1, #0]
    b084:	3501      	adds	r5, #1
    b086:	e7f4      	b.n	b072 <_svfprintf_r+0x1a2a>
    b088:	920c      	str	r2, [sp, #48]	; 0x30
    b08a:	9113      	str	r1, [sp, #76]	; 0x4c
    b08c:	900d      	str	r0, [sp, #52]	; 0x34
    b08e:	950f      	str	r5, [sp, #60]	; 0x3c
    b090:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    b092:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b094:	9916      	ldr	r1, [sp, #88]	; 0x58
    b096:	4413      	add	r3, r2
    b098:	9a05      	ldr	r2, [sp, #20]
    b09a:	fb01 2303 	mla	r3, r1, r3, r2
    b09e:	9305      	str	r3, [sp, #20]
    b0a0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    b0a4:	9302      	str	r3, [sp, #8]
    b0a6:	e5d5      	b.n	ac54 <_svfprintf_r+0x160c>
    b0a8:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b0aa:	18d3      	adds	r3, r2, r3
    b0ac:	4419      	add	r1, r3
    b0ae:	2366      	movs	r3, #102	; 0x66
    b0b0:	9105      	str	r1, [sp, #20]
    b0b2:	930b      	str	r3, [sp, #44]	; 0x2c
    b0b4:	e72d      	b.n	af12 <_svfprintf_r+0x18ca>
    b0b6:	f1c3 0301 	rsb	r3, r3, #1
    b0ba:	441a      	add	r2, r3
    b0bc:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    b0c0:	9302      	str	r3, [sp, #8]
    b0c2:	2367      	movs	r3, #103	; 0x67
    b0c4:	9205      	str	r2, [sp, #20]
    b0c6:	930b      	str	r3, [sp, #44]	; 0x2c
    b0c8:	e698      	b.n	adfc <_svfprintf_r+0x17b4>
    b0ca:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
    b0ce:	e759      	b.n	af84 <_svfprintf_r+0x193c>
    b0d0:	9b03      	ldr	r3, [sp, #12]
    b0d2:	f8dd 9008 	ldr.w	r9, [sp, #8]
    b0d6:	f8dd 801c 	ldr.w	r8, [sp, #28]
    b0da:	9305      	str	r3, [sp, #20]
    b0dc:	e4b4      	b.n	aa48 <_svfprintf_r+0x1400>
    b0de:	ee18 3a90 	vmov	r3, s17
    b0e2:	2b00      	cmp	r3, #0
    b0e4:	bfb4      	ite	lt
    b0e6:	212d      	movlt	r1, #45	; 0x2d
    b0e8:	f89d 1067 	ldrbge.w	r1, [sp, #103]	; 0x67
    b0ec:	4c25      	ldr	r4, [pc, #148]	; (b184 <_svfprintf_r+0x1b3c>)
    b0ee:	4b26      	ldr	r3, [pc, #152]	; (b188 <_svfprintf_r+0x1b40>)
    b0f0:	bfb8      	it	lt
    b0f2:	f88d 1067 	strblt.w	r1, [sp, #103]	; 0x67
    b0f6:	f028 0880 	bic.w	r8, r8, #128	; 0x80
    b0fa:	f7fe bc79 	b.w	99f0 <_svfprintf_r+0x3a8>
    b0fe:	9b03      	ldr	r3, [sp, #12]
    b100:	9302      	str	r3, [sp, #8]
    b102:	9305      	str	r3, [sp, #20]
    b104:	2373      	movs	r3, #115	; 0x73
    b106:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    b10a:	9003      	str	r0, [sp, #12]
    b10c:	900f      	str	r0, [sp, #60]	; 0x3c
    b10e:	900d      	str	r0, [sp, #52]	; 0x34
    b110:	930b      	str	r3, [sp, #44]	; 0x2c
    b112:	f7fe bc7a 	b.w	9a0a <_svfprintf_r+0x3c2>
    b116:	2302      	movs	r3, #2
    b118:	9314      	str	r3, [sp, #80]	; 0x50
    b11a:	e584      	b.n	ac26 <_svfprintf_r+0x15de>
    b11c:	9a03      	ldr	r2, [sp, #12]
    b11e:	4313      	orrs	r3, r2
    b120:	d105      	bne.n	b12e <_svfprintf_r+0x1ae6>
    b122:	2301      	movs	r3, #1
    b124:	2266      	movs	r2, #102	; 0x66
    b126:	9302      	str	r3, [sp, #8]
    b128:	920b      	str	r2, [sp, #44]	; 0x2c
    b12a:	9305      	str	r3, [sp, #20]
    b12c:	e666      	b.n	adfc <_svfprintf_r+0x17b4>
    b12e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b130:	3301      	adds	r3, #1
    b132:	441a      	add	r2, r3
    b134:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    b138:	9302      	str	r3, [sp, #8]
    b13a:	2366      	movs	r3, #102	; 0x66
    b13c:	9205      	str	r2, [sp, #20]
    b13e:	930b      	str	r3, [sp, #44]	; 0x2c
    b140:	e65c      	b.n	adfc <_svfprintf_r+0x17b4>
    b142:	9a08      	ldr	r2, [sp, #32]
    b144:	f899 3001 	ldrb.w	r3, [r9, #1]
    b148:	4689      	mov	r9, r1
    b14a:	f852 1b04 	ldr.w	r1, [r2], #4
    b14e:	9208      	str	r2, [sp, #32]
    b150:	ea41 71e1 	orr.w	r1, r1, r1, asr #31
    b154:	9103      	str	r1, [sp, #12]
    b156:	f7fe bad3 	b.w	9700 <_svfprintf_r+0xb8>
    b15a:	2300      	movs	r3, #0
    b15c:	930f      	str	r3, [sp, #60]	; 0x3c
    b15e:	930d      	str	r3, [sp, #52]	; 0x34
    b160:	e796      	b.n	b090 <_svfprintf_r+0x1a48>
    b162:	230c      	movs	r3, #12
    b164:	f8cb 3000 	str.w	r3, [fp]
    b168:	f04f 33ff 	mov.w	r3, #4294967295
    b16c:	9304      	str	r3, [sp, #16]
    b16e:	f7fe bb81 	b.w	9874 <_svfprintf_r+0x22c>
    b172:	ee1b 2a10 	vmov	r2, s22
    b176:	8993      	ldrh	r3, [r2, #12]
    b178:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b17c:	8193      	strh	r3, [r2, #12]
    b17e:	f7fe bec8 	b.w	9f12 <_svfprintf_r+0x8ca>
    b182:	bf00      	nop
    b184:	20000b24 	.word	0x20000b24
    b188:	20000b28 	.word	0x20000b28

0000b18c <_fclose_r>:
    b18c:	b570      	push	{r4, r5, r6, lr}
    b18e:	2900      	cmp	r1, #0
    b190:	d04b      	beq.n	b22a <_fclose_r+0x9e>
    b192:	4606      	mov	r6, r0
    b194:	460c      	mov	r4, r1
    b196:	b110      	cbz	r0, b19e <_fclose_r+0x12>
    b198:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b19a:	2b00      	cmp	r3, #0
    b19c:	d048      	beq.n	b230 <_fclose_r+0xa4>
    b19e:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b1a0:	07d8      	lsls	r0, r3, #31
    b1a2:	d534      	bpl.n	b20e <_fclose_r+0x82>
    b1a4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    b1a8:	2b00      	cmp	r3, #0
    b1aa:	d03e      	beq.n	b22a <_fclose_r+0x9e>
    b1ac:	4621      	mov	r1, r4
    b1ae:	4630      	mov	r0, r6
    b1b0:	f000 f850 	bl	b254 <__sflush_r>
    b1b4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    b1b6:	4605      	mov	r5, r0
    b1b8:	b133      	cbz	r3, b1c8 <_fclose_r+0x3c>
    b1ba:	69e1      	ldr	r1, [r4, #28]
    b1bc:	4630      	mov	r0, r6
    b1be:	4798      	blx	r3
    b1c0:	2800      	cmp	r0, #0
    b1c2:	bfb8      	it	lt
    b1c4:	f04f 35ff 	movlt.w	r5, #4294967295
    b1c8:	89a3      	ldrh	r3, [r4, #12]
    b1ca:	061a      	lsls	r2, r3, #24
    b1cc:	d43c      	bmi.n	b248 <_fclose_r+0xbc>
    b1ce:	6b21      	ldr	r1, [r4, #48]	; 0x30
    b1d0:	b141      	cbz	r1, b1e4 <_fclose_r+0x58>
    b1d2:	f104 0340 	add.w	r3, r4, #64	; 0x40
    b1d6:	4299      	cmp	r1, r3
    b1d8:	d002      	beq.n	b1e0 <_fclose_r+0x54>
    b1da:	4630      	mov	r0, r6
    b1dc:	f7fd fd4e 	bl	8c7c <_free_r>
    b1e0:	2300      	movs	r3, #0
    b1e2:	6323      	str	r3, [r4, #48]	; 0x30
    b1e4:	6c61      	ldr	r1, [r4, #68]	; 0x44
    b1e6:	b121      	cbz	r1, b1f2 <_fclose_r+0x66>
    b1e8:	4630      	mov	r0, r6
    b1ea:	f7fd fd47 	bl	8c7c <_free_r>
    b1ee:	2300      	movs	r3, #0
    b1f0:	6463      	str	r3, [r4, #68]	; 0x44
    b1f2:	f7fd fa03 	bl	85fc <__sfp_lock_acquire>
    b1f6:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b1f8:	2200      	movs	r2, #0
    b1fa:	07db      	lsls	r3, r3, #31
    b1fc:	81a2      	strh	r2, [r4, #12]
    b1fe:	d51f      	bpl.n	b240 <_fclose_r+0xb4>
    b200:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b202:	f7fd fc6f 	bl	8ae4 <__retarget_lock_close_recursive>
    b206:	f7fd f9ff 	bl	8608 <__sfp_lock_release>
    b20a:	4628      	mov	r0, r5
    b20c:	bd70      	pop	{r4, r5, r6, pc}
    b20e:	89a3      	ldrh	r3, [r4, #12]
    b210:	0599      	lsls	r1, r3, #22
    b212:	d4cb      	bmi.n	b1ac <_fclose_r+0x20>
    b214:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b216:	f7fd fc67 	bl	8ae8 <__retarget_lock_acquire_recursive>
    b21a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    b21e:	2b00      	cmp	r3, #0
    b220:	d1c4      	bne.n	b1ac <_fclose_r+0x20>
    b222:	6e65      	ldr	r5, [r4, #100]	; 0x64
    b224:	f015 0501 	ands.w	r5, r5, #1
    b228:	d005      	beq.n	b236 <_fclose_r+0xaa>
    b22a:	2500      	movs	r5, #0
    b22c:	4628      	mov	r0, r5
    b22e:	bd70      	pop	{r4, r5, r6, pc}
    b230:	f7fd f9c6 	bl	85c0 <__sinit>
    b234:	e7b3      	b.n	b19e <_fclose_r+0x12>
    b236:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b238:	f7fd fc58 	bl	8aec <__retarget_lock_release_recursive>
    b23c:	4628      	mov	r0, r5
    b23e:	bd70      	pop	{r4, r5, r6, pc}
    b240:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b242:	f7fd fc53 	bl	8aec <__retarget_lock_release_recursive>
    b246:	e7db      	b.n	b200 <_fclose_r+0x74>
    b248:	6921      	ldr	r1, [r4, #16]
    b24a:	4630      	mov	r0, r6
    b24c:	f7fd fd16 	bl	8c7c <_free_r>
    b250:	e7bd      	b.n	b1ce <_fclose_r+0x42>
    b252:	bf00      	nop

0000b254 <__sflush_r>:
    b254:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    b258:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b25c:	460c      	mov	r4, r1
    b25e:	0711      	lsls	r1, r2, #28
    b260:	4680      	mov	r8, r0
    b262:	d447      	bmi.n	b2f4 <__sflush_r+0xa0>
    b264:	6863      	ldr	r3, [r4, #4]
    b266:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    b26a:	2b00      	cmp	r3, #0
    b26c:	81a2      	strh	r2, [r4, #12]
    b26e:	dd5e      	ble.n	b32e <__sflush_r+0xda>
    b270:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    b272:	2d00      	cmp	r5, #0
    b274:	d058      	beq.n	b328 <__sflush_r+0xd4>
    b276:	2300      	movs	r3, #0
    b278:	f8d8 6000 	ldr.w	r6, [r8]
    b27c:	f8c8 3000 	str.w	r3, [r8]
    b280:	b293      	uxth	r3, r2
    b282:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    b286:	d156      	bne.n	b336 <__sflush_r+0xe2>
    b288:	2301      	movs	r3, #1
    b28a:	69e1      	ldr	r1, [r4, #28]
    b28c:	4640      	mov	r0, r8
    b28e:	47a8      	blx	r5
    b290:	1c43      	adds	r3, r0, #1
    b292:	d067      	beq.n	b364 <__sflush_r+0x110>
    b294:	89a3      	ldrh	r3, [r4, #12]
    b296:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    b298:	075f      	lsls	r7, r3, #29
    b29a:	d505      	bpl.n	b2a8 <__sflush_r+0x54>
    b29c:	6863      	ldr	r3, [r4, #4]
    b29e:	1ac0      	subs	r0, r0, r3
    b2a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b2a2:	b10b      	cbz	r3, b2a8 <__sflush_r+0x54>
    b2a4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    b2a6:	1ac0      	subs	r0, r0, r3
    b2a8:	69e1      	ldr	r1, [r4, #28]
    b2aa:	4602      	mov	r2, r0
    b2ac:	2300      	movs	r3, #0
    b2ae:	4640      	mov	r0, r8
    b2b0:	47a8      	blx	r5
    b2b2:	1c41      	adds	r1, r0, #1
    b2b4:	d141      	bne.n	b33a <__sflush_r+0xe6>
    b2b6:	f8d8 3000 	ldr.w	r3, [r8]
    b2ba:	2b00      	cmp	r3, #0
    b2bc:	d03d      	beq.n	b33a <__sflush_r+0xe6>
    b2be:	2b1d      	cmp	r3, #29
    b2c0:	d001      	beq.n	b2c6 <__sflush_r+0x72>
    b2c2:	2b16      	cmp	r3, #22
    b2c4:	d156      	bne.n	b374 <__sflush_r+0x120>
    b2c6:	89a3      	ldrh	r3, [r4, #12]
    b2c8:	6922      	ldr	r2, [r4, #16]
    b2ca:	6022      	str	r2, [r4, #0]
    b2cc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    b2d0:	2100      	movs	r1, #0
    b2d2:	6061      	str	r1, [r4, #4]
    b2d4:	81a3      	strh	r3, [r4, #12]
    b2d6:	6b21      	ldr	r1, [r4, #48]	; 0x30
    b2d8:	f8c8 6000 	str.w	r6, [r8]
    b2dc:	b321      	cbz	r1, b328 <__sflush_r+0xd4>
    b2de:	f104 0340 	add.w	r3, r4, #64	; 0x40
    b2e2:	4299      	cmp	r1, r3
    b2e4:	d002      	beq.n	b2ec <__sflush_r+0x98>
    b2e6:	4640      	mov	r0, r8
    b2e8:	f7fd fcc8 	bl	8c7c <_free_r>
    b2ec:	2000      	movs	r0, #0
    b2ee:	6320      	str	r0, [r4, #48]	; 0x30
    b2f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b2f4:	6926      	ldr	r6, [r4, #16]
    b2f6:	b1be      	cbz	r6, b328 <__sflush_r+0xd4>
    b2f8:	b293      	uxth	r3, r2
    b2fa:	6825      	ldr	r5, [r4, #0]
    b2fc:	6026      	str	r6, [r4, #0]
    b2fe:	079a      	lsls	r2, r3, #30
    b300:	bf0c      	ite	eq
    b302:	6963      	ldreq	r3, [r4, #20]
    b304:	2300      	movne	r3, #0
    b306:	1bad      	subs	r5, r5, r6
    b308:	60a3      	str	r3, [r4, #8]
    b30a:	e00b      	b.n	b324 <__sflush_r+0xd0>
    b30c:	462b      	mov	r3, r5
    b30e:	4632      	mov	r2, r6
    b310:	69e1      	ldr	r1, [r4, #28]
    b312:	6a67      	ldr	r7, [r4, #36]	; 0x24
    b314:	4640      	mov	r0, r8
    b316:	47b8      	blx	r7
    b318:	f1b0 0c00 	subs.w	ip, r0, #0
    b31c:	eba5 050c 	sub.w	r5, r5, ip
    b320:	4466      	add	r6, ip
    b322:	dd17      	ble.n	b354 <__sflush_r+0x100>
    b324:	2d00      	cmp	r5, #0
    b326:	dcf1      	bgt.n	b30c <__sflush_r+0xb8>
    b328:	2000      	movs	r0, #0
    b32a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b32e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    b330:	2b00      	cmp	r3, #0
    b332:	dc9d      	bgt.n	b270 <__sflush_r+0x1c>
    b334:	e7f8      	b.n	b328 <__sflush_r+0xd4>
    b336:	6d20      	ldr	r0, [r4, #80]	; 0x50
    b338:	e7ae      	b.n	b298 <__sflush_r+0x44>
    b33a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    b33e:	6922      	ldr	r2, [r4, #16]
    b340:	6022      	str	r2, [r4, #0]
    b342:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    b346:	81a3      	strh	r3, [r4, #12]
    b348:	2200      	movs	r2, #0
    b34a:	04db      	lsls	r3, r3, #19
    b34c:	6062      	str	r2, [r4, #4]
    b34e:	d5c2      	bpl.n	b2d6 <__sflush_r+0x82>
    b350:	6520      	str	r0, [r4, #80]	; 0x50
    b352:	e7c0      	b.n	b2d6 <__sflush_r+0x82>
    b354:	89a3      	ldrh	r3, [r4, #12]
    b356:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b35a:	f04f 30ff 	mov.w	r0, #4294967295
    b35e:	81a3      	strh	r3, [r4, #12]
    b360:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b364:	f8d8 3000 	ldr.w	r3, [r8]
    b368:	2b00      	cmp	r3, #0
    b36a:	d093      	beq.n	b294 <__sflush_r+0x40>
    b36c:	2b1d      	cmp	r3, #29
    b36e:	d006      	beq.n	b37e <__sflush_r+0x12a>
    b370:	2b16      	cmp	r3, #22
    b372:	d004      	beq.n	b37e <__sflush_r+0x12a>
    b374:	89a3      	ldrh	r3, [r4, #12]
    b376:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b37a:	81a3      	strh	r3, [r4, #12]
    b37c:	e7d5      	b.n	b32a <__sflush_r+0xd6>
    b37e:	f8c8 6000 	str.w	r6, [r8]
    b382:	e7d1      	b.n	b328 <__sflush_r+0xd4>

0000b384 <_fflush_r>:
    b384:	b538      	push	{r3, r4, r5, lr}
    b386:	460c      	mov	r4, r1
    b388:	4605      	mov	r5, r0
    b38a:	b108      	cbz	r0, b390 <_fflush_r+0xc>
    b38c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b38e:	b303      	cbz	r3, b3d2 <_fflush_r+0x4e>
    b390:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
    b394:	b188      	cbz	r0, b3ba <_fflush_r+0x36>
    b396:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b398:	07db      	lsls	r3, r3, #31
    b39a:	d401      	bmi.n	b3a0 <_fflush_r+0x1c>
    b39c:	0581      	lsls	r1, r0, #22
    b39e:	d50f      	bpl.n	b3c0 <_fflush_r+0x3c>
    b3a0:	4628      	mov	r0, r5
    b3a2:	4621      	mov	r1, r4
    b3a4:	f7ff ff56 	bl	b254 <__sflush_r>
    b3a8:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b3aa:	07da      	lsls	r2, r3, #31
    b3ac:	4605      	mov	r5, r0
    b3ae:	d402      	bmi.n	b3b6 <_fflush_r+0x32>
    b3b0:	89a3      	ldrh	r3, [r4, #12]
    b3b2:	059b      	lsls	r3, r3, #22
    b3b4:	d508      	bpl.n	b3c8 <_fflush_r+0x44>
    b3b6:	4628      	mov	r0, r5
    b3b8:	bd38      	pop	{r3, r4, r5, pc}
    b3ba:	4605      	mov	r5, r0
    b3bc:	4628      	mov	r0, r5
    b3be:	bd38      	pop	{r3, r4, r5, pc}
    b3c0:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b3c2:	f7fd fb91 	bl	8ae8 <__retarget_lock_acquire_recursive>
    b3c6:	e7eb      	b.n	b3a0 <_fflush_r+0x1c>
    b3c8:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b3ca:	f7fd fb8f 	bl	8aec <__retarget_lock_release_recursive>
    b3ce:	4628      	mov	r0, r5
    b3d0:	bd38      	pop	{r3, r4, r5, pc}
    b3d2:	f7fd f8f5 	bl	85c0 <__sinit>
    b3d6:	e7db      	b.n	b390 <_fflush_r+0xc>

0000b3d8 <_localeconv_r>:
    b3d8:	4800      	ldr	r0, [pc, #0]	; (b3dc <_localeconv_r+0x4>)
    b3da:	4770      	bx	lr
    b3dc:	200012d4 	.word	0x200012d4

0000b3e0 <memchr>:
    b3e0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b3e4:	2a10      	cmp	r2, #16
    b3e6:	db2b      	blt.n	b440 <memchr+0x60>
    b3e8:	f010 0f07 	tst.w	r0, #7
    b3ec:	d008      	beq.n	b400 <memchr+0x20>
    b3ee:	f810 3b01 	ldrb.w	r3, [r0], #1
    b3f2:	3a01      	subs	r2, #1
    b3f4:	428b      	cmp	r3, r1
    b3f6:	d02d      	beq.n	b454 <memchr+0x74>
    b3f8:	f010 0f07 	tst.w	r0, #7
    b3fc:	b342      	cbz	r2, b450 <memchr+0x70>
    b3fe:	d1f6      	bne.n	b3ee <memchr+0xe>
    b400:	b4f0      	push	{r4, r5, r6, r7}
    b402:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    b406:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    b40a:	f022 0407 	bic.w	r4, r2, #7
    b40e:	f07f 0700 	mvns.w	r7, #0
    b412:	2300      	movs	r3, #0
    b414:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    b418:	3c08      	subs	r4, #8
    b41a:	ea85 0501 	eor.w	r5, r5, r1
    b41e:	ea86 0601 	eor.w	r6, r6, r1
    b422:	fa85 f547 	uadd8	r5, r5, r7
    b426:	faa3 f587 	sel	r5, r3, r7
    b42a:	fa86 f647 	uadd8	r6, r6, r7
    b42e:	faa5 f687 	sel	r6, r5, r7
    b432:	b98e      	cbnz	r6, b458 <memchr+0x78>
    b434:	d1ee      	bne.n	b414 <memchr+0x34>
    b436:	bcf0      	pop	{r4, r5, r6, r7}
    b438:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b43c:	f002 0207 	and.w	r2, r2, #7
    b440:	b132      	cbz	r2, b450 <memchr+0x70>
    b442:	f810 3b01 	ldrb.w	r3, [r0], #1
    b446:	3a01      	subs	r2, #1
    b448:	ea83 0301 	eor.w	r3, r3, r1
    b44c:	b113      	cbz	r3, b454 <memchr+0x74>
    b44e:	d1f8      	bne.n	b442 <memchr+0x62>
    b450:	2000      	movs	r0, #0
    b452:	4770      	bx	lr
    b454:	3801      	subs	r0, #1
    b456:	4770      	bx	lr
    b458:	2d00      	cmp	r5, #0
    b45a:	bf06      	itte	eq
    b45c:	4635      	moveq	r5, r6
    b45e:	3803      	subeq	r0, #3
    b460:	3807      	subne	r0, #7
    b462:	f015 0f01 	tst.w	r5, #1
    b466:	d107      	bne.n	b478 <memchr+0x98>
    b468:	3001      	adds	r0, #1
    b46a:	f415 7f80 	tst.w	r5, #256	; 0x100
    b46e:	bf02      	ittt	eq
    b470:	3001      	addeq	r0, #1
    b472:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    b476:	3001      	addeq	r0, #1
    b478:	bcf0      	pop	{r4, r5, r6, r7}
    b47a:	3801      	subs	r0, #1
    b47c:	4770      	bx	lr
    b47e:	bf00      	nop

0000b480 <frexp>:
    b480:	b430      	push	{r4, r5}
    b482:	b082      	sub	sp, #8
    b484:	ed8d 0b00 	vstr	d0, [sp]
    b488:	9a01      	ldr	r2, [sp, #4]
    b48a:	4c19      	ldr	r4, [pc, #100]	; (b4f0 <frexp+0x70>)
    b48c:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    b490:	2100      	movs	r1, #0
    b492:	42a3      	cmp	r3, r4
    b494:	6001      	str	r1, [r0, #0]
    b496:	dc21      	bgt.n	b4dc <frexp+0x5c>
    b498:	9c00      	ldr	r4, [sp, #0]
    b49a:	431c      	orrs	r4, r3
    b49c:	d01e      	beq.n	b4dc <frexp+0x5c>
    b49e:	4c15      	ldr	r4, [pc, #84]	; (b4f4 <frexp+0x74>)
    b4a0:	4014      	ands	r4, r2
    b4a2:	b954      	cbnz	r4, b4ba <frexp+0x3a>
    b4a4:	ed9f 7b10 	vldr	d7, [pc, #64]	; b4e8 <frexp+0x68>
    b4a8:	ee20 7b07 	vmul.f64	d7, d0, d7
    b4ac:	ed8d 7b00 	vstr	d7, [sp]
    b4b0:	9a01      	ldr	r2, [sp, #4]
    b4b2:	f06f 0135 	mvn.w	r1, #53	; 0x35
    b4b6:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    b4ba:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
    b4be:	e9dd 4500 	ldrd	r4, r5, [sp]
    b4c2:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
    b4c6:	f042 557f 	orr.w	r5, r2, #1069547520	; 0x3fc00000
    b4ca:	151b      	asrs	r3, r3, #20
    b4cc:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
    b4d0:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    b4d4:	e9cd 4500 	strd	r4, r5, [sp]
    b4d8:	440b      	add	r3, r1
    b4da:	6003      	str	r3, [r0, #0]
    b4dc:	ed9d 0b00 	vldr	d0, [sp]
    b4e0:	b002      	add	sp, #8
    b4e2:	bc30      	pop	{r4, r5}
    b4e4:	4770      	bx	lr
    b4e6:	bf00      	nop
    b4e8:	00000000 	.word	0x00000000
    b4ec:	43500000 	.word	0x43500000
    b4f0:	7fefffff 	.word	0x7fefffff
    b4f4:	7ff00000 	.word	0x7ff00000

0000b4f8 <__assert_func>:
    b4f8:	b500      	push	{lr}
    b4fa:	4c0b      	ldr	r4, [pc, #44]	; (b528 <__assert_func+0x30>)
    b4fc:	6825      	ldr	r5, [r4, #0]
    b4fe:	4614      	mov	r4, r2
    b500:	68ee      	ldr	r6, [r5, #12]
    b502:	461a      	mov	r2, r3
    b504:	b085      	sub	sp, #20
    b506:	4603      	mov	r3, r0
    b508:	460d      	mov	r5, r1
    b50a:	b14c      	cbz	r4, b520 <__assert_func+0x28>
    b50c:	4907      	ldr	r1, [pc, #28]	; (b52c <__assert_func+0x34>)
    b50e:	9500      	str	r5, [sp, #0]
    b510:	e9cd 1401 	strd	r1, r4, [sp, #4]
    b514:	4630      	mov	r0, r6
    b516:	4906      	ldr	r1, [pc, #24]	; (b530 <__assert_func+0x38>)
    b518:	f000 ff86 	bl	c428 <fiprintf>
    b51c:	f7fb fa04 	bl	6928 <abort>
    b520:	4904      	ldr	r1, [pc, #16]	; (b534 <__assert_func+0x3c>)
    b522:	460c      	mov	r4, r1
    b524:	e7f3      	b.n	b50e <__assert_func+0x16>
    b526:	bf00      	nop
    b528:	2000176c 	.word	0x2000176c
    b52c:	200008fc 	.word	0x200008fc
    b530:	2000090c 	.word	0x2000090c
    b534:	200004a8 	.word	0x200004a8

0000b538 <_calloc_r>:
    b538:	b538      	push	{r3, r4, r5, lr}
    b53a:	fba1 1402 	umull	r1, r4, r1, r2
    b53e:	bb8c      	cbnz	r4, b5a4 <_calloc_r+0x6c>
    b540:	f7fc fb00 	bl	7b44 <_malloc_r>
    b544:	4605      	mov	r5, r0
    b546:	b1e0      	cbz	r0, b582 <_calloc_r+0x4a>
    b548:	f850 2c04 	ldr.w	r2, [r0, #-4]
    b54c:	f022 0203 	bic.w	r2, r2, #3
    b550:	3a04      	subs	r2, #4
    b552:	2a24      	cmp	r2, #36	; 0x24
    b554:	d817      	bhi.n	b586 <_calloc_r+0x4e>
    b556:	2a13      	cmp	r2, #19
    b558:	d91a      	bls.n	b590 <_calloc_r+0x58>
    b55a:	2a1b      	cmp	r2, #27
    b55c:	e9c0 4400 	strd	r4, r4, [r0]
    b560:	d91d      	bls.n	b59e <_calloc_r+0x66>
    b562:	2a24      	cmp	r2, #36	; 0x24
    b564:	bf14      	ite	ne
    b566:	f100 0210 	addne.w	r2, r0, #16
    b56a:	f100 0218 	addeq.w	r2, r0, #24
    b56e:	f04f 0300 	mov.w	r3, #0
    b572:	e9c0 4402 	strd	r4, r4, [r0, #8]
    b576:	bf04      	itt	eq
    b578:	6104      	streq	r4, [r0, #16]
    b57a:	6144      	streq	r4, [r0, #20]
    b57c:	e9c2 3300 	strd	r3, r3, [r2]
    b580:	6093      	str	r3, [r2, #8]
    b582:	4628      	mov	r0, r5
    b584:	bd38      	pop	{r3, r4, r5, pc}
    b586:	4621      	mov	r1, r4
    b588:	f7fd f990 	bl	88ac <memset>
    b58c:	4628      	mov	r0, r5
    b58e:	bd38      	pop	{r3, r4, r5, pc}
    b590:	4602      	mov	r2, r0
    b592:	2300      	movs	r3, #0
    b594:	e9c2 3300 	strd	r3, r3, [r2]
    b598:	6093      	str	r3, [r2, #8]
    b59a:	4628      	mov	r0, r5
    b59c:	bd38      	pop	{r3, r4, r5, pc}
    b59e:	f100 0208 	add.w	r2, r0, #8
    b5a2:	e7f6      	b.n	b592 <_calloc_r+0x5a>
    b5a4:	f7fd fa72 	bl	8a8c <__errno>
    b5a8:	230c      	movs	r3, #12
    b5aa:	2500      	movs	r5, #0
    b5ac:	6003      	str	r3, [r0, #0]
    b5ae:	e7e8      	b.n	b582 <_calloc_r+0x4a>

0000b5b0 <quorem>:
    b5b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b5b4:	6903      	ldr	r3, [r0, #16]
    b5b6:	690c      	ldr	r4, [r1, #16]
    b5b8:	42a3      	cmp	r3, r4
    b5ba:	b083      	sub	sp, #12
    b5bc:	f2c0 8087 	blt.w	b6ce <quorem+0x11e>
    b5c0:	3c01      	subs	r4, #1
    b5c2:	f101 0514 	add.w	r5, r1, #20
    b5c6:	00a3      	lsls	r3, r4, #2
    b5c8:	f100 0814 	add.w	r8, r0, #20
    b5cc:	9300      	str	r3, [sp, #0]
    b5ce:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    b5d2:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
    b5d6:	3301      	adds	r3, #1
    b5d8:	4681      	mov	r9, r0
    b5da:	429a      	cmp	r2, r3
    b5dc:	eb08 0084 	add.w	r0, r8, r4, lsl #2
    b5e0:	eb05 0784 	add.w	r7, r5, r4, lsl #2
    b5e4:	9001      	str	r0, [sp, #4]
    b5e6:	fbb2 f6f3 	udiv	r6, r2, r3
    b5ea:	d33b      	bcc.n	b664 <quorem+0xb4>
    b5ec:	f04f 0c00 	mov.w	ip, #0
    b5f0:	46ae      	mov	lr, r5
    b5f2:	4640      	mov	r0, r8
    b5f4:	46e2      	mov	sl, ip
    b5f6:	4663      	mov	r3, ip
    b5f8:	f85e bb04 	ldr.w	fp, [lr], #4
    b5fc:	6802      	ldr	r2, [r0, #0]
    b5fe:	fa1f fc8b 	uxth.w	ip, fp
    b602:	fb06 330c 	mla	r3, r6, ip, r3
    b606:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    b60a:	ea4f 4b1b 	mov.w	fp, fp, lsr #16
    b60e:	fb06 cc0b 	mla	ip, r6, fp, ip
    b612:	b29b      	uxth	r3, r3
    b614:	ebaa 0303 	sub.w	r3, sl, r3
    b618:	fa1f fa8c 	uxth.w	sl, ip
    b61c:	fa13 f382 	uxtah	r3, r3, r2
    b620:	ebca 4212 	rsb	r2, sl, r2, lsr #16
    b624:	eb02 4223 	add.w	r2, r2, r3, asr #16
    b628:	b29b      	uxth	r3, r3
    b62a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    b62e:	4577      	cmp	r7, lr
    b630:	f840 3b04 	str.w	r3, [r0], #4
    b634:	ea4f 4a22 	mov.w	sl, r2, asr #16
    b638:	ea4f 431c 	mov.w	r3, ip, lsr #16
    b63c:	d2dc      	bcs.n	b5f8 <quorem+0x48>
    b63e:	9b00      	ldr	r3, [sp, #0]
    b640:	f858 3003 	ldr.w	r3, [r8, r3]
    b644:	b973      	cbnz	r3, b664 <quorem+0xb4>
    b646:	9b01      	ldr	r3, [sp, #4]
    b648:	3b04      	subs	r3, #4
    b64a:	4598      	cmp	r8, r3
    b64c:	d304      	bcc.n	b658 <quorem+0xa8>
    b64e:	e007      	b.n	b660 <quorem+0xb0>
    b650:	4598      	cmp	r8, r3
    b652:	f104 34ff 	add.w	r4, r4, #4294967295
    b656:	d203      	bcs.n	b660 <quorem+0xb0>
    b658:	f853 2904 	ldr.w	r2, [r3], #-4
    b65c:	2a00      	cmp	r2, #0
    b65e:	d0f7      	beq.n	b650 <quorem+0xa0>
    b660:	f8c9 4010 	str.w	r4, [r9, #16]
    b664:	4648      	mov	r0, r9
    b666:	f7fd feab 	bl	93c0 <__mcmp>
    b66a:	2800      	cmp	r0, #0
    b66c:	db2b      	blt.n	b6c6 <quorem+0x116>
    b66e:	3601      	adds	r6, #1
    b670:	4641      	mov	r1, r8
    b672:	2300      	movs	r3, #0
    b674:	f855 0b04 	ldr.w	r0, [r5], #4
    b678:	f8d1 c000 	ldr.w	ip, [r1]
    b67c:	b282      	uxth	r2, r0
    b67e:	1a9a      	subs	r2, r3, r2
    b680:	0c03      	lsrs	r3, r0, #16
    b682:	fa12 f28c 	uxtah	r2, r2, ip
    b686:	ebc3 431c 	rsb	r3, r3, ip, lsr #16
    b68a:	eb03 4322 	add.w	r3, r3, r2, asr #16
    b68e:	b292      	uxth	r2, r2
    b690:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    b694:	42af      	cmp	r7, r5
    b696:	f841 2b04 	str.w	r2, [r1], #4
    b69a:	ea4f 4323 	mov.w	r3, r3, asr #16
    b69e:	d2e9      	bcs.n	b674 <quorem+0xc4>
    b6a0:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
    b6a4:	eb08 0384 	add.w	r3, r8, r4, lsl #2
    b6a8:	b96a      	cbnz	r2, b6c6 <quorem+0x116>
    b6aa:	3b04      	subs	r3, #4
    b6ac:	4598      	cmp	r8, r3
    b6ae:	d304      	bcc.n	b6ba <quorem+0x10a>
    b6b0:	e007      	b.n	b6c2 <quorem+0x112>
    b6b2:	4598      	cmp	r8, r3
    b6b4:	f104 34ff 	add.w	r4, r4, #4294967295
    b6b8:	d203      	bcs.n	b6c2 <quorem+0x112>
    b6ba:	f853 2904 	ldr.w	r2, [r3], #-4
    b6be:	2a00      	cmp	r2, #0
    b6c0:	d0f7      	beq.n	b6b2 <quorem+0x102>
    b6c2:	f8c9 4010 	str.w	r4, [r9, #16]
    b6c6:	4630      	mov	r0, r6
    b6c8:	b003      	add	sp, #12
    b6ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b6ce:	2000      	movs	r0, #0
    b6d0:	b003      	add	sp, #12
    b6d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b6d6:	bf00      	nop

0000b6d8 <_dtoa_r>:
    b6d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b6dc:	ed2d 8b02 	vpush	{d8}
    b6e0:	b08f      	sub	sp, #60	; 0x3c
    b6e2:	ed8d 0b02 	vstr	d0, [sp, #8]
    b6e6:	9101      	str	r1, [sp, #4]
    b6e8:	6b81      	ldr	r1, [r0, #56]	; 0x38
    b6ea:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    b6ec:	9305      	str	r3, [sp, #20]
    b6ee:	ec57 6b10 	vmov	r6, r7, d0
    b6f2:	4604      	mov	r4, r0
    b6f4:	4693      	mov	fp, r2
    b6f6:	b141      	cbz	r1, b70a <_dtoa_r+0x32>
    b6f8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    b6fa:	604a      	str	r2, [r1, #4]
    b6fc:	2301      	movs	r3, #1
    b6fe:	4093      	lsls	r3, r2
    b700:	608b      	str	r3, [r1, #8]
    b702:	f7fd fbfd 	bl	8f00 <_Bfree>
    b706:	2300      	movs	r3, #0
    b708:	63a3      	str	r3, [r4, #56]	; 0x38
    b70a:	f1b7 0800 	subs.w	r8, r7, #0
    b70e:	bfb4      	ite	lt
    b710:	2301      	movlt	r3, #1
    b712:	2300      	movge	r3, #0
    b714:	602b      	str	r3, [r5, #0]
    b716:	4bbe      	ldr	r3, [pc, #760]	; (ba10 <_dtoa_r+0x338>)
    b718:	bfbc      	itt	lt
    b71a:	f028 4800 	biclt.w	r8, r8, #2147483648	; 0x80000000
    b71e:	f8cd 800c 	strlt.w	r8, [sp, #12]
    b722:	ea33 0308 	bics.w	r3, r3, r8
    b726:	f000 809f 	beq.w	b868 <_dtoa_r+0x190>
    b72a:	ed9d 8b02 	vldr	d8, [sp, #8]
    b72e:	eeb5 8b40 	vcmp.f64	d8, #0.0
    b732:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b736:	d111      	bne.n	b75c <_dtoa_r+0x84>
    b738:	9a05      	ldr	r2, [sp, #20]
    b73a:	2301      	movs	r3, #1
    b73c:	6013      	str	r3, [r2, #0]
    b73e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    b740:	2b00      	cmp	r3, #0
    b742:	f000 823f 	beq.w	bbc4 <_dtoa_r+0x4ec>
    b746:	4bb3      	ldr	r3, [pc, #716]	; (ba14 <_dtoa_r+0x33c>)
    b748:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    b74a:	6013      	str	r3, [r2, #0]
    b74c:	3b01      	subs	r3, #1
    b74e:	9300      	str	r3, [sp, #0]
    b750:	9800      	ldr	r0, [sp, #0]
    b752:	b00f      	add	sp, #60	; 0x3c
    b754:	ecbd 8b02 	vpop	{d8}
    b758:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b75c:	aa0c      	add	r2, sp, #48	; 0x30
    b75e:	a90d      	add	r1, sp, #52	; 0x34
    b760:	4620      	mov	r0, r4
    b762:	eeb0 0b48 	vmov.f64	d0, d8
    b766:	f7fd fef7 	bl	9558 <__d2b>
    b76a:	ea5f 5318 	movs.w	r3, r8, lsr #20
    b76e:	4605      	mov	r5, r0
    b770:	f040 8092 	bne.w	b898 <_dtoa_r+0x1c0>
    b774:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
    b778:	440b      	add	r3, r1
    b77a:	f203 4232 	addw	r2, r3, #1074	; 0x432
    b77e:	2a20      	cmp	r2, #32
    b780:	f340 82fa 	ble.w	bd78 <_dtoa_r+0x6a0>
    b784:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
    b788:	fa08 f802 	lsl.w	r8, r8, r2
    b78c:	f203 4212 	addw	r2, r3, #1042	; 0x412
    b790:	40d6      	lsrs	r6, r2
    b792:	ea48 0206 	orr.w	r2, r8, r6
    b796:	ee07 2a10 	vmov	s14, r2
    b79a:	eeb8 7b47 	vcvt.f64.u32	d7, s14
    b79e:	1e58      	subs	r0, r3, #1
    b7a0:	ee17 6a90 	vmov	r6, s15
    b7a4:	ec53 2b17 	vmov	r2, r3, d7
    b7a8:	f04f 0a01 	mov.w	sl, #1
    b7ac:	f1a6 73f8 	sub.w	r3, r6, #32505856	; 0x1f00000
    b7b0:	ed9f 3b91 	vldr	d3, [pc, #580]	; b9f8 <_dtoa_r+0x320>
    b7b4:	ed9f 7b92 	vldr	d7, [pc, #584]	; ba00 <_dtoa_r+0x328>
    b7b8:	ed9f 5b93 	vldr	d5, [pc, #588]	; ba08 <_dtoa_r+0x330>
    b7bc:	ee06 0a90 	vmov	s13, r0
    b7c0:	ec43 2b12 	vmov	d2, r2, r3
    b7c4:	eeb8 4be6 	vcvt.f64.s32	d4, s13
    b7c8:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    b7cc:	ee32 6b46 	vsub.f64	d6, d2, d6
    b7d0:	eea6 7b03 	vfma.f64	d7, d6, d3
    b7d4:	eea4 7b05 	vfma.f64	d7, d4, d5
    b7d8:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    b7dc:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    b7e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b7e4:	ee16 7a90 	vmov	r7, s13
    b7e8:	d508      	bpl.n	b7fc <_dtoa_r+0x124>
    b7ea:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    b7ee:	eeb4 6b47 	vcmp.f64	d6, d7
    b7f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b7f6:	bf18      	it	ne
    b7f8:	f107 37ff 	addne.w	r7, r7, #4294967295
    b7fc:	2f16      	cmp	r7, #22
    b7fe:	f200 8145 	bhi.w	ba8c <_dtoa_r+0x3b4>
    b802:	4b85      	ldr	r3, [pc, #532]	; (ba18 <_dtoa_r+0x340>)
    b804:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
    b808:	ed93 7b00 	vldr	d7, [r3]
    b80c:	eeb4 8bc7 	vcmpe.f64	d8, d7
    b810:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b814:	d557      	bpl.n	b8c6 <_dtoa_r+0x1ee>
    b816:	1a09      	subs	r1, r1, r0
    b818:	2300      	movs	r3, #0
    b81a:	f1b1 0801 	subs.w	r8, r1, #1
    b81e:	f107 37ff 	add.w	r7, r7, #4294967295
    b822:	930a      	str	r3, [sp, #40]	; 0x28
    b824:	f100 8139 	bmi.w	ba9a <_dtoa_r+0x3c2>
    b828:	2300      	movs	r3, #0
    b82a:	9306      	str	r3, [sp, #24]
    b82c:	2f00      	cmp	r7, #0
    b82e:	da52      	bge.n	b8d6 <_dtoa_r+0x1fe>
    b830:	9b06      	ldr	r3, [sp, #24]
    b832:	9704      	str	r7, [sp, #16]
    b834:	1bdb      	subs	r3, r3, r7
    b836:	9306      	str	r3, [sp, #24]
    b838:	427b      	negs	r3, r7
    b83a:	9308      	str	r3, [sp, #32]
    b83c:	9b01      	ldr	r3, [sp, #4]
    b83e:	2b09      	cmp	r3, #9
    b840:	f04f 0700 	mov.w	r7, #0
    b844:	d84e      	bhi.n	b8e4 <_dtoa_r+0x20c>
    b846:	2b05      	cmp	r3, #5
    b848:	f340 829d 	ble.w	bd86 <_dtoa_r+0x6ae>
    b84c:	3b04      	subs	r3, #4
    b84e:	9301      	str	r3, [sp, #4]
    b850:	2600      	movs	r6, #0
    b852:	9b01      	ldr	r3, [sp, #4]
    b854:	1e9a      	subs	r2, r3, #2
    b856:	2a03      	cmp	r2, #3
    b858:	f200 8125 	bhi.w	baa6 <_dtoa_r+0x3ce>
    b85c:	e8df f012 	tbh	[pc, r2, lsl #1]
    b860:	03a703aa 	.word	0x03a703aa
    b864:	037e039d 	.word	0x037e039d
    b868:	9a05      	ldr	r2, [sp, #20]
    b86a:	f3c8 0813 	ubfx	r8, r8, #0, #20
    b86e:	f242 730f 	movw	r3, #9999	; 0x270f
    b872:	ea58 0806 	orrs.w	r8, r8, r6
    b876:	6013      	str	r3, [r2, #0]
    b878:	d11e      	bne.n	b8b8 <_dtoa_r+0x1e0>
    b87a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    b87c:	2b00      	cmp	r3, #0
    b87e:	f000 8591 	beq.w	c3a4 <_dtoa_r+0xccc>
    b882:	4b66      	ldr	r3, [pc, #408]	; (ba1c <_dtoa_r+0x344>)
    b884:	9300      	str	r3, [sp, #0]
    b886:	3308      	adds	r3, #8
    b888:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    b88a:	9800      	ldr	r0, [sp, #0]
    b88c:	6013      	str	r3, [r2, #0]
    b88e:	b00f      	add	sp, #60	; 0x3c
    b890:	ecbd 8b02 	vpop	{d8}
    b894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b898:	ee18 6a90 	vmov	r6, s17
    b89c:	f3c6 0613 	ubfx	r6, r6, #0, #20
    b8a0:	f2a3 30ff 	subw	r0, r3, #1023	; 0x3ff
    b8a4:	ec53 2b18 	vmov	r2, r3, d8
    b8a8:	f046 537f 	orr.w	r3, r6, #1069547520	; 0x3fc00000
    b8ac:	990c      	ldr	r1, [sp, #48]	; 0x30
    b8ae:	f04f 0a00 	mov.w	sl, #0
    b8b2:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    b8b6:	e77b      	b.n	b7b0 <_dtoa_r+0xd8>
    b8b8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    b8ba:	2b00      	cmp	r3, #0
    b8bc:	f040 833b 	bne.w	bf36 <_dtoa_r+0x85e>
    b8c0:	4b57      	ldr	r3, [pc, #348]	; (ba20 <_dtoa_r+0x348>)
    b8c2:	9300      	str	r3, [sp, #0]
    b8c4:	e744      	b.n	b750 <_dtoa_r+0x78>
    b8c6:	1a09      	subs	r1, r1, r0
    b8c8:	2300      	movs	r3, #0
    b8ca:	f1b1 0801 	subs.w	r8, r1, #1
    b8ce:	930a      	str	r3, [sp, #40]	; 0x28
    b8d0:	f100 80e3 	bmi.w	ba9a <_dtoa_r+0x3c2>
    b8d4:	9306      	str	r3, [sp, #24]
    b8d6:	2300      	movs	r3, #0
    b8d8:	9308      	str	r3, [sp, #32]
    b8da:	9b01      	ldr	r3, [sp, #4]
    b8dc:	9704      	str	r7, [sp, #16]
    b8de:	2b09      	cmp	r3, #9
    b8e0:	44b8      	add	r8, r7
    b8e2:	d9b0      	bls.n	b846 <_dtoa_r+0x16e>
    b8e4:	2300      	movs	r3, #0
    b8e6:	2601      	movs	r6, #1
    b8e8:	9301      	str	r3, [sp, #4]
    b8ea:	9607      	str	r6, [sp, #28]
    b8ec:	f04f 39ff 	mov.w	r9, #4294967295
    b8f0:	469b      	mov	fp, r3
    b8f2:	2100      	movs	r1, #0
    b8f4:	63e1      	str	r1, [r4, #60]	; 0x3c
    b8f6:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
    b8fa:	4620      	mov	r0, r4
    b8fc:	f7fd fada 	bl	8eb4 <_Balloc>
    b900:	9000      	str	r0, [sp, #0]
    b902:	2800      	cmp	r0, #0
    b904:	f000 8540 	beq.w	c388 <_dtoa_r+0xcb0>
    b908:	9b00      	ldr	r3, [sp, #0]
    b90a:	63a3      	str	r3, [r4, #56]	; 0x38
    b90c:	f1b9 0f0e 	cmp.w	r9, #14
    b910:	f200 80dc 	bhi.w	bacc <_dtoa_r+0x3f4>
    b914:	2e00      	cmp	r6, #0
    b916:	f000 80d9 	beq.w	bacc <_dtoa_r+0x3f4>
    b91a:	9b04      	ldr	r3, [sp, #16]
    b91c:	2b00      	cmp	r3, #0
    b91e:	f340 83de 	ble.w	c0de <_dtoa_r+0xa06>
    b922:	4a3d      	ldr	r2, [pc, #244]	; (ba18 <_dtoa_r+0x340>)
    b924:	f003 010f 	and.w	r1, r3, #15
    b928:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    b92c:	ed92 7b00 	vldr	d7, [r2]
    b930:	111a      	asrs	r2, r3, #4
    b932:	05db      	lsls	r3, r3, #23
    b934:	f140 8382 	bpl.w	c03c <_dtoa_r+0x964>
    b938:	493a      	ldr	r1, [pc, #232]	; (ba24 <_dtoa_r+0x34c>)
    b93a:	ed91 6b08 	vldr	d6, [r1, #32]
    b93e:	f002 020f 	and.w	r2, r2, #15
    b942:	2003      	movs	r0, #3
    b944:	ee88 5b06 	vdiv.f64	d5, d8, d6
    b948:	b15a      	cbz	r2, b962 <_dtoa_r+0x28a>
    b94a:	4936      	ldr	r1, [pc, #216]	; (ba24 <_dtoa_r+0x34c>)
    b94c:	07d6      	lsls	r6, r2, #31
    b94e:	d504      	bpl.n	b95a <_dtoa_r+0x282>
    b950:	ed91 6b00 	vldr	d6, [r1]
    b954:	3001      	adds	r0, #1
    b956:	ee27 7b06 	vmul.f64	d7, d7, d6
    b95a:	1052      	asrs	r2, r2, #1
    b95c:	f101 0108 	add.w	r1, r1, #8
    b960:	d1f4      	bne.n	b94c <_dtoa_r+0x274>
    b962:	ee85 6b07 	vdiv.f64	d6, d5, d7
    b966:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b968:	b13b      	cbz	r3, b97a <_dtoa_r+0x2a2>
    b96a:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    b96e:	eeb4 6bc7 	vcmpe.f64	d6, d7
    b972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b976:	f100 84ae 	bmi.w	c2d6 <_dtoa_r+0xbfe>
    b97a:	ee07 0a90 	vmov	s15, r0
    b97e:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    b982:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    b986:	eea5 7b06 	vfma.f64	d7, d5, d6
    b98a:	ee17 2a90 	vmov	r2, s15
    b98e:	ec51 0b17 	vmov	r0, r1, d7
    b992:	f1a2 7150 	sub.w	r1, r2, #54525952	; 0x3400000
    b996:	f1b9 0f00 	cmp.w	r9, #0
    b99a:	f000 8388 	beq.w	c0ae <_dtoa_r+0x9d6>
    b99e:	9e04      	ldr	r6, [sp, #16]
    b9a0:	464a      	mov	r2, r9
    b9a2:	9b07      	ldr	r3, [sp, #28]
    b9a4:	2b00      	cmp	r3, #0
    b9a6:	f000 8447 	beq.w	c238 <_dtoa_r+0xb60>
    b9aa:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    b9ae:	4b1a      	ldr	r3, [pc, #104]	; (ba18 <_dtoa_r+0x340>)
    b9b0:	eefd 4bc6 	vcvt.s32.f64	s9, d6
    b9b4:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
    b9b8:	eeb8 7be4 	vcvt.f64.s32	d7, s9
    b9bc:	ee36 7b47 	vsub.f64	d7, d6, d7
    b9c0:	ed1c 6b02 	vldr	d6, [ip, #-8]
    b9c4:	ee83 5b06 	vdiv.f64	d5, d3, d6
    b9c8:	ec41 0b16 	vmov	d6, r0, r1
    b9cc:	ee14 0a90 	vmov	r0, s9
    b9d0:	ee35 5b46 	vsub.f64	d5, d5, d6
    b9d4:	9900      	ldr	r1, [sp, #0]
    b9d6:	eeb4 5bc7 	vcmpe.f64	d5, d7
    b9da:	3030      	adds	r0, #48	; 0x30
    b9dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b9e0:	f801 0b01 	strb.w	r0, [r1], #1
    b9e4:	f300 84ac 	bgt.w	c340 <_dtoa_r+0xc68>
    b9e8:	eeb7 2b00 	vmov.f64	d2, #112	; 0x3f800000  1.0
    b9ec:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    b9f0:	f04f 0c00 	mov.w	ip, #0
    b9f4:	e031      	b.n	ba5a <_dtoa_r+0x382>
    b9f6:	bf00      	nop
    b9f8:	636f4361 	.word	0x636f4361
    b9fc:	3fd287a7 	.word	0x3fd287a7
    ba00:	8b60c8b3 	.word	0x8b60c8b3
    ba04:	3fc68a28 	.word	0x3fc68a28
    ba08:	509f79fb 	.word	0x509f79fb
    ba0c:	3fd34413 	.word	0x3fd34413
    ba10:	7ff00000 	.word	0x7ff00000
    ba14:	20000525 	.word	0x20000525
    ba18:	200002a8 	.word	0x200002a8
    ba1c:	20000ab0 	.word	0x20000ab0
    ba20:	20000abc 	.word	0x20000abc
    ba24:	20000280 	.word	0x20000280
    ba28:	f10c 0c01 	add.w	ip, ip, #1
    ba2c:	4594      	cmp	ip, r2
    ba2e:	da4d      	bge.n	bacc <_dtoa_r+0x3f4>
    ba30:	ee27 7b04 	vmul.f64	d7, d7, d4
    ba34:	ee25 5b04 	vmul.f64	d5, d5, d4
    ba38:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    ba3c:	ee16 3a90 	vmov	r3, s13
    ba40:	eeb8 3be6 	vcvt.f64.s32	d3, s13
    ba44:	3330      	adds	r3, #48	; 0x30
    ba46:	ee37 7b43 	vsub.f64	d7, d7, d3
    ba4a:	eeb4 7bc5 	vcmpe.f64	d7, d5
    ba4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ba52:	f801 3b01 	strb.w	r3, [r1], #1
    ba56:	f100 8473 	bmi.w	c340 <_dtoa_r+0xc68>
    ba5a:	ee32 6b47 	vsub.f64	d6, d2, d7
    ba5e:	eeb4 6bc5 	vcmpe.f64	d6, d5
    ba62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ba66:	d5df      	bpl.n	ba28 <_dtoa_r+0x350>
    ba68:	9a00      	ldr	r2, [sp, #0]
    ba6a:	9604      	str	r6, [sp, #16]
    ba6c:	e002      	b.n	ba74 <_dtoa_r+0x39c>
    ba6e:	428a      	cmp	r2, r1
    ba70:	f000 8450 	beq.w	c314 <_dtoa_r+0xc3c>
    ba74:	4689      	mov	r9, r1
    ba76:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
    ba7a:	2b39      	cmp	r3, #57	; 0x39
    ba7c:	d0f7      	beq.n	ba6e <_dtoa_r+0x396>
    ba7e:	3301      	adds	r3, #1
    ba80:	b2db      	uxtb	r3, r3
    ba82:	700b      	strb	r3, [r1, #0]
    ba84:	9b04      	ldr	r3, [sp, #16]
    ba86:	3301      	adds	r3, #1
    ba88:	9304      	str	r3, [sp, #16]
    ba8a:	e155      	b.n	bd38 <_dtoa_r+0x660>
    ba8c:	1a09      	subs	r1, r1, r0
    ba8e:	2301      	movs	r3, #1
    ba90:	f1b1 0801 	subs.w	r8, r1, #1
    ba94:	930a      	str	r3, [sp, #40]	; 0x28
    ba96:	f57f aec7 	bpl.w	b828 <_dtoa_r+0x150>
    ba9a:	f1c1 0301 	rsb	r3, r1, #1
    ba9e:	9306      	str	r3, [sp, #24]
    baa0:	f04f 0800 	mov.w	r8, #0
    baa4:	e6c2      	b.n	b82c <_dtoa_r+0x154>
    baa6:	2600      	movs	r6, #0
    baa8:	63e6      	str	r6, [r4, #60]	; 0x3c
    baaa:	4631      	mov	r1, r6
    baac:	4620      	mov	r0, r4
    baae:	f7fd fa01 	bl	8eb4 <_Balloc>
    bab2:	9000      	str	r0, [sp, #0]
    bab4:	2800      	cmp	r0, #0
    bab6:	f000 8467 	beq.w	c388 <_dtoa_r+0xcb0>
    baba:	9b00      	ldr	r3, [sp, #0]
    babc:	63a3      	str	r3, [r4, #56]	; 0x38
    babe:	f04f 33ff 	mov.w	r3, #4294967295
    bac2:	930b      	str	r3, [sp, #44]	; 0x2c
    bac4:	4699      	mov	r9, r3
    bac6:	2301      	movs	r3, #1
    bac8:	46b3      	mov	fp, r6
    baca:	9307      	str	r3, [sp, #28]
    bacc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    bace:	2a00      	cmp	r2, #0
    bad0:	db55      	blt.n	bb7e <_dtoa_r+0x4a6>
    bad2:	9904      	ldr	r1, [sp, #16]
    bad4:	290e      	cmp	r1, #14
    bad6:	dc52      	bgt.n	bb7e <_dtoa_r+0x4a6>
    bad8:	4bb7      	ldr	r3, [pc, #732]	; (bdb8 <_dtoa_r+0x6e0>)
    bada:	f1bb 0f00 	cmp.w	fp, #0
    bade:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    bae2:	ed93 6b00 	vldr	d6, [r3]
    bae6:	da15      	bge.n	bb14 <_dtoa_r+0x43c>
    bae8:	f1b9 0f00 	cmp.w	r9, #0
    baec:	dc12      	bgt.n	bb14 <_dtoa_r+0x43c>
    baee:	f040 82f2 	bne.w	c0d6 <_dtoa_r+0x9fe>
    baf2:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    baf6:	ee26 7b07 	vmul.f64	d7, d6, d7
    bafa:	eeb4 8bc7 	vcmpe.f64	d8, d7
    bafe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bb02:	46ca      	mov	sl, r9
    bb04:	464e      	mov	r6, r9
    bb06:	f200 826d 	bhi.w	bfe4 <_dtoa_r+0x90c>
    bb0a:	f8dd 8000 	ldr.w	r8, [sp]
    bb0e:	ea6f 0b0b 	mvn.w	fp, fp
    bb12:	e270      	b.n	bff6 <_dtoa_r+0x91e>
    bb14:	ee88 7b06 	vdiv.f64	d7, d8, d6
    bb18:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    bb1c:	9900      	ldr	r1, [sp, #0]
    bb1e:	ee17 3a10 	vmov	r3, s14
    bb22:	f1b9 0f01 	cmp.w	r9, #1
    bb26:	f103 0330 	add.w	r3, r3, #48	; 0x30
    bb2a:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    bb2e:	f801 3b01 	strb.w	r3, [r1], #1
    bb32:	eea5 8b46 	vfms.f64	d8, d5, d6
    bb36:	f000 8334 	beq.w	c1a2 <_dtoa_r+0xaca>
    bb3a:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    bb3e:	2301      	movs	r3, #1
    bb40:	e011      	b.n	bb66 <_dtoa_r+0x48e>
    bb42:	ee88 7b06 	vdiv.f64	d7, d8, d6
    bb46:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    bb4a:	3301      	adds	r3, #1
    bb4c:	ee17 2a10 	vmov	r2, s14
    bb50:	454b      	cmp	r3, r9
    bb52:	f102 0230 	add.w	r2, r2, #48	; 0x30
    bb56:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    bb5a:	f801 2b01 	strb.w	r2, [r1], #1
    bb5e:	eea5 8b46 	vfms.f64	d8, d5, d6
    bb62:	f000 831e 	beq.w	c1a2 <_dtoa_r+0xaca>
    bb66:	ee28 8b04 	vmul.f64	d8, d8, d4
    bb6a:	eeb5 8b40 	vcmp.f64	d8, #0.0
    bb6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bb72:	d1e6      	bne.n	bb42 <_dtoa_r+0x46a>
    bb74:	9b04      	ldr	r3, [sp, #16]
    bb76:	3301      	adds	r3, #1
    bb78:	9304      	str	r3, [sp, #16]
    bb7a:	4689      	mov	r9, r1
    bb7c:	e0dc      	b.n	bd38 <_dtoa_r+0x660>
    bb7e:	9b07      	ldr	r3, [sp, #28]
    bb80:	b343      	cbz	r3, bbd4 <_dtoa_r+0x4fc>
    bb82:	9b01      	ldr	r3, [sp, #4]
    bb84:	2b01      	cmp	r3, #1
    bb86:	f340 8276 	ble.w	c076 <_dtoa_r+0x99e>
    bb8a:	9b08      	ldr	r3, [sp, #32]
    bb8c:	f109 3aff 	add.w	sl, r9, #4294967295
    bb90:	4553      	cmp	r3, sl
    bb92:	f280 823f 	bge.w	c014 <_dtoa_r+0x93c>
    bb96:	9b08      	ldr	r3, [sp, #32]
    bb98:	f8cd a020 	str.w	sl, [sp, #32]
    bb9c:	ebaa 0203 	sub.w	r2, sl, r3
    bba0:	4417      	add	r7, r2
    bba2:	f04f 0a00 	mov.w	sl, #0
    bba6:	f1b9 0f00 	cmp.w	r9, #0
    bbaa:	f2c0 8325 	blt.w	c1f8 <_dtoa_r+0xb20>
    bbae:	9b06      	ldr	r3, [sp, #24]
    bbb0:	9309      	str	r3, [sp, #36]	; 0x24
    bbb2:	444b      	add	r3, r9
    bbb4:	44c8      	add	r8, r9
    bbb6:	9306      	str	r3, [sp, #24]
    bbb8:	2101      	movs	r1, #1
    bbba:	4620      	mov	r0, r4
    bbbc:	f7fd fa4c 	bl	9058 <__i2b>
    bbc0:	4606      	mov	r6, r0
    bbc2:	e00c      	b.n	bbde <_dtoa_r+0x506>
    bbc4:	4b7d      	ldr	r3, [pc, #500]	; (bdbc <_dtoa_r+0x6e4>)
    bbc6:	9300      	str	r3, [sp, #0]
    bbc8:	9800      	ldr	r0, [sp, #0]
    bbca:	b00f      	add	sp, #60	; 0x3c
    bbcc:	ecbd 8b02 	vpop	{d8}
    bbd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bbd4:	9b06      	ldr	r3, [sp, #24]
    bbd6:	f8dd a020 	ldr.w	sl, [sp, #32]
    bbda:	9e07      	ldr	r6, [sp, #28]
    bbdc:	9309      	str	r3, [sp, #36]	; 0x24
    bbde:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bbe0:	b16b      	cbz	r3, bbfe <_dtoa_r+0x526>
    bbe2:	f1b8 0f00 	cmp.w	r8, #0
    bbe6:	dd0a      	ble.n	bbfe <_dtoa_r+0x526>
    bbe8:	4543      	cmp	r3, r8
    bbea:	9906      	ldr	r1, [sp, #24]
    bbec:	461a      	mov	r2, r3
    bbee:	bfa8      	it	ge
    bbf0:	4642      	movge	r2, r8
    bbf2:	1a89      	subs	r1, r1, r2
    bbf4:	1a9b      	subs	r3, r3, r2
    bbf6:	9106      	str	r1, [sp, #24]
    bbf8:	9309      	str	r3, [sp, #36]	; 0x24
    bbfa:	eba8 0802 	sub.w	r8, r8, r2
    bbfe:	9b08      	ldr	r3, [sp, #32]
    bc00:	b163      	cbz	r3, bc1c <_dtoa_r+0x544>
    bc02:	9b07      	ldr	r3, [sp, #28]
    bc04:	2b00      	cmp	r3, #0
    bc06:	f000 82a7 	beq.w	c158 <_dtoa_r+0xa80>
    bc0a:	f1ba 0f00 	cmp.w	sl, #0
    bc0e:	f300 8204 	bgt.w	c01a <_dtoa_r+0x942>
    bc12:	9b08      	ldr	r3, [sp, #32]
    bc14:	ebb3 020a 	subs.w	r2, r3, sl
    bc18:	f040 82ff 	bne.w	c21a <_dtoa_r+0xb42>
    bc1c:	2101      	movs	r1, #1
    bc1e:	4620      	mov	r0, r4
    bc20:	f7fd fa1a 	bl	9058 <__i2b>
    bc24:	2f00      	cmp	r7, #0
    bc26:	4682      	mov	sl, r0
    bc28:	f300 80af 	bgt.w	bd8a <_dtoa_r+0x6b2>
    bc2c:	9b01      	ldr	r3, [sp, #4]
    bc2e:	2b01      	cmp	r3, #1
    bc30:	f340 8187 	ble.w	bf42 <_dtoa_r+0x86a>
    bc34:	2300      	movs	r3, #0
    bc36:	9308      	str	r3, [sp, #32]
    bc38:	2001      	movs	r0, #1
    bc3a:	2f00      	cmp	r7, #0
    bc3c:	f040 80b1 	bne.w	bda2 <_dtoa_r+0x6ca>
    bc40:	4440      	add	r0, r8
    bc42:	f010 001f 	ands.w	r0, r0, #31
    bc46:	f000 817a 	beq.w	bf3e <_dtoa_r+0x866>
    bc4a:	f1c0 0220 	rsb	r2, r0, #32
    bc4e:	2a04      	cmp	r2, #4
    bc50:	f300 8088 	bgt.w	bd64 <_dtoa_r+0x68c>
    bc54:	f040 81f6 	bne.w	c044 <_dtoa_r+0x96c>
    bc58:	9b06      	ldr	r3, [sp, #24]
    bc5a:	2b00      	cmp	r3, #0
    bc5c:	dd05      	ble.n	bc6a <_dtoa_r+0x592>
    bc5e:	4629      	mov	r1, r5
    bc60:	461a      	mov	r2, r3
    bc62:	4620      	mov	r0, r4
    bc64:	f7fd fb34 	bl	92d0 <__lshift>
    bc68:	4605      	mov	r5, r0
    bc6a:	f1b8 0f00 	cmp.w	r8, #0
    bc6e:	dd05      	ble.n	bc7c <_dtoa_r+0x5a4>
    bc70:	4651      	mov	r1, sl
    bc72:	4642      	mov	r2, r8
    bc74:	4620      	mov	r0, r4
    bc76:	f7fd fb2b 	bl	92d0 <__lshift>
    bc7a:	4682      	mov	sl, r0
    bc7c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    bc7e:	2b00      	cmp	r3, #0
    bc80:	f040 813f 	bne.w	bf02 <_dtoa_r+0x82a>
    bc84:	f1b9 0f00 	cmp.w	r9, #0
    bc88:	f340 8125 	ble.w	bed6 <_dtoa_r+0x7fe>
    bc8c:	9b07      	ldr	r3, [sp, #28]
    bc8e:	2b00      	cmp	r3, #0
    bc90:	f040 80a3 	bne.w	bdda <_dtoa_r+0x702>
    bc94:	9b04      	ldr	r3, [sp, #16]
    bc96:	3301      	adds	r3, #1
    bc98:	9304      	str	r3, [sp, #16]
    bc9a:	f8dd 8000 	ldr.w	r8, [sp]
    bc9e:	2701      	movs	r7, #1
    bca0:	e007      	b.n	bcb2 <_dtoa_r+0x5da>
    bca2:	4629      	mov	r1, r5
    bca4:	2300      	movs	r3, #0
    bca6:	220a      	movs	r2, #10
    bca8:	4620      	mov	r0, r4
    bcaa:	f7fd f933 	bl	8f14 <__multadd>
    bcae:	3701      	adds	r7, #1
    bcb0:	4605      	mov	r5, r0
    bcb2:	4651      	mov	r1, sl
    bcb4:	4628      	mov	r0, r5
    bcb6:	f7ff fc7b 	bl	b5b0 <quorem>
    bcba:	45b9      	cmp	r9, r7
    bcbc:	f100 0030 	add.w	r0, r0, #48	; 0x30
    bcc0:	f808 0b01 	strb.w	r0, [r8], #1
    bcc4:	dced      	bgt.n	bca2 <_dtoa_r+0x5ca>
    bcc6:	f1b9 0f00 	cmp.w	r9, #0
    bcca:	9a00      	ldr	r2, [sp, #0]
    bccc:	bfcc      	ite	gt
    bcce:	46cb      	movgt	fp, r9
    bcd0:	f04f 0b01 	movle.w	fp, #1
    bcd4:	4603      	mov	r3, r0
    bcd6:	4493      	add	fp, r2
    bcd8:	2700      	movs	r7, #0
    bcda:	4629      	mov	r1, r5
    bcdc:	2201      	movs	r2, #1
    bcde:	4620      	mov	r0, r4
    bce0:	9301      	str	r3, [sp, #4]
    bce2:	f7fd faf5 	bl	92d0 <__lshift>
    bce6:	4651      	mov	r1, sl
    bce8:	4605      	mov	r5, r0
    bcea:	f7fd fb69 	bl	93c0 <__mcmp>
    bcee:	2800      	cmp	r0, #0
    bcf0:	f340 81af 	ble.w	c052 <_dtoa_r+0x97a>
    bcf4:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    bcf8:	9a00      	ldr	r2, [sp, #0]
    bcfa:	f10b 3bff 	add.w	fp, fp, #4294967295
    bcfe:	e004      	b.n	bd0a <_dtoa_r+0x632>
    bd00:	455a      	cmp	r2, fp
    bd02:	f000 81b1 	beq.w	c068 <_dtoa_r+0x990>
    bd06:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    bd0a:	2b39      	cmp	r3, #57	; 0x39
    bd0c:	f10b 0901 	add.w	r9, fp, #1
    bd10:	d0f6      	beq.n	bd00 <_dtoa_r+0x628>
    bd12:	3301      	adds	r3, #1
    bd14:	f88b 3000 	strb.w	r3, [fp]
    bd18:	4651      	mov	r1, sl
    bd1a:	4620      	mov	r0, r4
    bd1c:	f7fd f8f0 	bl	8f00 <_Bfree>
    bd20:	b156      	cbz	r6, bd38 <_dtoa_r+0x660>
    bd22:	b12f      	cbz	r7, bd30 <_dtoa_r+0x658>
    bd24:	42b7      	cmp	r7, r6
    bd26:	d003      	beq.n	bd30 <_dtoa_r+0x658>
    bd28:	4639      	mov	r1, r7
    bd2a:	4620      	mov	r0, r4
    bd2c:	f7fd f8e8 	bl	8f00 <_Bfree>
    bd30:	4631      	mov	r1, r6
    bd32:	4620      	mov	r0, r4
    bd34:	f7fd f8e4 	bl	8f00 <_Bfree>
    bd38:	4629      	mov	r1, r5
    bd3a:	4620      	mov	r0, r4
    bd3c:	f7fd f8e0 	bl	8f00 <_Bfree>
    bd40:	2300      	movs	r3, #0
    bd42:	f889 3000 	strb.w	r3, [r9]
    bd46:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    bd4a:	601a      	str	r2, [r3, #0]
    bd4c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    bd4e:	2b00      	cmp	r3, #0
    bd50:	f43f acfe 	beq.w	b750 <_dtoa_r+0x78>
    bd54:	9800      	ldr	r0, [sp, #0]
    bd56:	f8c3 9000 	str.w	r9, [r3]
    bd5a:	b00f      	add	sp, #60	; 0x3c
    bd5c:	ecbd 8b02 	vpop	{d8}
    bd60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bd64:	f1c0 001c 	rsb	r0, r0, #28
    bd68:	9b06      	ldr	r3, [sp, #24]
    bd6a:	4403      	add	r3, r0
    bd6c:	9306      	str	r3, [sp, #24]
    bd6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bd70:	4403      	add	r3, r0
    bd72:	9309      	str	r3, [sp, #36]	; 0x24
    bd74:	4480      	add	r8, r0
    bd76:	e76f      	b.n	bc58 <_dtoa_r+0x580>
    bd78:	f1c2 0220 	rsb	r2, r2, #32
    bd7c:	fa06 f202 	lsl.w	r2, r6, r2
    bd80:	ee07 2a10 	vmov	s14, r2
    bd84:	e509      	b.n	b79a <_dtoa_r+0xc2>
    bd86:	2601      	movs	r6, #1
    bd88:	e563      	b.n	b852 <_dtoa_r+0x17a>
    bd8a:	4601      	mov	r1, r0
    bd8c:	463a      	mov	r2, r7
    bd8e:	4620      	mov	r0, r4
    bd90:	f7fd fa3e 	bl	9210 <__pow5mult>
    bd94:	9b01      	ldr	r3, [sp, #4]
    bd96:	2b01      	cmp	r3, #1
    bd98:	4682      	mov	sl, r0
    bd9a:	f340 81c5 	ble.w	c128 <_dtoa_r+0xa50>
    bd9e:	2300      	movs	r3, #0
    bda0:	9308      	str	r3, [sp, #32]
    bda2:	f8da 2010 	ldr.w	r2, [sl, #16]
    bda6:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
    bdaa:	6910      	ldr	r0, [r2, #16]
    bdac:	f7fd f904 	bl	8fb8 <__hi0bits>
    bdb0:	f1c0 0020 	rsb	r0, r0, #32
    bdb4:	e744      	b.n	bc40 <_dtoa_r+0x568>
    bdb6:	bf00      	nop
    bdb8:	200002a8 	.word	0x200002a8
    bdbc:	20000524 	.word	0x20000524
    bdc0:	4631      	mov	r1, r6
    bdc2:	2300      	movs	r3, #0
    bdc4:	220a      	movs	r2, #10
    bdc6:	4620      	mov	r0, r4
    bdc8:	f7fd f8a4 	bl	8f14 <__multadd>
    bdcc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bdce:	2b00      	cmp	r3, #0
    bdd0:	4606      	mov	r6, r0
    bdd2:	f340 82ce 	ble.w	c372 <_dtoa_r+0xc9a>
    bdd6:	9704      	str	r7, [sp, #16]
    bdd8:	4699      	mov	r9, r3
    bdda:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bddc:	2b00      	cmp	r3, #0
    bdde:	dd05      	ble.n	bdec <_dtoa_r+0x714>
    bde0:	4631      	mov	r1, r6
    bde2:	461a      	mov	r2, r3
    bde4:	4620      	mov	r0, r4
    bde6:	f7fd fa73 	bl	92d0 <__lshift>
    bdea:	4606      	mov	r6, r0
    bdec:	9b08      	ldr	r3, [sp, #32]
    bdee:	2b00      	cmp	r3, #0
    bdf0:	f040 81eb 	bne.w	c1ca <_dtoa_r+0xaf2>
    bdf4:	46b0      	mov	r8, r6
    bdf6:	9b02      	ldr	r3, [sp, #8]
    bdf8:	9f00      	ldr	r7, [sp, #0]
    bdfa:	f003 0201 	and.w	r2, r3, #1
    bdfe:	1e7b      	subs	r3, r7, #1
    be00:	444b      	add	r3, r9
    be02:	9308      	str	r3, [sp, #32]
    be04:	9b01      	ldr	r3, [sp, #4]
    be06:	920a      	str	r2, [sp, #40]	; 0x28
    be08:	4313      	orrs	r3, r2
    be0a:	9309      	str	r3, [sp, #36]	; 0x24
    be0c:	4651      	mov	r1, sl
    be0e:	4628      	mov	r0, r5
    be10:	f7ff fbce 	bl	b5b0 <quorem>
    be14:	4631      	mov	r1, r6
    be16:	4683      	mov	fp, r0
    be18:	4628      	mov	r0, r5
    be1a:	f7fd fad1 	bl	93c0 <__mcmp>
    be1e:	4642      	mov	r2, r8
    be20:	4651      	mov	r1, sl
    be22:	4681      	mov	r9, r0
    be24:	4620      	mov	r0, r4
    be26:	f7fd faed 	bl	9404 <__mdiff>
    be2a:	68c2      	ldr	r2, [r0, #12]
    be2c:	4601      	mov	r1, r0
    be2e:	f10b 0330 	add.w	r3, fp, #48	; 0x30
    be32:	2a00      	cmp	r2, #0
    be34:	d142      	bne.n	bebc <_dtoa_r+0x7e4>
    be36:	e9cd 0306 	strd	r0, r3, [sp, #24]
    be3a:	4628      	mov	r0, r5
    be3c:	f7fd fac0 	bl	93c0 <__mcmp>
    be40:	9906      	ldr	r1, [sp, #24]
    be42:	9002      	str	r0, [sp, #8]
    be44:	4620      	mov	r0, r4
    be46:	f7fd f85b 	bl	8f00 <_Bfree>
    be4a:	9a02      	ldr	r2, [sp, #8]
    be4c:	9b07      	ldr	r3, [sp, #28]
    be4e:	b91a      	cbnz	r2, be58 <_dtoa_r+0x780>
    be50:	9909      	ldr	r1, [sp, #36]	; 0x24
    be52:	2900      	cmp	r1, #0
    be54:	f000 827e 	beq.w	c354 <_dtoa_r+0xc7c>
    be58:	f1b9 0f00 	cmp.w	r9, #0
    be5c:	f2c0 8183 	blt.w	c166 <_dtoa_r+0xa8e>
    be60:	9901      	ldr	r1, [sp, #4]
    be62:	ea49 0901 	orr.w	r9, r9, r1
    be66:	990a      	ldr	r1, [sp, #40]	; 0x28
    be68:	ea51 0909 	orrs.w	r9, r1, r9
    be6c:	f000 817b 	beq.w	c166 <_dtoa_r+0xa8e>
    be70:	2a00      	cmp	r2, #0
    be72:	f300 81c6 	bgt.w	c202 <_dtoa_r+0xb2a>
    be76:	9a08      	ldr	r2, [sp, #32]
    be78:	703b      	strb	r3, [r7, #0]
    be7a:	f107 0901 	add.w	r9, r7, #1
    be7e:	4297      	cmp	r7, r2
    be80:	46cb      	mov	fp, r9
    be82:	f000 81c4 	beq.w	c20e <_dtoa_r+0xb36>
    be86:	4629      	mov	r1, r5
    be88:	2300      	movs	r3, #0
    be8a:	220a      	movs	r2, #10
    be8c:	4620      	mov	r0, r4
    be8e:	f7fd f841 	bl	8f14 <__multadd>
    be92:	4546      	cmp	r6, r8
    be94:	4605      	mov	r5, r0
    be96:	4631      	mov	r1, r6
    be98:	f04f 0300 	mov.w	r3, #0
    be9c:	f04f 020a 	mov.w	r2, #10
    bea0:	4620      	mov	r0, r4
    bea2:	d012      	beq.n	beca <_dtoa_r+0x7f2>
    bea4:	f7fd f836 	bl	8f14 <__multadd>
    bea8:	4641      	mov	r1, r8
    beaa:	4606      	mov	r6, r0
    beac:	2300      	movs	r3, #0
    beae:	220a      	movs	r2, #10
    beb0:	4620      	mov	r0, r4
    beb2:	f7fd f82f 	bl	8f14 <__multadd>
    beb6:	464f      	mov	r7, r9
    beb8:	4680      	mov	r8, r0
    beba:	e7a7      	b.n	be0c <_dtoa_r+0x734>
    bebc:	4620      	mov	r0, r4
    bebe:	9302      	str	r3, [sp, #8]
    bec0:	f7fd f81e 	bl	8f00 <_Bfree>
    bec4:	9b02      	ldr	r3, [sp, #8]
    bec6:	2201      	movs	r2, #1
    bec8:	e7c6      	b.n	be58 <_dtoa_r+0x780>
    beca:	f7fd f823 	bl	8f14 <__multadd>
    bece:	464f      	mov	r7, r9
    bed0:	4606      	mov	r6, r0
    bed2:	4680      	mov	r8, r0
    bed4:	e79a      	b.n	be0c <_dtoa_r+0x734>
    bed6:	9b01      	ldr	r3, [sp, #4]
    bed8:	2b02      	cmp	r3, #2
    beda:	dc71      	bgt.n	bfc0 <_dtoa_r+0x8e8>
    bedc:	9b07      	ldr	r3, [sp, #28]
    bede:	2b00      	cmp	r3, #0
    bee0:	f47f af7b 	bne.w	bdda <_dtoa_r+0x702>
    bee4:	9b04      	ldr	r3, [sp, #16]
    bee6:	4651      	mov	r1, sl
    bee8:	3301      	adds	r3, #1
    beea:	4628      	mov	r0, r5
    beec:	9304      	str	r3, [sp, #16]
    beee:	f7ff fb5f 	bl	b5b0 <quorem>
    bef2:	f8dd b000 	ldr.w	fp, [sp]
    bef6:	f100 0330 	add.w	r3, r0, #48	; 0x30
    befa:	f80b 3b01 	strb.w	r3, [fp], #1
    befe:	2700      	movs	r7, #0
    bf00:	e6eb      	b.n	bcda <_dtoa_r+0x602>
    bf02:	4651      	mov	r1, sl
    bf04:	4628      	mov	r0, r5
    bf06:	f7fd fa5b 	bl	93c0 <__mcmp>
    bf0a:	2800      	cmp	r0, #0
    bf0c:	f6bf aeba 	bge.w	bc84 <_dtoa_r+0x5ac>
    bf10:	4629      	mov	r1, r5
    bf12:	2300      	movs	r3, #0
    bf14:	220a      	movs	r2, #10
    bf16:	4620      	mov	r0, r4
    bf18:	f7fc fffc 	bl	8f14 <__multadd>
    bf1c:	9b04      	ldr	r3, [sp, #16]
    bf1e:	1e5f      	subs	r7, r3, #1
    bf20:	9b07      	ldr	r3, [sp, #28]
    bf22:	4605      	mov	r5, r0
    bf24:	2b00      	cmp	r3, #0
    bf26:	f47f af4b 	bne.w	bdc0 <_dtoa_r+0x6e8>
    bf2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bf2c:	2b00      	cmp	r3, #0
    bf2e:	f340 8218 	ble.w	c362 <_dtoa_r+0xc8a>
    bf32:	4699      	mov	r9, r3
    bf34:	e6b1      	b.n	bc9a <_dtoa_r+0x5c2>
    bf36:	4bbc      	ldr	r3, [pc, #752]	; (c228 <_dtoa_r+0xb50>)
    bf38:	9300      	str	r3, [sp, #0]
    bf3a:	3303      	adds	r3, #3
    bf3c:	e4a4      	b.n	b888 <_dtoa_r+0x1b0>
    bf3e:	201c      	movs	r0, #28
    bf40:	e712      	b.n	bd68 <_dtoa_r+0x690>
    bf42:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    bf46:	2800      	cmp	r0, #0
    bf48:	f47f ae74 	bne.w	bc34 <_dtoa_r+0x55c>
    bf4c:	f3c1 0213 	ubfx	r2, r1, #0, #20
    bf50:	2a00      	cmp	r2, #0
    bf52:	f000 80f4 	beq.w	c13e <_dtoa_r+0xa66>
    bf56:	9b02      	ldr	r3, [sp, #8]
    bf58:	9308      	str	r3, [sp, #32]
    bf5a:	e66d      	b.n	bc38 <_dtoa_r+0x560>
    bf5c:	2301      	movs	r3, #1
    bf5e:	9307      	str	r3, [sp, #28]
    bf60:	9b04      	ldr	r3, [sp, #16]
    bf62:	445b      	add	r3, fp
    bf64:	f103 0901 	add.w	r9, r3, #1
    bf68:	f1b9 0f01 	cmp.w	r9, #1
    bf6c:	46cc      	mov	ip, r9
    bf6e:	930b      	str	r3, [sp, #44]	; 0x2c
    bf70:	bfb8      	it	lt
    bf72:	f04f 0c01 	movlt.w	ip, #1
    bf76:	2100      	movs	r1, #0
    bf78:	f1bc 0f17 	cmp.w	ip, #23
    bf7c:	63e1      	str	r1, [r4, #60]	; 0x3c
    bf7e:	f77f acbc 	ble.w	b8fa <_dtoa_r+0x222>
    bf82:	2001      	movs	r0, #1
    bf84:	2204      	movs	r2, #4
    bf86:	0052      	lsls	r2, r2, #1
    bf88:	f102 0314 	add.w	r3, r2, #20
    bf8c:	4563      	cmp	r3, ip
    bf8e:	4601      	mov	r1, r0
    bf90:	f100 0001 	add.w	r0, r0, #1
    bf94:	d9f7      	bls.n	bf86 <_dtoa_r+0x8ae>
    bf96:	63e1      	str	r1, [r4, #60]	; 0x3c
    bf98:	e4af      	b.n	b8fa <_dtoa_r+0x222>
    bf9a:	2301      	movs	r3, #1
    bf9c:	9307      	str	r3, [sp, #28]
    bf9e:	f1bb 0f00 	cmp.w	fp, #0
    bfa2:	dd52      	ble.n	c04a <_dtoa_r+0x972>
    bfa4:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
    bfa8:	46d9      	mov	r9, fp
    bfaa:	46dc      	mov	ip, fp
    bfac:	e7e3      	b.n	bf76 <_dtoa_r+0x89e>
    bfae:	2300      	movs	r3, #0
    bfb0:	9307      	str	r3, [sp, #28]
    bfb2:	e7d5      	b.n	bf60 <_dtoa_r+0x888>
    bfb4:	2300      	movs	r3, #0
    bfb6:	9307      	str	r3, [sp, #28]
    bfb8:	e7f1      	b.n	bf9e <_dtoa_r+0x8c6>
    bfba:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    bfbe:	9704      	str	r7, [sp, #16]
    bfc0:	f1b9 0f00 	cmp.w	r9, #0
    bfc4:	f47f ada1 	bne.w	bb0a <_dtoa_r+0x432>
    bfc8:	4651      	mov	r1, sl
    bfca:	464b      	mov	r3, r9
    bfcc:	2205      	movs	r2, #5
    bfce:	4620      	mov	r0, r4
    bfd0:	f7fc ffa0 	bl	8f14 <__multadd>
    bfd4:	4601      	mov	r1, r0
    bfd6:	4682      	mov	sl, r0
    bfd8:	4628      	mov	r0, r5
    bfda:	f7fd f9f1 	bl	93c0 <__mcmp>
    bfde:	2800      	cmp	r0, #0
    bfe0:	f77f ad93 	ble.w	bb0a <_dtoa_r+0x432>
    bfe4:	9b04      	ldr	r3, [sp, #16]
    bfe6:	f103 0b01 	add.w	fp, r3, #1
    bfea:	9b00      	ldr	r3, [sp, #0]
    bfec:	2231      	movs	r2, #49	; 0x31
    bfee:	4698      	mov	r8, r3
    bff0:	f803 2b01 	strb.w	r2, [r3], #1
    bff4:	9300      	str	r3, [sp, #0]
    bff6:	4651      	mov	r1, sl
    bff8:	4620      	mov	r0, r4
    bffa:	f7fc ff81 	bl	8f00 <_Bfree>
    bffe:	f10b 0301 	add.w	r3, fp, #1
    c002:	f8dd 9000 	ldr.w	r9, [sp]
    c006:	9304      	str	r3, [sp, #16]
    c008:	f8cd 8000 	str.w	r8, [sp]
    c00c:	2e00      	cmp	r6, #0
    c00e:	f47f ae8f 	bne.w	bd30 <_dtoa_r+0x658>
    c012:	e691      	b.n	bd38 <_dtoa_r+0x660>
    c014:	eba3 0a0a 	sub.w	sl, r3, sl
    c018:	e5c5      	b.n	bba6 <_dtoa_r+0x4ce>
    c01a:	4631      	mov	r1, r6
    c01c:	4652      	mov	r2, sl
    c01e:	4620      	mov	r0, r4
    c020:	f7fd f8f6 	bl	9210 <__pow5mult>
    c024:	462a      	mov	r2, r5
    c026:	4601      	mov	r1, r0
    c028:	4606      	mov	r6, r0
    c02a:	4620      	mov	r0, r4
    c02c:	f7fd f842 	bl	90b4 <__multiply>
    c030:	4629      	mov	r1, r5
    c032:	4605      	mov	r5, r0
    c034:	4620      	mov	r0, r4
    c036:	f7fc ff63 	bl	8f00 <_Bfree>
    c03a:	e5ea      	b.n	bc12 <_dtoa_r+0x53a>
    c03c:	2002      	movs	r0, #2
    c03e:	eeb0 5b48 	vmov.f64	d5, d8
    c042:	e481      	b.n	b948 <_dtoa_r+0x270>
    c044:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    c048:	e68e      	b.n	bd68 <_dtoa_r+0x690>
    c04a:	f04f 0b01 	mov.w	fp, #1
    c04e:	46d9      	mov	r9, fp
    c050:	e44f      	b.n	b8f2 <_dtoa_r+0x21a>
    c052:	d103      	bne.n	c05c <_dtoa_r+0x984>
    c054:	9b01      	ldr	r3, [sp, #4]
    c056:	07db      	lsls	r3, r3, #31
    c058:	f53f ae4c 	bmi.w	bcf4 <_dtoa_r+0x61c>
    c05c:	46d9      	mov	r9, fp
    c05e:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    c062:	2b30      	cmp	r3, #48	; 0x30
    c064:	d0fa      	beq.n	c05c <_dtoa_r+0x984>
    c066:	e657      	b.n	bd18 <_dtoa_r+0x640>
    c068:	9b04      	ldr	r3, [sp, #16]
    c06a:	9a00      	ldr	r2, [sp, #0]
    c06c:	3301      	adds	r3, #1
    c06e:	9304      	str	r3, [sp, #16]
    c070:	2331      	movs	r3, #49	; 0x31
    c072:	7013      	strb	r3, [r2, #0]
    c074:	e650      	b.n	bd18 <_dtoa_r+0x640>
    c076:	f1ba 0f00 	cmp.w	sl, #0
    c07a:	f000 8123 	beq.w	c2c4 <_dtoa_r+0xbec>
    c07e:	f202 4233 	addw	r2, r2, #1075	; 0x433
    c082:	9b06      	ldr	r3, [sp, #24]
    c084:	9309      	str	r3, [sp, #36]	; 0x24
    c086:	4413      	add	r3, r2
    c088:	f8dd a020 	ldr.w	sl, [sp, #32]
    c08c:	9306      	str	r3, [sp, #24]
    c08e:	4490      	add	r8, r2
    c090:	e592      	b.n	bbb8 <_dtoa_r+0x4e0>
    c092:	ee07 0a90 	vmov	s15, r0
    c096:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
    c09a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    c09e:	eea6 5b07 	vfma.f64	d5, d6, d7
    c0a2:	ee15 2a90 	vmov	r2, s11
    c0a6:	ec51 0b15 	vmov	r0, r1, d5
    c0aa:	f1a2 7150 	sub.w	r1, r2, #54525952	; 0x3400000
    c0ae:	ec41 0b15 	vmov	d5, r0, r1
    c0b2:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    c0b6:	ee36 7b47 	vsub.f64	d7, d6, d7
    c0ba:	eeb4 7bc5 	vcmpe.f64	d7, d5
    c0be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c0c2:	f300 8137 	bgt.w	c334 <_dtoa_r+0xc5c>
    c0c6:	eeb1 5b45 	vneg.f64	d5, d5
    c0ca:	eeb4 7bc5 	vcmpe.f64	d7, d5
    c0ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c0d2:	f57f acfb 	bpl.w	bacc <_dtoa_r+0x3f4>
    c0d6:	f04f 0a00 	mov.w	sl, #0
    c0da:	4656      	mov	r6, sl
    c0dc:	e515      	b.n	bb0a <_dtoa_r+0x432>
    c0de:	f000 80f5 	beq.w	c2cc <_dtoa_r+0xbf4>
    c0e2:	9b04      	ldr	r3, [sp, #16]
    c0e4:	4951      	ldr	r1, [pc, #324]	; (c22c <_dtoa_r+0xb54>)
    c0e6:	425a      	negs	r2, r3
    c0e8:	f002 000f 	and.w	r0, r2, #15
    c0ec:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
    c0f0:	ed91 6b00 	vldr	d6, [r1]
    c0f4:	1112      	asrs	r2, r2, #4
    c0f6:	ee28 6b06 	vmul.f64	d6, d8, d6
    c0fa:	f000 8142 	beq.w	c382 <_dtoa_r+0xcaa>
    c0fe:	eeb0 7b46 	vmov.f64	d7, d6
    c102:	494b      	ldr	r1, [pc, #300]	; (c230 <_dtoa_r+0xb58>)
    c104:	2600      	movs	r6, #0
    c106:	2002      	movs	r0, #2
    c108:	07d3      	lsls	r3, r2, #31
    c10a:	d505      	bpl.n	c118 <_dtoa_r+0xa40>
    c10c:	ed91 5b00 	vldr	d5, [r1]
    c110:	3001      	adds	r0, #1
    c112:	2601      	movs	r6, #1
    c114:	ee27 7b05 	vmul.f64	d7, d7, d5
    c118:	1052      	asrs	r2, r2, #1
    c11a:	f101 0108 	add.w	r1, r1, #8
    c11e:	d1f3      	bne.n	c108 <_dtoa_r+0xa30>
    c120:	2e00      	cmp	r6, #0
    c122:	fe06 6b07 	vseleq.f64	d6, d6, d7
    c126:	e41e      	b.n	b966 <_dtoa_r+0x28e>
    c128:	9b02      	ldr	r3, [sp, #8]
    c12a:	2b00      	cmp	r3, #0
    c12c:	f47f ae37 	bne.w	bd9e <_dtoa_r+0x6c6>
    c130:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    c134:	f3c1 0213 	ubfx	r2, r1, #0, #20
    c138:	2a00      	cmp	r2, #0
    c13a:	f040 8137 	bne.w	c3ac <_dtoa_r+0xcd4>
    c13e:	4a3d      	ldr	r2, [pc, #244]	; (c234 <_dtoa_r+0xb5c>)
    c140:	400a      	ands	r2, r1
    c142:	2a00      	cmp	r2, #0
    c144:	f000 80fa 	beq.w	c33c <_dtoa_r+0xc64>
    c148:	9b06      	ldr	r3, [sp, #24]
    c14a:	3301      	adds	r3, #1
    c14c:	9306      	str	r3, [sp, #24]
    c14e:	2301      	movs	r3, #1
    c150:	f108 0801 	add.w	r8, r8, #1
    c154:	9308      	str	r3, [sp, #32]
    c156:	e56f      	b.n	bc38 <_dtoa_r+0x560>
    c158:	4629      	mov	r1, r5
    c15a:	9a08      	ldr	r2, [sp, #32]
    c15c:	4620      	mov	r0, r4
    c15e:	f7fd f857 	bl	9210 <__pow5mult>
    c162:	4605      	mov	r5, r0
    c164:	e55a      	b.n	bc1c <_dtoa_r+0x544>
    c166:	2a00      	cmp	r2, #0
    c168:	dd12      	ble.n	c190 <_dtoa_r+0xab8>
    c16a:	4629      	mov	r1, r5
    c16c:	2201      	movs	r2, #1
    c16e:	4620      	mov	r0, r4
    c170:	9301      	str	r3, [sp, #4]
    c172:	f7fd f8ad 	bl	92d0 <__lshift>
    c176:	4651      	mov	r1, sl
    c178:	4605      	mov	r5, r0
    c17a:	f7fd f921 	bl	93c0 <__mcmp>
    c17e:	2800      	cmp	r0, #0
    c180:	9b01      	ldr	r3, [sp, #4]
    c182:	f340 80e1 	ble.w	c348 <_dtoa_r+0xc70>
    c186:	2b39      	cmp	r3, #57	; 0x39
    c188:	f000 80ca 	beq.w	c320 <_dtoa_r+0xc48>
    c18c:	f10b 0331 	add.w	r3, fp, #49	; 0x31
    c190:	46b9      	mov	r9, r7
    c192:	f809 3b01 	strb.w	r3, [r9], #1
    c196:	9b04      	ldr	r3, [sp, #16]
    c198:	3301      	adds	r3, #1
    c19a:	4637      	mov	r7, r6
    c19c:	9304      	str	r3, [sp, #16]
    c19e:	4646      	mov	r6, r8
    c1a0:	e5ba      	b.n	bd18 <_dtoa_r+0x640>
    c1a2:	ee38 8b08 	vadd.f64	d8, d8, d8
    c1a6:	eeb4 8bc6 	vcmpe.f64	d8, d6
    c1aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c1ae:	dc0a      	bgt.n	c1c6 <_dtoa_r+0xaee>
    c1b0:	eeb4 8b46 	vcmp.f64	d8, d6
    c1b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c1b8:	f47f acdc 	bne.w	bb74 <_dtoa_r+0x49c>
    c1bc:	ee17 3a10 	vmov	r3, s14
    c1c0:	07d8      	lsls	r0, r3, #31
    c1c2:	f57f acd7 	bpl.w	bb74 <_dtoa_r+0x49c>
    c1c6:	9a00      	ldr	r2, [sp, #0]
    c1c8:	e454      	b.n	ba74 <_dtoa_r+0x39c>
    c1ca:	6871      	ldr	r1, [r6, #4]
    c1cc:	4620      	mov	r0, r4
    c1ce:	f7fc fe71 	bl	8eb4 <_Balloc>
    c1d2:	4607      	mov	r7, r0
    c1d4:	2800      	cmp	r0, #0
    c1d6:	f000 80de 	beq.w	c396 <_dtoa_r+0xcbe>
    c1da:	6933      	ldr	r3, [r6, #16]
    c1dc:	3302      	adds	r3, #2
    c1de:	009a      	lsls	r2, r3, #2
    c1e0:	f106 010c 	add.w	r1, r6, #12
    c1e4:	300c      	adds	r0, #12
    c1e6:	f7fa f869 	bl	62bc <memcpy>
    c1ea:	4639      	mov	r1, r7
    c1ec:	2201      	movs	r2, #1
    c1ee:	4620      	mov	r0, r4
    c1f0:	f7fd f86e 	bl	92d0 <__lshift>
    c1f4:	4680      	mov	r8, r0
    c1f6:	e5fe      	b.n	bdf6 <_dtoa_r+0x71e>
    c1f8:	9b06      	ldr	r3, [sp, #24]
    c1fa:	eba3 0309 	sub.w	r3, r3, r9
    c1fe:	9309      	str	r3, [sp, #36]	; 0x24
    c200:	e4da      	b.n	bbb8 <_dtoa_r+0x4e0>
    c202:	2b39      	cmp	r3, #57	; 0x39
    c204:	f000 808c 	beq.w	c320 <_dtoa_r+0xc48>
    c208:	46b9      	mov	r9, r7
    c20a:	3301      	adds	r3, #1
    c20c:	e7c1      	b.n	c192 <_dtoa_r+0xaba>
    c20e:	9a04      	ldr	r2, [sp, #16]
    c210:	3201      	adds	r2, #1
    c212:	4637      	mov	r7, r6
    c214:	9204      	str	r2, [sp, #16]
    c216:	4646      	mov	r6, r8
    c218:	e55f      	b.n	bcda <_dtoa_r+0x602>
    c21a:	4629      	mov	r1, r5
    c21c:	4620      	mov	r0, r4
    c21e:	f7fc fff7 	bl	9210 <__pow5mult>
    c222:	4605      	mov	r5, r0
    c224:	e4fa      	b.n	bc1c <_dtoa_r+0x544>
    c226:	bf00      	nop
    c228:	20000abc 	.word	0x20000abc
    c22c:	200002a8 	.word	0x200002a8
    c230:	20000280 	.word	0x20000280
    c234:	7ff00000 	.word	0x7ff00000
    c238:	4b5e      	ldr	r3, [pc, #376]	; (c3b4 <_dtoa_r+0xcdc>)
    c23a:	eefd 5bc6 	vcvt.s32.f64	s11, d6
    c23e:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
    c242:	ed1c 3b02 	vldr	d3, [ip, #-8]
    c246:	eeb8 7be5 	vcvt.f64.s32	d7, s11
    c24a:	ee36 7b47 	vsub.f64	d7, d6, d7
    c24e:	ec41 0b16 	vmov	d6, r0, r1
    c252:	ee15 1a90 	vmov	r1, s11
    c256:	ee23 3b06 	vmul.f64	d3, d3, d6
    c25a:	9800      	ldr	r0, [sp, #0]
    c25c:	3130      	adds	r1, #48	; 0x30
    c25e:	2a01      	cmp	r2, #1
    c260:	f800 1b01 	strb.w	r1, [r0], #1
    c264:	f000 8083 	beq.w	c36e <_dtoa_r+0xc96>
    c268:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    c26c:	9b00      	ldr	r3, [sp, #0]
    c26e:	1899      	adds	r1, r3, r2
    c270:	ee27 7b04 	vmul.f64	d7, d7, d4
    c274:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    c278:	ee16 3a90 	vmov	r3, s13
    c27c:	3330      	adds	r3, #48	; 0x30
    c27e:	f800 3b01 	strb.w	r3, [r0], #1
    c282:	4281      	cmp	r1, r0
    c284:	eeb8 5be6 	vcvt.f64.s32	d5, s13
    c288:	ee37 7b45 	vsub.f64	d7, d7, d5
    c28c:	d1f0      	bne.n	c270 <_dtoa_r+0xb98>
    c28e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    c292:	ee33 5b06 	vadd.f64	d5, d3, d6
    c296:	eeb4 5bc7 	vcmpe.f64	d5, d7
    c29a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c29e:	f53f abe3 	bmi.w	ba68 <_dtoa_r+0x390>
    c2a2:	ee36 6b43 	vsub.f64	d6, d6, d3
    c2a6:	eeb4 6bc7 	vcmpe.f64	d6, d7
    c2aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c2ae:	f77f ac0d 	ble.w	bacc <_dtoa_r+0x3f4>
    c2b2:	4689      	mov	r9, r1
    c2b4:	3901      	subs	r1, #1
    c2b6:	f819 3c01 	ldrb.w	r3, [r9, #-1]
    c2ba:	2b30      	cmp	r3, #48	; 0x30
    c2bc:	d0f9      	beq.n	c2b2 <_dtoa_r+0xbda>
    c2be:	1c73      	adds	r3, r6, #1
    c2c0:	9304      	str	r3, [sp, #16]
    c2c2:	e539      	b.n	bd38 <_dtoa_r+0x660>
    c2c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c2c6:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
    c2ca:	e6da      	b.n	c082 <_dtoa_r+0x9aa>
    c2cc:	2002      	movs	r0, #2
    c2ce:	eeb0 6b48 	vmov.f64	d6, d8
    c2d2:	f7ff bb48 	b.w	b966 <_dtoa_r+0x28e>
    c2d6:	f1b9 0f00 	cmp.w	r9, #0
    c2da:	f43f aeda 	beq.w	c092 <_dtoa_r+0x9ba>
    c2de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c2e0:	2a00      	cmp	r2, #0
    c2e2:	f77f abf3 	ble.w	bacc <_dtoa_r+0x3f4>
    c2e6:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    c2ea:	ee26 6b04 	vmul.f64	d6, d6, d4
    c2ee:	3001      	adds	r0, #1
    c2f0:	ee07 0a90 	vmov	s15, r0
    c2f4:	9b04      	ldr	r3, [sp, #16]
    c2f6:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    c2fa:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    c2fe:	eea6 7b05 	vfma.f64	d7, d6, d5
    c302:	ee17 ca90 	vmov	ip, s15
    c306:	ec51 0b17 	vmov	r0, r1, d7
    c30a:	1e5e      	subs	r6, r3, #1
    c30c:	f1ac 7150 	sub.w	r1, ip, #54525952	; 0x3400000
    c310:	f7ff bb47 	b.w	b9a2 <_dtoa_r+0x2ca>
    c314:	9b04      	ldr	r3, [sp, #16]
    c316:	3301      	adds	r3, #1
    c318:	9304      	str	r3, [sp, #16]
    c31a:	2331      	movs	r3, #49	; 0x31
    c31c:	f7ff bbb1 	b.w	ba82 <_dtoa_r+0x3aa>
    c320:	9b04      	ldr	r3, [sp, #16]
    c322:	46bb      	mov	fp, r7
    c324:	3301      	adds	r3, #1
    c326:	9304      	str	r3, [sp, #16]
    c328:	2339      	movs	r3, #57	; 0x39
    c32a:	4637      	mov	r7, r6
    c32c:	f80b 3b01 	strb.w	r3, [fp], #1
    c330:	4646      	mov	r6, r8
    c332:	e4e1      	b.n	bcf8 <_dtoa_r+0x620>
    c334:	f04f 0a00 	mov.w	sl, #0
    c338:	4656      	mov	r6, sl
    c33a:	e653      	b.n	bfe4 <_dtoa_r+0x90c>
    c33c:	9208      	str	r2, [sp, #32]
    c33e:	e47b      	b.n	bc38 <_dtoa_r+0x560>
    c340:	1c73      	adds	r3, r6, #1
    c342:	9304      	str	r3, [sp, #16]
    c344:	4689      	mov	r9, r1
    c346:	e4f7      	b.n	bd38 <_dtoa_r+0x660>
    c348:	f47f af22 	bne.w	c190 <_dtoa_r+0xab8>
    c34c:	07da      	lsls	r2, r3, #31
    c34e:	f57f af1f 	bpl.w	c190 <_dtoa_r+0xab8>
    c352:	e718      	b.n	c186 <_dtoa_r+0xaae>
    c354:	2b39      	cmp	r3, #57	; 0x39
    c356:	d0e3      	beq.n	c320 <_dtoa_r+0xc48>
    c358:	f1b9 0f00 	cmp.w	r9, #0
    c35c:	f73f af16 	bgt.w	c18c <_dtoa_r+0xab4>
    c360:	e716      	b.n	c190 <_dtoa_r+0xab8>
    c362:	9b01      	ldr	r3, [sp, #4]
    c364:	2b02      	cmp	r3, #2
    c366:	f73f ae28 	bgt.w	bfba <_dtoa_r+0x8e2>
    c36a:	9704      	str	r7, [sp, #16]
    c36c:	e5ba      	b.n	bee4 <_dtoa_r+0x80c>
    c36e:	4601      	mov	r1, r0
    c370:	e78d      	b.n	c28e <_dtoa_r+0xbb6>
    c372:	9b01      	ldr	r3, [sp, #4]
    c374:	2b02      	cmp	r3, #2
    c376:	f73f ae20 	bgt.w	bfba <_dtoa_r+0x8e2>
    c37a:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    c37e:	9704      	str	r7, [sp, #16]
    c380:	e52b      	b.n	bdda <_dtoa_r+0x702>
    c382:	2002      	movs	r0, #2
    c384:	f7ff baef 	b.w	b966 <_dtoa_r+0x28e>
    c388:	4b0b      	ldr	r3, [pc, #44]	; (c3b8 <_dtoa_r+0xce0>)
    c38a:	480c      	ldr	r0, [pc, #48]	; (c3bc <_dtoa_r+0xce4>)
    c38c:	2200      	movs	r2, #0
    c38e:	f240 11af 	movw	r1, #431	; 0x1af
    c392:	f7ff f8b1 	bl	b4f8 <__assert_func>
    c396:	4b08      	ldr	r3, [pc, #32]	; (c3b8 <_dtoa_r+0xce0>)
    c398:	4808      	ldr	r0, [pc, #32]	; (c3bc <_dtoa_r+0xce4>)
    c39a:	463a      	mov	r2, r7
    c39c:	f240 21ef 	movw	r1, #751	; 0x2ef
    c3a0:	f7ff f8aa 	bl	b4f8 <__assert_func>
    c3a4:	4b06      	ldr	r3, [pc, #24]	; (c3c0 <_dtoa_r+0xce8>)
    c3a6:	9300      	str	r3, [sp, #0]
    c3a8:	f7ff b9d2 	b.w	b750 <_dtoa_r+0x78>
    c3ac:	9b02      	ldr	r3, [sp, #8]
    c3ae:	9308      	str	r3, [sp, #32]
    c3b0:	e4f7      	b.n	bda2 <_dtoa_r+0x6ca>
    c3b2:	bf00      	nop
    c3b4:	200002a8 	.word	0x200002a8
    c3b8:	2000093c 	.word	0x2000093c
    c3bc:	20000ac0 	.word	0x20000ac0
    c3c0:	20000ab0 	.word	0x20000ab0

0000c3c4 <_wcrtomb_r>:
    c3c4:	b570      	push	{r4, r5, r6, lr}
    c3c6:	4605      	mov	r5, r0
    c3c8:	b084      	sub	sp, #16
    c3ca:	b15b      	cbz	r3, c3e4 <_wcrtomb_r+0x20>
    c3cc:	461c      	mov	r4, r3
    c3ce:	b169      	cbz	r1, c3ec <_wcrtomb_r+0x28>
    c3d0:	4b0e      	ldr	r3, [pc, #56]	; (c40c <_wcrtomb_r+0x48>)
    c3d2:	4628      	mov	r0, r5
    c3d4:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
    c3d8:	4623      	mov	r3, r4
    c3da:	47b0      	blx	r6
    c3dc:	1c43      	adds	r3, r0, #1
    c3de:	d00f      	beq.n	c400 <_wcrtomb_r+0x3c>
    c3e0:	b004      	add	sp, #16
    c3e2:	bd70      	pop	{r4, r5, r6, pc}
    c3e4:	f500 7482 	add.w	r4, r0, #260	; 0x104
    c3e8:	2900      	cmp	r1, #0
    c3ea:	d1f1      	bne.n	c3d0 <_wcrtomb_r+0xc>
    c3ec:	4a07      	ldr	r2, [pc, #28]	; (c40c <_wcrtomb_r+0x48>)
    c3ee:	4623      	mov	r3, r4
    c3f0:	f8d2 60e0 	ldr.w	r6, [r2, #224]	; 0xe0
    c3f4:	4628      	mov	r0, r5
    c3f6:	460a      	mov	r2, r1
    c3f8:	a901      	add	r1, sp, #4
    c3fa:	47b0      	blx	r6
    c3fc:	1c43      	adds	r3, r0, #1
    c3fe:	d1ef      	bne.n	c3e0 <_wcrtomb_r+0x1c>
    c400:	2200      	movs	r2, #0
    c402:	238a      	movs	r3, #138	; 0x8a
    c404:	6022      	str	r2, [r4, #0]
    c406:	602b      	str	r3, [r5, #0]
    c408:	b004      	add	sp, #16
    c40a:	bd70      	pop	{r4, r5, r6, pc}
    c40c:	200011e4 	.word	0x200011e4

0000c410 <_wcsrtombs_r>:
    c410:	b510      	push	{r4, lr}
    c412:	b082      	sub	sp, #8
    c414:	9c04      	ldr	r4, [sp, #16]
    c416:	e9cd 3400 	strd	r3, r4, [sp]
    c41a:	f04f 33ff 	mov.w	r3, #4294967295
    c41e:	f001 fbc7 	bl	dbb0 <_wcsnrtombs_r>
    c422:	b002      	add	sp, #8
    c424:	bd10      	pop	{r4, pc}
    c426:	bf00      	nop

0000c428 <fiprintf>:
    c428:	b40e      	push	{r1, r2, r3}
    c42a:	b510      	push	{r4, lr}
    c42c:	b083      	sub	sp, #12
    c42e:	ab05      	add	r3, sp, #20
    c430:	4c06      	ldr	r4, [pc, #24]	; (c44c <fiprintf+0x24>)
    c432:	f853 2b04 	ldr.w	r2, [r3], #4
    c436:	9301      	str	r3, [sp, #4]
    c438:	4601      	mov	r1, r0
    c43a:	6820      	ldr	r0, [r4, #0]
    c43c:	f000 f8c4 	bl	c5c8 <_vfiprintf_r>
    c440:	b003      	add	sp, #12
    c442:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c446:	b003      	add	sp, #12
    c448:	4770      	bx	lr
    c44a:	bf00      	nop
    c44c:	2000176c 	.word	0x2000176c

0000c450 <__ssprint_r>:
    c450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c454:	6893      	ldr	r3, [r2, #8]
    c456:	6817      	ldr	r7, [r2, #0]
    c458:	b083      	sub	sp, #12
    c45a:	4692      	mov	sl, r2
    c45c:	2b00      	cmp	r3, #0
    c45e:	d070      	beq.n	c542 <__ssprint_r+0xf2>
    c460:	4681      	mov	r9, r0
    c462:	688a      	ldr	r2, [r1, #8]
    c464:	6808      	ldr	r0, [r1, #0]
    c466:	460c      	mov	r4, r1
    c468:	3708      	adds	r7, #8
    c46a:	e043      	b.n	c4f4 <__ssprint_r+0xa4>
    c46c:	89a3      	ldrh	r3, [r4, #12]
    c46e:	f413 6f90 	tst.w	r3, #1152	; 0x480
    c472:	d02e      	beq.n	c4d2 <__ssprint_r+0x82>
    c474:	e9d4 1604 	ldrd	r1, r6, [r4, #16]
    c478:	eba0 0801 	sub.w	r8, r0, r1
    c47c:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    c480:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
    c484:	f108 0001 	add.w	r0, r8, #1
    c488:	1076      	asrs	r6, r6, #1
    c48a:	4428      	add	r0, r5
    c48c:	42b0      	cmp	r0, r6
    c48e:	4632      	mov	r2, r6
    c490:	bf84      	itt	hi
    c492:	4606      	movhi	r6, r0
    c494:	4632      	movhi	r2, r6
    c496:	055b      	lsls	r3, r3, #21
    c498:	d537      	bpl.n	c50a <__ssprint_r+0xba>
    c49a:	4611      	mov	r1, r2
    c49c:	4648      	mov	r0, r9
    c49e:	f7fb fb51 	bl	7b44 <_malloc_r>
    c4a2:	9001      	str	r0, [sp, #4]
    c4a4:	2800      	cmp	r0, #0
    c4a6:	d03a      	beq.n	c51e <__ssprint_r+0xce>
    c4a8:	4642      	mov	r2, r8
    c4aa:	6921      	ldr	r1, [r4, #16]
    c4ac:	f7f9 ff06 	bl	62bc <memcpy>
    c4b0:	89a2      	ldrh	r2, [r4, #12]
    c4b2:	9b01      	ldr	r3, [sp, #4]
    c4b4:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    c4b8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    c4bc:	81a2      	strh	r2, [r4, #12]
    c4be:	eba6 0208 	sub.w	r2, r6, r8
    c4c2:	eb03 0008 	add.w	r0, r3, r8
    c4c6:	6166      	str	r6, [r4, #20]
    c4c8:	60a2      	str	r2, [r4, #8]
    c4ca:	6123      	str	r3, [r4, #16]
    c4cc:	6020      	str	r0, [r4, #0]
    c4ce:	462e      	mov	r6, r5
    c4d0:	46a8      	mov	r8, r5
    c4d2:	4642      	mov	r2, r8
    c4d4:	4659      	mov	r1, fp
    c4d6:	f7fc f96d 	bl	87b4 <memmove>
    c4da:	f8da 3008 	ldr.w	r3, [sl, #8]
    c4de:	68a2      	ldr	r2, [r4, #8]
    c4e0:	6820      	ldr	r0, [r4, #0]
    c4e2:	1b92      	subs	r2, r2, r6
    c4e4:	4440      	add	r0, r8
    c4e6:	1b5b      	subs	r3, r3, r5
    c4e8:	60a2      	str	r2, [r4, #8]
    c4ea:	6020      	str	r0, [r4, #0]
    c4ec:	f8ca 3008 	str.w	r3, [sl, #8]
    c4f0:	b33b      	cbz	r3, c542 <__ssprint_r+0xf2>
    c4f2:	3708      	adds	r7, #8
    c4f4:	e957 b502 	ldrd	fp, r5, [r7, #-8]
    c4f8:	2d00      	cmp	r5, #0
    c4fa:	d0fa      	beq.n	c4f2 <__ssprint_r+0xa2>
    c4fc:	42aa      	cmp	r2, r5
    c4fe:	4616      	mov	r6, r2
    c500:	4690      	mov	r8, r2
    c502:	d9b3      	bls.n	c46c <__ssprint_r+0x1c>
    c504:	462e      	mov	r6, r5
    c506:	46a8      	mov	r8, r5
    c508:	e7e3      	b.n	c4d2 <__ssprint_r+0x82>
    c50a:	4648      	mov	r0, r9
    c50c:	f7fb fdd6 	bl	80bc <_realloc_r>
    c510:	4603      	mov	r3, r0
    c512:	2800      	cmp	r0, #0
    c514:	d1d3      	bne.n	c4be <__ssprint_r+0x6e>
    c516:	6921      	ldr	r1, [r4, #16]
    c518:	4648      	mov	r0, r9
    c51a:	f7fc fbaf 	bl	8c7c <_free_r>
    c51e:	89a3      	ldrh	r3, [r4, #12]
    c520:	220c      	movs	r2, #12
    c522:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c526:	f8c9 2000 	str.w	r2, [r9]
    c52a:	f04f 30ff 	mov.w	r0, #4294967295
    c52e:	81a3      	strh	r3, [r4, #12]
    c530:	2200      	movs	r2, #0
    c532:	2300      	movs	r3, #0
    c534:	f8ca 2008 	str.w	r2, [sl, #8]
    c538:	f8ca 3004 	str.w	r3, [sl, #4]
    c53c:	b003      	add	sp, #12
    c53e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c542:	2000      	movs	r0, #0
    c544:	2300      	movs	r3, #0
    c546:	f8ca 3004 	str.w	r3, [sl, #4]
    c54a:	b003      	add	sp, #12
    c54c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000c550 <__sprint_r.part.0>:
    c550:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c554:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    c556:	049c      	lsls	r4, r3, #18
    c558:	4690      	mov	r8, r2
    c55a:	d52d      	bpl.n	c5b8 <__sprint_r.part.0+0x68>
    c55c:	6893      	ldr	r3, [r2, #8]
    c55e:	6812      	ldr	r2, [r2, #0]
    c560:	b343      	cbz	r3, c5b4 <__sprint_r.part.0+0x64>
    c562:	468b      	mov	fp, r1
    c564:	4606      	mov	r6, r0
    c566:	f102 0908 	add.w	r9, r2, #8
    c56a:	e959 5a02 	ldrd	r5, sl, [r9, #-8]
    c56e:	ea5f 079a 	movs.w	r7, sl, lsr #2
    c572:	d015      	beq.n	c5a0 <__sprint_r.part.0+0x50>
    c574:	3d04      	subs	r5, #4
    c576:	2400      	movs	r4, #0
    c578:	e001      	b.n	c57e <__sprint_r.part.0+0x2e>
    c57a:	42a7      	cmp	r7, r4
    c57c:	d00e      	beq.n	c59c <__sprint_r.part.0+0x4c>
    c57e:	f855 1f04 	ldr.w	r1, [r5, #4]!
    c582:	465a      	mov	r2, fp
    c584:	4630      	mov	r0, r6
    c586:	f001 fa5b 	bl	da40 <_fputwc_r>
    c58a:	1c43      	adds	r3, r0, #1
    c58c:	f104 0401 	add.w	r4, r4, #1
    c590:	d1f3      	bne.n	c57a <__sprint_r.part.0+0x2a>
    c592:	2300      	movs	r3, #0
    c594:	e9c8 3301 	strd	r3, r3, [r8, #4]
    c598:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c59c:	f8d8 3008 	ldr.w	r3, [r8, #8]
    c5a0:	f02a 0a03 	bic.w	sl, sl, #3
    c5a4:	eba3 030a 	sub.w	r3, r3, sl
    c5a8:	f8c8 3008 	str.w	r3, [r8, #8]
    c5ac:	f109 0908 	add.w	r9, r9, #8
    c5b0:	2b00      	cmp	r3, #0
    c5b2:	d1da      	bne.n	c56a <__sprint_r.part.0+0x1a>
    c5b4:	2000      	movs	r0, #0
    c5b6:	e7ec      	b.n	c592 <__sprint_r.part.0+0x42>
    c5b8:	f001 f80c 	bl	d5d4 <__sfvwrite_r>
    c5bc:	2300      	movs	r3, #0
    c5be:	e9c8 3301 	strd	r3, r3, [r8, #4]
    c5c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c5c6:	bf00      	nop

0000c5c8 <_vfiprintf_r>:
    c5c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c5cc:	ed2d 8b02 	vpush	{d8}
    c5d0:	b0c5      	sub	sp, #276	; 0x114
    c5d2:	f10d 0a50 	add.w	sl, sp, #80	; 0x50
    c5d6:	4683      	mov	fp, r0
    c5d8:	ee08 1a10 	vmov	s16, r1
    c5dc:	4616      	mov	r6, r2
    c5de:	2100      	movs	r1, #0
    c5e0:	2208      	movs	r2, #8
    c5e2:	4650      	mov	r0, sl
    c5e4:	461c      	mov	r4, r3
    c5e6:	9307      	str	r3, [sp, #28]
    c5e8:	f7fc f960 	bl	88ac <memset>
    c5ec:	f1bb 0f00 	cmp.w	fp, #0
    c5f0:	d004      	beq.n	c5fc <_vfiprintf_r+0x34>
    c5f2:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
    c5f6:	2b00      	cmp	r3, #0
    c5f8:	f000 86a0 	beq.w	d33c <_vfiprintf_r+0xd74>
    c5fc:	ee18 2a10 	vmov	r2, s16
    c600:	6e53      	ldr	r3, [r2, #100]	; 0x64
    c602:	07db      	lsls	r3, r3, #31
    c604:	f140 8513 	bpl.w	d02e <_vfiprintf_r+0xa66>
    c608:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
    c60c:	b28a      	uxth	r2, r1
    c60e:	0495      	lsls	r5, r2, #18
    c610:	d40b      	bmi.n	c62a <_vfiprintf_r+0x62>
    c612:	ee18 3a10 	vmov	r3, s16
    c616:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
    c61a:	8199      	strh	r1, [r3, #12]
    c61c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    c61e:	b28a      	uxth	r2, r1
    c620:	ee18 1a10 	vmov	r1, s16
    c624:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    c628:	664b      	str	r3, [r1, #100]	; 0x64
    c62a:	0710      	lsls	r0, r2, #28
    c62c:	f140 8105 	bpl.w	c83a <_vfiprintf_r+0x272>
    c630:	ee18 3a10 	vmov	r3, s16
    c634:	691b      	ldr	r3, [r3, #16]
    c636:	2b00      	cmp	r3, #0
    c638:	f000 80ff 	beq.w	c83a <_vfiprintf_r+0x272>
    c63c:	f002 031a 	and.w	r3, r2, #26
    c640:	2b0a      	cmp	r3, #10
    c642:	f000 810a 	beq.w	c85a <_vfiprintf_r+0x292>
    c646:	2300      	movs	r3, #0
    c648:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
    c64c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
    c650:	aa1b      	add	r2, sp, #108	; 0x6c
    c652:	930c      	str	r3, [sp, #48]	; 0x30
    c654:	9218      	str	r2, [sp, #96]	; 0x60
    c656:	4691      	mov	r9, r2
    c658:	930b      	str	r3, [sp, #44]	; 0x2c
    c65a:	9305      	str	r3, [sp, #20]
    c65c:	46b0      	mov	r8, r6
    c65e:	4644      	mov	r4, r8
    c660:	4ba8      	ldr	r3, [pc, #672]	; (c904 <_vfiprintf_r+0x33c>)
    c662:	f8d3 50e4 	ldr.w	r5, [r3, #228]	; 0xe4
    c666:	f7fc f9a5 	bl	89b4 <__locale_mb_cur_max>
    c66a:	4622      	mov	r2, r4
    c66c:	4603      	mov	r3, r0
    c66e:	a912      	add	r1, sp, #72	; 0x48
    c670:	f8cd a000 	str.w	sl, [sp]
    c674:	4658      	mov	r0, fp
    c676:	47a8      	blx	r5
    c678:	2800      	cmp	r0, #0
    c67a:	f000 8145 	beq.w	c908 <_vfiprintf_r+0x340>
    c67e:	f2c0 8139 	blt.w	c8f4 <_vfiprintf_r+0x32c>
    c682:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c684:	2a25      	cmp	r2, #37	; 0x25
    c686:	4603      	mov	r3, r0
    c688:	d001      	beq.n	c68e <_vfiprintf_r+0xc6>
    c68a:	441c      	add	r4, r3
    c68c:	e7e8      	b.n	c660 <_vfiprintf_r+0x98>
    c68e:	ebb4 0608 	subs.w	r6, r4, r8
    c692:	4605      	mov	r5, r0
    c694:	f040 813c 	bne.w	c910 <_vfiprintf_r+0x348>
    c698:	2300      	movs	r3, #0
    c69a:	7861      	ldrb	r1, [r4, #1]
    c69c:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    c6a0:	f104 0801 	add.w	r8, r4, #1
    c6a4:	9306      	str	r3, [sp, #24]
    c6a6:	f04f 37ff 	mov.w	r7, #4294967295
    c6aa:	461e      	mov	r6, r3
    c6ac:	242b      	movs	r4, #43	; 0x2b
    c6ae:	f108 0801 	add.w	r8, r8, #1
    c6b2:	f1a1 0320 	sub.w	r3, r1, #32
    c6b6:	2b5a      	cmp	r3, #90	; 0x5a
    c6b8:	f200 8178 	bhi.w	c9ac <_vfiprintf_r+0x3e4>
    c6bc:	e8df f013 	tbh	[pc, r3, lsl #1]
    c6c0:	017602b5 	.word	0x017602b5
    c6c4:	02b00176 	.word	0x02b00176
    c6c8:	01760176 	.word	0x01760176
    c6cc:	006a0176 	.word	0x006a0176
    c6d0:	01760176 	.word	0x01760176
    c6d4:	028d027d 	.word	0x028d027d
    c6d8:	02880176 	.word	0x02880176
    c6dc:	01760297 	.word	0x01760297
    c6e0:	005b0292 	.word	0x005b0292
    c6e4:	005b005b 	.word	0x005b005b
    c6e8:	005b005b 	.word	0x005b005b
    c6ec:	005b005b 	.word	0x005b005b
    c6f0:	005b005b 	.word	0x005b005b
    c6f4:	01760176 	.word	0x01760176
    c6f8:	01760176 	.word	0x01760176
    c6fc:	01760176 	.word	0x01760176
    c700:	01760176 	.word	0x01760176
    c704:	025c0176 	.word	0x025c0176
    c708:	01760084 	.word	0x01760084
    c70c:	01760176 	.word	0x01760176
    c710:	01760176 	.word	0x01760176
    c714:	01760176 	.word	0x01760176
    c718:	01760176 	.word	0x01760176
    c71c:	00e80176 	.word	0x00e80176
    c720:	01760176 	.word	0x01760176
    c724:	02330176 	.word	0x02330176
    c728:	02da0176 	.word	0x02da0176
    c72c:	01760176 	.word	0x01760176
    c730:	0176058b 	.word	0x0176058b
    c734:	01760176 	.word	0x01760176
    c738:	01760176 	.word	0x01760176
    c73c:	01760176 	.word	0x01760176
    c740:	01760176 	.word	0x01760176
    c744:	025c0176 	.word	0x025c0176
    c748:	01760086 	.word	0x01760086
    c74c:	01760176 	.word	0x01760176
    c750:	008602cd 	.word	0x008602cd
    c754:	0176007f 	.word	0x0176007f
    c758:	017602c0 	.word	0x017602c0
    c75c:	00ea02fd 	.word	0x00ea02fd
    c760:	007f02ed 	.word	0x007f02ed
    c764:	02330176 	.word	0x02330176
    c768:	0569007c 	.word	0x0569007c
    c76c:	01760176 	.word	0x01760176
    c770:	0176056b 	.word	0x0176056b
    c774:	007c      	.short	0x007c
    c776:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    c77a:	2200      	movs	r2, #0
    c77c:	f818 1b01 	ldrb.w	r1, [r8], #1
    c780:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    c784:	eb03 0242 	add.w	r2, r3, r2, lsl #1
    c788:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    c78c:	2b09      	cmp	r3, #9
    c78e:	d9f5      	bls.n	c77c <_vfiprintf_r+0x1b4>
    c790:	9206      	str	r2, [sp, #24]
    c792:	e78e      	b.n	c6b2 <_vfiprintf_r+0xea>
    c794:	4658      	mov	r0, fp
    c796:	f7fe fe1f 	bl	b3d8 <_localeconv_r>
    c79a:	6843      	ldr	r3, [r0, #4]
    c79c:	930d      	str	r3, [sp, #52]	; 0x34
    c79e:	4618      	mov	r0, r3
    c7a0:	f7fc f9ae 	bl	8b00 <strlen>
    c7a4:	900e      	str	r0, [sp, #56]	; 0x38
    c7a6:	4605      	mov	r5, r0
    c7a8:	4658      	mov	r0, fp
    c7aa:	f7fe fe15 	bl	b3d8 <_localeconv_r>
    c7ae:	6883      	ldr	r3, [r0, #8]
    c7b0:	930b      	str	r3, [sp, #44]	; 0x2c
    c7b2:	2d00      	cmp	r5, #0
    c7b4:	f040 84d6 	bne.w	d164 <_vfiprintf_r+0xb9c>
    c7b8:	f898 1000 	ldrb.w	r1, [r8]
    c7bc:	e777      	b.n	c6ae <_vfiprintf_r+0xe6>
    c7be:	f898 1000 	ldrb.w	r1, [r8]
    c7c2:	f046 0620 	orr.w	r6, r6, #32
    c7c6:	e772      	b.n	c6ae <_vfiprintf_r+0xe6>
    c7c8:	f046 0610 	orr.w	r6, r6, #16
    c7cc:	06b4      	lsls	r4, r6, #26
    c7ce:	f140 818e 	bpl.w	caee <_vfiprintf_r+0x526>
    c7d2:	9b07      	ldr	r3, [sp, #28]
    c7d4:	3307      	adds	r3, #7
    c7d6:	f023 0307 	bic.w	r3, r3, #7
    c7da:	461a      	mov	r2, r3
    c7dc:	6859      	ldr	r1, [r3, #4]
    c7de:	f852 3b08 	ldr.w	r3, [r2], #8
    c7e2:	9207      	str	r2, [sp, #28]
    c7e4:	460a      	mov	r2, r1
    c7e6:	2900      	cmp	r1, #0
    c7e8:	f2c0 8470 	blt.w	d0cc <_vfiprintf_r+0xb04>
    c7ec:	1c79      	adds	r1, r7, #1
    c7ee:	f000 85a2 	beq.w	d336 <_vfiprintf_r+0xd6e>
    c7f2:	f026 0180 	bic.w	r1, r6, #128	; 0x80
    c7f6:	9103      	str	r1, [sp, #12]
    c7f8:	ea53 0102 	orrs.w	r1, r3, r2
    c7fc:	f000 843f 	beq.w	d07e <_vfiprintf_r+0xab6>
    c800:	2b0a      	cmp	r3, #10
    c802:	f172 0100 	sbcs.w	r1, r2, #0
    c806:	f080 8541 	bcs.w	d28c <_vfiprintf_r+0xcc4>
    c80a:	3330      	adds	r3, #48	; 0x30
    c80c:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
    c810:	9e03      	ldr	r6, [sp, #12]
    c812:	2301      	movs	r3, #1
    c814:	9304      	str	r3, [sp, #16]
    c816:	f20d 140f 	addw	r4, sp, #271	; 0x10f
    c81a:	9b04      	ldr	r3, [sp, #16]
    c81c:	42bb      	cmp	r3, r7
    c81e:	bfb8      	it	lt
    c820:	463b      	movlt	r3, r7
    c822:	9303      	str	r3, [sp, #12]
    c824:	2300      	movs	r3, #0
    c826:	9308      	str	r3, [sp, #32]
    c828:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    c82c:	2b00      	cmp	r3, #0
    c82e:	f000 80cb 	beq.w	c9c8 <_vfiprintf_r+0x400>
    c832:	9b03      	ldr	r3, [sp, #12]
    c834:	3301      	adds	r3, #1
    c836:	9303      	str	r3, [sp, #12]
    c838:	e0c6      	b.n	c9c8 <_vfiprintf_r+0x400>
    c83a:	ee18 1a10 	vmov	r1, s16
    c83e:	4658      	mov	r0, fp
    c840:	ee18 5a10 	vmov	r5, s16
    c844:	f001 f840 	bl	d8c8 <__swsetup_r>
    c848:	2800      	cmp	r0, #0
    c84a:	f040 8652 	bne.w	d4f2 <_vfiprintf_r+0xf2a>
    c84e:	89aa      	ldrh	r2, [r5, #12]
    c850:	f002 031a 	and.w	r3, r2, #26
    c854:	2b0a      	cmp	r3, #10
    c856:	f47f aef6 	bne.w	c646 <_vfiprintf_r+0x7e>
    c85a:	ee18 1a10 	vmov	r1, s16
    c85e:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
    c862:	2b00      	cmp	r3, #0
    c864:	f6ff aeef 	blt.w	c646 <_vfiprintf_r+0x7e>
    c868:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    c86a:	07db      	lsls	r3, r3, #31
    c86c:	d402      	bmi.n	c874 <_vfiprintf_r+0x2ac>
    c86e:	0597      	lsls	r7, r2, #22
    c870:	f140 8612 	bpl.w	d498 <_vfiprintf_r+0xed0>
    c874:	ee18 1a10 	vmov	r1, s16
    c878:	4623      	mov	r3, r4
    c87a:	4632      	mov	r2, r6
    c87c:	4658      	mov	r0, fp
    c87e:	f000 fe69 	bl	d554 <__sbprintf>
    c882:	9005      	str	r0, [sp, #20]
    c884:	9805      	ldr	r0, [sp, #20]
    c886:	b045      	add	sp, #276	; 0x114
    c888:	ecbd 8b02 	vpop	{d8}
    c88c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c890:	f046 0610 	orr.w	r6, r6, #16
    c894:	f016 0220 	ands.w	r2, r6, #32
    c898:	f000 8136 	beq.w	cb08 <_vfiprintf_r+0x540>
    c89c:	9b07      	ldr	r3, [sp, #28]
    c89e:	3307      	adds	r3, #7
    c8a0:	f023 0307 	bic.w	r3, r3, #7
    c8a4:	4619      	mov	r1, r3
    c8a6:	685a      	ldr	r2, [r3, #4]
    c8a8:	f851 3b08 	ldr.w	r3, [r1], #8
    c8ac:	9107      	str	r1, [sp, #28]
    c8ae:	f426 6180 	bic.w	r1, r6, #1024	; 0x400
    c8b2:	9103      	str	r1, [sp, #12]
    c8b4:	2100      	movs	r1, #0
    c8b6:	2000      	movs	r0, #0
    c8b8:	f88d 0043 	strb.w	r0, [sp, #67]	; 0x43
    c8bc:	1c78      	adds	r0, r7, #1
    c8be:	f000 8210 	beq.w	cce2 <_vfiprintf_r+0x71a>
    c8c2:	9803      	ldr	r0, [sp, #12]
    c8c4:	f020 0680 	bic.w	r6, r0, #128	; 0x80
    c8c8:	ea53 0002 	orrs.w	r0, r3, r2
    c8cc:	f040 8208 	bne.w	cce0 <_vfiprintf_r+0x718>
    c8d0:	2f00      	cmp	r7, #0
    c8d2:	f040 8538 	bne.w	d346 <_vfiprintf_r+0xd7e>
    c8d6:	2900      	cmp	r1, #0
    c8d8:	f040 83d5 	bne.w	d086 <_vfiprintf_r+0xabe>
    c8dc:	9b03      	ldr	r3, [sp, #12]
    c8de:	f013 0301 	ands.w	r3, r3, #1
    c8e2:	9304      	str	r3, [sp, #16]
    c8e4:	f000 8411 	beq.w	d10a <_vfiprintf_r+0xb42>
    c8e8:	2330      	movs	r3, #48	; 0x30
    c8ea:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
    c8ee:	f20d 140f 	addw	r4, sp, #271	; 0x10f
    c8f2:	e792      	b.n	c81a <_vfiprintf_r+0x252>
    c8f4:	2208      	movs	r2, #8
    c8f6:	2100      	movs	r1, #0
    c8f8:	4650      	mov	r0, sl
    c8fa:	f7fb ffd7 	bl	88ac <memset>
    c8fe:	2301      	movs	r3, #1
    c900:	441c      	add	r4, r3
    c902:	e6ad      	b.n	c660 <_vfiprintf_r+0x98>
    c904:	200011e4 	.word	0x200011e4
    c908:	ebb4 0608 	subs.w	r6, r4, r8
    c90c:	4605      	mov	r5, r0
    c90e:	d01b      	beq.n	c948 <_vfiprintf_r+0x380>
    c910:	9b19      	ldr	r3, [sp, #100]	; 0x64
    c912:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    c914:	3301      	adds	r3, #1
    c916:	4432      	add	r2, r6
    c918:	2b07      	cmp	r3, #7
    c91a:	e9c9 8600 	strd	r8, r6, [r9]
    c91e:	921a      	str	r2, [sp, #104]	; 0x68
    c920:	9319      	str	r3, [sp, #100]	; 0x64
    c922:	dd1c      	ble.n	c95e <_vfiprintf_r+0x396>
    c924:	2a00      	cmp	r2, #0
    c926:	f000 83a6 	beq.w	d076 <_vfiprintf_r+0xaae>
    c92a:	ee18 1a10 	vmov	r1, s16
    c92e:	aa18      	add	r2, sp, #96	; 0x60
    c930:	4658      	mov	r0, fp
    c932:	f7ff fe0d 	bl	c550 <__sprint_r.part.0>
    c936:	bb20      	cbnz	r0, c982 <_vfiprintf_r+0x3ba>
    c938:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    c93c:	9b05      	ldr	r3, [sp, #20]
    c93e:	4433      	add	r3, r6
    c940:	9305      	str	r3, [sp, #20]
    c942:	2d00      	cmp	r5, #0
    c944:	f47f aea8 	bne.w	c698 <_vfiprintf_r+0xd0>
    c948:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    c94a:	2b00      	cmp	r3, #0
    c94c:	f040 85c1 	bne.w	d4d2 <_vfiprintf_r+0xf0a>
    c950:	ee18 3a10 	vmov	r3, s16
    c954:	2200      	movs	r2, #0
    c956:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    c95a:	9219      	str	r2, [sp, #100]	; 0x64
    c95c:	e015      	b.n	c98a <_vfiprintf_r+0x3c2>
    c95e:	f109 0908 	add.w	r9, r9, #8
    c962:	e7eb      	b.n	c93c <_vfiprintf_r+0x374>
    c964:	ee18 1a10 	vmov	r1, s16
    c968:	aa18      	add	r2, sp, #96	; 0x60
    c96a:	4658      	mov	r0, fp
    c96c:	f7ff fdf0 	bl	c550 <__sprint_r.part.0>
    c970:	2800      	cmp	r0, #0
    c972:	f000 80a6 	beq.w	cac2 <_vfiprintf_r+0x4fa>
    c976:	9b08      	ldr	r3, [sp, #32]
    c978:	b11b      	cbz	r3, c982 <_vfiprintf_r+0x3ba>
    c97a:	9908      	ldr	r1, [sp, #32]
    c97c:	4658      	mov	r0, fp
    c97e:	f7fc f97d 	bl	8c7c <_free_r>
    c982:	ee18 3a10 	vmov	r3, s16
    c986:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    c98a:	ee18 2a10 	vmov	r2, s16
    c98e:	6e52      	ldr	r2, [r2, #100]	; 0x64
    c990:	f012 0f01 	tst.w	r2, #1
    c994:	b29a      	uxth	r2, r3
    c996:	f000 80a0 	beq.w	cada <_vfiprintf_r+0x512>
    c99a:	0650      	lsls	r0, r2, #25
    c99c:	f100 85b2 	bmi.w	d504 <_vfiprintf_r+0xf3c>
    c9a0:	9805      	ldr	r0, [sp, #20]
    c9a2:	b045      	add	sp, #276	; 0x114
    c9a4:	ecbd 8b02 	vpop	{d8}
    c9a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c9ac:	2900      	cmp	r1, #0
    c9ae:	d0cb      	beq.n	c948 <_vfiprintf_r+0x380>
    c9b0:	2300      	movs	r3, #0
    c9b2:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    c9b6:	2301      	movs	r3, #1
    c9b8:	e9cd 3303 	strd	r3, r3, [sp, #12]
    c9bc:	f88d 10ac 	strb.w	r1, [sp, #172]	; 0xac
    c9c0:	ac2b      	add	r4, sp, #172	; 0xac
    c9c2:	2300      	movs	r3, #0
    c9c4:	9308      	str	r3, [sp, #32]
    c9c6:	461f      	mov	r7, r3
    c9c8:	f016 0302 	ands.w	r3, r6, #2
    c9cc:	9309      	str	r3, [sp, #36]	; 0x24
    c9ce:	d002      	beq.n	c9d6 <_vfiprintf_r+0x40e>
    c9d0:	9b03      	ldr	r3, [sp, #12]
    c9d2:	3302      	adds	r3, #2
    c9d4:	9303      	str	r3, [sp, #12]
    c9d6:	f016 0384 	ands.w	r3, r6, #132	; 0x84
    c9da:	930a      	str	r3, [sp, #40]	; 0x28
    c9dc:	d105      	bne.n	c9ea <_vfiprintf_r+0x422>
    c9de:	9b06      	ldr	r3, [sp, #24]
    c9e0:	9a03      	ldr	r2, [sp, #12]
    c9e2:	1a9d      	subs	r5, r3, r2
    c9e4:	2d00      	cmp	r5, #0
    c9e6:	f300 827b 	bgt.w	cee0 <_vfiprintf_r+0x918>
    c9ea:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    c9ee:	1c41      	adds	r1, r0, #1
    c9f0:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
    c9f4:	b182      	cbz	r2, ca18 <_vfiprintf_r+0x450>
    c9f6:	2201      	movs	r2, #1
    c9f8:	3301      	adds	r3, #1
    c9fa:	f8c9 2004 	str.w	r2, [r9, #4]
    c9fe:	2907      	cmp	r1, #7
    ca00:	f10d 0243 	add.w	r2, sp, #67	; 0x43
    ca04:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    ca08:	f8c9 2000 	str.w	r2, [r9]
    ca0c:	f300 824a 	bgt.w	cea4 <_vfiprintf_r+0x8dc>
    ca10:	4608      	mov	r0, r1
    ca12:	f109 0908 	add.w	r9, r9, #8
    ca16:	3101      	adds	r1, #1
    ca18:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ca1a:	b1e2      	cbz	r2, ca56 <_vfiprintf_r+0x48e>
    ca1c:	aa11      	add	r2, sp, #68	; 0x44
    ca1e:	3302      	adds	r3, #2
    ca20:	f8c9 2000 	str.w	r2, [r9]
    ca24:	2907      	cmp	r1, #7
    ca26:	f04f 0202 	mov.w	r2, #2
    ca2a:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    ca2e:	f8c9 2004 	str.w	r2, [r9, #4]
    ca32:	f340 8250 	ble.w	ced6 <_vfiprintf_r+0x90e>
    ca36:	2b00      	cmp	r3, #0
    ca38:	f000 8343 	beq.w	d0c2 <_vfiprintf_r+0xafa>
    ca3c:	ee18 1a10 	vmov	r1, s16
    ca40:	aa18      	add	r2, sp, #96	; 0x60
    ca42:	4658      	mov	r0, fp
    ca44:	f7ff fd84 	bl	c550 <__sprint_r.part.0>
    ca48:	2800      	cmp	r0, #0
    ca4a:	d194      	bne.n	c976 <_vfiprintf_r+0x3ae>
    ca4c:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    ca50:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    ca54:	1c41      	adds	r1, r0, #1
    ca56:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    ca58:	2a80      	cmp	r2, #128	; 0x80
    ca5a:	f000 8184 	beq.w	cd66 <_vfiprintf_r+0x79e>
    ca5e:	9a04      	ldr	r2, [sp, #16]
    ca60:	1abd      	subs	r5, r7, r2
    ca62:	2d00      	cmp	r5, #0
    ca64:	f300 81d7 	bgt.w	ce16 <_vfiprintf_r+0x84e>
    ca68:	9a04      	ldr	r2, [sp, #16]
    ca6a:	f8c9 4000 	str.w	r4, [r9]
    ca6e:	4413      	add	r3, r2
    ca70:	2907      	cmp	r1, #7
    ca72:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    ca76:	f8c9 2004 	str.w	r2, [r9, #4]
    ca7a:	f340 816e 	ble.w	cd5a <_vfiprintf_r+0x792>
    ca7e:	2b00      	cmp	r3, #0
    ca80:	f000 8275 	beq.w	cf6e <_vfiprintf_r+0x9a6>
    ca84:	ee18 1a10 	vmov	r1, s16
    ca88:	aa18      	add	r2, sp, #96	; 0x60
    ca8a:	4658      	mov	r0, fp
    ca8c:	f7ff fd60 	bl	c550 <__sprint_r.part.0>
    ca90:	2800      	cmp	r0, #0
    ca92:	f47f af70 	bne.w	c976 <_vfiprintf_r+0x3ae>
    ca96:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    ca98:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    ca9c:	0775      	lsls	r5, r6, #29
    ca9e:	d505      	bpl.n	caac <_vfiprintf_r+0x4e4>
    caa0:	9a06      	ldr	r2, [sp, #24]
    caa2:	9903      	ldr	r1, [sp, #12]
    caa4:	1a54      	subs	r4, r2, r1
    caa6:	2c00      	cmp	r4, #0
    caa8:	f300 826b 	bgt.w	cf82 <_vfiprintf_r+0x9ba>
    caac:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
    cab0:	9803      	ldr	r0, [sp, #12]
    cab2:	4281      	cmp	r1, r0
    cab4:	bfac      	ite	ge
    cab6:	1852      	addge	r2, r2, r1
    cab8:	1812      	addlt	r2, r2, r0
    caba:	9205      	str	r2, [sp, #20]
    cabc:	2b00      	cmp	r3, #0
    cabe:	f47f af51 	bne.w	c964 <_vfiprintf_r+0x39c>
    cac2:	9908      	ldr	r1, [sp, #32]
    cac4:	2300      	movs	r3, #0
    cac6:	9319      	str	r3, [sp, #100]	; 0x64
    cac8:	2900      	cmp	r1, #0
    caca:	f000 8149 	beq.w	cd60 <_vfiprintf_r+0x798>
    cace:	4658      	mov	r0, fp
    cad0:	f7fc f8d4 	bl	8c7c <_free_r>
    cad4:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cad8:	e5c1      	b.n	c65e <_vfiprintf_r+0x96>
    cada:	059c      	lsls	r4, r3, #22
    cadc:	f53f af5d 	bmi.w	c99a <_vfiprintf_r+0x3d2>
    cae0:	ee18 4a10 	vmov	r4, s16
    cae4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    cae6:	f7fc f801 	bl	8aec <__retarget_lock_release_recursive>
    caea:	89a2      	ldrh	r2, [r4, #12]
    caec:	e755      	b.n	c99a <_vfiprintf_r+0x3d2>
    caee:	06f0      	lsls	r0, r6, #27
    caf0:	9a07      	ldr	r2, [sp, #28]
    caf2:	f100 831f 	bmi.w	d134 <_vfiprintf_r+0xb6c>
    caf6:	0671      	lsls	r1, r6, #25
    caf8:	f140 8319 	bpl.w	d12e <_vfiprintf_r+0xb66>
    cafc:	f932 3b04 	ldrsh.w	r3, [r2], #4
    cb00:	9207      	str	r2, [sp, #28]
    cb02:	17da      	asrs	r2, r3, #31
    cb04:	4611      	mov	r1, r2
    cb06:	e66e      	b.n	c7e6 <_vfiprintf_r+0x21e>
    cb08:	f016 0310 	ands.w	r3, r6, #16
    cb0c:	9907      	ldr	r1, [sp, #28]
    cb0e:	f040 8309 	bne.w	d124 <_vfiprintf_r+0xb5c>
    cb12:	f016 0040 	ands.w	r0, r6, #64	; 0x40
    cb16:	f000 8301 	beq.w	d11c <_vfiprintf_r+0xb54>
    cb1a:	461a      	mov	r2, r3
    cb1c:	f851 3b04 	ldr.w	r3, [r1], #4
    cb20:	9107      	str	r1, [sp, #28]
    cb22:	b29b      	uxth	r3, r3
    cb24:	e6c3      	b.n	c8ae <_vfiprintf_r+0x2e6>
    cb26:	9b07      	ldr	r3, [sp, #28]
    cb28:	461a      	mov	r2, r3
    cb2a:	2300      	movs	r3, #0
    cb2c:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    cb30:	4613      	mov	r3, r2
    cb32:	f853 4b04 	ldr.w	r4, [r3], #4
    cb36:	9303      	str	r3, [sp, #12]
    cb38:	2c00      	cmp	r4, #0
    cb3a:	f000 8412 	beq.w	d362 <_vfiprintf_r+0xd9a>
    cb3e:	2953      	cmp	r1, #83	; 0x53
    cb40:	f000 8365 	beq.w	d20e <_vfiprintf_r+0xc46>
    cb44:	f016 0510 	ands.w	r5, r6, #16
    cb48:	f040 8361 	bne.w	d20e <_vfiprintf_r+0xc46>
    cb4c:	1c7b      	adds	r3, r7, #1
    cb4e:	f000 84b3 	beq.w	d4b8 <_vfiprintf_r+0xef0>
    cb52:	463a      	mov	r2, r7
    cb54:	4629      	mov	r1, r5
    cb56:	4620      	mov	r0, r4
    cb58:	f7fe fc42 	bl	b3e0 <memchr>
    cb5c:	9008      	str	r0, [sp, #32]
    cb5e:	2800      	cmp	r0, #0
    cb60:	f000 849f 	beq.w	d4a2 <_vfiprintf_r+0xeda>
    cb64:	1b03      	subs	r3, r0, r4
    cb66:	9a03      	ldr	r2, [sp, #12]
    cb68:	9304      	str	r3, [sp, #16]
    cb6a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    cb6e:	462f      	mov	r7, r5
    cb70:	9207      	str	r2, [sp, #28]
    cb72:	9303      	str	r3, [sp, #12]
    cb74:	9508      	str	r5, [sp, #32]
    cb76:	e657      	b.n	c828 <_vfiprintf_r+0x260>
    cb78:	2943      	cmp	r1, #67	; 0x43
    cb7a:	d002      	beq.n	cb82 <_vfiprintf_r+0x5ba>
    cb7c:	06f5      	lsls	r5, r6, #27
    cb7e:	f140 832d 	bpl.w	d1dc <_vfiprintf_r+0xc14>
    cb82:	9d07      	ldr	r5, [sp, #28]
    cb84:	2208      	movs	r2, #8
    cb86:	2100      	movs	r1, #0
    cb88:	a816      	add	r0, sp, #88	; 0x58
    cb8a:	ac2b      	add	r4, sp, #172	; 0xac
    cb8c:	f7fb fe8e 	bl	88ac <memset>
    cb90:	ab16      	add	r3, sp, #88	; 0x58
    cb92:	f855 2b04 	ldr.w	r2, [r5], #4
    cb96:	4621      	mov	r1, r4
    cb98:	4658      	mov	r0, fp
    cb9a:	f7ff fc13 	bl	c3c4 <_wcrtomb_r>
    cb9e:	4603      	mov	r3, r0
    cba0:	3301      	adds	r3, #1
    cba2:	9004      	str	r0, [sp, #16]
    cba4:	f000 84b3 	beq.w	d50e <_vfiprintf_r+0xf46>
    cba8:	9b04      	ldr	r3, [sp, #16]
    cbaa:	9507      	str	r5, [sp, #28]
    cbac:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    cbb0:	9303      	str	r3, [sp, #12]
    cbb2:	2300      	movs	r3, #0
    cbb4:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    cbb8:	e703      	b.n	c9c2 <_vfiprintf_r+0x3fa>
    cbba:	9b07      	ldr	r3, [sp, #28]
    cbbc:	f853 2b04 	ldr.w	r2, [r3], #4
    cbc0:	9206      	str	r2, [sp, #24]
    cbc2:	2a00      	cmp	r2, #0
    cbc4:	f280 829c 	bge.w	d100 <_vfiprintf_r+0xb38>
    cbc8:	9a06      	ldr	r2, [sp, #24]
    cbca:	4252      	negs	r2, r2
    cbcc:	e9cd 2306 	strd	r2, r3, [sp, #24]
    cbd0:	f898 1000 	ldrb.w	r1, [r8]
    cbd4:	f046 0604 	orr.w	r6, r6, #4
    cbd8:	e569      	b.n	c6ae <_vfiprintf_r+0xe6>
    cbda:	f898 1000 	ldrb.w	r1, [r8]
    cbde:	f88d 4043 	strb.w	r4, [sp, #67]	; 0x43
    cbe2:	e564      	b.n	c6ae <_vfiprintf_r+0xe6>
    cbe4:	f898 1000 	ldrb.w	r1, [r8]
    cbe8:	f046 0680 	orr.w	r6, r6, #128	; 0x80
    cbec:	e55f      	b.n	c6ae <_vfiprintf_r+0xe6>
    cbee:	4642      	mov	r2, r8
    cbf0:	f812 1b01 	ldrb.w	r1, [r2], #1
    cbf4:	292a      	cmp	r1, #42	; 0x2a
    cbf6:	f000 8496 	beq.w	d526 <_vfiprintf_r+0xf5e>
    cbfa:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    cbfe:	2b09      	cmp	r3, #9
    cc00:	4690      	mov	r8, r2
    cc02:	f04f 0700 	mov.w	r7, #0
    cc06:	f63f ad54 	bhi.w	c6b2 <_vfiprintf_r+0xea>
    cc0a:	f818 1b01 	ldrb.w	r1, [r8], #1
    cc0e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    cc12:	eb03 0747 	add.w	r7, r3, r7, lsl #1
    cc16:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    cc1a:	2b09      	cmp	r3, #9
    cc1c:	d9f5      	bls.n	cc0a <_vfiprintf_r+0x642>
    cc1e:	e548      	b.n	c6b2 <_vfiprintf_r+0xea>
    cc20:	f898 1000 	ldrb.w	r1, [r8]
    cc24:	f046 0601 	orr.w	r6, r6, #1
    cc28:	e541      	b.n	c6ae <_vfiprintf_r+0xe6>
    cc2a:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    cc2e:	2b00      	cmp	r3, #0
    cc30:	f47f adc2 	bne.w	c7b8 <_vfiprintf_r+0x1f0>
    cc34:	2320      	movs	r3, #32
    cc36:	f898 1000 	ldrb.w	r1, [r8]
    cc3a:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    cc3e:	e536      	b.n	c6ae <_vfiprintf_r+0xe6>
    cc40:	f898 1000 	ldrb.w	r1, [r8]
    cc44:	296c      	cmp	r1, #108	; 0x6c
    cc46:	bf03      	ittte	eq
    cc48:	f898 1001 	ldrbeq.w	r1, [r8, #1]
    cc4c:	f046 0620 	orreq.w	r6, r6, #32
    cc50:	f108 0801 	addeq.w	r8, r8, #1
    cc54:	f046 0610 	orrne.w	r6, r6, #16
    cc58:	e529      	b.n	c6ae <_vfiprintf_r+0xe6>
    cc5a:	f898 1000 	ldrb.w	r1, [r8]
    cc5e:	2968      	cmp	r1, #104	; 0x68
    cc60:	bf03      	ittte	eq
    cc62:	f898 1001 	ldrbeq.w	r1, [r8, #1]
    cc66:	f446 7600 	orreq.w	r6, r6, #512	; 0x200
    cc6a:	f108 0801 	addeq.w	r8, r8, #1
    cc6e:	f046 0640 	orrne.w	r6, r6, #64	; 0x40
    cc72:	e51c      	b.n	c6ae <_vfiprintf_r+0xe6>
    cc74:	f046 0310 	orr.w	r3, r6, #16
    cc78:	9303      	str	r3, [sp, #12]
    cc7a:	9b03      	ldr	r3, [sp, #12]
    cc7c:	f013 0220 	ands.w	r2, r3, #32
    cc80:	f000 8206 	beq.w	d090 <_vfiprintf_r+0xac8>
    cc84:	9b07      	ldr	r3, [sp, #28]
    cc86:	3307      	adds	r3, #7
    cc88:	f023 0307 	bic.w	r3, r3, #7
    cc8c:	4619      	mov	r1, r3
    cc8e:	685a      	ldr	r2, [r3, #4]
    cc90:	f851 3b08 	ldr.w	r3, [r1], #8
    cc94:	9107      	str	r1, [sp, #28]
    cc96:	2101      	movs	r1, #1
    cc98:	e60d      	b.n	c8b6 <_vfiprintf_r+0x2ee>
    cc9a:	9a07      	ldr	r2, [sp, #28]
    cc9c:	f046 0302 	orr.w	r3, r6, #2
    cca0:	9303      	str	r3, [sp, #12]
    cca2:	f852 3b04 	ldr.w	r3, [r2], #4
    cca6:	9207      	str	r2, [sp, #28]
    cca8:	f647 0230 	movw	r2, #30768	; 0x7830
    ccac:	f8ad 2044 	strh.w	r2, [sp, #68]	; 0x44
    ccb0:	4ab8      	ldr	r2, [pc, #736]	; (cf94 <_vfiprintf_r+0x9cc>)
    ccb2:	920c      	str	r2, [sp, #48]	; 0x30
    ccb4:	2102      	movs	r1, #2
    ccb6:	2200      	movs	r2, #0
    ccb8:	e5fd      	b.n	c8b6 <_vfiprintf_r+0x2ee>
    ccba:	06b7      	lsls	r7, r6, #26
    ccbc:	f100 8248 	bmi.w	d150 <_vfiprintf_r+0xb88>
    ccc0:	06f5      	lsls	r5, r6, #27
    ccc2:	f100 8346 	bmi.w	d352 <_vfiprintf_r+0xd8a>
    ccc6:	0674      	lsls	r4, r6, #25
    ccc8:	f100 83d5 	bmi.w	d476 <_vfiprintf_r+0xeae>
    cccc:	05b0      	lsls	r0, r6, #22
    ccce:	f140 8340 	bpl.w	d352 <_vfiprintf_r+0xd8a>
    ccd2:	9b07      	ldr	r3, [sp, #28]
    ccd4:	9905      	ldr	r1, [sp, #20]
    ccd6:	f853 2b04 	ldr.w	r2, [r3], #4
    ccda:	9307      	str	r3, [sp, #28]
    ccdc:	7011      	strb	r1, [r2, #0]
    ccde:	e4be      	b.n	c65e <_vfiprintf_r+0x96>
    cce0:	9603      	str	r6, [sp, #12]
    cce2:	2901      	cmp	r1, #1
    cce4:	f43f ad8c 	beq.w	c800 <_vfiprintf_r+0x238>
    cce8:	2902      	cmp	r1, #2
    ccea:	ac44      	add	r4, sp, #272	; 0x110
    ccec:	d111      	bne.n	cd12 <_vfiprintf_r+0x74a>
    ccee:	980c      	ldr	r0, [sp, #48]	; 0x30
    ccf0:	f003 010f 	and.w	r1, r3, #15
    ccf4:	091b      	lsrs	r3, r3, #4
    ccf6:	5c41      	ldrb	r1, [r0, r1]
    ccf8:	f804 1d01 	strb.w	r1, [r4, #-1]!
    ccfc:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
    cd00:	0912      	lsrs	r2, r2, #4
    cd02:	ea53 0102 	orrs.w	r1, r3, r2
    cd06:	d1f3      	bne.n	ccf0 <_vfiprintf_r+0x728>
    cd08:	9e03      	ldr	r6, [sp, #12]
    cd0a:	ab44      	add	r3, sp, #272	; 0x110
    cd0c:	1b1b      	subs	r3, r3, r4
    cd0e:	9304      	str	r3, [sp, #16]
    cd10:	e583      	b.n	c81a <_vfiprintf_r+0x252>
    cd12:	f003 0107 	and.w	r1, r3, #7
    cd16:	08db      	lsrs	r3, r3, #3
    cd18:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
    cd1c:	08d2      	lsrs	r2, r2, #3
    cd1e:	3130      	adds	r1, #48	; 0x30
    cd20:	ea53 0502 	orrs.w	r5, r3, r2
    cd24:	4620      	mov	r0, r4
    cd26:	f804 1d01 	strb.w	r1, [r4, #-1]!
    cd2a:	d1f2      	bne.n	cd12 <_vfiprintf_r+0x74a>
    cd2c:	9e03      	ldr	r6, [sp, #12]
    cd2e:	07f3      	lsls	r3, r6, #31
    cd30:	d5eb      	bpl.n	cd0a <_vfiprintf_r+0x742>
    cd32:	2930      	cmp	r1, #48	; 0x30
    cd34:	d0e8      	beq.n	cd08 <_vfiprintf_r+0x740>
    cd36:	2330      	movs	r3, #48	; 0x30
    cd38:	3802      	subs	r0, #2
    cd3a:	f804 3c01 	strb.w	r3, [r4, #-1]
    cd3e:	ab44      	add	r3, sp, #272	; 0x110
    cd40:	1a1b      	subs	r3, r3, r0
    cd42:	9e03      	ldr	r6, [sp, #12]
    cd44:	9304      	str	r3, [sp, #16]
    cd46:	4604      	mov	r4, r0
    cd48:	e567      	b.n	c81a <_vfiprintf_r+0x252>
    cd4a:	9b04      	ldr	r3, [sp, #16]
    cd4c:	941b      	str	r4, [sp, #108]	; 0x6c
    cd4e:	2201      	movs	r2, #1
    cd50:	931c      	str	r3, [sp, #112]	; 0x70
    cd52:	931a      	str	r3, [sp, #104]	; 0x68
    cd54:	9219      	str	r2, [sp, #100]	; 0x64
    cd56:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cd5a:	f109 0908 	add.w	r9, r9, #8
    cd5e:	e69d      	b.n	ca9c <_vfiprintf_r+0x4d4>
    cd60:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cd64:	e47b      	b.n	c65e <_vfiprintf_r+0x96>
    cd66:	9a06      	ldr	r2, [sp, #24]
    cd68:	9d03      	ldr	r5, [sp, #12]
    cd6a:	1b55      	subs	r5, r2, r5
    cd6c:	2d00      	cmp	r5, #0
    cd6e:	f77f ae76 	ble.w	ca5e <_vfiprintf_r+0x496>
    cd72:	2d10      	cmp	r5, #16
    cd74:	f340 83bb 	ble.w	d4ee <_vfiprintf_r+0xf26>
    cd78:	9409      	str	r4, [sp, #36]	; 0x24
    cd7a:	ee18 4a10 	vmov	r4, s16
    cd7e:	e007      	b.n	cd90 <_vfiprintf_r+0x7c8>
    cd80:	f100 0c02 	add.w	ip, r0, #2
    cd84:	f109 0908 	add.w	r9, r9, #8
    cd88:	4610      	mov	r0, r2
    cd8a:	3d10      	subs	r5, #16
    cd8c:	2d10      	cmp	r5, #16
    cd8e:	dd1e      	ble.n	cdce <_vfiprintf_r+0x806>
    cd90:	4981      	ldr	r1, [pc, #516]	; (cf98 <_vfiprintf_r+0x9d0>)
    cd92:	f8c9 1000 	str.w	r1, [r9]
    cd96:	1c42      	adds	r2, r0, #1
    cd98:	3310      	adds	r3, #16
    cd9a:	2110      	movs	r1, #16
    cd9c:	2a07      	cmp	r2, #7
    cd9e:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    cda2:	f8c9 1004 	str.w	r1, [r9, #4]
    cda6:	ddeb      	ble.n	cd80 <_vfiprintf_r+0x7b8>
    cda8:	aa18      	add	r2, sp, #96	; 0x60
    cdaa:	2b00      	cmp	r3, #0
    cdac:	d074      	beq.n	ce98 <_vfiprintf_r+0x8d0>
    cdae:	4621      	mov	r1, r4
    cdb0:	4658      	mov	r0, fp
    cdb2:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cdb6:	f7ff fbcb 	bl	c550 <__sprint_r.part.0>
    cdba:	2800      	cmp	r0, #0
    cdbc:	f47f addb 	bne.w	c976 <_vfiprintf_r+0x3ae>
    cdc0:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cdc4:	3d10      	subs	r5, #16
    cdc6:	2d10      	cmp	r5, #16
    cdc8:	f100 0c01 	add.w	ip, r0, #1
    cdcc:	dce0      	bgt.n	cd90 <_vfiprintf_r+0x7c8>
    cdce:	9c09      	ldr	r4, [sp, #36]	; 0x24
    cdd0:	4a71      	ldr	r2, [pc, #452]	; (cf98 <_vfiprintf_r+0x9d0>)
    cdd2:	f8c9 5004 	str.w	r5, [r9, #4]
    cdd6:	442b      	add	r3, r5
    cdd8:	f1bc 0f07 	cmp.w	ip, #7
    cddc:	e9cd c319 	strd	ip, r3, [sp, #100]	; 0x64
    cde0:	f8c9 2000 	str.w	r2, [r9]
    cde4:	f340 8194 	ble.w	d110 <_vfiprintf_r+0xb48>
    cde8:	2b00      	cmp	r3, #0
    cdea:	f000 831f 	beq.w	d42c <_vfiprintf_r+0xe64>
    cdee:	ee18 1a10 	vmov	r1, s16
    cdf2:	aa18      	add	r2, sp, #96	; 0x60
    cdf4:	4658      	mov	r0, fp
    cdf6:	f7ff fbab 	bl	c550 <__sprint_r.part.0>
    cdfa:	2800      	cmp	r0, #0
    cdfc:	f47f adbb 	bne.w	c976 <_vfiprintf_r+0x3ae>
    ce00:	9a04      	ldr	r2, [sp, #16]
    ce02:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    ce06:	1abd      	subs	r5, r7, r2
    ce08:	2d00      	cmp	r5, #0
    ce0a:	f100 0101 	add.w	r1, r0, #1
    ce0e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    ce12:	f77f ae29 	ble.w	ca68 <_vfiprintf_r+0x4a0>
    ce16:	2d10      	cmp	r5, #16
    ce18:	dd29      	ble.n	ce6e <_vfiprintf_r+0x8a6>
    ce1a:	9409      	str	r4, [sp, #36]	; 0x24
    ce1c:	2710      	movs	r7, #16
    ce1e:	ee18 4a10 	vmov	r4, s16
    ce22:	e007      	b.n	ce34 <_vfiprintf_r+0x86c>
    ce24:	f100 0c02 	add.w	ip, r0, #2
    ce28:	f109 0908 	add.w	r9, r9, #8
    ce2c:	4610      	mov	r0, r2
    ce2e:	3d10      	subs	r5, #16
    ce30:	2d10      	cmp	r5, #16
    ce32:	dd1a      	ble.n	ce6a <_vfiprintf_r+0x8a2>
    ce34:	1c42      	adds	r2, r0, #1
    ce36:	4958      	ldr	r1, [pc, #352]	; (cf98 <_vfiprintf_r+0x9d0>)
    ce38:	3310      	adds	r3, #16
    ce3a:	2a07      	cmp	r2, #7
    ce3c:	e9c9 1700 	strd	r1, r7, [r9]
    ce40:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    ce44:	ddee      	ble.n	ce24 <_vfiprintf_r+0x85c>
    ce46:	aa18      	add	r2, sp, #96	; 0x60
    ce48:	b303      	cbz	r3, ce8c <_vfiprintf_r+0x8c4>
    ce4a:	4621      	mov	r1, r4
    ce4c:	4658      	mov	r0, fp
    ce4e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    ce52:	f7ff fb7d 	bl	c550 <__sprint_r.part.0>
    ce56:	2800      	cmp	r0, #0
    ce58:	f47f ad8d 	bne.w	c976 <_vfiprintf_r+0x3ae>
    ce5c:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    ce60:	3d10      	subs	r5, #16
    ce62:	2d10      	cmp	r5, #16
    ce64:	f100 0c01 	add.w	ip, r0, #1
    ce68:	dce4      	bgt.n	ce34 <_vfiprintf_r+0x86c>
    ce6a:	9c09      	ldr	r4, [sp, #36]	; 0x24
    ce6c:	4661      	mov	r1, ip
    ce6e:	4a4a      	ldr	r2, [pc, #296]	; (cf98 <_vfiprintf_r+0x9d0>)
    ce70:	f8c9 5004 	str.w	r5, [r9, #4]
    ce74:	442b      	add	r3, r5
    ce76:	2907      	cmp	r1, #7
    ce78:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    ce7c:	f8c9 2000 	str.w	r2, [r9]
    ce80:	f300 80e7 	bgt.w	d052 <_vfiprintf_r+0xa8a>
    ce84:	f109 0908 	add.w	r9, r9, #8
    ce88:	3101      	adds	r1, #1
    ce8a:	e5ed      	b.n	ca68 <_vfiprintf_r+0x4a0>
    ce8c:	f04f 0c01 	mov.w	ip, #1
    ce90:	4618      	mov	r0, r3
    ce92:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    ce96:	e7ca      	b.n	ce2e <_vfiprintf_r+0x866>
    ce98:	f04f 0c01 	mov.w	ip, #1
    ce9c:	4618      	mov	r0, r3
    ce9e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cea2:	e772      	b.n	cd8a <_vfiprintf_r+0x7c2>
    cea4:	2b00      	cmp	r3, #0
    cea6:	f000 8104 	beq.w	d0b2 <_vfiprintf_r+0xaea>
    ceaa:	ee18 1a10 	vmov	r1, s16
    ceae:	aa18      	add	r2, sp, #96	; 0x60
    ceb0:	4658      	mov	r0, fp
    ceb2:	f7ff fb4d 	bl	c550 <__sprint_r.part.0>
    ceb6:	2800      	cmp	r0, #0
    ceb8:	f47f ad5d 	bne.w	c976 <_vfiprintf_r+0x3ae>
    cebc:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cec0:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cec4:	1c41      	adds	r1, r0, #1
    cec6:	e5a7      	b.n	ca18 <_vfiprintf_r+0x450>
    cec8:	2302      	movs	r3, #2
    ceca:	aa11      	add	r2, sp, #68	; 0x44
    cecc:	931c      	str	r3, [sp, #112]	; 0x70
    cece:	921b      	str	r2, [sp, #108]	; 0x6c
    ced0:	2101      	movs	r1, #1
    ced2:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    ced6:	4608      	mov	r0, r1
    ced8:	f109 0908 	add.w	r9, r9, #8
    cedc:	1c41      	adds	r1, r0, #1
    cede:	e5ba      	b.n	ca56 <_vfiprintf_r+0x48e>
    cee0:	2d10      	cmp	r5, #16
    cee2:	f340 82e5 	ble.w	d4b0 <_vfiprintf_r+0xee8>
    cee6:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
    ceea:	940f      	str	r4, [sp, #60]	; 0x3c
    ceec:	4608      	mov	r0, r1
    ceee:	ee18 4a10 	vmov	r4, s16
    cef2:	e007      	b.n	cf04 <_vfiprintf_r+0x93c>
    cef4:	f100 0c02 	add.w	ip, r0, #2
    cef8:	f109 0908 	add.w	r9, r9, #8
    cefc:	4610      	mov	r0, r2
    cefe:	3d10      	subs	r5, #16
    cf00:	2d10      	cmp	r5, #16
    cf02:	dd1d      	ble.n	cf40 <_vfiprintf_r+0x978>
    cf04:	4925      	ldr	r1, [pc, #148]	; (cf9c <_vfiprintf_r+0x9d4>)
    cf06:	f8c9 1000 	str.w	r1, [r9]
    cf0a:	1c42      	adds	r2, r0, #1
    cf0c:	3310      	adds	r3, #16
    cf0e:	2110      	movs	r1, #16
    cf10:	2a07      	cmp	r2, #7
    cf12:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    cf16:	f8c9 1004 	str.w	r1, [r9, #4]
    cf1a:	ddeb      	ble.n	cef4 <_vfiprintf_r+0x92c>
    cf1c:	aa18      	add	r2, sp, #96	; 0x60
    cf1e:	b303      	cbz	r3, cf62 <_vfiprintf_r+0x99a>
    cf20:	4621      	mov	r1, r4
    cf22:	4658      	mov	r0, fp
    cf24:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cf28:	f7ff fb12 	bl	c550 <__sprint_r.part.0>
    cf2c:	2800      	cmp	r0, #0
    cf2e:	f47f ad22 	bne.w	c976 <_vfiprintf_r+0x3ae>
    cf32:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cf36:	3d10      	subs	r5, #16
    cf38:	2d10      	cmp	r5, #16
    cf3a:	f100 0c01 	add.w	ip, r0, #1
    cf3e:	dce1      	bgt.n	cf04 <_vfiprintf_r+0x93c>
    cf40:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    cf42:	4660      	mov	r0, ip
    cf44:	4a15      	ldr	r2, [pc, #84]	; (cf9c <_vfiprintf_r+0x9d4>)
    cf46:	f8c9 5004 	str.w	r5, [r9, #4]
    cf4a:	442b      	add	r3, r5
    cf4c:	2807      	cmp	r0, #7
    cf4e:	e9cd 0319 	strd	r0, r3, [sp, #100]	; 0x64
    cf52:	f8c9 2000 	str.w	r2, [r9]
    cf56:	f300 80c1 	bgt.w	d0dc <_vfiprintf_r+0xb14>
    cf5a:	f109 0908 	add.w	r9, r9, #8
    cf5e:	1c41      	adds	r1, r0, #1
    cf60:	e546      	b.n	c9f0 <_vfiprintf_r+0x428>
    cf62:	4618      	mov	r0, r3
    cf64:	f04f 0c01 	mov.w	ip, #1
    cf68:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cf6c:	e7c7      	b.n	cefe <_vfiprintf_r+0x936>
    cf6e:	0776      	lsls	r6, r6, #29
    cf70:	9319      	str	r3, [sp, #100]	; 0x64
    cf72:	d553      	bpl.n	d01c <_vfiprintf_r+0xa54>
    cf74:	9a06      	ldr	r2, [sp, #24]
    cf76:	9903      	ldr	r1, [sp, #12]
    cf78:	1a54      	subs	r4, r2, r1
    cf7a:	2c00      	cmp	r4, #0
    cf7c:	dd4e      	ble.n	d01c <_vfiprintf_r+0xa54>
    cf7e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cf82:	2c10      	cmp	r4, #16
    cf84:	f340 82b0 	ble.w	d4e8 <_vfiprintf_r+0xf20>
    cf88:	9919      	ldr	r1, [sp, #100]	; 0x64
    cf8a:	ee18 6a10 	vmov	r6, s16
    cf8e:	2510      	movs	r5, #16
    cf90:	e00d      	b.n	cfae <_vfiprintf_r+0x9e6>
    cf92:	bf00      	nop
    cf94:	20000b2c 	.word	0x20000b2c
    cf98:	20000fd8 	.word	0x20000fd8
    cf9c:	20000b6c 	.word	0x20000b6c
    cfa0:	1c88      	adds	r0, r1, #2
    cfa2:	f109 0908 	add.w	r9, r9, #8
    cfa6:	4611      	mov	r1, r2
    cfa8:	3c10      	subs	r4, #16
    cfaa:	2c10      	cmp	r4, #16
    cfac:	dd1a      	ble.n	cfe4 <_vfiprintf_r+0xa1c>
    cfae:	1c4a      	adds	r2, r1, #1
    cfb0:	48b3      	ldr	r0, [pc, #716]	; (d280 <_vfiprintf_r+0xcb8>)
    cfb2:	3310      	adds	r3, #16
    cfb4:	2a07      	cmp	r2, #7
    cfb6:	e9c9 0500 	strd	r0, r5, [r9]
    cfba:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    cfbe:	ddef      	ble.n	cfa0 <_vfiprintf_r+0x9d8>
    cfc0:	aa18      	add	r2, sp, #96	; 0x60
    cfc2:	b333      	cbz	r3, d012 <_vfiprintf_r+0xa4a>
    cfc4:	4631      	mov	r1, r6
    cfc6:	4658      	mov	r0, fp
    cfc8:	f7ff fac2 	bl	c550 <__sprint_r.part.0>
    cfcc:	2800      	cmp	r0, #0
    cfce:	f47f acd2 	bne.w	c976 <_vfiprintf_r+0x3ae>
    cfd2:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
    cfd6:	3c10      	subs	r4, #16
    cfd8:	2c10      	cmp	r4, #16
    cfda:	f101 0001 	add.w	r0, r1, #1
    cfde:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cfe2:	dce4      	bgt.n	cfae <_vfiprintf_r+0x9e6>
    cfe4:	4aa6      	ldr	r2, [pc, #664]	; (d280 <_vfiprintf_r+0xcb8>)
    cfe6:	f8c9 4004 	str.w	r4, [r9, #4]
    cfea:	4423      	add	r3, r4
    cfec:	2807      	cmp	r0, #7
    cfee:	e9cd 0319 	strd	r0, r3, [sp, #100]	; 0x64
    cff2:	f8c9 2000 	str.w	r2, [r9]
    cff6:	f77f ad59 	ble.w	caac <_vfiprintf_r+0x4e4>
    cffa:	b17b      	cbz	r3, d01c <_vfiprintf_r+0xa54>
    cffc:	ee18 1a10 	vmov	r1, s16
    d000:	aa18      	add	r2, sp, #96	; 0x60
    d002:	4658      	mov	r0, fp
    d004:	f7ff faa4 	bl	c550 <__sprint_r.part.0>
    d008:	2800      	cmp	r0, #0
    d00a:	f47f acb4 	bne.w	c976 <_vfiprintf_r+0x3ae>
    d00e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d010:	e54c      	b.n	caac <_vfiprintf_r+0x4e4>
    d012:	2001      	movs	r0, #1
    d014:	4619      	mov	r1, r3
    d016:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d01a:	e7c5      	b.n	cfa8 <_vfiprintf_r+0x9e0>
    d01c:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
    d020:	9903      	ldr	r1, [sp, #12]
    d022:	428a      	cmp	r2, r1
    d024:	bfac      	ite	ge
    d026:	189b      	addge	r3, r3, r2
    d028:	185b      	addlt	r3, r3, r1
    d02a:	9305      	str	r3, [sp, #20]
    d02c:	e549      	b.n	cac2 <_vfiprintf_r+0x4fa>
    d02e:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
    d032:	058f      	lsls	r7, r1, #22
    d034:	ee18 3a10 	vmov	r3, s16
    d038:	b28a      	uxth	r2, r1
    d03a:	f53f aae8 	bmi.w	c60e <_vfiprintf_r+0x46>
    d03e:	ee18 5a10 	vmov	r5, s16
    d042:	6d98      	ldr	r0, [r3, #88]	; 0x58
    d044:	f7fb fd50 	bl	8ae8 <__retarget_lock_acquire_recursive>
    d048:	f9b5 100c 	ldrsh.w	r1, [r5, #12]
    d04c:	b28a      	uxth	r2, r1
    d04e:	f7ff bade 	b.w	c60e <_vfiprintf_r+0x46>
    d052:	2b00      	cmp	r3, #0
    d054:	f43f ae79 	beq.w	cd4a <_vfiprintf_r+0x782>
    d058:	ee18 1a10 	vmov	r1, s16
    d05c:	aa18      	add	r2, sp, #96	; 0x60
    d05e:	4658      	mov	r0, fp
    d060:	f7ff fa76 	bl	c550 <__sprint_r.part.0>
    d064:	2800      	cmp	r0, #0
    d066:	f47f ac86 	bne.w	c976 <_vfiprintf_r+0x3ae>
    d06a:	9919      	ldr	r1, [sp, #100]	; 0x64
    d06c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d06e:	3101      	adds	r1, #1
    d070:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d074:	e4f8      	b.n	ca68 <_vfiprintf_r+0x4a0>
    d076:	9219      	str	r2, [sp, #100]	; 0x64
    d078:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d07c:	e45e      	b.n	c93c <_vfiprintf_r+0x374>
    d07e:	2f00      	cmp	r7, #0
    d080:	f47f abc3 	bne.w	c80a <_vfiprintf_r+0x242>
    d084:	9e03      	ldr	r6, [sp, #12]
    d086:	2700      	movs	r7, #0
    d088:	9704      	str	r7, [sp, #16]
    d08a:	ac44      	add	r4, sp, #272	; 0x110
    d08c:	f7ff bbc5 	b.w	c81a <_vfiprintf_r+0x252>
    d090:	9b03      	ldr	r3, [sp, #12]
    d092:	f013 0310 	ands.w	r3, r3, #16
    d096:	d154      	bne.n	d142 <_vfiprintf_r+0xb7a>
    d098:	9a03      	ldr	r2, [sp, #12]
    d09a:	f012 0040 	ands.w	r0, r2, #64	; 0x40
    d09e:	f000 816b 	beq.w	d378 <_vfiprintf_r+0xdb0>
    d0a2:	9907      	ldr	r1, [sp, #28]
    d0a4:	461a      	mov	r2, r3
    d0a6:	f851 3b04 	ldr.w	r3, [r1], #4
    d0aa:	9107      	str	r1, [sp, #28]
    d0ac:	b29b      	uxth	r3, r3
    d0ae:	2101      	movs	r1, #1
    d0b0:	e401      	b.n	c8b6 <_vfiprintf_r+0x2ee>
    d0b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d0b4:	2a00      	cmp	r2, #0
    d0b6:	d164      	bne.n	d182 <_vfiprintf_r+0xbba>
    d0b8:	4618      	mov	r0, r3
    d0ba:	2101      	movs	r1, #1
    d0bc:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d0c0:	e4c9      	b.n	ca56 <_vfiprintf_r+0x48e>
    d0c2:	2101      	movs	r1, #1
    d0c4:	4618      	mov	r0, r3
    d0c6:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d0ca:	e4c4      	b.n	ca56 <_vfiprintf_r+0x48e>
    d0cc:	425b      	negs	r3, r3
    d0ce:	eb62 0242 	sbc.w	r2, r2, r2, lsl #1
    d0d2:	9603      	str	r6, [sp, #12]
    d0d4:	202d      	movs	r0, #45	; 0x2d
    d0d6:	2101      	movs	r1, #1
    d0d8:	f7ff bbee 	b.w	c8b8 <_vfiprintf_r+0x2f0>
    d0dc:	2b00      	cmp	r3, #0
    d0de:	f000 8088 	beq.w	d1f2 <_vfiprintf_r+0xc2a>
    d0e2:	ee18 1a10 	vmov	r1, s16
    d0e6:	aa18      	add	r2, sp, #96	; 0x60
    d0e8:	4658      	mov	r0, fp
    d0ea:	f7ff fa31 	bl	c550 <__sprint_r.part.0>
    d0ee:	2800      	cmp	r0, #0
    d0f0:	f47f ac41 	bne.w	c976 <_vfiprintf_r+0x3ae>
    d0f4:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    d0f8:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d0fc:	1c41      	adds	r1, r0, #1
    d0fe:	e477      	b.n	c9f0 <_vfiprintf_r+0x428>
    d100:	f898 1000 	ldrb.w	r1, [r8]
    d104:	9307      	str	r3, [sp, #28]
    d106:	f7ff bad2 	b.w	c6ae <_vfiprintf_r+0xe6>
    d10a:	ac44      	add	r4, sp, #272	; 0x110
    d10c:	f7ff bb85 	b.w	c81a <_vfiprintf_r+0x252>
    d110:	f109 0908 	add.w	r9, r9, #8
    d114:	f10c 0101 	add.w	r1, ip, #1
    d118:	4660      	mov	r0, ip
    d11a:	e4a0      	b.n	ca5e <_vfiprintf_r+0x496>
    d11c:	f416 7200 	ands.w	r2, r6, #512	; 0x200
    d120:	f040 8197 	bne.w	d452 <_vfiprintf_r+0xe8a>
    d124:	f851 3b04 	ldr.w	r3, [r1], #4
    d128:	9107      	str	r1, [sp, #28]
    d12a:	f7ff bbc0 	b.w	c8ae <_vfiprintf_r+0x2e6>
    d12e:	05b3      	lsls	r3, r6, #22
    d130:	f100 8188 	bmi.w	d444 <_vfiprintf_r+0xe7c>
    d134:	f852 3b04 	ldr.w	r3, [r2], #4
    d138:	9207      	str	r2, [sp, #28]
    d13a:	17da      	asrs	r2, r3, #31
    d13c:	4611      	mov	r1, r2
    d13e:	f7ff bb52 	b.w	c7e6 <_vfiprintf_r+0x21e>
    d142:	9907      	ldr	r1, [sp, #28]
    d144:	f851 3b04 	ldr.w	r3, [r1], #4
    d148:	9107      	str	r1, [sp, #28]
    d14a:	2101      	movs	r1, #1
    d14c:	f7ff bbb3 	b.w	c8b6 <_vfiprintf_r+0x2ee>
    d150:	9b07      	ldr	r3, [sp, #28]
    d152:	9805      	ldr	r0, [sp, #20]
    d154:	f853 1b04 	ldr.w	r1, [r3], #4
    d158:	9307      	str	r3, [sp, #28]
    d15a:	17c2      	asrs	r2, r0, #31
    d15c:	e9c1 0200 	strd	r0, r2, [r1]
    d160:	f7ff ba7d 	b.w	c65e <_vfiprintf_r+0x96>
    d164:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d166:	2b00      	cmp	r3, #0
    d168:	f43f ab26 	beq.w	c7b8 <_vfiprintf_r+0x1f0>
    d16c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d16e:	781b      	ldrb	r3, [r3, #0]
    d170:	2b00      	cmp	r3, #0
    d172:	f43f ab21 	beq.w	c7b8 <_vfiprintf_r+0x1f0>
    d176:	f898 1000 	ldrb.w	r1, [r8]
    d17a:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
    d17e:	f7ff ba96 	b.w	c6ae <_vfiprintf_r+0xe6>
    d182:	2302      	movs	r3, #2
    d184:	aa11      	add	r2, sp, #68	; 0x44
    d186:	931c      	str	r3, [sp, #112]	; 0x70
    d188:	921b      	str	r2, [sp, #108]	; 0x6c
    d18a:	2001      	movs	r0, #1
    d18c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d190:	e6a2      	b.n	ced8 <_vfiprintf_r+0x910>
    d192:	9603      	str	r6, [sp, #12]
    d194:	e571      	b.n	cc7a <_vfiprintf_r+0x6b2>
    d196:	4b3b      	ldr	r3, [pc, #236]	; (d284 <_vfiprintf_r+0xcbc>)
    d198:	930c      	str	r3, [sp, #48]	; 0x30
    d19a:	f016 0220 	ands.w	r2, r6, #32
    d19e:	d059      	beq.n	d254 <_vfiprintf_r+0xc8c>
    d1a0:	9b07      	ldr	r3, [sp, #28]
    d1a2:	3307      	adds	r3, #7
    d1a4:	f023 0307 	bic.w	r3, r3, #7
    d1a8:	4618      	mov	r0, r3
    d1aa:	685a      	ldr	r2, [r3, #4]
    d1ac:	f850 3b08 	ldr.w	r3, [r0], #8
    d1b0:	9007      	str	r0, [sp, #28]
    d1b2:	07f4      	lsls	r4, r6, #31
    d1b4:	d509      	bpl.n	d1ca <_vfiprintf_r+0xc02>
    d1b6:	ea53 0002 	orrs.w	r0, r3, r2
    d1ba:	d006      	beq.n	d1ca <_vfiprintf_r+0xc02>
    d1bc:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
    d1c0:	2130      	movs	r1, #48	; 0x30
    d1c2:	f046 0602 	orr.w	r6, r6, #2
    d1c6:	f88d 1044 	strb.w	r1, [sp, #68]	; 0x44
    d1ca:	f426 6180 	bic.w	r1, r6, #1024	; 0x400
    d1ce:	9103      	str	r1, [sp, #12]
    d1d0:	2102      	movs	r1, #2
    d1d2:	f7ff bb70 	b.w	c8b6 <_vfiprintf_r+0x2ee>
    d1d6:	4b2c      	ldr	r3, [pc, #176]	; (d288 <_vfiprintf_r+0xcc0>)
    d1d8:	930c      	str	r3, [sp, #48]	; 0x30
    d1da:	e7de      	b.n	d19a <_vfiprintf_r+0xbd2>
    d1dc:	9b07      	ldr	r3, [sp, #28]
    d1de:	2101      	movs	r1, #1
    d1e0:	f853 2b04 	ldr.w	r2, [r3], #4
    d1e4:	9103      	str	r1, [sp, #12]
    d1e6:	f88d 20ac 	strb.w	r2, [sp, #172]	; 0xac
    d1ea:	9307      	str	r3, [sp, #28]
    d1ec:	9104      	str	r1, [sp, #16]
    d1ee:	ac2b      	add	r4, sp, #172	; 0xac
    d1f0:	e4df      	b.n	cbb2 <_vfiprintf_r+0x5ea>
    d1f2:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
    d1f6:	2a00      	cmp	r2, #0
    d1f8:	f040 8132 	bne.w	d460 <_vfiprintf_r+0xe98>
    d1fc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d1fe:	2a00      	cmp	r2, #0
    d200:	f47f ae62 	bne.w	cec8 <_vfiprintf_r+0x900>
    d204:	4618      	mov	r0, r3
    d206:	2101      	movs	r1, #1
    d208:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d20c:	e427      	b.n	ca5e <_vfiprintf_r+0x496>
    d20e:	2100      	movs	r1, #0
    d210:	2208      	movs	r2, #8
    d212:	a816      	add	r0, sp, #88	; 0x58
    d214:	9413      	str	r4, [sp, #76]	; 0x4c
    d216:	f7fb fb49 	bl	88ac <memset>
    d21a:	1c79      	adds	r1, r7, #1
    d21c:	f000 80bc 	beq.w	d398 <_vfiprintf_r+0xdd0>
    d220:	2500      	movs	r5, #0
    d222:	9407      	str	r4, [sp, #28]
    d224:	462c      	mov	r4, r5
    d226:	e00c      	b.n	d242 <_vfiprintf_r+0xc7a>
    d228:	a92b      	add	r1, sp, #172	; 0xac
    d22a:	4658      	mov	r0, fp
    d22c:	f7ff f8ca 	bl	c3c4 <_wcrtomb_r>
    d230:	1c42      	adds	r2, r0, #1
    d232:	4420      	add	r0, r4
    d234:	f000 816b 	beq.w	d50e <_vfiprintf_r+0xf46>
    d238:	42b8      	cmp	r0, r7
    d23a:	dc08      	bgt.n	d24e <_vfiprintf_r+0xc86>
    d23c:	f000 8170 	beq.w	d520 <_vfiprintf_r+0xf58>
    d240:	4604      	mov	r4, r0
    d242:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    d244:	5952      	ldr	r2, [r2, r5]
    d246:	ab16      	add	r3, sp, #88	; 0x58
    d248:	3504      	adds	r5, #4
    d24a:	2a00      	cmp	r2, #0
    d24c:	d1ec      	bne.n	d228 <_vfiprintf_r+0xc60>
    d24e:	9404      	str	r4, [sp, #16]
    d250:	9c07      	ldr	r4, [sp, #28]
    d252:	e0af      	b.n	d3b4 <_vfiprintf_r+0xdec>
    d254:	f016 0310 	ands.w	r3, r6, #16
    d258:	9807      	ldr	r0, [sp, #28]
    d25a:	d10c      	bne.n	d276 <_vfiprintf_r+0xcae>
    d25c:	f016 0440 	ands.w	r4, r6, #64	; 0x40
    d260:	d005      	beq.n	d26e <_vfiprintf_r+0xca6>
    d262:	461a      	mov	r2, r3
    d264:	f850 3b04 	ldr.w	r3, [r0], #4
    d268:	9007      	str	r0, [sp, #28]
    d26a:	b29b      	uxth	r3, r3
    d26c:	e7a1      	b.n	d1b2 <_vfiprintf_r+0xbea>
    d26e:	f416 7200 	ands.w	r2, r6, #512	; 0x200
    d272:	f040 80e1 	bne.w	d438 <_vfiprintf_r+0xe70>
    d276:	f850 3b04 	ldr.w	r3, [r0], #4
    d27a:	9007      	str	r0, [sp, #28]
    d27c:	e799      	b.n	d1b2 <_vfiprintf_r+0xbea>
    d27e:	bf00      	nop
    d280:	20000b6c 	.word	0x20000b6c
    d284:	20000b2c 	.word	0x20000b2c
    d288:	20000b40 	.word	0x20000b40
    d28c:	9903      	ldr	r1, [sp, #12]
    d28e:	9704      	str	r7, [sp, #16]
    d290:	ac44      	add	r4, sp, #272	; 0x110
    d292:	469e      	mov	lr, r3
    d294:	ee08 ba90 	vmov	s17, fp
    d298:	f401 6680 	and.w	r6, r1, #1024	; 0x400
    d29c:	f04f 0c00 	mov.w	ip, #0
    d2a0:	4623      	mov	r3, r4
    d2a2:	e006      	b.n	d2b2 <_vfiprintf_r+0xcea>
    d2a4:	f1be 0f0a 	cmp.w	lr, #10
    d2a8:	f172 0200 	sbcs.w	r2, r2, #0
    d2ac:	d339      	bcc.n	d322 <_vfiprintf_r+0xd5a>
    d2ae:	46a6      	mov	lr, r4
    d2b0:	462a      	mov	r2, r5
    d2b2:	49a6      	ldr	r1, [pc, #664]	; (d54c <_vfiprintf_r+0xf84>)
    d2b4:	eb1e 0002 	adds.w	r0, lr, r2
    d2b8:	f140 0000 	adc.w	r0, r0, #0
    d2bc:	460f      	mov	r7, r1
    d2be:	fba1 1400 	umull	r1, r4, r1, r0
    d2c2:	f024 0103 	bic.w	r1, r4, #3
    d2c6:	eb01 0194 	add.w	r1, r1, r4, lsr #2
    d2ca:	1a40      	subs	r0, r0, r1
    d2cc:	ebbe 0100 	subs.w	r1, lr, r0
    d2d0:	f04f 35cc 	mov.w	r5, #3435973836	; 0xcccccccc
    d2d4:	f162 0400 	sbc.w	r4, r2, #0
    d2d8:	fb05 f501 	mul.w	r5, r5, r1
    d2dc:	fb07 5504 	mla	r5, r7, r4, r5
    d2e0:	fba1 4107 	umull	r4, r1, r1, r7
    d2e4:	440d      	add	r5, r1
    d2e6:	2705      	movs	r7, #5
    d2e8:	f004 0101 	and.w	r1, r4, #1
    d2ec:	fba1 1b07 	umull	r1, fp, r1, r7
    d2f0:	1809      	adds	r1, r1, r0
    d2f2:	0864      	lsrs	r4, r4, #1
    d2f4:	3130      	adds	r1, #48	; 0x30
    d2f6:	f803 1c01 	strb.w	r1, [r3, #-1]
    d2fa:	ea44 74c5 	orr.w	r4, r4, r5, lsl #31
    d2fe:	f10c 0c01 	add.w	ip, ip, #1
    d302:	3b01      	subs	r3, #1
    d304:	086d      	lsrs	r5, r5, #1
    d306:	2e00      	cmp	r6, #0
    d308:	d0cc      	beq.n	d2a4 <_vfiprintf_r+0xcdc>
    d30a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d30c:	7809      	ldrb	r1, [r1, #0]
    d30e:	4561      	cmp	r1, ip
    d310:	d1c8      	bne.n	d2a4 <_vfiprintf_r+0xcdc>
    d312:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    d316:	d0c5      	beq.n	d2a4 <_vfiprintf_r+0xcdc>
    d318:	f1be 0f0a 	cmp.w	lr, #10
    d31c:	f172 0200 	sbcs.w	r2, r2, #0
    d320:	d26c      	bcs.n	d3fc <_vfiprintf_r+0xe34>
    d322:	461c      	mov	r4, r3
    d324:	ab44      	add	r3, sp, #272	; 0x110
    d326:	1b1b      	subs	r3, r3, r4
    d328:	9f04      	ldr	r7, [sp, #16]
    d32a:	9e03      	ldr	r6, [sp, #12]
    d32c:	9304      	str	r3, [sp, #16]
    d32e:	ee18 ba90 	vmov	fp, s17
    d332:	f7ff ba72 	b.w	c81a <_vfiprintf_r+0x252>
    d336:	9603      	str	r6, [sp, #12]
    d338:	f7ff ba62 	b.w	c800 <_vfiprintf_r+0x238>
    d33c:	4658      	mov	r0, fp
    d33e:	f7fb f93f 	bl	85c0 <__sinit>
    d342:	f7ff b95b 	b.w	c5fc <_vfiprintf_r+0x34>
    d346:	2901      	cmp	r1, #1
    d348:	9603      	str	r6, [sp, #12]
    d34a:	f47f accd 	bne.w	cce8 <_vfiprintf_r+0x720>
    d34e:	f7ff ba5c 	b.w	c80a <_vfiprintf_r+0x242>
    d352:	9b07      	ldr	r3, [sp, #28]
    d354:	9905      	ldr	r1, [sp, #20]
    d356:	f853 2b04 	ldr.w	r2, [r3], #4
    d35a:	6011      	str	r1, [r2, #0]
    d35c:	9307      	str	r3, [sp, #28]
    d35e:	f7ff b97e 	b.w	c65e <_vfiprintf_r+0x96>
    d362:	2f06      	cmp	r7, #6
    d364:	463b      	mov	r3, r7
    d366:	9a03      	ldr	r2, [sp, #12]
    d368:	4c79      	ldr	r4, [pc, #484]	; (d550 <_vfiprintf_r+0xf88>)
    d36a:	9207      	str	r2, [sp, #28]
    d36c:	bf28      	it	cs
    d36e:	2306      	movcs	r3, #6
    d370:	9304      	str	r3, [sp, #16]
    d372:	9303      	str	r3, [sp, #12]
    d374:	f7ff bb25 	b.w	c9c2 <_vfiprintf_r+0x3fa>
    d378:	9b03      	ldr	r3, [sp, #12]
    d37a:	9907      	ldr	r1, [sp, #28]
    d37c:	f413 7200 	ands.w	r2, r3, #512	; 0x200
    d380:	bf14      	ite	ne
    d382:	f851 3b04 	ldrne.w	r3, [r1], #4
    d386:	f851 3b04 	ldreq.w	r3, [r1], #4
    d38a:	9107      	str	r1, [sp, #28]
    d38c:	bf1c      	itt	ne
    d38e:	4602      	movne	r2, r0
    d390:	b2db      	uxtbne	r3, r3
    d392:	2101      	movs	r1, #1
    d394:	f7ff ba8f 	b.w	c8b6 <_vfiprintf_r+0x2ee>
    d398:	ab16      	add	r3, sp, #88	; 0x58
    d39a:	9300      	str	r3, [sp, #0]
    d39c:	2300      	movs	r3, #0
    d39e:	4619      	mov	r1, r3
    d3a0:	aa13      	add	r2, sp, #76	; 0x4c
    d3a2:	4658      	mov	r0, fp
    d3a4:	f7ff f834 	bl	c410 <_wcsrtombs_r>
    d3a8:	4603      	mov	r3, r0
    d3aa:	3301      	adds	r3, #1
    d3ac:	9004      	str	r0, [sp, #16]
    d3ae:	f000 80ae 	beq.w	d50e <_vfiprintf_r+0xf46>
    d3b2:	9413      	str	r4, [sp, #76]	; 0x4c
    d3b4:	9b04      	ldr	r3, [sp, #16]
    d3b6:	2b00      	cmp	r3, #0
    d3b8:	d030      	beq.n	d41c <_vfiprintf_r+0xe54>
    d3ba:	2b63      	cmp	r3, #99	; 0x63
    d3bc:	dc63      	bgt.n	d486 <_vfiprintf_r+0xebe>
    d3be:	2300      	movs	r3, #0
    d3c0:	9308      	str	r3, [sp, #32]
    d3c2:	ac2b      	add	r4, sp, #172	; 0xac
    d3c4:	2208      	movs	r2, #8
    d3c6:	2100      	movs	r1, #0
    d3c8:	a816      	add	r0, sp, #88	; 0x58
    d3ca:	f7fb fa6f 	bl	88ac <memset>
    d3ce:	9d04      	ldr	r5, [sp, #16]
    d3d0:	ab16      	add	r3, sp, #88	; 0x58
    d3d2:	9300      	str	r3, [sp, #0]
    d3d4:	aa13      	add	r2, sp, #76	; 0x4c
    d3d6:	462b      	mov	r3, r5
    d3d8:	4621      	mov	r1, r4
    d3da:	4658      	mov	r0, fp
    d3dc:	f7ff f818 	bl	c410 <_wcsrtombs_r>
    d3e0:	4285      	cmp	r5, r0
    d3e2:	f040 80ab 	bne.w	d53c <_vfiprintf_r+0xf74>
    d3e6:	9b03      	ldr	r3, [sp, #12]
    d3e8:	9a04      	ldr	r2, [sp, #16]
    d3ea:	9307      	str	r3, [sp, #28]
    d3ec:	2300      	movs	r3, #0
    d3ee:	54a3      	strb	r3, [r4, r2]
    d3f0:	461f      	mov	r7, r3
    d3f2:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    d3f6:	9303      	str	r3, [sp, #12]
    d3f8:	f7ff ba16 	b.w	c828 <_vfiprintf_r+0x260>
    d3fc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    d3fe:	990d      	ldr	r1, [sp, #52]	; 0x34
    d400:	1a9b      	subs	r3, r3, r2
    d402:	4618      	mov	r0, r3
    d404:	9308      	str	r3, [sp, #32]
    d406:	f7fb faa3 	bl	8950 <strncpy>
    d40a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d40c:	9b08      	ldr	r3, [sp, #32]
    d40e:	784a      	ldrb	r2, [r1, #1]
    d410:	b10a      	cbz	r2, d416 <_vfiprintf_r+0xe4e>
    d412:	3101      	adds	r1, #1
    d414:	910b      	str	r1, [sp, #44]	; 0x2c
    d416:	f04f 0c00 	mov.w	ip, #0
    d41a:	e748      	b.n	d2ae <_vfiprintf_r+0xce6>
    d41c:	9b03      	ldr	r3, [sp, #12]
    d41e:	9307      	str	r3, [sp, #28]
    d420:	9b04      	ldr	r3, [sp, #16]
    d422:	9303      	str	r3, [sp, #12]
    d424:	461f      	mov	r7, r3
    d426:	9308      	str	r3, [sp, #32]
    d428:	f7ff b9fe 	b.w	c828 <_vfiprintf_r+0x260>
    d42c:	2101      	movs	r1, #1
    d42e:	4618      	mov	r0, r3
    d430:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d434:	f7ff bb13 	b.w	ca5e <_vfiprintf_r+0x496>
    d438:	f850 3b04 	ldr.w	r3, [r0], #4
    d43c:	9007      	str	r0, [sp, #28]
    d43e:	4622      	mov	r2, r4
    d440:	b2db      	uxtb	r3, r3
    d442:	e6b6      	b.n	d1b2 <_vfiprintf_r+0xbea>
    d444:	f912 3b04 	ldrsb.w	r3, [r2], #4
    d448:	9207      	str	r2, [sp, #28]
    d44a:	17da      	asrs	r2, r3, #31
    d44c:	4611      	mov	r1, r2
    d44e:	f7ff b9ca 	b.w	c7e6 <_vfiprintf_r+0x21e>
    d452:	f851 3b04 	ldr.w	r3, [r1], #4
    d456:	9107      	str	r1, [sp, #28]
    d458:	4602      	mov	r2, r0
    d45a:	b2db      	uxtb	r3, r3
    d45c:	f7ff ba27 	b.w	c8ae <_vfiprintf_r+0x2e6>
    d460:	2301      	movs	r3, #1
    d462:	931c      	str	r3, [sp, #112]	; 0x70
    d464:	2101      	movs	r1, #1
    d466:	f10d 0343 	add.w	r3, sp, #67	; 0x43
    d46a:	931b      	str	r3, [sp, #108]	; 0x6c
    d46c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d470:	460b      	mov	r3, r1
    d472:	f7ff bacd 	b.w	ca10 <_vfiprintf_r+0x448>
    d476:	9b07      	ldr	r3, [sp, #28]
    d478:	9905      	ldr	r1, [sp, #20]
    d47a:	f853 2b04 	ldr.w	r2, [r3], #4
    d47e:	9307      	str	r3, [sp, #28]
    d480:	8011      	strh	r1, [r2, #0]
    d482:	f7ff b8ec 	b.w	c65e <_vfiprintf_r+0x96>
    d486:	1c59      	adds	r1, r3, #1
    d488:	4658      	mov	r0, fp
    d48a:	f7fa fb5b 	bl	7b44 <_malloc_r>
    d48e:	4604      	mov	r4, r0
    d490:	2800      	cmp	r0, #0
    d492:	d03c      	beq.n	d50e <_vfiprintf_r+0xf46>
    d494:	9008      	str	r0, [sp, #32]
    d496:	e795      	b.n	d3c4 <_vfiprintf_r+0xdfc>
    d498:	6d88      	ldr	r0, [r1, #88]	; 0x58
    d49a:	f7fb fb27 	bl	8aec <__retarget_lock_release_recursive>
    d49e:	f7ff b9e9 	b.w	c874 <_vfiprintf_r+0x2ac>
    d4a2:	9b03      	ldr	r3, [sp, #12]
    d4a4:	9307      	str	r3, [sp, #28]
    d4a6:	e9cd 7703 	strd	r7, r7, [sp, #12]
    d4aa:	9f08      	ldr	r7, [sp, #32]
    d4ac:	f7ff b9bc 	b.w	c828 <_vfiprintf_r+0x260>
    d4b0:	9819      	ldr	r0, [sp, #100]	; 0x64
    d4b2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d4b4:	3001      	adds	r0, #1
    d4b6:	e545      	b.n	cf44 <_vfiprintf_r+0x97c>
    d4b8:	9b03      	ldr	r3, [sp, #12]
    d4ba:	9307      	str	r3, [sp, #28]
    d4bc:	4620      	mov	r0, r4
    d4be:	f7fb fb1f 	bl	8b00 <strlen>
    d4c2:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
    d4c6:	462f      	mov	r7, r5
    d4c8:	9004      	str	r0, [sp, #16]
    d4ca:	9303      	str	r3, [sp, #12]
    d4cc:	9508      	str	r5, [sp, #32]
    d4ce:	f7ff b9ab 	b.w	c828 <_vfiprintf_r+0x260>
    d4d2:	ee18 1a10 	vmov	r1, s16
    d4d6:	aa18      	add	r2, sp, #96	; 0x60
    d4d8:	4658      	mov	r0, fp
    d4da:	f7ff f839 	bl	c550 <__sprint_r.part.0>
    d4de:	2800      	cmp	r0, #0
    d4e0:	f43f aa36 	beq.w	c950 <_vfiprintf_r+0x388>
    d4e4:	f7ff ba4d 	b.w	c982 <_vfiprintf_r+0x3ba>
    d4e8:	9819      	ldr	r0, [sp, #100]	; 0x64
    d4ea:	3001      	adds	r0, #1
    d4ec:	e57a      	b.n	cfe4 <_vfiprintf_r+0xa1c>
    d4ee:	468c      	mov	ip, r1
    d4f0:	e46e      	b.n	cdd0 <_vfiprintf_r+0x808>
    d4f2:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    d4f4:	07d9      	lsls	r1, r3, #31
    d4f6:	d405      	bmi.n	d504 <_vfiprintf_r+0xf3c>
    d4f8:	89ab      	ldrh	r3, [r5, #12]
    d4fa:	059a      	lsls	r2, r3, #22
    d4fc:	d402      	bmi.n	d504 <_vfiprintf_r+0xf3c>
    d4fe:	6da8      	ldr	r0, [r5, #88]	; 0x58
    d500:	f7fb faf4 	bl	8aec <__retarget_lock_release_recursive>
    d504:	f04f 33ff 	mov.w	r3, #4294967295
    d508:	9305      	str	r3, [sp, #20]
    d50a:	f7ff ba49 	b.w	c9a0 <_vfiprintf_r+0x3d8>
    d50e:	ee18 2a10 	vmov	r2, s16
    d512:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
    d516:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d51a:	8193      	strh	r3, [r2, #12]
    d51c:	f7ff ba35 	b.w	c98a <_vfiprintf_r+0x3c2>
    d520:	9c07      	ldr	r4, [sp, #28]
    d522:	9704      	str	r7, [sp, #16]
    d524:	e746      	b.n	d3b4 <_vfiprintf_r+0xdec>
    d526:	9b07      	ldr	r3, [sp, #28]
    d528:	f898 1001 	ldrb.w	r1, [r8, #1]
    d52c:	f853 7b04 	ldr.w	r7, [r3], #4
    d530:	9307      	str	r3, [sp, #28]
    d532:	4690      	mov	r8, r2
    d534:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
    d538:	f7ff b8b9 	b.w	c6ae <_vfiprintf_r+0xe6>
    d53c:	ee18 2a10 	vmov	r2, s16
    d540:	8993      	ldrh	r3, [r2, #12]
    d542:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d546:	8193      	strh	r3, [r2, #12]
    d548:	f7ff ba15 	b.w	c976 <_vfiprintf_r+0x3ae>
    d54c:	cccccccd 	.word	0xcccccccd
    d550:	20000b54 	.word	0x20000b54

0000d554 <__sbprintf>:
    d554:	b570      	push	{r4, r5, r6, lr}
    d556:	460c      	mov	r4, r1
    d558:	8989      	ldrh	r1, [r1, #12]
    d55a:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
    d55e:	f021 0102 	bic.w	r1, r1, #2
    d562:	f8ad 1014 	strh.w	r1, [sp, #20]
    d566:	6e61      	ldr	r1, [r4, #100]	; 0x64
    d568:	911b      	str	r1, [sp, #108]	; 0x6c
    d56a:	89e1      	ldrh	r1, [r4, #14]
    d56c:	f8ad 1016 	strh.w	r1, [sp, #22]
    d570:	69e1      	ldr	r1, [r4, #28]
    d572:	9109      	str	r1, [sp, #36]	; 0x24
    d574:	6a61      	ldr	r1, [r4, #36]	; 0x24
    d576:	910b      	str	r1, [sp, #44]	; 0x2c
    d578:	a91c      	add	r1, sp, #112	; 0x70
    d57a:	9102      	str	r1, [sp, #8]
    d57c:	9106      	str	r1, [sp, #24]
    d57e:	f44f 6180 	mov.w	r1, #1024	; 0x400
    d582:	4606      	mov	r6, r0
    d584:	9104      	str	r1, [sp, #16]
    d586:	9107      	str	r1, [sp, #28]
    d588:	a818      	add	r0, sp, #96	; 0x60
    d58a:	2100      	movs	r1, #0
    d58c:	e9cd 3200 	strd	r3, r2, [sp]
    d590:	9108      	str	r1, [sp, #32]
    d592:	f7fb faa5 	bl	8ae0 <__retarget_lock_init_recursive>
    d596:	e9dd 3200 	ldrd	r3, r2, [sp]
    d59a:	a902      	add	r1, sp, #8
    d59c:	4630      	mov	r0, r6
    d59e:	f7ff f813 	bl	c5c8 <_vfiprintf_r>
    d5a2:	1e05      	subs	r5, r0, #0
    d5a4:	db07      	blt.n	d5b6 <__sbprintf+0x62>
    d5a6:	a902      	add	r1, sp, #8
    d5a8:	4630      	mov	r0, r6
    d5aa:	f7fd feeb 	bl	b384 <_fflush_r>
    d5ae:	2800      	cmp	r0, #0
    d5b0:	bf18      	it	ne
    d5b2:	f04f 35ff 	movne.w	r5, #4294967295
    d5b6:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    d5ba:	065b      	lsls	r3, r3, #25
    d5bc:	d503      	bpl.n	d5c6 <__sbprintf+0x72>
    d5be:	89a3      	ldrh	r3, [r4, #12]
    d5c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d5c4:	81a3      	strh	r3, [r4, #12]
    d5c6:	9818      	ldr	r0, [sp, #96]	; 0x60
    d5c8:	f7fb fa8c 	bl	8ae4 <__retarget_lock_close_recursive>
    d5cc:	4628      	mov	r0, r5
    d5ce:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
    d5d2:	bd70      	pop	{r4, r5, r6, pc}

0000d5d4 <__sfvwrite_r>:
    d5d4:	6893      	ldr	r3, [r2, #8]
    d5d6:	2b00      	cmp	r3, #0
    d5d8:	f000 8085 	beq.w	d6e6 <__sfvwrite_r+0x112>
    d5dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d5e0:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
    d5e4:	460c      	mov	r4, r1
    d5e6:	0719      	lsls	r1, r3, #28
    d5e8:	4680      	mov	r8, r0
    d5ea:	b083      	sub	sp, #12
    d5ec:	4617      	mov	r7, r2
    d5ee:	b298      	uxth	r0, r3
    d5f0:	d525      	bpl.n	d63e <__sfvwrite_r+0x6a>
    d5f2:	6923      	ldr	r3, [r4, #16]
    d5f4:	b31b      	cbz	r3, d63e <__sfvwrite_r+0x6a>
    d5f6:	f010 0302 	ands.w	r3, r0, #2
    d5fa:	683d      	ldr	r5, [r7, #0]
    d5fc:	d02d      	beq.n	d65a <__sfvwrite_r+0x86>
    d5fe:	f04f 0a00 	mov.w	sl, #0
    d602:	f8df b2c0 	ldr.w	fp, [pc, #704]	; d8c4 <__sfvwrite_r+0x2f0>
    d606:	4656      	mov	r6, sl
    d608:	46b9      	mov	r9, r7
    d60a:	455e      	cmp	r6, fp
    d60c:	4633      	mov	r3, r6
    d60e:	4652      	mov	r2, sl
    d610:	bf28      	it	cs
    d612:	465b      	movcs	r3, fp
    d614:	4640      	mov	r0, r8
    d616:	2e00      	cmp	r6, #0
    d618:	d052      	beq.n	d6c0 <__sfvwrite_r+0xec>
    d61a:	69e1      	ldr	r1, [r4, #28]
    d61c:	6a67      	ldr	r7, [r4, #36]	; 0x24
    d61e:	47b8      	blx	r7
    d620:	2800      	cmp	r0, #0
    d622:	dd56      	ble.n	d6d2 <__sfvwrite_r+0xfe>
    d624:	f8d9 3008 	ldr.w	r3, [r9, #8]
    d628:	1a1b      	subs	r3, r3, r0
    d62a:	4482      	add	sl, r0
    d62c:	1a36      	subs	r6, r6, r0
    d62e:	f8c9 3008 	str.w	r3, [r9, #8]
    d632:	2b00      	cmp	r3, #0
    d634:	d1e9      	bne.n	d60a <__sfvwrite_r+0x36>
    d636:	2000      	movs	r0, #0
    d638:	b003      	add	sp, #12
    d63a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d63e:	4621      	mov	r1, r4
    d640:	4640      	mov	r0, r8
    d642:	f000 f941 	bl	d8c8 <__swsetup_r>
    d646:	2800      	cmp	r0, #0
    d648:	f040 8138 	bne.w	d8bc <__sfvwrite_r+0x2e8>
    d64c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d650:	683d      	ldr	r5, [r7, #0]
    d652:	b298      	uxth	r0, r3
    d654:	f010 0302 	ands.w	r3, r0, #2
    d658:	d1d1      	bne.n	d5fe <__sfvwrite_r+0x2a>
    d65a:	f010 0901 	ands.w	r9, r0, #1
    d65e:	d144      	bne.n	d6ea <__sfvwrite_r+0x116>
    d660:	464e      	mov	r6, r9
    d662:	9700      	str	r7, [sp, #0]
    d664:	b346      	cbz	r6, d6b8 <__sfvwrite_r+0xe4>
    d666:	0582      	lsls	r2, r0, #22
    d668:	f8d4 b008 	ldr.w	fp, [r4, #8]
    d66c:	f140 8085 	bpl.w	d77a <__sfvwrite_r+0x1a6>
    d670:	45b3      	cmp	fp, r6
    d672:	465a      	mov	r2, fp
    d674:	f200 80b4 	bhi.w	d7e0 <__sfvwrite_r+0x20c>
    d678:	f410 6f90 	tst.w	r0, #1152	; 0x480
    d67c:	f040 80c1 	bne.w	d802 <__sfvwrite_r+0x22e>
    d680:	6820      	ldr	r0, [r4, #0]
    d682:	9201      	str	r2, [sp, #4]
    d684:	4649      	mov	r1, r9
    d686:	f7fb f895 	bl	87b4 <memmove>
    d68a:	68a3      	ldr	r3, [r4, #8]
    d68c:	9a01      	ldr	r2, [sp, #4]
    d68e:	eba3 010b 	sub.w	r1, r3, fp
    d692:	6823      	ldr	r3, [r4, #0]
    d694:	60a1      	str	r1, [r4, #8]
    d696:	4413      	add	r3, r2
    d698:	46b2      	mov	sl, r6
    d69a:	6023      	str	r3, [r4, #0]
    d69c:	2600      	movs	r6, #0
    d69e:	9a00      	ldr	r2, [sp, #0]
    d6a0:	6893      	ldr	r3, [r2, #8]
    d6a2:	eba3 030a 	sub.w	r3, r3, sl
    d6a6:	44d1      	add	r9, sl
    d6a8:	6093      	str	r3, [r2, #8]
    d6aa:	2b00      	cmp	r3, #0
    d6ac:	d0c3      	beq.n	d636 <__sfvwrite_r+0x62>
    d6ae:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
    d6b2:	b280      	uxth	r0, r0
    d6b4:	2e00      	cmp	r6, #0
    d6b6:	d1d6      	bne.n	d666 <__sfvwrite_r+0x92>
    d6b8:	e9d5 9600 	ldrd	r9, r6, [r5]
    d6bc:	3508      	adds	r5, #8
    d6be:	e7d1      	b.n	d664 <__sfvwrite_r+0x90>
    d6c0:	e9d5 a600 	ldrd	sl, r6, [r5]
    d6c4:	3508      	adds	r5, #8
    d6c6:	e7a0      	b.n	d60a <__sfvwrite_r+0x36>
    d6c8:	4621      	mov	r1, r4
    d6ca:	4640      	mov	r0, r8
    d6cc:	f7fd fe5a 	bl	b384 <_fflush_r>
    d6d0:	b388      	cbz	r0, d736 <__sfvwrite_r+0x162>
    d6d2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d6d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d6da:	f04f 30ff 	mov.w	r0, #4294967295
    d6de:	81a3      	strh	r3, [r4, #12]
    d6e0:	b003      	add	sp, #12
    d6e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d6e6:	2000      	movs	r0, #0
    d6e8:	4770      	bx	lr
    d6ea:	461e      	mov	r6, r3
    d6ec:	46ba      	mov	sl, r7
    d6ee:	4699      	mov	r9, r3
    d6f0:	4618      	mov	r0, r3
    d6f2:	9500      	str	r5, [sp, #0]
    d6f4:	461f      	mov	r7, r3
    d6f6:	b366      	cbz	r6, d752 <__sfvwrite_r+0x17e>
    d6f8:	2800      	cmp	r0, #0
    d6fa:	d032      	beq.n	d762 <__sfvwrite_r+0x18e>
    d6fc:	464a      	mov	r2, r9
    d6fe:	e9d4 1304 	ldrd	r1, r3, [r4, #16]
    d702:	6820      	ldr	r0, [r4, #0]
    d704:	68a5      	ldr	r5, [r4, #8]
    d706:	42b2      	cmp	r2, r6
    d708:	bf28      	it	cs
    d70a:	4632      	movcs	r2, r6
    d70c:	4288      	cmp	r0, r1
    d70e:	d904      	bls.n	d71a <__sfvwrite_r+0x146>
    d710:	eb05 0b03 	add.w	fp, r5, r3
    d714:	455a      	cmp	r2, fp
    d716:	f300 80a7 	bgt.w	d868 <__sfvwrite_r+0x294>
    d71a:	4293      	cmp	r3, r2
    d71c:	dc64      	bgt.n	d7e8 <__sfvwrite_r+0x214>
    d71e:	69e1      	ldr	r1, [r4, #28]
    d720:	6a65      	ldr	r5, [r4, #36]	; 0x24
    d722:	463a      	mov	r2, r7
    d724:	4640      	mov	r0, r8
    d726:	47a8      	blx	r5
    d728:	f1b0 0b00 	subs.w	fp, r0, #0
    d72c:	ddd1      	ble.n	d6d2 <__sfvwrite_r+0xfe>
    d72e:	ebb9 090b 	subs.w	r9, r9, fp
    d732:	d0c9      	beq.n	d6c8 <__sfvwrite_r+0xf4>
    d734:	2001      	movs	r0, #1
    d736:	f8da 3008 	ldr.w	r3, [sl, #8]
    d73a:	eba3 030b 	sub.w	r3, r3, fp
    d73e:	445f      	add	r7, fp
    d740:	eba6 060b 	sub.w	r6, r6, fp
    d744:	f8ca 3008 	str.w	r3, [sl, #8]
    d748:	2b00      	cmp	r3, #0
    d74a:	f43f af74 	beq.w	d636 <__sfvwrite_r+0x62>
    d74e:	2e00      	cmp	r6, #0
    d750:	d1d2      	bne.n	d6f8 <__sfvwrite_r+0x124>
    d752:	9a00      	ldr	r2, [sp, #0]
    d754:	6856      	ldr	r6, [r2, #4]
    d756:	4613      	mov	r3, r2
    d758:	3208      	adds	r2, #8
    d75a:	9200      	str	r2, [sp, #0]
    d75c:	2e00      	cmp	r6, #0
    d75e:	d0f8      	beq.n	d752 <__sfvwrite_r+0x17e>
    d760:	681f      	ldr	r7, [r3, #0]
    d762:	4632      	mov	r2, r6
    d764:	210a      	movs	r1, #10
    d766:	4638      	mov	r0, r7
    d768:	f7fd fe3a 	bl	b3e0 <memchr>
    d76c:	2800      	cmp	r0, #0
    d76e:	f000 809c 	beq.w	d8aa <__sfvwrite_r+0x2d6>
    d772:	3001      	adds	r0, #1
    d774:	eba0 0907 	sub.w	r9, r0, r7
    d778:	e7c0      	b.n	d6fc <__sfvwrite_r+0x128>
    d77a:	6820      	ldr	r0, [r4, #0]
    d77c:	6923      	ldr	r3, [r4, #16]
    d77e:	4298      	cmp	r0, r3
    d780:	d816      	bhi.n	d7b0 <__sfvwrite_r+0x1dc>
    d782:	6962      	ldr	r2, [r4, #20]
    d784:	42b2      	cmp	r2, r6
    d786:	d813      	bhi.n	d7b0 <__sfvwrite_r+0x1dc>
    d788:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    d78c:	42b3      	cmp	r3, r6
    d78e:	bf28      	it	cs
    d790:	4633      	movcs	r3, r6
    d792:	69e1      	ldr	r1, [r4, #28]
    d794:	fb93 f3f2 	sdiv	r3, r3, r2
    d798:	6a67      	ldr	r7, [r4, #36]	; 0x24
    d79a:	fb02 f303 	mul.w	r3, r2, r3
    d79e:	4640      	mov	r0, r8
    d7a0:	464a      	mov	r2, r9
    d7a2:	47b8      	blx	r7
    d7a4:	f1b0 0a00 	subs.w	sl, r0, #0
    d7a8:	dd93      	ble.n	d6d2 <__sfvwrite_r+0xfe>
    d7aa:	eba6 060a 	sub.w	r6, r6, sl
    d7ae:	e776      	b.n	d69e <__sfvwrite_r+0xca>
    d7b0:	45b3      	cmp	fp, r6
    d7b2:	46da      	mov	sl, fp
    d7b4:	bf28      	it	cs
    d7b6:	46b2      	movcs	sl, r6
    d7b8:	4652      	mov	r2, sl
    d7ba:	4649      	mov	r1, r9
    d7bc:	f7fa fffa 	bl	87b4 <memmove>
    d7c0:	68a3      	ldr	r3, [r4, #8]
    d7c2:	6822      	ldr	r2, [r4, #0]
    d7c4:	eba3 030a 	sub.w	r3, r3, sl
    d7c8:	4452      	add	r2, sl
    d7ca:	60a3      	str	r3, [r4, #8]
    d7cc:	6022      	str	r2, [r4, #0]
    d7ce:	2b00      	cmp	r3, #0
    d7d0:	d1eb      	bne.n	d7aa <__sfvwrite_r+0x1d6>
    d7d2:	4621      	mov	r1, r4
    d7d4:	4640      	mov	r0, r8
    d7d6:	f7fd fdd5 	bl	b384 <_fflush_r>
    d7da:	2800      	cmp	r0, #0
    d7dc:	d0e5      	beq.n	d7aa <__sfvwrite_r+0x1d6>
    d7de:	e778      	b.n	d6d2 <__sfvwrite_r+0xfe>
    d7e0:	6820      	ldr	r0, [r4, #0]
    d7e2:	46b3      	mov	fp, r6
    d7e4:	4632      	mov	r2, r6
    d7e6:	e74c      	b.n	d682 <__sfvwrite_r+0xae>
    d7e8:	4639      	mov	r1, r7
    d7ea:	9201      	str	r2, [sp, #4]
    d7ec:	f7fa ffe2 	bl	87b4 <memmove>
    d7f0:	9a01      	ldr	r2, [sp, #4]
    d7f2:	68a3      	ldr	r3, [r4, #8]
    d7f4:	1a9b      	subs	r3, r3, r2
    d7f6:	60a3      	str	r3, [r4, #8]
    d7f8:	6823      	ldr	r3, [r4, #0]
    d7fa:	4413      	add	r3, r2
    d7fc:	6023      	str	r3, [r4, #0]
    d7fe:	4693      	mov	fp, r2
    d800:	e795      	b.n	d72e <__sfvwrite_r+0x15a>
    d802:	6823      	ldr	r3, [r4, #0]
    d804:	6921      	ldr	r1, [r4, #16]
    d806:	eba3 0b01 	sub.w	fp, r3, r1
    d80a:	6963      	ldr	r3, [r4, #20]
    d80c:	eb03 0a43 	add.w	sl, r3, r3, lsl #1
    d810:	eb0a 7ada 	add.w	sl, sl, sl, lsr #31
    d814:	f10b 0301 	add.w	r3, fp, #1
    d818:	ea4f 0a6a 	mov.w	sl, sl, asr #1
    d81c:	4433      	add	r3, r6
    d81e:	4553      	cmp	r3, sl
    d820:	4652      	mov	r2, sl
    d822:	bf84      	itt	hi
    d824:	469a      	movhi	sl, r3
    d826:	4652      	movhi	r2, sl
    d828:	0543      	lsls	r3, r0, #21
    d82a:	d52c      	bpl.n	d886 <__sfvwrite_r+0x2b2>
    d82c:	4611      	mov	r1, r2
    d82e:	4640      	mov	r0, r8
    d830:	f7fa f988 	bl	7b44 <_malloc_r>
    d834:	2800      	cmp	r0, #0
    d836:	d03b      	beq.n	d8b0 <__sfvwrite_r+0x2dc>
    d838:	465a      	mov	r2, fp
    d83a:	6921      	ldr	r1, [r4, #16]
    d83c:	9001      	str	r0, [sp, #4]
    d83e:	f7f8 fd3d 	bl	62bc <memcpy>
    d842:	89a2      	ldrh	r2, [r4, #12]
    d844:	9b01      	ldr	r3, [sp, #4]
    d846:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    d84a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    d84e:	81a2      	strh	r2, [r4, #12]
    d850:	eb03 000b 	add.w	r0, r3, fp
    d854:	6123      	str	r3, [r4, #16]
    d856:	ebaa 030b 	sub.w	r3, sl, fp
    d85a:	f8c4 a014 	str.w	sl, [r4, #20]
    d85e:	60a3      	str	r3, [r4, #8]
    d860:	6020      	str	r0, [r4, #0]
    d862:	46b3      	mov	fp, r6
    d864:	4632      	mov	r2, r6
    d866:	e70c      	b.n	d682 <__sfvwrite_r+0xae>
    d868:	4639      	mov	r1, r7
    d86a:	465a      	mov	r2, fp
    d86c:	f7fa ffa2 	bl	87b4 <memmove>
    d870:	6823      	ldr	r3, [r4, #0]
    d872:	445b      	add	r3, fp
    d874:	6023      	str	r3, [r4, #0]
    d876:	4621      	mov	r1, r4
    d878:	4640      	mov	r0, r8
    d87a:	f7fd fd83 	bl	b384 <_fflush_r>
    d87e:	2800      	cmp	r0, #0
    d880:	f43f af55 	beq.w	d72e <__sfvwrite_r+0x15a>
    d884:	e725      	b.n	d6d2 <__sfvwrite_r+0xfe>
    d886:	4640      	mov	r0, r8
    d888:	f7fa fc18 	bl	80bc <_realloc_r>
    d88c:	4603      	mov	r3, r0
    d88e:	2800      	cmp	r0, #0
    d890:	d1de      	bne.n	d850 <__sfvwrite_r+0x27c>
    d892:	6921      	ldr	r1, [r4, #16]
    d894:	4640      	mov	r0, r8
    d896:	f7fb f9f1 	bl	8c7c <_free_r>
    d89a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d89e:	220c      	movs	r2, #12
    d8a0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    d8a4:	f8c8 2000 	str.w	r2, [r8]
    d8a8:	e715      	b.n	d6d6 <__sfvwrite_r+0x102>
    d8aa:	1c72      	adds	r2, r6, #1
    d8ac:	4691      	mov	r9, r2
    d8ae:	e726      	b.n	d6fe <__sfvwrite_r+0x12a>
    d8b0:	220c      	movs	r2, #12
    d8b2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d8b6:	f8c8 2000 	str.w	r2, [r8]
    d8ba:	e70c      	b.n	d6d6 <__sfvwrite_r+0x102>
    d8bc:	f04f 30ff 	mov.w	r0, #4294967295
    d8c0:	e6ba      	b.n	d638 <__sfvwrite_r+0x64>
    d8c2:	bf00      	nop
    d8c4:	7ffffc00 	.word	0x7ffffc00

0000d8c8 <__swsetup_r>:
    d8c8:	b538      	push	{r3, r4, r5, lr}
    d8ca:	4b31      	ldr	r3, [pc, #196]	; (d990 <__swsetup_r+0xc8>)
    d8cc:	681b      	ldr	r3, [r3, #0]
    d8ce:	4605      	mov	r5, r0
    d8d0:	460c      	mov	r4, r1
    d8d2:	b113      	cbz	r3, d8da <__swsetup_r+0x12>
    d8d4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    d8d6:	2a00      	cmp	r2, #0
    d8d8:	d04e      	beq.n	d978 <__swsetup_r+0xb0>
    d8da:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d8de:	0718      	lsls	r0, r3, #28
    d8e0:	b29a      	uxth	r2, r3
    d8e2:	d51c      	bpl.n	d91e <__swsetup_r+0x56>
    d8e4:	6921      	ldr	r1, [r4, #16]
    d8e6:	b329      	cbz	r1, d934 <__swsetup_r+0x6c>
    d8e8:	f012 0001 	ands.w	r0, r2, #1
    d8ec:	d007      	beq.n	d8fe <__swsetup_r+0x36>
    d8ee:	2000      	movs	r0, #0
    d8f0:	60a0      	str	r0, [r4, #8]
    d8f2:	6960      	ldr	r0, [r4, #20]
    d8f4:	4240      	negs	r0, r0
    d8f6:	61a0      	str	r0, [r4, #24]
    d8f8:	b139      	cbz	r1, d90a <__swsetup_r+0x42>
    d8fa:	2000      	movs	r0, #0
    d8fc:	bd38      	pop	{r3, r4, r5, pc}
    d8fe:	0795      	lsls	r5, r2, #30
    d900:	bf58      	it	pl
    d902:	6960      	ldrpl	r0, [r4, #20]
    d904:	60a0      	str	r0, [r4, #8]
    d906:	2900      	cmp	r1, #0
    d908:	d1f7      	bne.n	d8fa <__swsetup_r+0x32>
    d90a:	0612      	lsls	r2, r2, #24
    d90c:	bf58      	it	pl
    d90e:	4608      	movpl	r0, r1
    d910:	d5f4      	bpl.n	d8fc <__swsetup_r+0x34>
    d912:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d916:	81a3      	strh	r3, [r4, #12]
    d918:	f04f 30ff 	mov.w	r0, #4294967295
    d91c:	bd38      	pop	{r3, r4, r5, pc}
    d91e:	06d1      	lsls	r1, r2, #27
    d920:	d52e      	bpl.n	d980 <__swsetup_r+0xb8>
    d922:	0752      	lsls	r2, r2, #29
    d924:	d414      	bmi.n	d950 <__swsetup_r+0x88>
    d926:	6921      	ldr	r1, [r4, #16]
    d928:	f043 0308 	orr.w	r3, r3, #8
    d92c:	81a3      	strh	r3, [r4, #12]
    d92e:	b29a      	uxth	r2, r3
    d930:	2900      	cmp	r1, #0
    d932:	d1d9      	bne.n	d8e8 <__swsetup_r+0x20>
    d934:	f402 7020 	and.w	r0, r2, #640	; 0x280
    d938:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    d93c:	d0d4      	beq.n	d8e8 <__swsetup_r+0x20>
    d93e:	4621      	mov	r1, r4
    d940:	4628      	mov	r0, r5
    d942:	f000 f947 	bl	dbd4 <__smakebuf_r>
    d946:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d94a:	6921      	ldr	r1, [r4, #16]
    d94c:	b29a      	uxth	r2, r3
    d94e:	e7cb      	b.n	d8e8 <__swsetup_r+0x20>
    d950:	6b21      	ldr	r1, [r4, #48]	; 0x30
    d952:	b151      	cbz	r1, d96a <__swsetup_r+0xa2>
    d954:	f104 0240 	add.w	r2, r4, #64	; 0x40
    d958:	4291      	cmp	r1, r2
    d95a:	d004      	beq.n	d966 <__swsetup_r+0x9e>
    d95c:	4628      	mov	r0, r5
    d95e:	f7fb f98d 	bl	8c7c <_free_r>
    d962:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d966:	2200      	movs	r2, #0
    d968:	6322      	str	r2, [r4, #48]	; 0x30
    d96a:	6921      	ldr	r1, [r4, #16]
    d96c:	2200      	movs	r2, #0
    d96e:	e9c4 1200 	strd	r1, r2, [r4]
    d972:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    d976:	e7d7      	b.n	d928 <__swsetup_r+0x60>
    d978:	4618      	mov	r0, r3
    d97a:	f7fa fe21 	bl	85c0 <__sinit>
    d97e:	e7ac      	b.n	d8da <__swsetup_r+0x12>
    d980:	2209      	movs	r2, #9
    d982:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d986:	602a      	str	r2, [r5, #0]
    d988:	f04f 30ff 	mov.w	r0, #4294967295
    d98c:	81a3      	strh	r3, [r4, #12]
    d98e:	bd38      	pop	{r3, r4, r5, pc}
    d990:	2000176c 	.word	0x2000176c

0000d994 <__fputwc>:
    d994:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d998:	b082      	sub	sp, #8
    d99a:	4682      	mov	sl, r0
    d99c:	4688      	mov	r8, r1
    d99e:	4614      	mov	r4, r2
    d9a0:	f7fb f808 	bl	89b4 <__locale_mb_cur_max>
    d9a4:	2801      	cmp	r0, #1
    d9a6:	d103      	bne.n	d9b0 <__fputwc+0x1c>
    d9a8:	f108 33ff 	add.w	r3, r8, #4294967295
    d9ac:	2bfe      	cmp	r3, #254	; 0xfe
    d9ae:	d936      	bls.n	da1e <__fputwc+0x8a>
    d9b0:	f10d 0904 	add.w	r9, sp, #4
    d9b4:	4642      	mov	r2, r8
    d9b6:	f104 035c 	add.w	r3, r4, #92	; 0x5c
    d9ba:	4649      	mov	r1, r9
    d9bc:	4650      	mov	r0, sl
    d9be:	f7fe fd01 	bl	c3c4 <_wcrtomb_r>
    d9c2:	1c42      	adds	r2, r0, #1
    d9c4:	4606      	mov	r6, r0
    d9c6:	d032      	beq.n	da2e <__fputwc+0x9a>
    d9c8:	b320      	cbz	r0, da14 <__fputwc+0x80>
    d9ca:	f89d c004 	ldrb.w	ip, [sp, #4]
    d9ce:	2500      	movs	r5, #0
    d9d0:	e009      	b.n	d9e6 <__fputwc+0x52>
    d9d2:	6823      	ldr	r3, [r4, #0]
    d9d4:	1c5a      	adds	r2, r3, #1
    d9d6:	6022      	str	r2, [r4, #0]
    d9d8:	f883 c000 	strb.w	ip, [r3]
    d9dc:	3501      	adds	r5, #1
    d9de:	42b5      	cmp	r5, r6
    d9e0:	d218      	bcs.n	da14 <__fputwc+0x80>
    d9e2:	f819 cf01 	ldrb.w	ip, [r9, #1]!
    d9e6:	68a3      	ldr	r3, [r4, #8]
    d9e8:	3b01      	subs	r3, #1
    d9ea:	2b00      	cmp	r3, #0
    d9ec:	60a3      	str	r3, [r4, #8]
    d9ee:	daf0      	bge.n	d9d2 <__fputwc+0x3e>
    d9f0:	69a7      	ldr	r7, [r4, #24]
    d9f2:	42bb      	cmp	r3, r7
    d9f4:	4661      	mov	r1, ip
    d9f6:	4622      	mov	r2, r4
    d9f8:	4650      	mov	r0, sl
    d9fa:	db02      	blt.n	da02 <__fputwc+0x6e>
    d9fc:	f1bc 0f0a 	cmp.w	ip, #10
    da00:	d1e7      	bne.n	d9d2 <__fputwc+0x3e>
    da02:	f000 f953 	bl	dcac <__swbuf_r>
    da06:	1c43      	adds	r3, r0, #1
    da08:	d1e8      	bne.n	d9dc <__fputwc+0x48>
    da0a:	4606      	mov	r6, r0
    da0c:	4630      	mov	r0, r6
    da0e:	b002      	add	sp, #8
    da10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    da14:	4646      	mov	r6, r8
    da16:	4630      	mov	r0, r6
    da18:	b002      	add	sp, #8
    da1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    da1e:	fa5f fc88 	uxtb.w	ip, r8
    da22:	f88d c004 	strb.w	ip, [sp, #4]
    da26:	4606      	mov	r6, r0
    da28:	f10d 0904 	add.w	r9, sp, #4
    da2c:	e7cf      	b.n	d9ce <__fputwc+0x3a>
    da2e:	89a3      	ldrh	r3, [r4, #12]
    da30:	4630      	mov	r0, r6
    da32:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    da36:	81a3      	strh	r3, [r4, #12]
    da38:	b002      	add	sp, #8
    da3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    da3e:	bf00      	nop

0000da40 <_fputwc_r>:
    da40:	b530      	push	{r4, r5, lr}
    da42:	6e53      	ldr	r3, [r2, #100]	; 0x64
    da44:	f013 0f01 	tst.w	r3, #1
    da48:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
    da4c:	4614      	mov	r4, r2
    da4e:	b083      	sub	sp, #12
    da50:	4605      	mov	r5, r0
    da52:	b29a      	uxth	r2, r3
    da54:	d101      	bne.n	da5a <_fputwc_r+0x1a>
    da56:	0598      	lsls	r0, r3, #22
    da58:	d51c      	bpl.n	da94 <_fputwc_r+0x54>
    da5a:	0490      	lsls	r0, r2, #18
    da5c:	d406      	bmi.n	da6c <_fputwc_r+0x2c>
    da5e:	6e62      	ldr	r2, [r4, #100]	; 0x64
    da60:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    da64:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    da68:	81a3      	strh	r3, [r4, #12]
    da6a:	6662      	str	r2, [r4, #100]	; 0x64
    da6c:	4622      	mov	r2, r4
    da6e:	4628      	mov	r0, r5
    da70:	f7ff ff90 	bl	d994 <__fputwc>
    da74:	6e63      	ldr	r3, [r4, #100]	; 0x64
    da76:	07da      	lsls	r2, r3, #31
    da78:	4605      	mov	r5, r0
    da7a:	d402      	bmi.n	da82 <_fputwc_r+0x42>
    da7c:	89a3      	ldrh	r3, [r4, #12]
    da7e:	059b      	lsls	r3, r3, #22
    da80:	d502      	bpl.n	da88 <_fputwc_r+0x48>
    da82:	4628      	mov	r0, r5
    da84:	b003      	add	sp, #12
    da86:	bd30      	pop	{r4, r5, pc}
    da88:	6da0      	ldr	r0, [r4, #88]	; 0x58
    da8a:	f7fb f82f 	bl	8aec <__retarget_lock_release_recursive>
    da8e:	4628      	mov	r0, r5
    da90:	b003      	add	sp, #12
    da92:	bd30      	pop	{r4, r5, pc}
    da94:	6da0      	ldr	r0, [r4, #88]	; 0x58
    da96:	9101      	str	r1, [sp, #4]
    da98:	f7fb f826 	bl	8ae8 <__retarget_lock_acquire_recursive>
    da9c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    daa0:	9901      	ldr	r1, [sp, #4]
    daa2:	b29a      	uxth	r2, r3
    daa4:	e7d9      	b.n	da5a <_fputwc_r+0x1a>
    daa6:	bf00      	nop

0000daa8 <_wcsnrtombs_l>:
    daa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    daac:	b08b      	sub	sp, #44	; 0x2c
    daae:	e9dd 8a15 	ldrd	r8, sl, [sp, #84]	; 0x54
    dab2:	9f14      	ldr	r7, [sp, #80]	; 0x50
    dab4:	9103      	str	r1, [sp, #12]
    dab6:	4681      	mov	r9, r0
    dab8:	9205      	str	r2, [sp, #20]
    daba:	461e      	mov	r6, r3
    dabc:	f1b8 0f00 	cmp.w	r8, #0
    dac0:	d05c      	beq.n	db7c <_wcsnrtombs_l+0xd4>
    dac2:	9b03      	ldr	r3, [sp, #12]
    dac4:	2b00      	cmp	r3, #0
    dac6:	d05e      	beq.n	db86 <_wcsnrtombs_l+0xde>
    dac8:	9b05      	ldr	r3, [sp, #20]
    daca:	681d      	ldr	r5, [r3, #0]
    dacc:	2f00      	cmp	r7, #0
    dace:	d06a      	beq.n	dba6 <_wcsnrtombs_l+0xfe>
    dad0:	1e74      	subs	r4, r6, #1
    dad2:	b34e      	cbz	r6, db28 <_wcsnrtombs_l+0x80>
    dad4:	9b03      	ldr	r3, [sp, #12]
    dad6:	9304      	str	r3, [sp, #16]
    dad8:	3d04      	subs	r5, #4
    dada:	2600      	movs	r6, #0
    dadc:	9501      	str	r5, [sp, #4]
    dade:	e00b      	b.n	daf8 <_wcsnrtombs_l+0x50>
    dae0:	9b03      	ldr	r3, [sp, #12]
    dae2:	bb2b      	cbnz	r3, db30 <_wcsnrtombs_l+0x88>
    dae4:	9b01      	ldr	r3, [sp, #4]
    dae6:	681a      	ldr	r2, [r3, #0]
    dae8:	2a00      	cmp	r2, #0
    daea:	d03a      	beq.n	db62 <_wcsnrtombs_l+0xba>
    daec:	45bc      	cmp	ip, r7
    daee:	d25c      	bcs.n	dbaa <_wcsnrtombs_l+0x102>
    daf0:	3c01      	subs	r4, #1
    daf2:	1c63      	adds	r3, r4, #1
    daf4:	4666      	mov	r6, ip
    daf6:	d017      	beq.n	db28 <_wcsnrtombs_l+0x80>
    daf8:	f8d8 3000 	ldr.w	r3, [r8]
    dafc:	9302      	str	r3, [sp, #8]
    dafe:	9b01      	ldr	r3, [sp, #4]
    db00:	f8da 50e0 	ldr.w	r5, [sl, #224]	; 0xe0
    db04:	f853 2f04 	ldr.w	r2, [r3, #4]!
    db08:	9301      	str	r3, [sp, #4]
    db0a:	a907      	add	r1, sp, #28
    db0c:	4643      	mov	r3, r8
    db0e:	4648      	mov	r0, r9
    db10:	f8d8 b004 	ldr.w	fp, [r8, #4]
    db14:	47a8      	blx	r5
    db16:	1c42      	adds	r2, r0, #1
    db18:	d03a      	beq.n	db90 <_wcsnrtombs_l+0xe8>
    db1a:	eb00 0c06 	add.w	ip, r0, r6
    db1e:	45bc      	cmp	ip, r7
    db20:	d9de      	bls.n	dae0 <_wcsnrtombs_l+0x38>
    db22:	9b02      	ldr	r3, [sp, #8]
    db24:	e9c8 3b00 	strd	r3, fp, [r8]
    db28:	4630      	mov	r0, r6
    db2a:	b00b      	add	sp, #44	; 0x2c
    db2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    db30:	2800      	cmp	r0, #0
    db32:	dd0e      	ble.n	db52 <_wcsnrtombs_l+0xaa>
    db34:	9b04      	ldr	r3, [sp, #16]
    db36:	9d01      	ldr	r5, [sp, #4]
    db38:	4418      	add	r0, r3
    db3a:	1e5a      	subs	r2, r3, #1
    db3c:	a907      	add	r1, sp, #28
    db3e:	f100 3eff 	add.w	lr, r0, #4294967295
    db42:	f811 3b01 	ldrb.w	r3, [r1], #1
    db46:	f802 3f01 	strb.w	r3, [r2, #1]!
    db4a:	4572      	cmp	r2, lr
    db4c:	d1f9      	bne.n	db42 <_wcsnrtombs_l+0x9a>
    db4e:	9501      	str	r5, [sp, #4]
    db50:	9004      	str	r0, [sp, #16]
    db52:	9b05      	ldr	r3, [sp, #20]
    db54:	681a      	ldr	r2, [r3, #0]
    db56:	3204      	adds	r2, #4
    db58:	601a      	str	r2, [r3, #0]
    db5a:	9b01      	ldr	r3, [sp, #4]
    db5c:	681a      	ldr	r2, [r3, #0]
    db5e:	2a00      	cmp	r2, #0
    db60:	d1c4      	bne.n	daec <_wcsnrtombs_l+0x44>
    db62:	9b03      	ldr	r3, [sp, #12]
    db64:	b10b      	cbz	r3, db6a <_wcsnrtombs_l+0xc2>
    db66:	9b05      	ldr	r3, [sp, #20]
    db68:	601a      	str	r2, [r3, #0]
    db6a:	f10c 36ff 	add.w	r6, ip, #4294967295
    db6e:	2200      	movs	r2, #0
    db70:	4630      	mov	r0, r6
    db72:	f8c8 2000 	str.w	r2, [r8]
    db76:	b00b      	add	sp, #44	; 0x2c
    db78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    db7c:	9b03      	ldr	r3, [sp, #12]
    db7e:	f500 7886 	add.w	r8, r0, #268	; 0x10c
    db82:	2b00      	cmp	r3, #0
    db84:	d1a0      	bne.n	dac8 <_wcsnrtombs_l+0x20>
    db86:	9b05      	ldr	r3, [sp, #20]
    db88:	f04f 37ff 	mov.w	r7, #4294967295
    db8c:	681d      	ldr	r5, [r3, #0]
    db8e:	e79f      	b.n	dad0 <_wcsnrtombs_l+0x28>
    db90:	4606      	mov	r6, r0
    db92:	218a      	movs	r1, #138	; 0x8a
    db94:	2200      	movs	r2, #0
    db96:	4630      	mov	r0, r6
    db98:	f8c9 1000 	str.w	r1, [r9]
    db9c:	f8c8 2000 	str.w	r2, [r8]
    dba0:	b00b      	add	sp, #44	; 0x2c
    dba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dba6:	463e      	mov	r6, r7
    dba8:	e7be      	b.n	db28 <_wcsnrtombs_l+0x80>
    dbaa:	4666      	mov	r6, ip
    dbac:	e7bc      	b.n	db28 <_wcsnrtombs_l+0x80>
    dbae:	bf00      	nop

0000dbb0 <_wcsnrtombs_r>:
    dbb0:	b510      	push	{r4, lr}
    dbb2:	b084      	sub	sp, #16
    dbb4:	4c05      	ldr	r4, [pc, #20]	; (dbcc <_wcsnrtombs_r+0x1c>)
    dbb6:	9806      	ldr	r0, [sp, #24]
    dbb8:	9000      	str	r0, [sp, #0]
    dbba:	9807      	ldr	r0, [sp, #28]
    dbbc:	9001      	str	r0, [sp, #4]
    dbbe:	4804      	ldr	r0, [pc, #16]	; (dbd0 <_wcsnrtombs_r+0x20>)
    dbc0:	6800      	ldr	r0, [r0, #0]
    dbc2:	9402      	str	r4, [sp, #8]
    dbc4:	f7ff ff70 	bl	daa8 <_wcsnrtombs_l>
    dbc8:	b004      	add	sp, #16
    dbca:	bd10      	pop	{r4, pc}
    dbcc:	200011e4 	.word	0x200011e4
    dbd0:	2000176c 	.word	0x2000176c

0000dbd4 <__smakebuf_r>:
    dbd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dbd8:	898b      	ldrh	r3, [r1, #12]
    dbda:	460c      	mov	r4, r1
    dbdc:	0799      	lsls	r1, r3, #30
    dbde:	b096      	sub	sp, #88	; 0x58
    dbe0:	d508      	bpl.n	dbf4 <__smakebuf_r+0x20>
    dbe2:	f104 0343 	add.w	r3, r4, #67	; 0x43
    dbe6:	2201      	movs	r2, #1
    dbe8:	e9c4 3204 	strd	r3, r2, [r4, #16]
    dbec:	6023      	str	r3, [r4, #0]
    dbee:	b016      	add	sp, #88	; 0x58
    dbf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    dbf4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    dbf8:	2900      	cmp	r1, #0
    dbfa:	4606      	mov	r6, r0
    dbfc:	db25      	blt.n	dc4a <__smakebuf_r+0x76>
    dbfe:	466a      	mov	r2, sp
    dc00:	f000 f8ac 	bl	dd5c <_fstat_r>
    dc04:	2800      	cmp	r0, #0
    dc06:	db1f      	blt.n	dc48 <__smakebuf_r+0x74>
    dc08:	9d01      	ldr	r5, [sp, #4]
    dc0a:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    dc0e:	f5a5 5500 	sub.w	r5, r5, #8192	; 0x2000
    dc12:	fab5 f585 	clz	r5, r5
    dc16:	f44f 6880 	mov.w	r8, #1024	; 0x400
    dc1a:	096d      	lsrs	r5, r5, #5
    dc1c:	f44f 6700 	mov.w	r7, #2048	; 0x800
    dc20:	4641      	mov	r1, r8
    dc22:	4630      	mov	r0, r6
    dc24:	f7f9 ff8e 	bl	7b44 <_malloc_r>
    dc28:	b1e0      	cbz	r0, dc64 <__smakebuf_r+0x90>
    dc2a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    dc2e:	f8c4 8014 	str.w	r8, [r4, #20]
    dc32:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    dc36:	6020      	str	r0, [r4, #0]
    dc38:	6120      	str	r0, [r4, #16]
    dc3a:	81a3      	strh	r3, [r4, #12]
    dc3c:	bb35      	cbnz	r5, dc8c <__smakebuf_r+0xb8>
    dc3e:	433b      	orrs	r3, r7
    dc40:	81a3      	strh	r3, [r4, #12]
    dc42:	b016      	add	sp, #88	; 0x58
    dc44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    dc48:	89a3      	ldrh	r3, [r4, #12]
    dc4a:	f013 0580 	ands.w	r5, r3, #128	; 0x80
    dc4e:	d019      	beq.n	dc84 <__smakebuf_r+0xb0>
    dc50:	f04f 0840 	mov.w	r8, #64	; 0x40
    dc54:	2500      	movs	r5, #0
    dc56:	4641      	mov	r1, r8
    dc58:	4630      	mov	r0, r6
    dc5a:	462f      	mov	r7, r5
    dc5c:	f7f9 ff72 	bl	7b44 <_malloc_r>
    dc60:	2800      	cmp	r0, #0
    dc62:	d1e2      	bne.n	dc2a <__smakebuf_r+0x56>
    dc64:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    dc68:	059a      	lsls	r2, r3, #22
    dc6a:	d4c0      	bmi.n	dbee <__smakebuf_r+0x1a>
    dc6c:	f023 0303 	bic.w	r3, r3, #3
    dc70:	f104 0243 	add.w	r2, r4, #67	; 0x43
    dc74:	f043 0302 	orr.w	r3, r3, #2
    dc78:	2101      	movs	r1, #1
    dc7a:	e9c4 2104 	strd	r2, r1, [r4, #16]
    dc7e:	81a3      	strh	r3, [r4, #12]
    dc80:	6022      	str	r2, [r4, #0]
    dc82:	e7b4      	b.n	dbee <__smakebuf_r+0x1a>
    dc84:	f44f 6880 	mov.w	r8, #1024	; 0x400
    dc88:	462f      	mov	r7, r5
    dc8a:	e7c9      	b.n	dc20 <__smakebuf_r+0x4c>
    dc8c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    dc90:	4630      	mov	r0, r6
    dc92:	f000 f879 	bl	dd88 <_isatty_r>
    dc96:	b910      	cbnz	r0, dc9e <__smakebuf_r+0xca>
    dc98:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    dc9c:	e7cf      	b.n	dc3e <__smakebuf_r+0x6a>
    dc9e:	89a3      	ldrh	r3, [r4, #12]
    dca0:	f023 0303 	bic.w	r3, r3, #3
    dca4:	f043 0301 	orr.w	r3, r3, #1
    dca8:	b21b      	sxth	r3, r3
    dcaa:	e7c8      	b.n	dc3e <__smakebuf_r+0x6a>

0000dcac <__swbuf_r>:
    dcac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dcae:	460d      	mov	r5, r1
    dcb0:	4614      	mov	r4, r2
    dcb2:	4606      	mov	r6, r0
    dcb4:	b110      	cbz	r0, dcbc <__swbuf_r+0x10>
    dcb6:	6b43      	ldr	r3, [r0, #52]	; 0x34
    dcb8:	2b00      	cmp	r3, #0
    dcba:	d04c      	beq.n	dd56 <__swbuf_r+0xaa>
    dcbc:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    dcc0:	69a3      	ldr	r3, [r4, #24]
    dcc2:	60a3      	str	r3, [r4, #8]
    dcc4:	0717      	lsls	r7, r2, #28
    dcc6:	b290      	uxth	r0, r2
    dcc8:	d51b      	bpl.n	dd02 <__swbuf_r+0x56>
    dcca:	6923      	ldr	r3, [r4, #16]
    dccc:	b1cb      	cbz	r3, dd02 <__swbuf_r+0x56>
    dcce:	b2ed      	uxtb	r5, r5
    dcd0:	0481      	lsls	r1, r0, #18
    dcd2:	462f      	mov	r7, r5
    dcd4:	d522      	bpl.n	dd1c <__swbuf_r+0x70>
    dcd6:	6822      	ldr	r2, [r4, #0]
    dcd8:	6961      	ldr	r1, [r4, #20]
    dcda:	1ad3      	subs	r3, r2, r3
    dcdc:	4299      	cmp	r1, r3
    dcde:	dd29      	ble.n	dd34 <__swbuf_r+0x88>
    dce0:	3301      	adds	r3, #1
    dce2:	68a1      	ldr	r1, [r4, #8]
    dce4:	3901      	subs	r1, #1
    dce6:	60a1      	str	r1, [r4, #8]
    dce8:	1c51      	adds	r1, r2, #1
    dcea:	6021      	str	r1, [r4, #0]
    dcec:	7015      	strb	r5, [r2, #0]
    dcee:	6962      	ldr	r2, [r4, #20]
    dcf0:	429a      	cmp	r2, r3
    dcf2:	d027      	beq.n	dd44 <__swbuf_r+0x98>
    dcf4:	89a3      	ldrh	r3, [r4, #12]
    dcf6:	07db      	lsls	r3, r3, #31
    dcf8:	d501      	bpl.n	dcfe <__swbuf_r+0x52>
    dcfa:	2d0a      	cmp	r5, #10
    dcfc:	d022      	beq.n	dd44 <__swbuf_r+0x98>
    dcfe:	4638      	mov	r0, r7
    dd00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dd02:	4621      	mov	r1, r4
    dd04:	4630      	mov	r0, r6
    dd06:	f7ff fddf 	bl	d8c8 <__swsetup_r>
    dd0a:	bb08      	cbnz	r0, dd50 <__swbuf_r+0xa4>
    dd0c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    dd10:	6923      	ldr	r3, [r4, #16]
    dd12:	b290      	uxth	r0, r2
    dd14:	b2ed      	uxtb	r5, r5
    dd16:	0481      	lsls	r1, r0, #18
    dd18:	462f      	mov	r7, r5
    dd1a:	d4dc      	bmi.n	dcd6 <__swbuf_r+0x2a>
    dd1c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    dd20:	81a2      	strh	r2, [r4, #12]
    dd22:	6e62      	ldr	r2, [r4, #100]	; 0x64
    dd24:	6961      	ldr	r1, [r4, #20]
    dd26:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
    dd2a:	6662      	str	r2, [r4, #100]	; 0x64
    dd2c:	6822      	ldr	r2, [r4, #0]
    dd2e:	1ad3      	subs	r3, r2, r3
    dd30:	4299      	cmp	r1, r3
    dd32:	dcd5      	bgt.n	dce0 <__swbuf_r+0x34>
    dd34:	4621      	mov	r1, r4
    dd36:	4630      	mov	r0, r6
    dd38:	f7fd fb24 	bl	b384 <_fflush_r>
    dd3c:	b940      	cbnz	r0, dd50 <__swbuf_r+0xa4>
    dd3e:	6822      	ldr	r2, [r4, #0]
    dd40:	2301      	movs	r3, #1
    dd42:	e7ce      	b.n	dce2 <__swbuf_r+0x36>
    dd44:	4621      	mov	r1, r4
    dd46:	4630      	mov	r0, r6
    dd48:	f7fd fb1c 	bl	b384 <_fflush_r>
    dd4c:	2800      	cmp	r0, #0
    dd4e:	d0d6      	beq.n	dcfe <__swbuf_r+0x52>
    dd50:	f04f 37ff 	mov.w	r7, #4294967295
    dd54:	e7d3      	b.n	dcfe <__swbuf_r+0x52>
    dd56:	f7fa fc33 	bl	85c0 <__sinit>
    dd5a:	e7af      	b.n	dcbc <__swbuf_r+0x10>

0000dd5c <_fstat_r>:
    dd5c:	b570      	push	{r4, r5, r6, lr}
    dd5e:	460c      	mov	r4, r1
    dd60:	4d08      	ldr	r5, [pc, #32]	; (dd84 <_fstat_r+0x28>)
    dd62:	4603      	mov	r3, r0
    dd64:	2600      	movs	r6, #0
    dd66:	4620      	mov	r0, r4
    dd68:	4611      	mov	r1, r2
    dd6a:	461c      	mov	r4, r3
    dd6c:	602e      	str	r6, [r5, #0]
    dd6e:	f7f8 fdcf 	bl	6910 <_fstat>
    dd72:	1c43      	adds	r3, r0, #1
    dd74:	d000      	beq.n	dd78 <_fstat_r+0x1c>
    dd76:	bd70      	pop	{r4, r5, r6, pc}
    dd78:	682b      	ldr	r3, [r5, #0]
    dd7a:	2b00      	cmp	r3, #0
    dd7c:	d0fb      	beq.n	dd76 <_fstat_r+0x1a>
    dd7e:	6023      	str	r3, [r4, #0]
    dd80:	bd70      	pop	{r4, r5, r6, pc}
    dd82:	bf00      	nop
    dd84:	200074e8 	.word	0x200074e8

0000dd88 <_isatty_r>:
    dd88:	b538      	push	{r3, r4, r5, lr}
    dd8a:	4d07      	ldr	r5, [pc, #28]	; (dda8 <_isatty_r+0x20>)
    dd8c:	2200      	movs	r2, #0
    dd8e:	4604      	mov	r4, r0
    dd90:	4608      	mov	r0, r1
    dd92:	602a      	str	r2, [r5, #0]
    dd94:	f7f8 fdc2 	bl	691c <_isatty>
    dd98:	1c43      	adds	r3, r0, #1
    dd9a:	d000      	beq.n	dd9e <_isatty_r+0x16>
    dd9c:	bd38      	pop	{r3, r4, r5, pc}
    dd9e:	682b      	ldr	r3, [r5, #0]
    dda0:	2b00      	cmp	r3, #0
    dda2:	d0fb      	beq.n	dd9c <_isatty_r+0x14>
    dda4:	6023      	str	r3, [r4, #0]
    dda6:	bd38      	pop	{r3, r4, r5, pc}
    dda8:	200074e8 	.word	0x200074e8
    ddac:	00000000 	.word	0x00000000

0000ddb0 <___init_veneer>:
    ddb0:	f85f f000 	ldr.w	pc, [pc]	; ddb4 <___init_veneer+0x4>
    ddb4:	60001aad 	.word	0x60001aad

0000ddb8 <___reboot_Teensyduino__veneer>:
    ddb8:	f85f f000 	ldr.w	pc, [pc]	; ddbc <___reboot_Teensyduino__veneer+0x4>
    ddbc:	60001a05 	.word	0x60001a05

Disassembly of section .fini:

0000ddc0 <_fini>:
    ddc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ddc2:	bf00      	nop
