
C:\Users\Adam\AppData\Local\Temp\arduino\sketches\1E3EBD161CF261E6D284F0D719605E18/main.ino.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
	if (dest == src) return;
	do {
		*dest++ = *src++;
	} while (dest < dest_end);
#else
	asm volatile(
60001400:	4281      	cmp	r1, r0
60001402:	d005      	beq.n	60001410 <memory_copy+0x10>
60001404:	f851 3b04 	ldr.w	r3, [r1], #4
60001408:	f840 3b04 	str.w	r3, [r0], #4
6000140c:	4282      	cmp	r2, r0
6000140e:	d8f9      	bhi.n	60001404 <memory_copy+0x4>
	"	cmp	%[end], %[dest]		\n"
	"	bhi.n	1b			\n"
	"2:					\n"
	: [dest] "+r" (dest), [src] "+r" (src) : [end] "r" (dest_end) : "r3", "memory");
#endif
}
60001410:	4770      	bx	lr
60001412:	bf00      	nop

60001414 <memory_clear.constprop.0>:
#if 0
	while (dest < dest_end) {
		*dest++ = 0;
	}
#else
	asm volatile(
60001414:	4a04      	ldr	r2, [pc, #16]	; (60001428 <memory_clear.constprop.0+0x14>)
60001416:	4905      	ldr	r1, [pc, #20]	; (6000142c <memory_clear.constprop.0+0x18>)
60001418:	f04f 0300 	mov.w	r3, #0
6000141c:	f842 3b04 	str.w	r3, [r2], #4
60001420:	4291      	cmp	r1, r2
60001422:	d8fb      	bhi.n	6000141c <memory_clear.constprop.0+0x8>
	"1:	str.w	r3, [%[dest]], #4	\n"
	"	cmp	%[end], %[dest]		\n"
	"	bhi.n	1b			\n"
	: [dest] "+r" (dest) : [end] "r" (dest_end) : "r3", "memory");
#endif
}
60001424:	4770      	bx	lr
60001426:	bf00      	nop
60001428:	20001ec0 	.word	0x20001ec0
6000142c:	2000a760 	.word	0x2000a760

60001430 <ResetHandler2>:
{
60001430:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
	__asm__ volatile("dsb":::"memory");
60001434:	f3bf 8f4f 	dsb	sy
	asm volatile("nop");
60001438:	bf00      	nop
	asm volatile("nop");
6000143a:	bf00      	nop
	asm volatile("nop");
6000143c:	bf00      	nop
	asm volatile("nop");
6000143e:	bf00      	nop
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001440:	f000 f916 	bl	60001670 <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001444:	4b67      	ldr	r3, [pc, #412]	; (600015e4 <ResetHandler2+0x1b4>)
60001446:	2208      	movs	r2, #8
60001448:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
	asm volatile("nop");
6000144c:	bf00      	nop
	asm volatile("nop");
6000144e:	bf00      	nop
	asm volatile("nop");
60001450:	bf00      	nop
	asm volatile("nop");
60001452:	bf00      	nop
	asm volatile("nop");
60001454:	bf00      	nop
	asm volatile("nop");
60001456:	bf00      	nop
	asm volatile("nop");
60001458:	bf00      	nop
	asm volatile("nop");
6000145a:	bf00      	nop
	asm volatile("nop");
6000145c:	bf00      	nop
	asm volatile("nop");
6000145e:	bf00      	nop
	asm volatile("nop");
60001460:	bf00      	nop
	asm volatile("nop");
60001462:	bf00      	nop
	asm volatile("nop");
60001464:	bf00      	nop
	asm volatile("nop");
60001466:	bf00      	nop
	asm volatile("nop");
60001468:	bf00      	nop
	asm volatile("nop");
6000146a:	bf00      	nop
	memory_copy(&_stext, &_stextload, &_etext);
6000146c:	4a5e      	ldr	r2, [pc, #376]	; (600015e8 <ResetHandler2+0x1b8>)
6000146e:	495f      	ldr	r1, [pc, #380]	; (600015ec <ResetHandler2+0x1bc>)
60001470:	485f      	ldr	r0, [pc, #380]	; (600015f0 <ResetHandler2+0x1c0>)
60001472:	f7ff ffc5 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
60001476:	4a5f      	ldr	r2, [pc, #380]	; (600015f4 <ResetHandler2+0x1c4>)
60001478:	495f      	ldr	r1, [pc, #380]	; (600015f8 <ResetHandler2+0x1c8>)
6000147a:	4860      	ldr	r0, [pc, #384]	; (600015fc <ResetHandler2+0x1cc>)
6000147c:	f7ff ffc0 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001480:	4c5f      	ldr	r4, [pc, #380]	; (60001600 <ResetHandler2+0x1d0>)
60001482:	f7ff ffc7 	bl	60001414 <memory_clear.constprop.0>
	SCB_CPACR = 0x00F00000;
60001486:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000
6000148a:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000148e:	2300      	movs	r3, #0
60001490:	4a5c      	ldr	r2, [pc, #368]	; (60001604 <ResetHandler2+0x1d4>)
	SCB_CPACR = 0x00F00000;
60001492:	f8c1 0d88 	str.w	r0, [r1, #3464]	; 0xd88
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001496:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
6000149a:	3301      	adds	r3, #1
6000149c:	2bb0      	cmp	r3, #176	; 0xb0
6000149e:	d1fa      	bne.n	60001496 <ResetHandler2+0x66>
600014a0:	4b59      	ldr	r3, [pc, #356]	; (60001608 <ResetHandler2+0x1d8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600014a2:	2180      	movs	r1, #128	; 0x80
600014a4:	4a59      	ldr	r2, [pc, #356]	; (6000160c <ResetHandler2+0x1dc>)
600014a6:	f803 1b01 	strb.w	r1, [r3], #1
600014aa:	4293      	cmp	r3, r2
600014ac:	d1fb      	bne.n	600014a6 <ResetHandler2+0x76>
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b2:	4e4c      	ldr	r6, [pc, #304]	; (600015e4 <ResetHandler2+0x1b4>)
600014b4:	f04f 3980 	mov.w	r9, #2155905152	; 0x80808080
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b8:	f8df b180 	ldr.w	fp, [pc, #384]	; 6000163c <ResetHandler2+0x20c>
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8df a180 	ldr.w	sl, [pc, #384]	; 60001640 <ResetHandler2+0x210>
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014c0:	f04f 31ff 	mov.w	r1, #4294967295
	SCB_VTOR = (uint32_t)_VectorsRam;
600014c4:	f8c5 4d08 	str.w	r4, [r5, #3336]	; 0xd08
	SYST_CVR = 0;
600014c8:	2700      	movs	r7, #0
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014ca:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014ce:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014d2:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014d6:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014da:	f8d5 3d24 	ldr.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014de:	f8df 8164 	ldr.w	r8, [pc, #356]	; 60001644 <ResetHandler2+0x214>
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014e2:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e6:	4a4a      	ldr	r2, [pc, #296]	; (60001610 <ResetHandler2+0x1e0>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014e8:	f8c5 3d24 	str.w	r3, [r5, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ec:	f8d8 301c 	ldr.w	r3, [r8, #28]
600014f0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014f4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014f8:	f8c8 301c 	str.w	r3, [r8, #28]
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014fc:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
60001500:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
60001504:	f043 0340 	orr.w	r3, r3, #64	; 0x40
60001508:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000150c:	6691      	str	r1, [r2, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
6000150e:	66d1      	str	r1, [r2, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
60001510:	6711      	str	r1, [r2, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
60001512:	6751      	str	r1, [r2, #116]	; 0x74
	configure_cache();
60001514:	f000 f8b4 	bl	60001680 <configure_cache>
	_VectorsRam[14] = pendablesrvreq_isr;
60001518:	4b3e      	ldr	r3, [pc, #248]	; (60001614 <ResetHandler2+0x1e4>)
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000151a:	493f      	ldr	r1, [pc, #252]	; (60001618 <ResetHandler2+0x1e8>)
	_VectorsRam[14] = pendablesrvreq_isr;
6000151c:	63a3      	str	r3, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
6000151e:	4b3f      	ldr	r3, [pc, #252]	; (6000161c <ResetHandler2+0x1ec>)
60001520:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001522:	2363      	movs	r3, #99	; 0x63
60001524:	616b      	str	r3, [r5, #20]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001526:	2303      	movs	r3, #3
	SYST_CVR = 0;
60001528:	61af      	str	r7, [r5, #24]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000152a:	612b      	str	r3, [r5, #16]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
6000152c:	4b3c      	ldr	r3, [pc, #240]	; (60001620 <ResetHandler2+0x1f0>)
6000152e:	f8c5 3d20 	str.w	r3, [r5, #3360]	; 0xd20
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001532:	f8d5 3dfc 	ldr.w	r3, [r5, #3580]	; 0xdfc
60001536:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
6000153a:	f8c5 3dfc 	str.w	r3, [r5, #3580]	; 0xdfc
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000153e:	4b39      	ldr	r3, [pc, #228]	; (60001624 <ResetHandler2+0x1f4>)
60001540:	681a      	ldr	r2, [r3, #0]
60001542:	f042 0201 	orr.w	r2, r2, #1
60001546:	601a      	str	r2, [r3, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001548:	685b      	ldr	r3, [r3, #4]
6000154a:	600b      	str	r3, [r1, #0]
	usb_pll_start();	
6000154c:	f000 f920 	bl	60001790 <usb_pll_start>
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001550:	f8c6 9104 	str.w	r9, [r6, #260]	; 0x104
	set_arm_clock(F_CPU);
60001554:	4834      	ldr	r0, [pc, #208]	; (60001628 <ResetHandler2+0x1f8>)
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001556:	f8c6 b100 	str.w	fp, [r6, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000155a:	f8c6 90f4 	str.w	r9, [r6, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000155e:	f8c6 a0f0 	str.w	sl, [r6, #240]	; 0xf0
	set_arm_clock(F_CPU);
60001562:	f000 fab1 	bl	60001ac8 <__set_arm_clock_veneer>
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001566:	f8d8 106c 	ldr.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
6000156a:	4b30      	ldr	r3, [pc, #192]	; (6000162c <ResetHandler2+0x1fc>)
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000156c:	4a30      	ldr	r2, [pc, #192]	; (60001630 <ResetHandler2+0x200>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000156e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
60001572:	f8c8 106c 	str.w	r1, [r8, #108]	; 0x6c
	PIT_MCR = 0;
60001576:	601f      	str	r7, [r3, #0]
	PIT_TCTRL0 = 0;
60001578:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000157c:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001580:	f8c3 7128 	str.w	r7, [r3, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001584:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001588:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000158a:	07db      	lsls	r3, r3, #31
6000158c:	d408      	bmi.n	600015a0 <ResetHandler2+0x170>
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000158e:	f642 6315 	movw	r3, #11797	; 0x2e15
		SNVS_LPSRTCLR = 1546300800u << 15;
60001592:	4928      	ldr	r1, [pc, #160]	; (60001634 <ResetHandler2+0x204>)
60001594:	6551      	str	r1, [r2, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001596:	6513      	str	r3, [r2, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001598:	6b93      	ldr	r3, [r2, #56]	; 0x38
6000159a:	f043 0301 	orr.w	r3, r3, #1
6000159e:	6393      	str	r3, [r2, #56]	; 0x38
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600015a0:	4a23      	ldr	r2, [pc, #140]	; (60001630 <ResetHandler2+0x200>)
600015a2:	4c25      	ldr	r4, [pc, #148]	; (60001638 <ResetHandler2+0x208>)
600015a4:	6893      	ldr	r3, [r2, #8]
600015a6:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
600015aa:	6093      	str	r3, [r2, #8]
	analog_init();
600015ac:	f000 fa54 	bl	60001a58 <analog_init>
	pwm_init();
600015b0:	f000 fa86 	bl	60001ac0 <__pwm_init_veneer>
	tempmon_init();
600015b4:	f000 f91a 	bl	600017ec <tempmon_init>
	startup_middle_hook();
600015b8:	f000 f85c 	bl	60001674 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015bc:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015be:	2b13      	cmp	r3, #19
600015c0:	d9fc      	bls.n	600015bc <ResetHandler2+0x18c>
	usb_init();
600015c2:	f000 f9ab 	bl	6000191c <usb_init>
600015c6:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015c8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015cc:	d3fb      	bcc.n	600015c6 <ResetHandler2+0x196>
	startup_debug_reset();
600015ce:	f000 f855 	bl	6000167c <startup_debug_reset>
	startup_late_hook();
600015d2:	f000 f851 	bl	60001678 <startup_default_late_hook>
	__libc_init_array();
600015d6:	f000 fa7b 	bl	60001ad0 <____libc_init_array_veneer>
	main();
600015da:	f000 fa7d 	bl	60001ad8 <__main_veneer>
	while (1) asm("WFI");
600015de:	bf30      	wfi
600015e0:	e7fd      	b.n	600015de <ResetHandler2+0x1ae>
600015e2:	bf00      	nop
600015e4:	400d8000 	.word	0x400d8000
600015e8:	0000df80 	.word	0x0000df80
600015ec:	60001c14 	.word	0x60001c14
600015f0:	00000000 	.word	0x00000000
600015f4:	20001ec0 	.word	0x20001ec0
600015f8:	6000fb98 	.word	0x6000fb98
600015fc:	20000000 	.word	0x20000000
60001600:	20001c00 	.word	0x20001c00
60001604:	000068fd 	.word	0x000068fd
60001608:	e000e400 	.word	0xe000e400
6000160c:	e000e4a0 	.word	0xe000e4a0
60001610:	400ac000 	.word	0x400ac000
60001614:	000051e1 	.word	0x000051e1
60001618:	2000a5a4 	.word	0x2000a5a4
6000161c:	000051e5 	.word	0x000051e5
60001620:	20200000 	.word	0x20200000
60001624:	e0001000 	.word	0xe0001000
60001628:	016e3600 	.word	0x016e3600
6000162c:	40084000 	.word	0x40084000
60001630:	400d4000 	.word	0x400d4000
60001634:	56c00000 	.word	0x56c00000
60001638:	2000a5a8 	.word	0x2000a5a8
6000163c:	2018101b 	.word	0x2018101b
60001640:	13110d0c 	.word	0x13110d0c
60001644:	400fc000 	.word	0x400fc000

60001648 <ResetHandler>:
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001648:	4b05      	ldr	r3, [pc, #20]	; (60001660 <ResetHandler+0x18>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000164a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000164e:	4a05      	ldr	r2, [pc, #20]	; (60001664 <ResetHandler+0x1c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001650:	4805      	ldr	r0, [pc, #20]	; (60001668 <ResetHandler+0x20>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001652:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001654:	6418      	str	r0, [r3, #64]	; 0x40
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : "memory");
60001656:	4a05      	ldr	r2, [pc, #20]	; (6000166c <ResetHandler+0x24>)
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001658:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : "memory");
6000165a:	4695      	mov	sp, r2
	ResetHandler2();
6000165c:	f7ff fee8 	bl	60001430 <ResetHandler2>
60001660:	400ac000 	.word	0x400ac000
60001664:	aaaaaaaf 	.word	0xaaaaaaaf
60001668:	00200007 	.word	0x00200007
6000166c:	20070000 	.word	0x20070000

60001670 <startup_default_early_hook>:
FLASHMEM void startup_default_early_hook(void) {}
60001670:	4770      	bx	lr
60001672:	bf00      	nop

60001674 <startup_default_middle_hook>:
60001674:	4770      	bx	lr
60001676:	bf00      	nop

60001678 <startup_default_late_hook>:
60001678:	4770      	bx	lr
6000167a:	bf00      	nop

6000167c <startup_debug_reset>:
FLASHMEM void startup_debug_reset(void) { __asm__ volatile("nop"); }
6000167c:	bf00      	nop
6000167e:	4770      	bx	lr

60001680 <configure_cache>:
{
60001680:	b410      	push	{r4}
	SCB_MPU_CTRL = 0; // turn off MPU
60001682:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60001686:	2100      	movs	r1, #0
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001688:	2410      	movs	r4, #16
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
6000168a:	4831      	ldr	r0, [pc, #196]	; (60001750 <configure_cache+0xd0>)
	SCB_MPU_CTRL = 0; // turn off MPU
6000168c:	f8c3 1d94 	str.w	r1, [r3, #3476]	; 0xd94
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001690:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001694:	2411      	movs	r4, #17
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001696:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_NOCACHE | READONLY | SIZE_512K;
6000169a:	482e      	ldr	r0, [pc, #184]	; (60001754 <configure_cache+0xd4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
6000169c:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016a0:	2412      	movs	r4, #18
	SCB_MPU_RASR = MEM_NOCACHE | READONLY | SIZE_512K;
600016a2:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016a6:	482c      	ldr	r0, [pc, #176]	; (60001758 <configure_cache+0xd8>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016a8:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ac:	4a2b      	ldr	r2, [pc, #172]	; (6000175c <configure_cache+0xdc>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ae:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016b2:	4c2b      	ldr	r4, [pc, #172]	; (60001760 <configure_cache+0xe0>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016b4:	f042 0215 	orr.w	r2, r2, #21
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016b8:	482a      	ldr	r0, [pc, #168]	; (60001764 <configure_cache+0xe4>)
	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016ba:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016be:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016c2:	4c29      	ldr	r4, [pc, #164]	; (60001768 <configure_cache+0xe8>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016c4:	4829      	ldr	r0, [pc, #164]	; (6000176c <configure_cache+0xec>)
	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016c6:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016ca:	f8c3 0da0 	str.w	r0, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016ce:	4c28      	ldr	r4, [pc, #160]	; (60001770 <configure_cache+0xf0>)
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016d0:	f8c3 2d9c 	str.w	r2, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016d4:	4827      	ldr	r0, [pc, #156]	; (60001774 <configure_cache+0xf4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016d6:	4a28      	ldr	r2, [pc, #160]	; (60001778 <configure_cache+0xf8>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600016d8:	f8c3 4da0 	str.w	r4, [r3, #3488]	; 0xda0
	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600016dc:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600016e0:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016e4:	f502 22a0 	add.w	r2, r2, #327680	; 0x50000
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016e8:	4c24      	ldr	r4, [pc, #144]	; (6000177c <configure_cache+0xfc>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016ea:	320c      	adds	r2, #12
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016ec:	4824      	ldr	r0, [pc, #144]	; (60001780 <configure_cache+0x100>)
	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600016ee:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600016f2:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016f6:	4a23      	ldr	r2, [pc, #140]	; (60001784 <configure_cache+0x104>)
	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600016f8:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600016fc:	4c22      	ldr	r4, [pc, #136]	; (60001788 <configure_cache+0x108>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600016fe:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001702:	f102 6240 	add.w	r2, r2, #201326592	; 0xc000000
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001706:	f8c3 4d9c 	str.w	r4, [r3, #3484]	; 0xd9c
	SCB_MPU_RBAR = 0x80000000 | REGION(i++); // SEMC: SDRAM, NAND, SRAM, etc
6000170a:	4820      	ldr	r0, [pc, #128]	; (6000178c <configure_cache+0x10c>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000170c:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1G;
60001710:	320c      	adds	r2, #12
	SCB_MPU_RBAR = 0x80000000 | REGION(i++); // SEMC: SDRAM, NAND, SRAM, etc
60001712:	f8c3 0d9c 	str.w	r0, [r3, #3484]	; 0xd9c
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1G;
60001716:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
	asm("nop"); // allow a few cycles for bus writes before enable MPU
6000171a:	bf00      	nop
	asm("nop");
6000171c:	bf00      	nop
	asm("nop");
6000171e:	bf00      	nop
	asm("nop");
60001720:	bf00      	nop
	asm("nop");
60001722:	bf00      	nop
	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001724:	2201      	movs	r2, #1
60001726:	f8c3 2d94 	str.w	r2, [r3, #3476]	; 0xd94
	asm("dsb");
6000172a:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172e:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001732:	f8c3 1f50 	str.w	r1, [r3, #3920]	; 0xf50
	asm("dsb");
60001736:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000173a:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173e:	f8d3 2d14 	ldr.w	r2, [r3, #3348]	; 0xd14
}
60001742:	f85d 4b04 	ldr.w	r4, [sp], #4
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
60001746:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
6000174a:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
}
6000174e:	4770      	bx	lr
60001750:	1000003f 	.word	0x1000003f
60001754:	07080025 	.word	0x07080025
60001758:	00100009 	.word	0x00100009
6000175c:	2000a760 	.word	0x2000a760
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	60000018 	.word	0x60000018
60001784:	070b002f 	.word	0x070b002f
60001788:	70000019 	.word	0x70000019
6000178c:	8000001a 	.word	0x8000001a

60001790 <usb_pll_start>:
{
60001790:	b4f0      	push	{r4, r5, r6, r7}
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001792:	4a15      	ldr	r2, [pc, #84]	; (600017e8 <usb_pll_start+0x58>)
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001794:	2740      	movs	r7, #64	; 0x40
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001796:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000179a:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000179e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
600017a2:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
600017a6:	f243 0042 	movw	r0, #12354	; 0x3042
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
600017aa:	6913      	ldr	r3, [r2, #16]
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
600017ac:	f013 0f02 	tst.w	r3, #2
600017b0:	d10e      	bne.n	600017d0 <usb_pll_start+0x40>
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
600017b2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
600017b6:	d00f      	beq.n	600017d8 <usb_pll_start+0x48>
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
600017b8:	f413 5f80 	tst.w	r3, #4096	; 0x1000
600017bc:	d00e      	beq.n	600017dc <usb_pll_start+0x4c>
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
600017be:	2b00      	cmp	r3, #0
600017c0:	daf3      	bge.n	600017aa <usb_pll_start+0x1a>
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
600017c2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
600017c6:	d10b      	bne.n	600017e0 <usb_pll_start+0x50>
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
600017c8:	065b      	lsls	r3, r3, #25
600017ca:	d50b      	bpl.n	600017e4 <usb_pll_start+0x54>
}
600017cc:	bcf0      	pop	{r4, r5, r6, r7}
600017ce:	4770      	bx	lr
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
600017d0:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
600017d2:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
600017d4:	6190      	str	r0, [r2, #24]
			continue;
600017d6:	e7e8      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
600017d8:	6155      	str	r5, [r2, #20]
			continue;
600017da:	e7e6      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
600017dc:	6156      	str	r6, [r2, #20]
			continue;
600017de:	e7e4      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600017e0:	6191      	str	r1, [r2, #24]
			continue;
600017e2:	e7e2      	b.n	600017aa <usb_pll_start+0x1a>
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600017e4:	6157      	str	r7, [r2, #20]
			continue;
600017e6:	e7e0      	b.n	600017aa <usb_pll_start+0x1a>
600017e8:	400d8000 	.word	0x400d8000

600017ec <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017ec:	4a3f      	ldr	r2, [pc, #252]	; (600018ec <tempmon_init+0x100>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600017ee:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600017f0:	493f      	ldr	r1, [pc, #252]	; (600018f0 <tempmon_init+0x104>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
600017f2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600017f6:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600017fa:	f04f 0c00 	mov.w	ip, #0
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600017fe:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 600018f4 <tempmon_init+0x108>
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001802:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001806:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 600018f8 <tempmon_init+0x10c>
{
6000180a:	b430      	push	{r4, r5}
  TEMPMON_TEMPSENSE0 &= ~0x1U;
6000180c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001810:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  calibrationData = HW_OCOTP_ANA1;
60001814:	f8d1 10e0 	ldr.w	r1, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001818:	4d38      	ldr	r5, [pc, #224]	; (600018fc <tempmon_init+0x110>)
6000181a:	b2cb      	uxtb	r3, r1
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
6000181c:	4c38      	ldr	r4, [pc, #224]	; (60001900 <tempmon_init+0x114>)
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000181e:	4839      	ldr	r0, [pc, #228]	; (60001904 <tempmon_init+0x118>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001820:	602b      	str	r3, [r5, #0]
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001822:	ee07 3a90 	vmov	s15, r3
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
60001826:	0d0b      	lsrs	r3, r1, #20
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001828:	f3c1 210b 	ubfx	r1, r1, #8, #12
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000182c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
60001830:	ee06 3a90 	vmov	s13, r3
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001834:	ee07 1a10 	vmov	s14, r1
60001838:	4b33      	ldr	r3, [pc, #204]	; (60001908 <tempmon_init+0x11c>)
6000183a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
6000183e:	6021      	str	r1, [r4, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001840:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001844:	4931      	ldr	r1, [pc, #196]	; (6000190c <tempmon_init+0x120>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001846:	ee37 6ac6 	vsub.f32	s12, s15, s12
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000184a:	ee37 5ac5 	vsub.f32	s10, s15, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
6000184e:	ee76 6ac7 	vsub.f32	s13, s13, s14
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001852:	ee77 7ae5 	vsub.f32	s15, s15, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001856:	ee26 6a26 	vmul.f32	s12, s12, s13
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
6000185a:	edc3 6a00 	vstr	s13, [r3]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000185e:	ee25 5a26 	vmul.f32	s10, s10, s13
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001862:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001866:	ee67 4aa6 	vmul.f32	s9, s15, s13
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
6000186a:	edc0 7a00 	vstr	s15, [r0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000186e:	eec6 5a27 	vdiv.f32	s11, s12, s15
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001872:	4827      	ldr	r0, [pc, #156]	; (60001910 <tempmon_init+0x124>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001874:	ee85 6a27 	vdiv.f32	s12, s10, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001878:	eec4 6aa7 	vdiv.f32	s13, s9, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000187c:	ee75 5a87 	vadd.f32	s11, s11, s14
60001880:	eefc 5ae5 	vcvt.u32.f32	s11, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001884:	ee36 6a07 	vadd.f32	s12, s12, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001888:	ee15 4a90 	vmov	r4, s11
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000188c:	eebc 6ac6 	vcvt.u32.f32	s12, s12
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001890:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001894:	ee76 7a87 	vadd.f32	s15, s13, s14
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001898:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000189c:	ee16 3a10 	vmov	r3, s12
600018a0:	f8d2 4190 	ldr.w	r4, [r2, #400]	; 0x190
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018a4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600018a8:	ea01 4103 	and.w	r1, r1, r3, lsl #16
600018ac:	4321      	orrs	r1, r4
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018ae:	ee17 3a90 	vmov	r3, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
600018b2:	f8c2 1190 	str.w	r1, [r2, #400]	; 0x190
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600018b6:	f3c3 030b 	ubfx	r3, r3, #0, #12
600018ba:	f8d2 1190 	ldr.w	r1, [r2, #400]	; 0x190
600018be:	430b      	orrs	r3, r1
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
600018c0:	4914      	ldr	r1, [pc, #80]	; (60001914 <tempmon_init+0x128>)
600018c2:	f8c2 3190 	str.w	r3, [r2, #400]	; 0x190
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
600018c6:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
600018ca:	f043 0302 	orr.w	r3, r3, #2
600018ce:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
600018d2:	4b11      	ldr	r3, [pc, #68]	; (60001918 <tempmon_init+0x12c>)
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600018d4:	f880 c040 	strb.w	ip, [r0, #64]	; 0x40
600018d8:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018dc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
600018e0:	2201      	movs	r2, #1
}
600018e2:	bc30      	pop	{r4, r5}
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600018e4:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
}
600018e8:	4770      	bx	lr
600018ea:	bf00      	nop
600018ec:	400d8100 	.word	0x400d8100
600018f0:	401f4400 	.word	0x401f4400
600018f4:	42aa0000 	.word	0x42aa0000
600018f8:	42b40000 	.word	0x42b40000
600018fc:	2000a550 	.word	0x2000a550
60001900:	2000a54c 	.word	0x2000a54c
60001904:	2000a554 	.word	0x2000a554
60001908:	2000a558 	.word	0x2000a558
6000190c:	0fff0000 	.word	0x0fff0000
60001910:	e000e400 	.word	0xe000e400
60001914:	20001c00 	.word	0x20001c00
60001918:	00006ae5 	.word	0x00006ae5

6000191c <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
6000191c:	4b31      	ldr	r3, [pc, #196]	; (600019e4 <usb_init+0xc8>)
6000191e:	f640 7261 	movw	r2, #3937	; 0xf61
{
60001922:	b510      	push	{r4, lr}
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001924:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001928:	f240 4404 	movw	r4, #1028	; 0x404
	usb_init_serialnumber();
6000192c:	f000 f8dc 	bl	60001ae8 <__usb_init_serialnumber_veneer>
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001930:	4a2d      	ldr	r2, [pc, #180]	; (600019e8 <usb_init+0xcc>)
	USB1_BURSTSIZE = 0x0404;
60001932:	492e      	ldr	r1, [pc, #184]	; (600019ec <usb_init+0xd0>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001934:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001938:	482d      	ldr	r0, [pc, #180]	; (600019f0 <usb_init+0xd4>)
	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
6000193a:	f043 0303 	orr.w	r3, r3, #3
6000193e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001942:	4b2c      	ldr	r3, [pc, #176]	; (600019f4 <usb_init+0xd8>)
	USB1_BURSTSIZE = 0x0404;
60001944:	f8c1 4160 	str.w	r4, [r1, #352]	; 0x160
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001948:	6802      	ldr	r2, [r0, #0]
6000194a:	421a      	tst	r2, r3
6000194c:	d103      	bne.n	60001956 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
6000194e:	f8d1 31a8 	ldr.w	r3, [r1, #424]	; 0x1a8
60001952:	079a      	lsls	r2, r3, #30
60001954:	d01b      	beq.n	6000198e <usb_init+0x72>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001956:	4a25      	ldr	r2, [pc, #148]	; (600019ec <usb_init+0xd0>)
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001958:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
6000195c:	4b24      	ldr	r3, [pc, #144]	; (600019f0 <usb_init+0xd4>)
6000195e:	6359      	str	r1, [r3, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001960:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001964:	f043 0302 	orr.w	r3, r3, #2
60001968:	f8c2 3140 	str.w	r3, [r2, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
6000196c:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001970:	079b      	lsls	r3, r3, #30
60001972:	d4fb      	bmi.n	6000196c <usb_init+0x50>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001974:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001978:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
6000197c:	4b1c      	ldr	r3, [pc, #112]	; (600019f0 <usb_init+0xd4>)
6000197e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001982:	f8c1 028c 	str.w	r0, [r1, #652]	; 0x28c
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001986:	2019      	movs	r0, #25
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001988:	639a      	str	r2, [r3, #56]	; 0x38
		delay(25);
6000198a:	f000 f8a9 	bl	60001ae0 <__delay_veneer>
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000198e:	4a18      	ldr	r2, [pc, #96]	; (600019f0 <usb_init+0xd4>)
60001990:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001994:	4c15      	ldr	r4, [pc, #84]	; (600019ec <usb_init+0xd0>)
	USBPHY1_PWD = 0;
60001996:	2100      	movs	r1, #0
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001998:	6390      	str	r0, [r2, #56]	; 0x38
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000199a:	200a      	movs	r0, #10
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000199c:	4b16      	ldr	r3, [pc, #88]	; (600019f8 <usb_init+0xdc>)
	USBPHY1_PWD = 0;
6000199e:	6011      	str	r1, [r2, #0]
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
600019a0:	f44f 7220 	mov.w	r2, #640	; 0x280
	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
600019a4:	f8c4 01a8 	str.w	r0, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
600019a8:	4618      	mov	r0, r3
600019aa:	f000 f885 	bl	60001ab8 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
600019ae:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
600019b2:	4603      	mov	r3, r0
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
600019b4:	f44f 0081 	mov.w	r0, #4227072	; 0x408000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
600019b8:	f240 1143 	movw	r1, #323	; 0x143
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
600019bc:	6018      	str	r0, [r3, #0]
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
600019be:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
	endpoint_queue_head[1].config = (64 << 16);
600019c2:	641a      	str	r2, [r3, #64]	; 0x40
600019c4:	4b0d      	ldr	r3, [pc, #52]	; (600019fc <usb_init+0xe0>)
600019c6:	4a0e      	ldr	r2, [pc, #56]	; (60001a00 <usb_init+0xe4>)
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
600019c8:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
600019cc:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
600019d0:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
600019d4:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600019d8:	2301      	movs	r3, #1
	NVIC_ENABLE_IRQ(IRQ_USB1);
600019da:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
	USB1_USBCMD = USB_USBCMD_RS;
600019de:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	//transfer_log_head = 0;
	//transfer_log_count = 0;
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}
600019e2:	bd10      	pop	{r4, pc}
600019e4:	400d8000 	.word	0x400d8000
600019e8:	400fc000 	.word	0x400fc000
600019ec:	402e0000 	.word	0x402e0000
600019f0:	400d9000 	.word	0x400d9000
600019f4:	001e1c00 	.word	0x001e1c00
600019f8:	20000000 	.word	0x20000000
600019fc:	20001c00 	.word	0x20001c00
60001a00:	00006ccd 	.word	0x00006ccd

60001a04 <_reboot_Teensyduino_>:


FLASHMEM __attribute__((noinline)) void _reboot_Teensyduino_(void)
{
60001a04:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001a06:	4b0e      	ldr	r3, [pc, #56]	; (60001a40 <_reboot_Teensyduino_+0x3c>)
60001a08:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001a0a:	079b      	lsls	r3, r3, #30
60001a0c:	d400      	bmi.n	60001a10 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001a0e:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001a10:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001a12:	4b0c      	ldr	r3, [pc, #48]	; (60001a44 <_reboot_Teensyduino_+0x40>)
60001a14:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001a16:	4a0c      	ldr	r2, [pc, #48]	; (60001a48 <_reboot_Teensyduino_+0x44>)
		USB1_USBCMD = 0;
60001a18:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001a1c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
		IOMUXC_GPR_GPR16 = 0x00200003;
60001a20:	490a      	ldr	r1, [pc, #40]	; (60001a4c <_reboot_Teensyduino_+0x48>)
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001a22:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
		IOMUXC_GPR_GPR16 = 0x00200003;
60001a26:	6411      	str	r1, [r2, #64]	; 0x40
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001a28:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001a2a:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a2e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
		*p = 0xEB120000;
60001a32:	4807      	ldr	r0, [pc, #28]	; (60001a50 <_reboot_Teensyduino_+0x4c>)
60001a34:	4a07      	ldr	r2, [pc, #28]	; (60001a54 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a36:	69db      	ldr	r3, [r3, #28]
		*p = 0xEB120000;
60001a38:	6002      	str	r2, [r0, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001a3a:	689b      	ldr	r3, [r3, #8]
60001a3c:	4798      	blx	r3
	}
	__builtin_unreachable();
60001a3e:	bf00      	nop
60001a40:	401f4400 	.word	0x401f4400
60001a44:	402e0000 	.word	0x402e0000
60001a48:	400ac000 	.word	0x400ac000
60001a4c:	00200003 	.word	0x00200003
60001a50:	20208000 	.word	0x20208000
60001a54:	eb120000 	.word	0xeb120000

60001a58 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a58:	4b10      	ldr	r3, [pc, #64]	; (60001a9c <analog_init+0x44>)
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a5a:	20a0      	movs	r0, #160	; 0xa0
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a5c:	4a10      	ldr	r2, [pc, #64]	; (60001aa0 <analog_init+0x48>)
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a5e:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a60:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
{
60001a64:	b410      	push	{r4}
	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001a66:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a68:	f240 6437 	movw	r4, #1591	; 0x637
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001a6c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
60001a6e:	f441 7140 	orr.w	r1, r1, #768	; 0x300
60001a72:	66d9      	str	r1, [r3, #108]	; 0x6c
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001a74:	6454      	str	r4, [r2, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001a76:	6490      	str	r0, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001a78:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a7a:	061b      	lsls	r3, r3, #24
60001a7c:	d4fc      	bmi.n	60001a78 <analog_init+0x20>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a7e:	4a09      	ldr	r2, [pc, #36]	; (60001aa4 <analog_init+0x4c>)
60001a80:	f240 6137 	movw	r1, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a84:	23a0      	movs	r3, #160	; 0xa0
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001a86:	6451      	str	r1, [r2, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001a88:	6493      	str	r3, [r2, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001a8a:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001a8c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001a90:	d1fb      	bne.n	60001a8a <analog_init+0x32>
		//yield();
	}
	calibrating = 0;
60001a92:	4a05      	ldr	r2, [pc, #20]	; (60001aa8 <analog_init+0x50>)
60001a94:	7013      	strb	r3, [r2, #0]
}
60001a96:	f85d 4b04 	ldr.w	r4, [sp], #4
60001a9a:	4770      	bx	lr
60001a9c:	400fc000 	.word	0x400fc000
60001aa0:	400c4000 	.word	0x400c4000
60001aa4:	400c8000 	.word	0x400c8000
60001aa8:	2000a70e 	.word	0x2000a70e

60001aac <_init>:
60001aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60001aae:	bf00      	nop
60001ab0:	bcf8      	pop	{r3, r4, r5, r6, r7}
60001ab2:	bc08      	pop	{r3}
60001ab4:	469e      	mov	lr, r3
60001ab6:	4770      	bx	lr

60001ab8 <__memset_veneer>:
60001ab8:	f85f f000 	ldr.w	pc, [pc]	; 60001abc <__memset_veneer+0x4>
60001abc:	00008a65 	.word	0x00008a65

60001ac0 <__pwm_init_veneer>:
60001ac0:	f85f f000 	ldr.w	pc, [pc]	; 60001ac4 <__pwm_init_veneer+0x4>
60001ac4:	00006809 	.word	0x00006809

60001ac8 <__set_arm_clock_veneer>:
60001ac8:	f85f f000 	ldr.w	pc, [pc]	; 60001acc <__set_arm_clock_veneer+0x4>
60001acc:	00005af5 	.word	0x00005af5

60001ad0 <____libc_init_array_veneer>:
60001ad0:	f85f f000 	ldr.w	pc, [pc]	; 60001ad4 <____libc_init_array_veneer+0x4>
60001ad4:	00008c51 	.word	0x00008c51

60001ad8 <__main_veneer>:
60001ad8:	f85f f000 	ldr.w	pc, [pc]	; 60001adc <__main_veneer+0x4>
60001adc:	00006465 	.word	0x00006465

60001ae0 <__delay_veneer>:
60001ae0:	f85f f000 	ldr.w	pc, [pc]	; 60001ae4 <__delay_veneer+0x4>
60001ae4:	00005de5 	.word	0x00005de5

60001ae8 <__usb_init_serialnumber_veneer>:
60001ae8:	f85f f000 	ldr.w	pc, [pc]	; 60001aec <__usb_init_serialnumber_veneer+0x4>
60001aec:	0000743d 	.word	0x0000743d

60001af0 <__frame_dummy_init_array_entry>:
60001af0:	00000105 00000149 00000435 00000c5d     ....I...5...]...
60001b00:	00000f01 00004e85 00005199              .....N...Q..

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <irq_gpio6789>:
	while (SNVS_HPCR & SNVS_HPCR_RTC_EN); // wait
	// stop the SRTC
	SNVS_LPCR &= ~SNVS_LPCR_SRTC_ENV;
	while (SNVS_LPCR & SNVS_LPCR_SRTC_ENV); // wait
	// set the SRTC
	SNVS_LPSRTCLR = t << 15;
      20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SNVS_LPSRTCMR = t >> 17;
	// start the SRTC
	SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
	while (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)); // wait
      22:	f04f 4384 	mov.w	r3, #1107296256	; 0x42000000
	SNVS_LPSRTCLR = t << 15;
      26:	699d      	ldr	r5, [r3, #24]
	SNVS_LPSRTCMR = t >> 17;
      28:	695a      	ldr	r2, [r3, #20]
	SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
      2a:	4015      	ands	r5, r2
      2c:	d00d      	beq.n	4a <_teensy_model_identifier+0x26>
      2e:	4f25      	ldr	r7, [pc, #148]	; (c4 <_teensy_model_identifier+0xa0>)
      30:	2601      	movs	r6, #1
	while (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)); // wait
      32:	619d      	str	r5, [r3, #24]
      34:	fa95 f4a5 	rbit	r4, r5
	// start the RTC and sync it to the SRTC
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
      38:	fab4 f484 	clz	r4, r4
      3c:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
}
      40:	fa06 f404 	lsl.w	r4, r6, r4
      44:	4798      	blx	r3
      46:	43a5      	bics	r5, r4
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
	return usec;
}
      48:	d1f4      	bne.n	34 <_teensy_model_identifier+0x10>
      4a:	4b1f      	ldr	r3, [pc, #124]	; (c8 <_teensy_model_identifier+0xa4>)
      4c:	699d      	ldr	r5, [r3, #24]
      4e:	695a      	ldr	r2, [r3, #20]
      50:	4015      	ands	r5, r2
      52:	d00d      	beq.n	70 <_teensy_model_identifier+0x4c>
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      54:	4f1d      	ldr	r7, [pc, #116]	; (cc <_teensy_model_identifier+0xa8>)
      56:	2601      	movs	r6, #1
      58:	619d      	str	r5, [r3, #24]
      5a:	fa95 f4a5 	rbit	r4, r5
}
      5e:	fab4 f484 	clz	r4, r4
      62:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      66:	fa06 f404 	lsl.w	r4, r6, r4
      6a:	4798      	blx	r3
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
		MillisTimer *next = waiting->_next;
      6c:	43a5      	bics	r5, r4
		waiting->addToActiveList();
      6e:	d1f4      	bne.n	5a <_teensy_model_identifier+0x36>
      70:	4b17      	ldr	r3, [pc, #92]	; (d0 <_teensy_model_identifier+0xac>)
	while (waiting) {
      72:	699d      	ldr	r5, [r3, #24]
      74:	695a      	ldr	r2, [r3, #20]
		waiting = next;
	}
}
      76:	4015      	ands	r5, r2
			event.triggerEvent(0, timer);
      78:	d00d      	beq.n	96 <_teensy_model_identifier+0x72>
      7a:	4f16      	ldr	r7, [pc, #88]	; (d4 <_teensy_model_identifier+0xb0>)
      7c:	2601      	movs	r6, #1
      7e:	619d      	str	r5, [r3, #24]
			timer->_ms--;
      80:	fa95 f4a5 	rbit	r4, r5
			break;
      84:	fab4 f484 	clz	r4, r4
      88:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      8c:	fa06 f404 	lsl.w	r4, r6, r4
      90:	4798      	blx	r3
      92:	43a5      	bics	r5, r4
	if(!(ch & 0x80)) {
      94:	d1f4      	bne.n	80 <_teensy_model_identifier+0x5c>
      96:	4b10      	ldr	r3, [pc, #64]	; (d8 <_teensy_model_identifier+0xb4>)
	if (pin > sizeof(pin_to_channel)) return 0;
      98:	699d      	ldr	r5, [r3, #24]
}
      9a:	695a      	ldr	r2, [r3, #20]
      9c:	4015      	ands	r5, r2
      9e:	d00d      	beq.n	bc <_teensy_model_identifier+0x98>
      a0:	4f0e      	ldr	r7, [pc, #56]	; (dc <_teensy_model_identifier+0xb8>)
      a2:	2601      	movs	r6, #1
      a4:	619d      	str	r5, [r3, #24]
      a6:	fa95 f4a5 	rbit	r4, r5
      aa:	fab4 f484 	clz	r4, r4
      ae:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FF8000;
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
	flash_wait();
      b2:	fa06 f404 	lsl.w	r4, r6, r4
      b6:	4798      	blx	r3
      b8:	43a5      	bics	r5, r4
      ba:	d1f4      	bne.n	a6 <_teensy_model_identifier+0x82>
{
	irq_anyport(&GPIO6_DR, isr_table_gpio1);
	irq_anyport(&GPIO7_DR, isr_table_gpio2);
	irq_anyport(&GPIO8_DR, isr_table_gpio3);
	irq_anyport(&GPIO9_DR, isr_table_gpio4);
	asm volatile ("dsb":::"memory");
      bc:	f3bf 8f4f 	dsb	sy
}
      c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      c2:	bf00      	nop
      c4:	20001784 	.word	0x20001784
      c8:	42004000 	.word	0x42004000
      cc:	20001804 	.word	0x20001804
      d0:	42008000 	.word	0x42008000
      d4:	20001884 	.word	0x20001884
      d8:	4200c000 	.word	0x4200c000
      dc:	20001904 	.word	0x20001904

000000e0 <register_tm_clones>:
    else if(c == '-')
      isNegative = true;
    else if (c == '.')
      isFraction = true;
    else if(c >= '0' && c <= '9')  {      // is c a digit?
      value = value * 10 + c - '0';
      e0:	4805      	ldr	r0, [pc, #20]	; (f8 <register_tm_clones+0x18>)
      e2:	4b06      	ldr	r3, [pc, #24]	; (fc <register_tm_clones+0x1c>)
      e4:	1a1b      	subs	r3, r3, r0
      e6:	0fd9      	lsrs	r1, r3, #31
      if(isFraction)
      e8:	eb01 01a3 	add.w	r1, r1, r3, asr #2
      ec:	1049      	asrs	r1, r1, #1
         fraction *= 0.1;
      ee:	d002      	beq.n	f6 <register_tm_clones+0x16>
      f0:	4b03      	ldr	r3, [pc, #12]	; (100 <register_tm_clones+0x20>)
      f2:	b103      	cbz	r3, f6 <register_tm_clones+0x16>
      f4:	4718      	bx	r3
      f6:	4770      	bx	lr
      f8:	20001ec0 	.word	0x20001ec0
    return 0; // zero returned if timeout
      fc:	20001ec0 	.word	0x20001ec0
    value = -value;
  if(isFraction)
    return value * fraction;
  else
    return value;
}
     100:	00000000 	.word	0x00000000

00000104 <frame_dummy>:
     104:	b508      	push	{r3, lr}
     106:	4b05      	ldr	r3, [pc, #20]	; (11c <frame_dummy+0x18>)
     108:	b11b      	cbz	r3, 112 <frame_dummy+0xe>
     10a:	4905      	ldr	r1, [pc, #20]	; (120 <frame_dummy+0x1c>)
     10c:	4805      	ldr	r0, [pc, #20]	; (124 <frame_dummy+0x20>)
     10e:	f3af 8000 	nop.w
     112:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     116:	f7ff bfe3 	b.w	e0 <register_tm_clones>
     11a:	bf00      	nop
     11c:	00000000 	.word	0x00000000
     120:	2000a4f8 	.word	0x2000a4f8
     124:	60012800 	.word	0x60012800

00000128 <printMode(void*)>:
uint32_t lastTransmission = 0;
bool btConnected = false;

auto timer = timer_create_default();

bool printMode(void *params) {
     128:	b508      	push	{r3, lr}
  Serial.printf("OpenHaldex mode=%d\n", state.mode);
     12a:	4b04      	ldr	r3, [pc, #16]	; (13c <printMode(void*)+0x14>)
     12c:	4904      	ldr	r1, [pc, #16]	; (140 <printMode(void*)+0x18>)
     12e:	781a      	ldrb	r2, [r3, #0]
     130:	4804      	ldr	r0, [pc, #16]	; (144 <printMode(void*)+0x1c>)
     132:	f005 fc75 	bl	5a20 <Print::printf(char const*, ...)>
  return true;
}
     136:	2001      	movs	r0, #1
     138:	bd08      	pop	{r3, pc}
     13a:	bf00      	nop
     13c:	2000a580 	.word	0x2000a580
     140:	20000690 	.word	0x20000690
     144:	20001110 	.word	0x20001110

00000148 <_GLOBAL__sub_I_state>:
    btInit();  // can't have BT_Conf as an interrupt and change the pin state...
  }

  // light up the LED as per the 'state.mode'
  LED();
}
     148:	b508      	push	{r3, lr}
***/

struct EEPROMClass{

#if defined(__arm__) && defined(TEENSYDUINO)
    EEPROMClass()                        { eeprom_initialize(); }
     14a:	f005 ff41 	bl	5fd0 <eeprom_initialize>
        }

        return true;
    }

    Timer() : tasks{} {}
     14e:	f44f 72a0 	mov.w	r2, #320	; 0x140
     152:	2100      	movs	r1, #0
     154:	4801      	ldr	r0, [pc, #4]	; (15c <_GLOBAL__sub_I_state+0x14>)
     156:	f008 fc85 	bl	8a64 <memset>
     15a:	bd08      	pop	{r3, pc}
     15c:	2000a5b0 	.word	0x2000a5b0

00000160 <setup>:
			remainder -= n; 
		}
		count += write(buf, count);
	}
	return count;
}
     160:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	// is always initialized early during startup.  The baud rate setting
	// is not used.  Communication occurs at USB native speed.  For
	// compatibility with Arduino code, Serial.begin waits up to 2 seconds
	// for your PC to open the virtual serial port.
        void begin(long baud_unused __attribute__((unused))) {
		uint32_t millis_begin = systick_millis_count;
     164:	4d5f      	ldr	r5, [pc, #380]	; (2e4 <setup+0x184>)
				// Wait up to 2 seconds for Arduino Serial Monitor
				if (elapsed > 2000) break;
			} else {
				// But wait only 3/4 second if there is no sign the
				// USB host has begun the USB enumeration process.
				if (elapsed > 750) break;
     166:	f240 28ee 	movw	r8, #750	; 0x2ee
     16a:	4c5f      	ldr	r4, [pc, #380]	; (2e8 <setup+0x188>)
	// Testing Serial as a boolean indicates whether USB is active and a program
	// running on your PC has raised the DTR signal, which typically means it has
	// opened the port and is ready to communicate.
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     16c:	4f5f      	ldr	r7, [pc, #380]	; (2ec <setup+0x18c>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     16e:	f8df 91b8 	ldr.w	r9, [pc, #440]	; 328 <setup+0x1c8>
		uint32_t millis_begin = systick_millis_count;
     172:	682e      	ldr	r6, [r5, #0]
		yield();
     174:	f007 fd44 	bl	7c00 <yield>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     178:	7823      	ldrb	r3, [r4, #0]
     17a:	2b00      	cmp	r3, #0
     17c:	d07d      	beq.n	27a <setup+0x11a>
     17e:	783b      	ldrb	r3, [r7, #0]
     180:	07db      	lsls	r3, r3, #31
     182:	d57a      	bpl.n	27a <setup+0x11a>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     184:	682b      	ldr	r3, [r5, #0]
     186:	f8d9 2000 	ldr.w	r2, [r9]
     18a:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     18c:	2b0e      	cmp	r3, #14
     18e:	d974      	bls.n	27a <setup+0x11a>
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     190:	2124      	movs	r1, #36	; 0x24
     192:	4857      	ldr	r0, [pc, #348]	; (2f0 <setup+0x190>)
     194:	f007 fcb6 	bl	7b04 <usb_serial_write>
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
	// Print a string and newline
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     198:	4856      	ldr	r0, [pc, #344]	; (2f4 <setup+0x194>)
     19a:	f005 fc25 	bl	59e8 <Print::println()>
  Serial.printf("Running at %dMHz\r\n", F_CPU_ACTUAL / (1000 * 1000));
     19e:	4a56      	ldr	r2, [pc, #344]	; (2f8 <setup+0x198>)
     1a0:	4b56      	ldr	r3, [pc, #344]	; (2fc <setup+0x19c>)
     1a2:	6812      	ldr	r2, [r2, #0]
     1a4:	4956      	ldr	r1, [pc, #344]	; (300 <setup+0x1a0>)
     1a6:	fba3 3202 	umull	r3, r2, r3, r2
     1aa:	4852      	ldr	r0, [pc, #328]	; (2f4 <setup+0x194>)
     1ac:	0c92      	lsrs	r2, r2, #18
     1ae:	f005 fc37 	bl	5a20 <Print::printf(char const*, ...)>
  Serial2.begin(baudBT);
     1b2:	2200      	movs	r2, #0
     1b4:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     1b8:	4852      	ldr	r0, [pc, #328]	; (304 <setup+0x1a4>)
     1ba:	f005 f913 	bl	53e4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>
     1be:	2117      	movs	r1, #23
     1c0:	4851      	ldr	r0, [pc, #324]	; (308 <setup+0x1a8>)
     1c2:	f007 fc9f 	bl	7b04 <usb_serial_write>
     1c6:	484b      	ldr	r0, [pc, #300]	; (2f4 <setup+0x194>)
     1c8:	f005 fc0e 	bl	59e8 <Print::println()>
  pinMode(LED_BUILTIN, OUTPUT);
     1cc:	2101      	movs	r1, #1
     1ce:	200d      	movs	r0, #13
     1d0:	f005 fe98 	bl	5f04 <pinMode>
  canInit();
     1d4:	f002 fc0c 	bl	29f0 <canInit()>
  readEEP();
     1d8:	f004 feb6 	bl	4f48 <readEEP()>
  pinMode(pinLED_R, OUTPUT);
     1dc:	2101      	movs	r1, #1
     1de:	200c      	movs	r0, #12
     1e0:	f005 fe90 	bl	5f04 <pinMode>
  pinMode(pinLED_G, OUTPUT);
     1e4:	2101      	movs	r1, #1
     1e6:	200a      	movs	r0, #10
     1e8:	f005 fe8c 	bl	5f04 <pinMode>
  pinMode(pinLED_B, OUTPUT);
     1ec:	2101      	movs	r1, #1
     1ee:	200b      	movs	r0, #11
     1f0:	f005 fe88 	bl	5f04 <pinMode>
  attachInterrupt(pinSwitchMode, checkSwitchMode, HIGH);
     1f4:	2201      	movs	r2, #1
     1f6:	4945      	ldr	r1, [pc, #276]	; (30c <setup+0x1ac>)
     1f8:	2011      	movs	r0, #17
     1fa:	f006 f8b1 	bl	6360 <attachInterrupt>
  pinMode(pinBT_Conf, INPUT);
     1fe:	2100      	movs	r1, #0
     200:	2004      	movs	r0, #4
     202:	f005 fe7f 	bl	5f04 <pinMode>

    inline
    struct task *
    next_task_slot()
    {
        timer_foreach_task(slot) {
     206:	4b42      	ldr	r3, [pc, #264]	; (310 <setup+0x1b0>)
     208:	6828      	ldr	r0, [r5, #0]
     20a:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     20e:	681a      	ldr	r2, [r3, #0]
     210:	2a00      	cmp	r2, #0
     212:	d048      	beq.n	2a6 <setup+0x146>
        timer_foreach_task(slot) {
     214:	3314      	adds	r3, #20
     216:	428b      	cmp	r3, r1
     218:	d1f9      	bne.n	20e <setup+0xae>
     21a:	4b3d      	ldr	r3, [pc, #244]	; (310 <setup+0x1b0>)
     21c:	6828      	ldr	r0, [r5, #0]
     21e:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     222:	681a      	ldr	r2, [r3, #0]
     224:	2a00      	cmp	r2, #0
     226:	d052      	beq.n	2ce <setup+0x16e>
        timer_foreach_task(slot) {
     228:	3314      	adds	r3, #20
     22a:	428b      	cmp	r3, r1
     22c:	d1f9      	bne.n	222 <setup+0xc2>
     22e:	4b38      	ldr	r3, [pc, #224]	; (310 <setup+0x1b0>)
     230:	6828      	ldr	r0, [r5, #0]
     232:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     236:	681a      	ldr	r2, [r3, #0]
     238:	2a00      	cmp	r2, #0
     23a:	d03e      	beq.n	2ba <setup+0x15a>
        timer_foreach_task(slot) {
     23c:	3314      	adds	r3, #20
     23e:	428b      	cmp	r3, r1
     240:	d1f9      	bne.n	236 <setup+0xd6>
     242:	4b33      	ldr	r3, [pc, #204]	; (310 <setup+0x1b0>)
     244:	6828      	ldr	r0, [r5, #0]
     246:	f503 71a0 	add.w	r1, r3, #320	; 0x140
            if (slot->handler == NULL) return slot;
     24a:	681a      	ldr	r2, [r3, #0]
     24c:	b312      	cbz	r2, 294 <setup+0x134>
        timer_foreach_task(slot) {
     24e:	3314      	adds	r3, #20
     250:	428b      	cmp	r3, r1
     252:	d1fa      	bne.n	24a <setup+0xea>
  CCM_ANALOG_PLL_AUDIO |= CCM_ANALOG_PLL_AUDIO_POWERDOWN;
     254:	4b2f      	ldr	r3, [pc, #188]	; (314 <setup+0x1b4>)
     256:	6f1a      	ldr	r2, [r3, #112]	; 0x70
     258:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     25c:	671a      	str	r2, [r3, #112]	; 0x70
  CCM_ANALOG_PLL_VIDEO |= CCM_ANALOG_PLL_VIDEO_POWERDOWN;
     25e:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
     262:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     266:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  CCM_ANALOG_PLL_ENET |= CCM_ANALOG_PLL_ENET_POWERDOWN;
     26a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
     26e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
     272:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
}
     276:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			uint32_t elapsed = systick_millis_count - millis_begin;
     27a:	682b      	ldr	r3, [r5, #0]
			if (usb_configuration) {
     27c:	7822      	ldrb	r2, [r4, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
     27e:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
     280:	b12a      	cbz	r2, 28e <setup+0x12e>
				if (elapsed > 2000) break;
     282:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
     286:	d883      	bhi.n	190 <setup+0x30>
			yield();
     288:	f007 fcba 	bl	7c00 <yield>
     28c:	e772      	b.n	174 <setup+0x14>
				if (elapsed > 750) break;
     28e:	4543      	cmp	r3, r8
     290:	d9fa      	bls.n	288 <setup+0x128>
     292:	e77d      	b.n	190 <setup+0x30>
    {
        struct task * const slot = next_task_slot();

        if (!slot) return NULL;

        slot->handler = h;
     294:	4c20      	ldr	r4, [pc, #128]	; (318 <setup+0x1b8>)
        slot->opaque = opaque;
        slot->start = start;
        slot->expires = expires;
     296:	2132      	movs	r1, #50	; 0x32
        slot->start = start;
     298:	e9c3 2001 	strd	r2, r0, [r3, #4]
        slot->repeat = repeat;
     29c:	2201      	movs	r2, #1
        slot->handler = h;
     29e:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     2a0:	e9c3 1203 	strd	r1, r2, [r3, #12]

        return slot;
     2a4:	e7d6      	b.n	254 <setup+0xf4>
        slot->handler = h;
     2a6:	4c1d      	ldr	r4, [pc, #116]	; (31c <setup+0x1bc>)
        slot->expires = expires;
     2a8:	f640 31b8 	movw	r1, #3000	; 0xbb8
        slot->opaque = opaque;
     2ac:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     2ae:	2201      	movs	r2, #1
        slot->start = start;
     2b0:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     2b2:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     2b4:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     2b8:	e7af      	b.n	21a <setup+0xba>
        slot->handler = h;
     2ba:	4c19      	ldr	r4, [pc, #100]	; (320 <setup+0x1c0>)
        slot->expires = expires;
     2bc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
        slot->opaque = opaque;
     2c0:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     2c2:	2201      	movs	r2, #1
        slot->start = start;
     2c4:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     2c6:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     2c8:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     2cc:	e7b9      	b.n	242 <setup+0xe2>
        slot->handler = h;
     2ce:	4c15      	ldr	r4, [pc, #84]	; (324 <setup+0x1c4>)
        slot->expires = expires;
     2d0:	f241 3188 	movw	r1, #5000	; 0x1388
        slot->opaque = opaque;
     2d4:	605a      	str	r2, [r3, #4]
        slot->repeat = repeat;
     2d6:	2201      	movs	r2, #1
        slot->start = start;
     2d8:	6098      	str	r0, [r3, #8]
        slot->handler = h;
     2da:	601c      	str	r4, [r3, #0]
        slot->repeat = repeat;
     2dc:	e9c3 1203 	strd	r1, r2, [r3, #12]
        return slot;
     2e0:	e7a5      	b.n	22e <setup+0xce>
     2e2:	bf00      	nop
     2e4:	2000a5a8 	.word	0x2000a5a8
     2e8:	2000a71d 	.word	0x2000a71d
     2ec:	2000a71c 	.word	0x2000a71c
     2f0:	20000ea8 	.word	0x20000ea8
     2f4:	20001110 	.word	0x20001110
     2f8:	2000110c 	.word	0x2000110c
     2fc:	431bde83 	.word	0x431bde83
     300:	20000ed0 	.word	0x20000ed0
     304:	20001120 	.word	0x20001120
     308:	20000ee4 	.word	0x20000ee4
     30c:	00000981 	.word	0x00000981
     310:	2000a5b0 	.word	0x2000a5b0
     314:	400d8000 	.word	0x400d8000
     318:	000035e1 	.word	0x000035e1
     31c:	00000439 	.word	0x00000439
     320:	00000129 	.word	0x00000129
     324:	00005059 	.word	0x00005059
     328:	2000a6f8 	.word	0x2000a6f8

0000032c <loop>:
void loop() {
     32c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     330:	4d3b      	ldr	r5, [pc, #236]	; (420 <loop+0xf4>)
     332:	b084      	sub	sp, #16
     334:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 430 <loop+0x104>
        task->handler = NULL;
     338:	2700      	movs	r7, #0
                    task->repeat = task->handler(task->opaque) && task->repeat;
     33a:	f04f 0a01 	mov.w	sl, #1
     33e:	f505 76a0 	add.w	r6, r5, #320	; 0x140
     342:	462c      	mov	r4, r5
     344:	e009      	b.n	35a <loop+0x2e>
     346:	f854 3c04 	ldr.w	r3, [r4, #-4]
     34a:	b1bb      	cbz	r3, 37c <loop+0x50>
     34c:	f844 ac04 	str.w	sl, [r4, #-4]
                    if (task->repeat) task->start = t;
     350:	f844 9c0c 	str.w	r9, [r4, #-12]
        timer_foreach_task(task) {
     354:	3414      	adds	r4, #20
     356:	42b4      	cmp	r4, r6
     358:	d019      	beq.n	38e <loop+0x62>
            if (task->handler) {
     35a:	f854 2c14 	ldr.w	r2, [r4, #-20]
     35e:	2a00      	cmp	r2, #0
     360:	d0f8      	beq.n	354 <loop+0x28>
     362:	f8d8 9000 	ldr.w	r9, [r8]
                if (duration >= task->expires) {
     366:	e954 3103 	ldrd	r3, r1, [r4, #-12]
                const unsigned long duration = t - task->start;
     36a:	eba9 0303 	sub.w	r3, r9, r3
                if (duration >= task->expires) {
     36e:	428b      	cmp	r3, r1
     370:	d3f0      	bcc.n	354 <loop+0x28>
                    task->repeat = task->handler(task->opaque) && task->repeat;
     372:	f854 0c10 	ldr.w	r0, [r4, #-16]
     376:	4790      	blx	r2
     378:	2800      	cmp	r0, #0
     37a:	d1e4      	bne.n	346 <loop+0x1a>
        task->repeat = 0;
     37c:	f844 7c04 	str.w	r7, [r4, #-4]
        task->opaque = T();
     380:	e944 7705 	strd	r7, r7, [r4, #-20]
        task->expires = 0;
     384:	e944 7703 	strd	r7, r7, [r4, #-12]
        timer_foreach_task(task) {
     388:	3414      	adds	r4, #20
     38a:	42b4      	cmp	r4, r6
     38c:	d1e5      	bne.n	35a <loop+0x2e>
     38e:	f8d8 3000 	ldr.w	r3, [r8]
            if (task->handler) {
     392:	f855 3c14 	ldr.w	r3, [r5, #-20]
     396:	b133      	cbz	r3, 3a6 <loop+0x7a>
     398:	f8d8 3000 	ldr.w	r3, [r8]
                if (duration >= task->expires) {
     39c:	e955 1203 	ldrd	r1, r2, [r5, #-12]
                const unsigned long duration = t - task->start;
     3a0:	1a5b      	subs	r3, r3, r1
                if (duration >= task->expires) {
     3a2:	4293      	cmp	r3, r2
     3a4:	d202      	bcs.n	3ac <loop+0x80>
        timer_foreach_const_task(task) {
     3a6:	3514      	adds	r5, #20
     3a8:	42b5      	cmp	r5, r6
     3aa:	d1f2      	bne.n	392 <loop+0x66>
  if (millis() - lastTransmission >= btTimeout) {
     3ac:	491d      	ldr	r1, [pc, #116]	; (424 <loop+0xf8>)
    bt_packet rx_packet = { 0 };
     3ae:	2400      	movs	r4, #0
     3b0:	f8d8 3000 	ldr.w	r3, [r8]
  if (millis() - lastTransmission >= btTimeout) {
     3b4:	6809      	ldr	r1, [r1, #0]
     3b6:	f8d8 3000 	ldr.w	r3, [r8]
     3ba:	4a1b      	ldr	r2, [pc, #108]	; (428 <loop+0xfc>)
     3bc:	1a5b      	subs	r3, r3, r1
  while (Serial2.available()) {
     3be:	4d1b      	ldr	r5, [pc, #108]	; (42c <loop+0x100>)
  if (millis() - lastTransmission >= btTimeout) {
     3c0:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
     3c4:	bf2c      	ite	cs
     3c6:	2300      	movcs	r3, #0
     3c8:	2301      	movcc	r3, #1
     3ca:	7013      	strb	r3, [r2, #0]
     3cc:	e00c      	b.n	3e8 <loop+0xbc>
    bt_packet rx_packet = { 0 };
     3ce:	e9cd 4400 	strd	r4, r4, [sp]
     3d2:	9402      	str	r4, [sp, #8]
     3d4:	f88d 400c 	strb.w	r4, [sp, #12]
	long parseInt(LookaheadMode lookahead = SKIP_ALL, char ignore = '\x01');
	float parseFloat(LookaheadMode lookahead = SKIP_ALL, char ignore = '\x01');
	size_t readBytes(char *buffer, size_t length);
	size_t readBytes(uint8_t *buffer, size_t length) { return readBytes((char *)buffer, length); }
	size_t readBytesUntil(char terminator, char *buffer, size_t length);
	size_t readBytesUntil(char terminator, uint8_t *buffer, size_t length) { return readBytesUntil(terminator, (char *)buffer, length); }
     3d8:	f005 fb48 	bl	5a6c <Stream::readBytesUntil(char, char*, unsigned int)>
     3dc:	4603      	mov	r3, r0
    btProcess(&rx_packet);
     3de:	4668      	mov	r0, sp
    rx_packet.len = Serial2.readBytesUntil(SERIAL_PACKET_END, rx_packet.data, ARRAY_SIZE(rx_packet.data));
     3e0:	f88d 3000 	strb.w	r3, [sp]
    btProcess(&rx_packet);
     3e4:	f000 f8d2 	bl	58c <btProcess(bt_packet*)>
  while (Serial2.available()) {
     3e8:	4628      	mov	r0, r5
     3ea:	f004 ff1d 	bl	5228 <HardwareSerialIMXRT::available()>
     3ee:	4606      	mov	r6, r0
     3f0:	230c      	movs	r3, #12
     3f2:	f10d 0201 	add.w	r2, sp, #1
     3f6:	21ff      	movs	r1, #255	; 0xff
     3f8:	4628      	mov	r0, r5
     3fa:	2e00      	cmp	r6, #0
     3fc:	d1e7      	bne.n	3ce <loop+0xa2>
  if (digitalRead(pinBT_Conf)) {
     3fe:	2004      	movs	r0, #4
     400:	f005 fd6e 	bl	5ee0 <digitalRead>
     404:	b920      	cbnz	r0, 410 <loop+0xe4>
}
     406:	b004      	add	sp, #16
     408:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     40c:	f000 bbbc 	b.w	b88 <LED()>
    btInit();  // can't have BT_Conf as an interrupt and change the pin state...
     410:	f000 f982 	bl	718 <btInit()>
}
     414:	b004      	add	sp, #16
     416:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LED();
     41a:	f000 bbb5 	b.w	b88 <LED()>
     41e:	bf00      	nop
     420:	2000a5c4 	.word	0x2000a5c4
     424:	2000a4f0 	.word	0x2000a4f0
     428:	2000a70d 	.word	0x2000a70d
     42c:	20001120 	.word	0x20001120
     430:	2000a5a8 	.word	0x2000a5a8

00000434 <_GLOBAL__sub_I__Z12btSendStatusPv>:
     434:	f005 bdcc 	b.w	5fd0 <eeprom_initialize>

00000438 <btSendStatus(void*)>:
#include "openhaldex.h"

bool btSendStatus(void *params) {
     438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  bt_packet packet;
  if (!isScreen) {
     43c:	4f4a      	ldr	r7, [pc, #296]	; (568 <btSendStatus(void*)+0x130>)
bool btSendStatus(void *params) {
     43e:	b085      	sub	sp, #20
  if (!isScreen) {
     440:	783b      	ldrb	r3, [r7, #0]
     442:	2b00      	cmp	r3, #0
     444:	d03f      	beq.n	4c6 <btSendStatus(void*)+0x8e>
     446:	f8df 9138 	ldr.w	r9, [pc, #312]	; 580 <btSendStatus(void*)+0x148>
     44a:	f10d 0b01 	add.w	fp, sp, #1
     44e:	f8df 8134 	ldr.w	r8, [pc, #308]	; 584 <btSendStatus(void*)+0x14c>
     452:	f8df a134 	ldr.w	sl, [pc, #308]	; 588 <btSendStatus(void*)+0x150>

  if (isScreen) {
    packet.data[0] = APP_MSG_STATUS;
    packet.data[1] = 0;  // was haldexStatus
    packet.data[2] = haldexEngagement;
    packet.data[3] = int(lockTarget);
     456:	edd8 7a00 	vldr	s15, [r8]
    packet.data[7] = int(pedValue);
    packet.data[8] = softwareVersion;
    packet.data[9] = SERIAL_PACKET_END;
    packet.len = 10;

    Serial2.write(packet.data, packet.len);
     45a:	4659      	mov	r1, fp
    packet.data[7] = int(pedValue);
     45c:	4b43      	ldr	r3, [pc, #268]	; (56c <btSendStatus(void*)+0x134>)
    packet.data[3] = int(lockTarget);
     45e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    packet.data[2] = haldexEngagement;
     462:	f899 4000 	ldrb.w	r4, [r9]
    packet.data[7] = int(pedValue);
     466:	ed93 7a00 	vldr	s14, [r3]
    packet.data[5] = state.mode_override;
     46a:	4841      	ldr	r0, [pc, #260]	; (570 <btSendStatus(void*)+0x138>)
    packet.data[3] = int(lockTarget);
     46c:	ee17 3a90 	vmov	r3, s15
    packet.data[7] = int(pedValue);
     470:	eefd 7ac7 	vcvt.s32.f32	s15, s14
    packet.data[2] = haldexEngagement;
     474:	f88d 4003 	strb.w	r4, [sp, #3]
    packet.data[3] = int(lockTarget);
     478:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[8] = softwareVersion;
     47c:	4b3d      	ldr	r3, [pc, #244]	; (574 <btSendStatus(void*)+0x13c>)
    packet.data[7] = int(pedValue);
     47e:	ee17 2a90 	vmov	r2, s15
    packet.data[5] = state.mode_override;
     482:	f890 4023 	ldrb.w	r4, [r0, #35]	; 0x23
    packet.data[8] = softwareVersion;
     486:	681b      	ldr	r3, [r3, #0]
    packet.data[7] = int(pedValue);
     488:	f88d 2008 	strb.w	r2, [sp, #8]
    packet.data[6] = state.mode;
     48c:	7802      	ldrb	r2, [r0, #0]
    packet.len = 10;
     48e:	f44f 7085 	mov.w	r0, #266	; 0x10a
    packet.data[4] = vehicleSpeed;
     492:	f89a 5000 	ldrb.w	r5, [sl]
    packet.data[5] = state.mode_override;
     496:	f88d 4006 	strb.w	r4, [sp, #6]
    packet.data[9] = SERIAL_PACKET_END;
     49a:	24ff      	movs	r4, #255	; 0xff
    packet.data[8] = softwareVersion;
     49c:	f88d 3009 	strb.w	r3, [sp, #9]
    packet.data[1] = 0;  // was haldexStatus
     4a0:	2300      	movs	r3, #0
    packet.data[6] = state.mode;
     4a2:	f88d 2007 	strb.w	r2, [sp, #7]
    Serial2.write(packet.data, packet.len);
     4a6:	220a      	movs	r2, #10
    packet.len = 10;
     4a8:	f8ad 0000 	strh.w	r0, [sp]
    Serial2.write(packet.data, packet.len);
     4ac:	4832      	ldr	r0, [pc, #200]	; (578 <btSendStatus(void*)+0x140>)
    packet.data[4] = vehicleSpeed;
     4ae:	f88d 5005 	strb.w	r5, [sp, #5]
    packet.data[9] = SERIAL_PACKET_END;
     4b2:	f88d 400a 	strb.w	r4, [sp, #10]
    packet.data[1] = 0;  // was haldexStatus
     4b6:	f88d 3002 	strb.w	r3, [sp, #2]
    Serial2.write(packet.data, packet.len);
     4ba:	f005 fa61 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
  }
  return true;
}
     4be:	2001      	movs	r0, #1
     4c0:	b005      	add	sp, #20
     4c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    packet.data[3] = lockTarget;  //lockTarget;
     4c6:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 584 <btSendStatus(void*)+0x14c>
     4ca:	f10d 0106 	add.w	r1, sp, #6
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     4ce:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 580 <btSendStatus(void*)+0x148>
        packet.data[i] = SERIAL_PACKET_END - 1;
     4d2:	20fe      	movs	r0, #254	; 0xfe
    packet.data[3] = lockTarget;  //lockTarget;
     4d4:	edd8 7a00 	vldr	s15, [r8]
    packet.data[1] = 0;  // was haldexStatus
     4d8:	f88d 3002 	strb.w	r3, [sp, #2]
    packet.data[3] = lockTarget;  //lockTarget;
     4dc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     4e0:	f899 3000 	ldrb.w	r3, [r9]
    packet.data[4] = vehicleSpeed;  //vehicleSpeed;
     4e4:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 588 <btSendStatus(void*)+0x150>
    packet.data[2] = haldexEngagement;  //haldexEngagement;
     4e8:	f88d 3003 	strb.w	r3, [sp, #3]
    packet.data[3] = lockTarget;  //lockTarget;
     4ec:	ee17 3a90 	vmov	r3, s15
     4f0:	f88d 3004 	strb.w	r3, [sp, #4]
    packet.data[4] = vehicleSpeed;  //vehicleSpeed;
     4f4:	f89a 3000 	ldrb.w	r3, [sl]
     4f8:	f88d 3005 	strb.w	r3, [sp, #5]
    packet.data[5] = SERIAL_PACKET_END;
     4fc:	23ff      	movs	r3, #255	; 0xff
     4fe:	f88d 3006 	strb.w	r3, [sp, #6]
    packet.len = 6;
     502:	f44f 7383 	mov.w	r3, #262	; 0x106
     506:	f8ad 3000 	strh.w	r3, [sp]
     50a:	f10d 0302 	add.w	r3, sp, #2
    for (int i = 0; i < packet.len - 1; i++) {
     50e:	4299      	cmp	r1, r3
     510:	d007      	beq.n	522 <btSendStatus(void*)+0xea>
      if (packet.data[i] == SERIAL_PACKET_END) {
     512:	781a      	ldrb	r2, [r3, #0]
     514:	3301      	adds	r3, #1
     516:	2aff      	cmp	r2, #255	; 0xff
        packet.data[i] = SERIAL_PACKET_END - 1;
     518:	bf08      	it	eq
     51a:	f803 0c01 	strbeq.w	r0, [r3, #-1]
    for (int i = 0; i < packet.len - 1; i++) {
     51e:	4299      	cmp	r1, r3
     520:	d1f7      	bne.n	512 <btSendStatus(void*)+0xda>
     522:	f10d 0b01 	add.w	fp, sp, #1
     526:	2101      	movs	r1, #1
    for (int i = 0; i < packet.len; i++) {
     528:	2400      	movs	r4, #0
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
     52a:	4d14      	ldr	r5, [pc, #80]	; (57c <btSendStatus(void*)+0x144>)
     52c:	465e      	mov	r6, fp
     52e:	e001      	b.n	534 <btSendStatus(void*)+0xfc>
      Serial.println(packet.data[i]);
     530:	f816 1f01 	ldrb.w	r1, [r6, #1]!
     534:	220a      	movs	r2, #10
     536:	2300      	movs	r3, #0
     538:	4628      	mov	r0, r5
    for (int i = 0; i < packet.len; i++) {
     53a:	3401      	adds	r4, #1
     53c:	f005 fa7e 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	// Print an unsigned number and newline
	size_t println(uint8_t b)			{ return print(b) + println(); }
     540:	4628      	mov	r0, r5
     542:	f005 fa51 	bl	59e8 <Print::println()>
     546:	f89d 2000 	ldrb.w	r2, [sp]
     54a:	42a2      	cmp	r2, r4
     54c:	dcf0      	bgt.n	530 <btSendStatus(void*)+0xf8>
    Serial2.write(packet.data, packet.len);
     54e:	4659      	mov	r1, fp
     550:	4809      	ldr	r0, [pc, #36]	; (578 <btSendStatus(void*)+0x140>)
     552:	f005 fa15 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
  if (isScreen) {
     556:	783b      	ldrb	r3, [r7, #0]
     558:	2b00      	cmp	r3, #0
     55a:	f47f af7c 	bne.w	456 <btSendStatus(void*)+0x1e>
}
     55e:	2001      	movs	r0, #1
     560:	b005      	add	sp, #20
     562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     566:	bf00      	nop
     568:	2000a714 	.word	0x2000a714
     56c:	2000a510 	.word	0x2000a510
     570:	2000a580 	.word	0x2000a580
     574:	200019c0 	.word	0x200019c0
     578:	20001120 	.word	0x20001120
     57c:	20001110 	.word	0x20001110
     580:	2000a710 	.word	0x2000a710
     584:	2000a4f4 	.word	0x2000a4f4
     588:	2000a720 	.word	0x2000a720

0000058c <btProcess(bt_packet*)>:
     58c:	4a57      	ldr	r2, [pc, #348]	; (6ec <btProcess(bt_packet*)+0x160>)

void btProcess(bt_packet *rx_packet) {
  byte lockpoint_index;
  bt_packet tx_packet;

  lastTransmission = millis();
     58e:	4b58      	ldr	r3, [pc, #352]	; (6f0 <btProcess(bt_packet*)+0x164>)
     590:	6812      	ldr	r2, [r2, #0]
void btProcess(bt_packet *rx_packet) {
     592:	b510      	push	{r4, lr}
  lastTransmission = millis();
     594:	601a      	str	r2, [r3, #0]
void btProcess(bt_packet *rx_packet) {
     596:	b086      	sub	sp, #24

  switch (rx_packet->data[0]) {
     598:	7843      	ldrb	r3, [r0, #1]
     59a:	2b04      	cmp	r3, #4
     59c:	d80b      	bhi.n	5b6 <btProcess(bt_packet*)+0x2a>
     59e:	e8df f003 	tbb	[pc, r3]
     5a2:	0a39      	.short	0x0a39
     5a4:	0c13      	.short	0x0c13
     5a6:	03          	.byte	0x03
     5a7:	00          	.byte	0x00
          Serial.println("App assumed control of override");
          break;
      }
      break;
    case APP_MSG_IS_SCREEN:
      isScreen = true;
     5a8:	4952      	ldr	r1, [pc, #328]	; (6f4 <btProcess(bt_packet*)+0x168>)
     5aa:	2001      	movs	r0, #1
      state.mode_override = false;
     5ac:	4b52      	ldr	r3, [pc, #328]	; (6f8 <btProcess(bt_packet*)+0x16c>)
     5ae:	2200      	movs	r2, #0
      isScreen = true;
     5b0:	7008      	strb	r0, [r1, #0]
      state.mode_override = false;
     5b2:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
      break;
  }
}
     5b6:	b006      	add	sp, #24
     5b8:	bd10      	pop	{r4, pc}
      switch (rx_packet->data[1]) {
     5ba:	7883      	ldrb	r3, [r0, #2]
     5bc:	2b03      	cmp	r3, #3
     5be:	d8fa      	bhi.n	5b6 <btProcess(bt_packet*)+0x2a>
     5c0:	e8df f003 	tbb	[pc, r3]
     5c4:	5664867d 	.word	0x5664867d
      lockpoint_index = rx_packet->data[1];
     5c8:	7882      	ldrb	r2, [r0, #2]
      if (lockpoint_index < NUM_LOCK_POINTS) {
     5ca:	2a09      	cmp	r2, #9
     5cc:	d8f3      	bhi.n	5b6 <btProcess(bt_packet*)+0x2a>
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     5ce:	4c4a      	ldr	r4, [pc, #296]	; (6f8 <btProcess(bt_packet*)+0x16c>)
     5d0:	eb02 0342 	add.w	r3, r2, r2, lsl #1
     5d4:	78c1      	ldrb	r1, [r0, #3]
        if (lockpoint_index > 6) {
     5d6:	2a06      	cmp	r2, #6
        state.custom_mode.lockpoints[lockpoint_index].speed = rx_packet->data[2];
     5d8:	4423      	add	r3, r4
     5da:	7059      	strb	r1, [r3, #1]
        state.custom_mode.lockpoints[lockpoint_index].lock = rx_packet->data[3];
     5dc:	7901      	ldrb	r1, [r0, #4]
     5de:	7099      	strb	r1, [r3, #2]
        state.custom_mode.lockpoints[lockpoint_index].intensity = rx_packet->data[4];
     5e0:	7941      	ldrb	r1, [r0, #5]
     5e2:	70d9      	strb	r1, [r3, #3]
        if (lockpoint_index > 6) {
     5e4:	d93a      	bls.n	65c <btProcess(bt_packet*)+0xd0>
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     5e6:	1fd0      	subs	r0, r2, #7
     5e8:	2101      	movs	r1, #1
     5ea:	7fe3      	ldrb	r3, [r4, #31]
     5ec:	4081      	lsls	r1, r0
     5ee:	4319      	orrs	r1, r3
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     5f0:	f894 3020 	ldrb.w	r3, [r4, #32]
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     5f4:	b2c9      	uxtb	r1, r1
     5f6:	77e1      	strb	r1, [r4, #31]
        state.custom_mode.lockpoint_count++;
     5f8:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     5fc:	9100      	str	r1, [sp, #0]
        state.custom_mode.lockpoint_count++;
     5fe:	3001      	adds	r0, #1
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     600:	493e      	ldr	r1, [pc, #248]	; (6fc <btProcess(bt_packet*)+0x170>)
        state.custom_mode.lockpoint_count++;
     602:	b2c0      	uxtb	r0, r0
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     604:	9001      	str	r0, [sp, #4]
        state.custom_mode.lockpoint_count++;
     606:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
        Serial.printf("lockpoint[%d] low 0x%x high 0x%x (count %d)\n",
     60a:	483d      	ldr	r0, [pc, #244]	; (700 <btProcess(bt_packet*)+0x174>)
     60c:	f005 fa08 	bl	5a20 <Print::printf(char const*, ...)>
}
     610:	b006      	add	sp, #24
     612:	bd10      	pop	{r4, pc}
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     614:	7883      	ldrb	r3, [r0, #2]
     616:	2b03      	cmp	r3, #3
     618:	d80a      	bhi.n	630 <btProcess(bt_packet*)+0xa4>
     61a:	4a37      	ldr	r2, [pc, #220]	; (6f8 <btProcess(bt_packet*)+0x16c>)
      if (state.mode == MODE_FWD) {
     61c:	2b01      	cmp	r3, #1
      state.ped_threshold = rx_packet->data[2];
     61e:	78c1      	ldrb	r1, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     620:	7013      	strb	r3, [r2, #0]
      state.ped_threshold = rx_packet->data[2];
     622:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
      if (state.mode == MODE_FWD) {
     626:	d109      	bne.n	63c <btProcess(bt_packet*)+0xb0>
        lockTarget = 0;
     628:	4b36      	ldr	r3, [pc, #216]	; (704 <btProcess(bt_packet*)+0x178>)
     62a:	2200      	movs	r2, #0
     62c:	601a      	str	r2, [r3, #0]
     62e:	e005      	b.n	63c <btProcess(bt_packet*)+0xb0>
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     630:	4b31      	ldr	r3, [pc, #196]	; (6f8 <btProcess(bt_packet*)+0x16c>)
     632:	2100      	movs	r1, #0
      state.ped_threshold = rx_packet->data[2];
     634:	78c2      	ldrb	r2, [r0, #3]
      state.mode = rx_packet->data[1] <= MODE_CUSTOM ? (openhaldex_mode_id)rx_packet->data[1] : MODE_STOCK;
     636:	7019      	strb	r1, [r3, #0]
      state.ped_threshold = rx_packet->data[2];
     638:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      if (rx_packet->data[1] == MODE_CUSTOM) {
     63c:	7882      	ldrb	r2, [r0, #2]
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     63e:	78c3      	ldrb	r3, [r0, #3]
      if (rx_packet->data[1] == MODE_CUSTOM) {
     640:	f1a2 0003 	sub.w	r0, r2, #3
     644:	4c30      	ldr	r4, [pc, #192]	; (708 <btProcess(bt_packet*)+0x17c>)
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     646:	4931      	ldr	r1, [pc, #196]	; (70c <btProcess(bt_packet*)+0x180>)
      if (rx_packet->data[1] == MODE_CUSTOM) {
     648:	fab0 f080 	clz	r0, r0
     64c:	0940      	lsrs	r0, r0, #5
     64e:	7020      	strb	r0, [r4, #0]
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     650:	482b      	ldr	r0, [pc, #172]	; (700 <btProcess(bt_packet*)+0x174>)
}
     652:	b006      	add	sp, #24
     654:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      Serial.printf("APP_MSG_MODE: mode=%d ped_threshold=%d%%\n", rx_packet->data[1], rx_packet->data[2]);
     658:	f005 b9e2 	b.w	5a20 <Print::printf(char const*, ...)>
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     65c:	2001      	movs	r0, #1
     65e:	f894 3020 	ldrb.w	r3, [r4, #32]
          state.custom_mode.lockpoint_rx_h |= (1 << (lockpoint_index - 7));
     662:	7fe1      	ldrb	r1, [r4, #31]
          state.custom_mode.lockpoint_rx_l |= (1 << lockpoint_index);
     664:	4090      	lsls	r0, r2
     666:	4303      	orrs	r3, r0
     668:	b2db      	uxtb	r3, r3
     66a:	f884 3020 	strb.w	r3, [r4, #32]
     66e:	e7c3      	b.n	5f8 <btProcess(bt_packet*)+0x6c>
          state.mode_override = false;
     670:	4b21      	ldr	r3, [pc, #132]	; (6f8 <btProcess(bt_packet*)+0x16c>)
     672:	2200      	movs	r2, #0
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     674:	211f      	movs	r1, #31
     676:	4826      	ldr	r0, [pc, #152]	; (710 <btProcess(bt_packet*)+0x184>)
     678:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
     67c:	f007 fa42 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
     680:	481f      	ldr	r0, [pc, #124]	; (700 <btProcess(bt_packet*)+0x174>)
}
     682:	b006      	add	sp, #24
     684:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     688:	f005 b9ae 	b.w	59e8 <Print::println()>
          tx_packet.data[2] = state.mode;
     68c:	4b1a      	ldr	r3, [pc, #104]	; (6f8 <btProcess(bt_packet*)+0x16c>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     68e:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     690:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     694:	2402      	movs	r4, #2
          tx_packet.data[2] = state.mode;
     696:	7818      	ldrb	r0, [r3, #0]
          tx_packet.data[3] = state.ped_threshold;
     698:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
          tx_packet.data[4] = SERIAL_PACKET_END;
     69c:	f88d 200d 	strb.w	r2, [sp, #13]
          Serial2.write(tx_packet.data, tx_packet.len);
     6a0:	2205      	movs	r2, #5
          tx_packet.data[2] = state.mode;
     6a2:	f88d 000b 	strb.w	r0, [sp, #11]
          tx_packet.len = 5;
     6a6:	f8ad 1008 	strh.w	r1, [sp, #8]
          Serial2.write(tx_packet.data, tx_packet.len);
     6aa:	f10d 0109 	add.w	r1, sp, #9
     6ae:	4819      	ldr	r0, [pc, #100]	; (714 <btProcess(bt_packet*)+0x188>)
          tx_packet.data[3] = state.ped_threshold;
     6b0:	f88d 300c 	strb.w	r3, [sp, #12]
          tx_packet.data[1] = DATA_CTRL_CHECK_MODE;
     6b4:	f88d 400a 	strb.w	r4, [sp, #10]
          Serial2.write(tx_packet.data, tx_packet.len);
     6b8:	f005 f962 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
          break;
     6bc:	e77b      	b.n	5b6 <btProcess(bt_packet*)+0x2a>
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     6be:	4b0e      	ldr	r3, [pc, #56]	; (6f8 <btProcess(bt_packet*)+0x16c>)
          tx_packet.data[4] = SERIAL_PACKET_END;
     6c0:	22ff      	movs	r2, #255	; 0xff
          tx_packet.len = 5;
     6c2:	f240 3105 	movw	r1, #773	; 0x305
          tx_packet.data[1] = DATA_CTRL_CHECK_LOCKPOINTS;
     6c6:	2400      	movs	r4, #0
          tx_packet.data[2] = state.custom_mode.lockpoint_rx_l;
     6c8:	f893 0020 	ldrb.w	r0, [r3, #32]
          tx_packet.data[3] = state.custom_mode.lockpoint_rx_h;
     6cc:	7fdb      	ldrb	r3, [r3, #31]
     6ce:	e7e5      	b.n	69c <btProcess(bt_packet*)+0x110>
          state.custom_mode.lockpoint_rx_l = 0;
     6d0:	4b09      	ldr	r3, [pc, #36]	; (6f8 <btProcess(bt_packet*)+0x16c>)
     6d2:	2100      	movs	r1, #0
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     6d4:	221e      	movs	r2, #30
     6d6:	1c58      	adds	r0, r3, #1
          state.custom_mode.lockpoint_rx_l = 0;
     6d8:	f883 1020 	strb.w	r1, [r3, #32]
          state.custom_mode.lockpoint_rx_h = 0;
     6dc:	77d9      	strb	r1, [r3, #31]
          state.custom_mode.lockpoint_count = 0;
     6de:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
}
     6e2:	b006      	add	sp, #24
     6e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          memset(state.custom_mode.lockpoints, 0, sizeof(state.custom_mode.lockpoints));
     6e8:	f008 b9bc 	b.w	8a64 <memset>
     6ec:	2000a5a8 	.word	0x2000a5a8
     6f0:	2000a4f0 	.word	0x2000a4f0
     6f4:	2000a714 	.word	0x2000a714
     6f8:	2000a580 	.word	0x2000a580
     6fc:	20000640 	.word	0x20000640
     700:	20001110 	.word	0x20001110
     704:	2000a4f4 	.word	0x2000a4f4
     708:	2000a713 	.word	0x2000a713
     70c:	20000614 	.word	0x20000614
     710:	20000670 	.word	0x20000670
     714:	20001120 	.word	0x20001120

00000718 <btInit()>:

void btInit() {
     718:	b530      	push	{r4, r5, lr}
#if stateDebug
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
     71a:	2400      	movs	r4, #0
void btInit() {
     71c:	b0a3      	sub	sp, #140	; 0x8c
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
     71e:	227c      	movs	r2, #124	; 0x7c
  Serial2.begin(38400);  // AT mode requires Baud 38400

  Serial2.write("AT\r\n");  // confirm in AT mode
#if stateDebug
  Serial.println(F("AT"));
  while (!Serial2.available()) {}
     720:	4d88      	ldr	r5, [pc, #544]	; (944 <btInit()+0x22c>)
  uint8_t at_buf[128] = { 0 };  // allocate buffer for Bluetooth module Serial messages
     722:	4621      	mov	r1, r4
     724:	a803      	add	r0, sp, #12
     726:	9402      	str	r4, [sp, #8]
     728:	f008 f99c 	bl	8a64 <memset>
  digitalWrite(pinLED_R, LOW);
     72c:	4621      	mov	r1, r4
     72e:	200c      	movs	r0, #12
     730:	f005 fbac 	bl	5e8c <digitalWrite>
  digitalWrite(pinLED_G, LOW);
     734:	4621      	mov	r1, r4
     736:	200a      	movs	r0, #10
     738:	f005 fba8 	bl	5e8c <digitalWrite>
  digitalWrite(pinLED_B, LOW);
     73c:	4621      	mov	r1, r4
     73e:	200b      	movs	r0, #11
     740:	f005 fba4 	bl	5e8c <digitalWrite>
     744:	2120      	movs	r1, #32
     746:	4880      	ldr	r0, [pc, #512]	; (948 <btInit()+0x230>)
     748:	f007 f9dc 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     74c:	487f      	ldr	r0, [pc, #508]	; (94c <btInit()+0x234>)
     74e:	f005 f94b 	bl	59e8 <Print::println()>
  pinMode(pinBT_Conf, OUTPUT);
     752:	2101      	movs	r1, #1
     754:	2004      	movs	r0, #4
     756:	f005 fbd5 	bl	5f04 <pinMode>
  pinMode(pinBT_Reset, OUTPUT);
     75a:	2005      	movs	r0, #5
     75c:	2101      	movs	r1, #1
     75e:	f005 fbd1 	bl	5f04 <pinMode>
  digitalWrite(pinBT_Reset, LOW);
     762:	4621      	mov	r1, r4
     764:	2005      	movs	r0, #5
     766:	f005 fb91 	bl	5e8c <digitalWrite>
  digitalWrite(pinBT_Conf, HIGH);
     76a:	2101      	movs	r1, #1
     76c:	2004      	movs	r0, #4
     76e:	f005 fb8d 	bl	5e8c <digitalWrite>
  blinkLED(625, 4, 10, 0, 0);  // 2500ms total 'high' time for reset, blink LED takes 625ms to complete (625x4=2500ms)
     772:	4623      	mov	r3, r4
     774:	220a      	movs	r2, #10
     776:	f240 2071 	movw	r0, #625	; 0x271
     77a:	2104      	movs	r1, #4
     77c:	9400      	str	r4, [sp, #0]
     77e:	f000 fa3f 	bl	c00 <blinkLED(int, int, int, int, int)>
  pinMode(pinBT_Reset, INPUT);
     782:	4621      	mov	r1, r4
     784:	2005      	movs	r0, #5
     786:	f005 fbbd 	bl	5f04 <pinMode>
  delay(2500);
     78a:	f640 10c4 	movw	r0, #2500	; 0x9c4
     78e:	f005 fb29 	bl	5de4 <delay>
  Serial2.end();         // end current (if any) Serial2/Bluetooth connections
     792:	4628      	mov	r0, r5
     794:	f004 fdf2 	bl	537c <HardwareSerialIMXRT::end()>
  Serial2.begin(38400);  // AT mode requires Baud 38400
     798:	4622      	mov	r2, r4
     79a:	f44f 4116 	mov.w	r1, #38400	; 0x9600
     79e:	4628      	mov	r0, r5
     7a0:	f004 fe20 	bl	53e4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>
							  return write((const uint8_t *)str, strlen(str)); }
     7a4:	2204      	movs	r2, #4
     7a6:	496a      	ldr	r1, [pc, #424]	; (950 <btInit()+0x238>)
     7a8:	4628      	mov	r0, r5
     7aa:	f005 f8e9 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
     7ae:	2102      	movs	r1, #2
     7b0:	4868      	ldr	r0, [pc, #416]	; (954 <btInit()+0x23c>)
     7b2:	f007 f9a7 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     7b6:	4865      	ldr	r0, [pc, #404]	; (94c <btInit()+0x234>)
     7b8:	f005 f916 	bl	59e8 <Print::println()>
  while (!Serial2.available()) {}
     7bc:	4628      	mov	r0, r5
     7be:	f004 fd33 	bl	5228 <HardwareSerialIMXRT::available()>
     7c2:	2800      	cmp	r0, #0
     7c4:	d0fa      	beq.n	7bc <btInit()+0xa4>
     7c6:	2380      	movs	r3, #128	; 0x80
     7c8:	210d      	movs	r1, #13
     7ca:	aa02      	add	r2, sp, #8
     7cc:	485d      	ldr	r0, [pc, #372]	; (944 <btInit()+0x22c>)
     7ce:	f005 f94d 	bl	5a6c <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\r', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     7d2:	aa02      	add	r2, sp, #8
     7d4:	4960      	ldr	r1, [pc, #384]	; (958 <btInit()+0x240>)
     7d6:	485d      	ldr	r0, [pc, #372]	; (94c <btInit()+0x234>)
     7d8:	f005 f922 	bl	5a20 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     7dc:	2300      	movs	r3, #0
     7de:	220a      	movs	r2, #10
     7e0:	2101      	movs	r1, #1
     7e2:	9300      	str	r3, [sp, #0]
     7e4:	f44f 709c 	mov.w	r0, #312	; 0x138
     7e8:	f000 fa0a 	bl	c00 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     7ec:	2212      	movs	r2, #18
     7ee:	495b      	ldr	r1, [pc, #364]	; (95c <btInit()+0x244>)
     7f0:	4854      	ldr	r0, [pc, #336]	; (944 <btInit()+0x22c>)
     7f2:	f005 f8c5 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
     7f6:	2110      	movs	r1, #16
     7f8:	4859      	ldr	r0, [pc, #356]	; (960 <btInit()+0x248>)
     7fa:	f007 f983 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     7fe:	4853      	ldr	r0, [pc, #332]	; (94c <btInit()+0x234>)

  Serial2.write("AT+UART=9600,0,0\r\n");  // set baud at 38400
#if stateDebug
  Serial.println(F("AT+UART=9600,0,0"));
  while (!Serial2.available()) {}
     800:	4c50      	ldr	r4, [pc, #320]	; (944 <btInit()+0x22c>)
     802:	f005 f8f1 	bl	59e8 <Print::println()>
     806:	4620      	mov	r0, r4
     808:	f004 fd0e 	bl	5228 <HardwareSerialIMXRT::available()>
     80c:	2800      	cmp	r0, #0
     80e:	d0fa      	beq.n	806 <btInit()+0xee>
     810:	2380      	movs	r3, #128	; 0x80
     812:	210a      	movs	r1, #10
     814:	aa02      	add	r2, sp, #8
     816:	484b      	ldr	r0, [pc, #300]	; (944 <btInit()+0x22c>)
     818:	f005 f928 	bl	5a6c <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     81c:	aa02      	add	r2, sp, #8
     81e:	494e      	ldr	r1, [pc, #312]	; (958 <btInit()+0x240>)
     820:	484a      	ldr	r0, [pc, #296]	; (94c <btInit()+0x234>)
     822:	f005 f8fd 	bl	5a20 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     826:	2300      	movs	r3, #0
     828:	220a      	movs	r2, #10
     82a:	2101      	movs	r1, #1
     82c:	9300      	str	r3, [sp, #0]
     82e:	f44f 709c 	mov.w	r0, #312	; 0x138
     832:	f000 f9e5 	bl	c00 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     836:	2216      	movs	r2, #22
     838:	494a      	ldr	r1, [pc, #296]	; (964 <btInit()+0x24c>)
     83a:	4842      	ldr	r0, [pc, #264]	; (944 <btInit()+0x22c>)
     83c:	f005 f8a0 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
     840:	2114      	movs	r1, #20
     842:	4849      	ldr	r0, [pc, #292]	; (968 <btInit()+0x250>)
     844:	f007 f95e 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     848:	4840      	ldr	r0, [pc, #256]	; (94c <btInit()+0x234>)

  Serial2.write("AT+NAME=OpenHaldexT4\r\n");  // set Bluetooth name
#if stateDebug
  Serial.println(F("AT+NAME=OpenHaldexT4"));
  while (!Serial2.available()) {}
     84a:	4c3e      	ldr	r4, [pc, #248]	; (944 <btInit()+0x22c>)
     84c:	f005 f8cc 	bl	59e8 <Print::println()>
     850:	4620      	mov	r0, r4
     852:	f004 fce9 	bl	5228 <HardwareSerialIMXRT::available()>
     856:	2800      	cmp	r0, #0
     858:	d0fa      	beq.n	850 <btInit()+0x138>
     85a:	2380      	movs	r3, #128	; 0x80
     85c:	210a      	movs	r1, #10
     85e:	aa02      	add	r2, sp, #8
     860:	4838      	ldr	r0, [pc, #224]	; (944 <btInit()+0x22c>)
     862:	f005 f903 	bl	5a6c <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     866:	aa02      	add	r2, sp, #8
     868:	493b      	ldr	r1, [pc, #236]	; (958 <btInit()+0x240>)
     86a:	4838      	ldr	r0, [pc, #224]	; (94c <btInit()+0x234>)
     86c:	f005 f8d8 	bl	5a20 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     870:	2300      	movs	r3, #0
     872:	220a      	movs	r2, #10
     874:	2101      	movs	r1, #1
     876:	9300      	str	r3, [sp, #0]
     878:	f44f 709c 	mov.w	r0, #312	; 0x138
     87c:	f000 f9c0 	bl	c00 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     880:	220b      	movs	r2, #11
     882:	493a      	ldr	r1, [pc, #232]	; (96c <btInit()+0x254>)
     884:	482f      	ldr	r0, [pc, #188]	; (944 <btInit()+0x22c>)
     886:	f005 f87b 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
     88a:	2109      	movs	r1, #9
     88c:	4838      	ldr	r0, [pc, #224]	; (970 <btInit()+0x258>)
     88e:	f007 f939 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     892:	482e      	ldr	r0, [pc, #184]	; (94c <btInit()+0x234>)

  Serial2.write("AT+ROLE=0\r\n");  // query current role
#if stateDebug
  Serial.println(F("AT+ROLE=0"));
  while (!Serial2.available()) {}
     894:	4c2b      	ldr	r4, [pc, #172]	; (944 <btInit()+0x22c>)
     896:	f005 f8a7 	bl	59e8 <Print::println()>
     89a:	4620      	mov	r0, r4
     89c:	f004 fcc4 	bl	5228 <HardwareSerialIMXRT::available()>
     8a0:	2800      	cmp	r0, #0
     8a2:	d0fa      	beq.n	89a <btInit()+0x182>
     8a4:	2380      	movs	r3, #128	; 0x80
     8a6:	210a      	movs	r1, #10
     8a8:	aa02      	add	r2, sp, #8
     8aa:	4826      	ldr	r0, [pc, #152]	; (944 <btInit()+0x22c>)
     8ac:	f005 f8de 	bl	5a6c <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
     8b0:	aa02      	add	r2, sp, #8
     8b2:	4929      	ldr	r1, [pc, #164]	; (958 <btInit()+0x240>)
     8b4:	4825      	ldr	r0, [pc, #148]	; (94c <btInit()+0x234>)
     8b6:	f005 f8b3 	bl	5a20 <Print::printf(char const*, ...)>
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     8ba:	2300      	movs	r3, #0
     8bc:	220a      	movs	r2, #10
     8be:	2101      	movs	r1, #1
     8c0:	9300      	str	r3, [sp, #0]
     8c2:	f44f 709c 	mov.w	r0, #312	; 0x138
     8c6:	f000 f99b 	bl	c00 <blinkLED(int, int, int, int, int)>
							  return write((const uint8_t *)str, strlen(str)); }
     8ca:	220a      	movs	r2, #10
     8cc:	4929      	ldr	r1, [pc, #164]	; (974 <btInit()+0x25c>)
     8ce:	481d      	ldr	r0, [pc, #116]	; (944 <btInit()+0x22c>)
     8d0:	f005 f856 	bl	5980 <Print::write(unsigned char const*, unsigned int)>
     8d4:	2108      	movs	r1, #8
     8d6:	4828      	ldr	r0, [pc, #160]	; (978 <btInit()+0x260>)
     8d8:	f007 f914 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
     8dc:	481b      	ldr	r0, [pc, #108]	; (94c <btInit()+0x234>)

  Serial2.write("AT+RESET\r\n");  // reset Bluetooth module/connections
#if stateDebug
  Serial.println(F("AT+RESET"));
  while (!Serial2.available()) {}
     8de:	4c19      	ldr	r4, [pc, #100]	; (944 <btInit()+0x22c>)
     8e0:	f005 f882 	bl	59e8 <Print::println()>
     8e4:	4620      	mov	r0, r4
     8e6:	f004 fc9f 	bl	5228 <HardwareSerialIMXRT::available()>
     8ea:	2800      	cmp	r0, #0
     8ec:	d0fa      	beq.n	8e4 <btInit()+0x1cc>
  Serial2.readBytesUntil('\n', at_buf, ARRAY_SIZE(at_buf));
  Serial.printf("%s\r\n", at_buf);
#endif /* stateDebug */
  blinkLED(312, 1, 10, 0, 0);
     8ee:	2400      	movs	r4, #0
     8f0:	2380      	movs	r3, #128	; 0x80
     8f2:	aa02      	add	r2, sp, #8
     8f4:	210a      	movs	r1, #10
     8f6:	4813      	ldr	r0, [pc, #76]	; (944 <btInit()+0x22c>)
     8f8:	f005 f8b8 	bl	5a6c <Stream::readBytesUntil(char, char*, unsigned int)>
  Serial.printf("%s\r\n", at_buf);
     8fc:	aa02      	add	r2, sp, #8
     8fe:	4916      	ldr	r1, [pc, #88]	; (958 <btInit()+0x240>)
     900:	4812      	ldr	r0, [pc, #72]	; (94c <btInit()+0x234>)
     902:	f005 f88d 	bl	5a20 <Print::printf(char const*, ...)>
  blinkLED(312, 1, 10, 0, 0);
     906:	4623      	mov	r3, r4
     908:	2101      	movs	r1, #1
     90a:	220a      	movs	r2, #10
     90c:	f44f 709c 	mov.w	r0, #312	; 0x138
     910:	9400      	str	r4, [sp, #0]
     912:	f000 f975 	bl	c00 <blinkLED(int, int, int, int, int)>

  Serial2.end();          // end AT mode
     916:	480b      	ldr	r0, [pc, #44]	; (944 <btInit()+0x22c>)
     918:	f004 fd30 	bl	537c <HardwareSerialIMXRT::end()>
  Serial2.begin(baudBT);  // begin normal mode with the above baud
     91c:	4622      	mov	r2, r4
     91e:	4809      	ldr	r0, [pc, #36]	; (944 <btInit()+0x22c>)
     920:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     924:	f004 fd5e 	bl	53e4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>

  pinMode(pinBT_Conf, INPUT);
     928:	4621      	mov	r1, r4
     92a:	2004      	movs	r0, #4
     92c:	f005 faea 	bl	5f04 <pinMode>
     930:	2116      	movs	r1, #22
     932:	4812      	ldr	r0, [pc, #72]	; (97c <btInit()+0x264>)
     934:	f007 f8e6 	bl	7b04 <usb_serial_write>
     938:	4804      	ldr	r0, [pc, #16]	; (94c <btInit()+0x234>)
     93a:	f005 f855 	bl	59e8 <Print::println()>

#if stateDebug
  Serial.println(F("Bluetooth initialised!"));
#endif /* stateDebug */
}
     93e:	b023      	add	sp, #140	; 0x8c
     940:	bd30      	pop	{r4, r5, pc}
     942:	bf00      	nop
     944:	20001120 	.word	0x20001120
     948:	20000480 	.word	0x20000480
     94c:	20001110 	.word	0x20001110
     950:	200004a4 	.word	0x200004a4
     954:	200004ac 	.word	0x200004ac
     958:	200004b0 	.word	0x200004b0
     95c:	200004b8 	.word	0x200004b8
     960:	200004cc 	.word	0x200004cc
     964:	200004e0 	.word	0x200004e0
     968:	200004f8 	.word	0x200004f8
     96c:	20000510 	.word	0x20000510
     970:	2000051c 	.word	0x2000051c
     974:	20000528 	.word	0x20000528
     978:	20000534 	.word	0x20000534
     97c:	20000540 	.word	0x20000540

00000980 <checkSwitchMode()>:
#include "openhaldex.h"

void checkSwitchMode() {
     980:	b570      	push	{r4, r5, r6, lr}
     982:	4d78      	ldr	r5, [pc, #480]	; (b64 <checkSwitchMode()+0x1e4>)
     984:	211b      	movs	r1, #27
     986:	4878      	ldr	r0, [pc, #480]	; (b68 <checkSwitchMode()+0x1e8>)
  int i = 0;
     988:	2400      	movs	r4, #0
     98a:	f007 f8bb 	bl	7b04 <usb_serial_write>
     98e:	4628      	mov	r0, r5
     990:	4e76      	ldr	r6, [pc, #472]	; (b6c <checkSwitchMode()+0x1ec>)
     992:	f005 f829 	bl	59e8 <Print::println()>
     996:	e02b      	b.n	9f0 <checkSwitchMode()+0x70>
  }
}

void blinkLED(int duration, int flashes, int R, int G, int B) {
  for (int i = 0; i < flashes; i++) {
    delay(duration);
     998:	f005 fa24 	bl	5de4 <delay>
    analogWrite(pinLED_R, R);
     99c:	2105      	movs	r1, #5
     99e:	200c      	movs	r0, #12
     9a0:	f005 fe8e 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, G);
     9a4:	2100      	movs	r1, #0
     9a6:	200a      	movs	r0, #10
     9a8:	f005 fe8a 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, B);
     9ac:	2105      	movs	r1, #5
     9ae:	200b      	movs	r0, #11
     9b0:	f005 fe86 	bl	66c0 <analogWrite>
    delay(duration);
     9b4:	2064      	movs	r0, #100	; 0x64
     9b6:	f005 fa15 	bl	5de4 <delay>
    analogWrite(pinLED_R, 0);
     9ba:	2100      	movs	r1, #0
     9bc:	200c      	movs	r0, #12
     9be:	f005 fe7f 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     9c2:	2100      	movs	r1, #0
     9c4:	200a      	movs	r0, #10
     9c6:	f005 fe7b 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     9ca:	2100      	movs	r1, #0
     9cc:	200b      	movs	r0, #11
     9ce:	f005 fe77 	bl	66c0 <analogWrite>
     9d2:	2120      	movs	r1, #32
     9d4:	4630      	mov	r0, r6
     9d6:	f007 f895 	bl	7b04 <usb_serial_write>
     9da:	4628      	mov	r0, r5
     9dc:	f005 f804 	bl	59e8 <Print::println()>
	size_t print(int n)				{ return print((long)n); }
     9e0:	4621      	mov	r1, r4
     9e2:	4628      	mov	r0, r5
    i++;
     9e4:	3401      	adds	r4, #1
     9e6:	f004 fff3 	bl	59d0 <Print::print(long)>
	// Print a signed number and newline
	size_t println(int n)				{ return print(n) + println(); }
     9ea:	4628      	mov	r0, r5
     9ec:	f004 fffc 	bl	59e8 <Print::println()>
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     9f0:	2004      	movs	r0, #4
     9f2:	f005 fa75 	bl	5ee0 <digitalRead>
     9f6:	4603      	mov	r3, r0
    delay(duration);
     9f8:	2064      	movs	r0, #100	; 0x64
  while (digitalRead(pinBT_Conf) && (i < 11)) {
     9fa:	2b00      	cmp	r3, #0
     9fc:	d058      	beq.n	ab0 <checkSwitchMode()+0x130>
     9fe:	2c0b      	cmp	r4, #11
     a00:	d1ca      	bne.n	998 <checkSwitchMode()+0x18>
    Serial.printf("Is Standalone: %d\n", isStandalone);
     a02:	4d5b      	ldr	r5, [pc, #364]	; (b70 <checkSwitchMode()+0x1f0>)
    isStandalone = !isStandalone;
     a04:	240b      	movs	r4, #11
    Serial.printf("Is Standalone: %d\n", isStandalone);
     a06:	495b      	ldr	r1, [pc, #364]	; (b74 <checkSwitchMode()+0x1f4>)
     a08:	4856      	ldr	r0, [pc, #344]	; (b64 <checkSwitchMode()+0x1e4>)
     a0a:	782a      	ldrb	r2, [r5, #0]
     a0c:	f005 f808 	bl	5a20 <Print::printf(char const*, ...)>
    isStandalone = !isStandalone;
     a10:	782b      	ldrb	r3, [r5, #0]
     a12:	f083 0301 	eor.w	r3, r3, #1
     a16:	702b      	strb	r3, [r5, #0]
    delay(duration);
     a18:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     a1c:	f005 f9e2 	bl	5de4 <delay>
    analogWrite(pinLED_R, R);
     a20:	2105      	movs	r1, #5
     a22:	200c      	movs	r0, #12
     a24:	f005 fe4c 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, G);
     a28:	2100      	movs	r1, #0
     a2a:	200a      	movs	r0, #10
     a2c:	f005 fe48 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, B);
     a30:	2105      	movs	r1, #5
     a32:	200b      	movs	r0, #11
     a34:	f005 fe44 	bl	66c0 <analogWrite>
    delay(duration);
     a38:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
     a3c:	f005 f9d2 	bl	5de4 <delay>
    analogWrite(pinLED_R, 0);
     a40:	2100      	movs	r1, #0
     a42:	200c      	movs	r0, #12
     a44:	f005 fe3c 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     a48:	2100      	movs	r1, #0
     a4a:	200a      	movs	r0, #10
     a4c:	f005 fe38 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     a50:	2100      	movs	r1, #0
     a52:	200b      	movs	r0, #11
     a54:	f005 fe34 	bl	66c0 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     a58:	3c01      	subs	r4, #1
     a5a:	d1dd      	bne.n	a18 <checkSwitchMode()+0x98>
  if (btConnected) {
     a5c:	4b46      	ldr	r3, [pc, #280]	; (b78 <checkSwitchMode()+0x1f8>)
     a5e:	7819      	ldrb	r1, [r3, #0]
     a60:	b361      	cbz	r1, abc <checkSwitchMode()+0x13c>
     a62:	240b      	movs	r4, #11
    delay(duration);
     a64:	2064      	movs	r0, #100	; 0x64
     a66:	f005 f9bd 	bl	5de4 <delay>
    analogWrite(pinLED_R, R);
     a6a:	2105      	movs	r1, #5
     a6c:	200c      	movs	r0, #12
     a6e:	f005 fe27 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, G);
     a72:	2105      	movs	r1, #5
     a74:	200a      	movs	r0, #10
     a76:	f005 fe23 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, B);
     a7a:	2105      	movs	r1, #5
     a7c:	200b      	movs	r0, #11
     a7e:	f005 fe1f 	bl	66c0 <analogWrite>
    delay(duration);
     a82:	2064      	movs	r0, #100	; 0x64
     a84:	f005 f9ae 	bl	5de4 <delay>
    analogWrite(pinLED_R, 0);
     a88:	2100      	movs	r1, #0
     a8a:	200c      	movs	r0, #12
     a8c:	f005 fe18 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     a90:	2100      	movs	r1, #0
     a92:	200a      	movs	r0, #10
     a94:	f005 fe14 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     a98:	2100      	movs	r1, #0
     a9a:	200b      	movs	r0, #11
     a9c:	f005 fe10 	bl	66c0 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     aa0:	3c01      	subs	r4, #1
     aa2:	d1df      	bne.n	a64 <checkSwitchMode()+0xe4>
  delay(300);  // reduce button bashing
     aa4:	f44f 7096 	mov.w	r0, #300	; 0x12c
}
     aa8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(300);  // reduce button bashing
     aac:	f005 b99a 	b.w	5de4 <delay>
  if (i >= 11) {
     ab0:	2c0b      	cmp	r4, #11
     ab2:	d0a6      	beq.n	a02 <checkSwitchMode()+0x82>
  if (btConnected) {
     ab4:	4b30      	ldr	r3, [pc, #192]	; (b78 <checkSwitchMode()+0x1f8>)
     ab6:	7819      	ldrb	r1, [r3, #0]
     ab8:	2900      	cmp	r1, #0
     aba:	d1d2      	bne.n	a62 <checkSwitchMode()+0xe2>
    buttonToggle++;
     abc:	4a2f      	ldr	r2, [pc, #188]	; (b7c <checkSwitchMode()+0x1fc>)
     abe:	6813      	ldr	r3, [r2, #0]
     ac0:	3301      	adds	r3, #1
    if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     ac2:	2b03      	cmp	r3, #3
    buttonToggle++;
     ac4:	6013      	str	r3, [r2, #0]
    if (buttonToggle > 3) {  // if button bashed, possible for buttonToggle to go over 3; just reset (error catching)
     ac6:	dd06      	ble.n	ad6 <checkSwitchMode()+0x156>
      buttonToggle = 0;
     ac8:	6011      	str	r1, [r2, #0]
        if (isStandalone) {  // jump over 'stock' since it's Standalone and can't see Body CAN
     aca:	4b29      	ldr	r3, [pc, #164]	; (b70 <checkSwitchMode()+0x1f0>)
     acc:	781b      	ldrb	r3, [r3, #0]
     ace:	b393      	cbz	r3, b36 <checkSwitchMode()+0x1b6>
          buttonToggle++;
     ad0:	2301      	movs	r3, #1
     ad2:	6013      	str	r3, [r2, #0]
          break;
     ad4:	e7e6      	b.n	aa4 <checkSwitchMode()+0x124>
    switch (buttonToggle) {
     ad6:	2b03      	cmp	r3, #3
     ad8:	d8e4      	bhi.n	aa4 <checkSwitchMode()+0x124>
     ada:	a101      	add	r1, pc, #4	; (adr r1, ae0 <checkSwitchMode()+0x160>)
     adc:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
     ae0:	00000acb 	.word	0x00000acb
     ae4:	00000b1f 	.word	0x00000b1f
     ae8:	00000b07 	.word	0x00000b07
     aec:	00000af1 	.word	0x00000af1
        if (isStandalone) {
     af0:	4b1f      	ldr	r3, [pc, #124]	; (b70 <checkSwitchMode()+0x1f0>)
     af2:	7819      	ldrb	r1, [r3, #0]
     af4:	b321      	cbz	r1, b40 <checkSwitchMode()+0x1c0>
          state.mode_override = false;
     af6:	4b22      	ldr	r3, [pc, #136]	; (b80 <checkSwitchMode()+0x200>)
          state.mode = MODE_FWD;
     af8:	2101      	movs	r1, #1
          state.mode_override = false;
     afa:	2000      	movs	r0, #0
          state.mode = MODE_FWD;
     afc:	7019      	strb	r1, [r3, #0]
          buttonToggle = 1;
     afe:	6011      	str	r1, [r2, #0]
          state.mode_override = false;
     b00:	f883 0023 	strb.w	r0, [r3, #35]	; 0x23
          break;
     b04:	e7ce      	b.n	aa4 <checkSwitchMode()+0x124>
        state.mode_override = false;
     b06:	4b1e      	ldr	r3, [pc, #120]	; (b80 <checkSwitchMode()+0x200>)
     b08:	2100      	movs	r1, #0
        state.mode = MODE_5050;
     b0a:	2202      	movs	r2, #2
  delay(300);  // reduce button bashing
     b0c:	f44f 7096 	mov.w	r0, #300	; 0x12c
        state.mode_override = false;
     b10:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
        state.mode = MODE_5050;
     b14:	701a      	strb	r2, [r3, #0]
}
     b16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(300);  // reduce button bashing
     b1a:	f005 b963 	b.w	5de4 <delay>
        state.mode_override = false;
     b1e:	4b18      	ldr	r3, [pc, #96]	; (b80 <checkSwitchMode()+0x200>)
     b20:	2100      	movs	r1, #0
        state.mode = MODE_FWD;
     b22:	2201      	movs	r2, #1
  delay(300);  // reduce button bashing
     b24:	f44f 7096 	mov.w	r0, #300	; 0x12c
        state.mode_override = false;
     b28:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
        state.mode = MODE_FWD;
     b2c:	701a      	strb	r2, [r3, #0]
}
     b2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  delay(300);  // reduce button bashing
     b32:	f005 b957 	b.w	5de4 <delay>
        state.mode_override = false;  // was disabled & false?
     b36:	4a12      	ldr	r2, [pc, #72]	; (b80 <checkSwitchMode()+0x200>)
     b38:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
        state.mode = MODE_STOCK;
     b3c:	7013      	strb	r3, [r2, #0]
        break;
     b3e:	e7b1      	b.n	aa4 <checkSwitchMode()+0x124>
        if (isCustom) {
     b40:	4b10      	ldr	r3, [pc, #64]	; (b84 <checkSwitchMode()+0x204>)
     b42:	781b      	ldrb	r3, [r3, #0]
     b44:	b143      	cbz	r3, b58 <checkSwitchMode()+0x1d8>
          state.mode_override = false;
     b46:	4b0e      	ldr	r3, [pc, #56]	; (b80 <checkSwitchMode()+0x200>)
          state.mode = MODE_CUSTOM;
     b48:	2403      	movs	r4, #3
          buttonToggle = -1;
     b4a:	f04f 30ff 	mov.w	r0, #4294967295
          state.mode_override = false;
     b4e:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
          state.mode = MODE_CUSTOM;
     b52:	701c      	strb	r4, [r3, #0]
          buttonToggle = -1;
     b54:	6010      	str	r0, [r2, #0]
          break;
     b56:	e7a5      	b.n	aa4 <checkSwitchMode()+0x124>
          state.mode_override = false;
     b58:	4909      	ldr	r1, [pc, #36]	; (b80 <checkSwitchMode()+0x200>)
          buttonToggle = 0;
     b5a:	6013      	str	r3, [r2, #0]
          state.mode_override = false;
     b5c:	f881 3023 	strb.w	r3, [r1, #35]	; 0x23
          state.mode = MODE_STOCK;
     b60:	700b      	strb	r3, [r1, #0]
          break;
     b62:	e79f      	b.n	aa4 <checkSwitchMode()+0x124>
     b64:	20001110 	.word	0x20001110
     b68:	2000042c 	.word	0x2000042c
     b6c:	20000448 	.word	0x20000448
     b70:	2000a715 	.word	0x2000a715
     b74:	2000046c 	.word	0x2000046c
     b78:	2000a70d 	.word	0x2000a70d
     b7c:	2000a4d4 	.word	0x2000a4d4
     b80:	2000a580 	.word	0x2000a580
     b84:	2000a713 	.word	0x2000a713

00000b88 <LED()>:
void LED() {
     b88:	b508      	push	{r3, lr}
  switch (state.mode) {
     b8a:	4b1c      	ldr	r3, [pc, #112]	; (bfc <LED()+0x74>)
     b8c:	781b      	ldrb	r3, [r3, #0]
     b8e:	2b03      	cmp	r3, #3
     b90:	d833      	bhi.n	bfa <LED()+0x72>
     b92:	e8df f003 	tbb	[pc, r3]
     b96:	1e2c      	.short	0x1e2c
     b98:	0210      	.short	0x0210
      analogWrite(pinLED_R, 5);
     b9a:	2105      	movs	r1, #5
     b9c:	200c      	movs	r0, #12
     b9e:	f005 fd8f 	bl	66c0 <analogWrite>
      analogWrite(pinLED_G, 0);
     ba2:	2100      	movs	r1, #0
     ba4:	200a      	movs	r0, #10
     ba6:	f005 fd8b 	bl	66c0 <analogWrite>
      analogWrite(pinLED_B, 5);
     baa:	2105      	movs	r1, #5
     bac:	200b      	movs	r0, #11
}
     bae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 5);
     bb2:	f005 bd85 	b.w	66c0 <analogWrite>
      analogWrite(pinLED_R, 0);
     bb6:	2100      	movs	r1, #0
     bb8:	200c      	movs	r0, #12
     bba:	f005 fd81 	bl	66c0 <analogWrite>
      analogWrite(pinLED_G, 0);
     bbe:	2100      	movs	r1, #0
     bc0:	200a      	movs	r0, #10
     bc2:	f005 fd7d 	bl	66c0 <analogWrite>
      analogWrite(pinLED_B, 10);
     bc6:	210a      	movs	r1, #10
     bc8:	200b      	movs	r0, #11
}
     bca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 10);
     bce:	f005 bd77 	b.w	66c0 <analogWrite>
      analogWrite(pinLED_R, 0);
     bd2:	2100      	movs	r1, #0
     bd4:	200c      	movs	r0, #12
     bd6:	f005 fd73 	bl	66c0 <analogWrite>
      analogWrite(pinLED_G, 10);
     bda:	210a      	movs	r1, #10
      analogWrite(pinLED_G, 0);
     bdc:	200a      	movs	r0, #10
     bde:	f005 fd6f 	bl	66c0 <analogWrite>
      analogWrite(pinLED_B, 0);
     be2:	2100      	movs	r1, #0
     be4:	200b      	movs	r0, #11
}
     be6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      analogWrite(pinLED_B, 0);
     bea:	f005 bd69 	b.w	66c0 <analogWrite>
      analogWrite(pinLED_R, 10);
     bee:	210a      	movs	r1, #10
     bf0:	200c      	movs	r0, #12
     bf2:	f005 fd65 	bl	66c0 <analogWrite>
      analogWrite(pinLED_G, 0);
     bf6:	2100      	movs	r1, #0
     bf8:	e7f0      	b.n	bdc <LED()+0x54>
}
     bfa:	bd08      	pop	{r3, pc}
     bfc:	2000a580 	.word	0x2000a580

00000c00 <blinkLED(int, int, int, int, int)>:
void blinkLED(int duration, int flashes, int R, int G, int B) {
     c00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (int i = 0; i < flashes; i++) {
     c04:	1e0e      	subs	r6, r1, #0
void blinkLED(int duration, int flashes, int R, int G, int B) {
     c06:	f8dd 9020 	ldr.w	r9, [sp, #32]
  for (int i = 0; i < flashes; i++) {
     c0a:	dd24      	ble.n	c56 <blinkLED(int, int, int, int, int)+0x56>
     c0c:	4605      	mov	r5, r0
     c0e:	4617      	mov	r7, r2
     c10:	4698      	mov	r8, r3
     c12:	2400      	movs	r4, #0
    delay(duration);
     c14:	4628      	mov	r0, r5
  for (int i = 0; i < flashes; i++) {
     c16:	3401      	adds	r4, #1
    delay(duration);
     c18:	f005 f8e4 	bl	5de4 <delay>
    analogWrite(pinLED_R, R);
     c1c:	4639      	mov	r1, r7
     c1e:	200c      	movs	r0, #12
     c20:	f005 fd4e 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, G);
     c24:	4641      	mov	r1, r8
     c26:	200a      	movs	r0, #10
     c28:	f005 fd4a 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, B);
     c2c:	4649      	mov	r1, r9
     c2e:	200b      	movs	r0, #11
     c30:	f005 fd46 	bl	66c0 <analogWrite>
    delay(duration);
     c34:	4628      	mov	r0, r5
     c36:	f005 f8d5 	bl	5de4 <delay>
    analogWrite(pinLED_R, 0);
     c3a:	2100      	movs	r1, #0
     c3c:	200c      	movs	r0, #12
     c3e:	f005 fd3f 	bl	66c0 <analogWrite>
    analogWrite(pinLED_G, 0);
     c42:	2100      	movs	r1, #0
     c44:	200a      	movs	r0, #10
     c46:	f005 fd3b 	bl	66c0 <analogWrite>
    analogWrite(pinLED_B, 0);
     c4a:	2100      	movs	r1, #0
     c4c:	200b      	movs	r0, #11
     c4e:	f005 fd37 	bl	66c0 <analogWrite>
  for (int i = 0; i < flashes; i++) {
     c52:	42a6      	cmp	r6, r4
     c54:	d1de      	bne.n	c14 <blinkLED(int, int, int, int, int)+0x14>
  }
     c56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     c5a:	bf00      	nop

00000c5c <_GLOBAL__sub_I__Z15checkSwitchModev>:
     c5c:	f005 b9b8 	b.w	5fd0 <eeprom_initialize>

00000c60 <get_lockTarget_adjusted_value(unsigned char)>:

  return target;
}

static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
  if (state.mode == MODE_5050) {
     c60:	4b1c      	ldr	r3, [pc, #112]	; (cd4 <get_lockTarget_adjusted_value(unsigned char)+0x74>)
     c62:	781a      	ldrb	r2, [r3, #0]
     c64:	2a02      	cmp	r2, #2
     c66:	d022      	beq.n	cae <get_lockTarget_adjusted_value(unsigned char)+0x4e>
    }

    return 0;
  } else {
    // Potentially avoid doing math below..
    if (lockTarget == 0) {
     c68:	4b1b      	ldr	r3, [pc, #108]	; (cd8 <get_lockTarget_adjusted_value(unsigned char)+0x78>)
     c6a:	ed93 7a00 	vldr	s14, [r3]
     c6e:	eeb5 7a40 	vcmp.f32	s14, #0.0
     c72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c76:	d101      	bne.n	c7c <get_lockTarget_adjusted_value(unsigned char)+0x1c>
    return 0;
     c78:	2000      	movs	r0, #0
     c7a:	4770      	bx	lr

    /* Hackery to get the response closer to the target... we are trying to control the
        Haldex as if it's linear.. but it's not. In future, I'd like to implement some sort
        of feedback loop to trim the calculation being made here but this will do for now.  */
    float target_fudge_factor = lockTarget;
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     c7c:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5

    return value * (target_fudge_factor / 100);
     c80:	ed9f 6a16 	vldr	s12, [pc, #88]	; cdc <get_lockTarget_adjusted_value(unsigned char)+0x7c>
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     c84:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    return value * (target_fudge_factor / 100);
     c88:	ee07 0a90 	vmov	s15, r0
static uint8_t get_lockTarget_adjusted_value(uint8_t value) {
     c8c:	b082      	sub	sp, #8
    return value * (target_fudge_factor / 100);
     c8e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    target_fudge_factor = (target_fudge_factor / 2) + 20;
     c92:	eee7 6a25 	vfma.f32	s13, s14, s11
    return value * (target_fudge_factor / 100);
     c96:	ee86 7a86 	vdiv.f32	s14, s13, s12
     c9a:	ee67 7a87 	vmul.f32	s15, s15, s14
     c9e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
     ca2:	edcd 7a01 	vstr	s15, [sp, #4]
     ca6:	f89d 0004 	ldrb.w	r0, [sp, #4]
  }
}
     caa:	b002      	add	sp, #8
     cac:	4770      	bx	lr
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0) {
     cae:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     cb2:	4a0b      	ldr	r2, [pc, #44]	; (ce0 <get_lockTarget_adjusted_value(unsigned char)+0x80>)
     cb4:	ee07 3a90 	vmov	s15, r3
     cb8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     cbc:	edd2 7a00 	vldr	s15, [r2]
     cc0:	eeb4 7ae7 	vcmpe.f32	s14, s15
     cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     cc8:	d903      	bls.n	cd2 <get_lockTarget_adjusted_value(unsigned char)+0x72>
      return value;
     cca:	2b00      	cmp	r3, #0
     ccc:	bf18      	it	ne
     cce:	2000      	movne	r0, #0
     cd0:	4770      	bx	lr
}
     cd2:	4770      	bx	lr
     cd4:	2000a580 	.word	0x2000a580
     cd8:	2000a4f4 	.word	0x2000a4f4
     cdc:	42c80000 	.word	0x42c80000
     ce0:	2000a510 	.word	0x2000a510

00000ce4 <getLockData(CAN_message_t*)>:

void getLockData(CAN_message_t *frame) {
     ce4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (state.mode == MODE_5050) {
     ce8:	4d7c      	ldr	r5, [pc, #496]	; (edc <getLockData(CAN_message_t*)+0x1f8>)
void getLockData(CAN_message_t *frame) {
     cea:	4604      	mov	r4, r0
  if (state.mode == MODE_5050) {
     cec:	782b      	ldrb	r3, [r5, #0]
     cee:	2b02      	cmp	r3, #2
void getLockData(CAN_message_t *frame) {
     cf0:	ed2d 8b02 	vpush	{d8}
     cf4:	b086      	sub	sp, #24
  if (state.mode == MODE_5050) {
     cf6:	d079      	beq.n	dec <getLockData(CAN_message_t*)+0x108>
  } else if (state.mode == MODE_FWD) {
     cf8:	2b01      	cmp	r3, #1
     cfa:	d047      	beq.n	d8c <getLockData(CAN_message_t*)+0xa8>
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     cfc:	f895 0021 	ldrb.w	r0, [r5, #33]	; 0x21
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     d00:	786f      	ldrb	r7, [r5, #1]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     d02:	1e42      	subs	r2, r0, #1
  lockpoint lp_lower = state.custom_mode.lockpoints[0];
     d04:	f895 8002 	ldrb.w	r8, [r5, #2]
  lockpoint lp_upper = state.custom_mode.lockpoints[state.custom_mode.lockpoint_count - 1];
     d08:	eb02 0242 	add.w	r2, r2, r2, lsl #1
     d0c:	442a      	add	r2, r5
     d0e:	7853      	ldrb	r3, [r2, #1]
     d10:	7892      	ldrb	r2, [r2, #2]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     d12:	b1d8      	cbz	r0, d4c <getLockData(CAN_message_t*)+0x68>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     d14:	4972      	ldr	r1, [pc, #456]	; (ee0 <getLockData(CAN_message_t*)+0x1fc>)
     d16:	46ac      	mov	ip, r5
     d18:	46be      	mov	lr, r7
     d1a:	780e      	ldrb	r6, [r1, #0]
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     d1c:	2100      	movs	r1, #0
     d1e:	e004      	b.n	d2a <getLockData(CAN_message_t*)+0x46>
     d20:	3101      	adds	r1, #1
     d22:	4288      	cmp	r0, r1
     d24:	d012      	beq.n	d4c <getLockData(CAN_message_t*)+0x68>
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     d26:	f89c e001 	ldrb.w	lr, [ip, #1]
     d2a:	4576      	cmp	r6, lr
  for (int i = 0; i < state.custom_mode.lockpoint_count; i++) {
     d2c:	f10c 0c03 	add.w	ip, ip, #3
    if (vehicleSpeed <= state.custom_mode.lockpoints[i].speed) {
     d30:	d8f6      	bhi.n	d20 <getLockData(CAN_message_t*)+0x3c>
      lp_upper = state.custom_mode.lockpoints[i];
     d32:	eb01 0341 	add.w	r3, r1, r1, lsl #1
     d36:	442b      	add	r3, r5
     d38:	789a      	ldrb	r2, [r3, #2]
      lp_lower = state.custom_mode.lockpoints[(i == 0) ? 0 : i - 1];
     d3a:	b131      	cbz	r1, d4a <getLockData(CAN_message_t*)+0x66>
     d3c:	3901      	subs	r1, #1
     d3e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
     d42:	186b      	adds	r3, r5, r1
     d44:	785f      	ldrb	r7, [r3, #1]
     d46:	f893 8002 	ldrb.w	r8, [r3, #2]
      break;
     d4a:	4673      	mov	r3, lr
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     d4c:	f895 1022 	ldrb.w	r1, [r5, #34]	; 0x22
     d50:	4864      	ldr	r0, [pc, #400]	; (ee4 <getLockData(CAN_message_t*)+0x200>)
     d52:	ee07 1a90 	vmov	s15, r1
     d56:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     d5a:	edd0 7a00 	vldr	s15, [r0]
     d5e:	eeb4 7ae7 	vcmpe.f32	s14, s15
     d62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d66:	d80b      	bhi.n	d80 <getLockData(CAN_message_t*)+0x9c>
    if (vehicleSpeed <= lp_lower.speed) {
     d68:	495d      	ldr	r1, [pc, #372]	; (ee0 <getLockData(CAN_message_t*)+0x1fc>)
     d6a:	7809      	ldrb	r1, [r1, #0]
     d6c:	42b9      	cmp	r1, r7
     d6e:	f240 80af 	bls.w	ed0 <getLockData(CAN_message_t*)+0x1ec>
    if (vehicleSpeed >= lp_upper.speed) {
     d72:	4299      	cmp	r1, r3
     d74:	d37f      	bcc.n	e76 <getLockData(CAN_message_t*)+0x192>
      return lp_upper.lock;
     d76:	ee07 2a90 	vmov	s15, r2
     d7a:	eeb8 8a67 	vcvt.f32.u32	s16, s15
     d7e:	e007      	b.n	d90 <getLockData(CAN_message_t*)+0xac>
  if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     d80:	2900      	cmp	r1, #0
     d82:	d0f1      	beq.n	d68 <getLockData(CAN_message_t*)+0x84>
     d84:	f895 1023 	ldrb.w	r1, [r5, #35]	; 0x23
     d88:	2900      	cmp	r1, #0
     d8a:	d1ed      	bne.n	d68 <getLockData(CAN_message_t*)+0x84>
      return 0;
     d8c:	ed9f 8a56 	vldr	s16, [pc, #344]	; ee8 <getLockData(CAN_message_t*)+0x204>
  // returns fraction if locking slightly?
  // assumed frame.buf[1] = 0 x (0xF0)?
  // assumed frame.buf[1] = Value x (0xF0)?
  // assumed frame.buf[1] = 100 x (0xF0)?

  switch (frame->id) {
     d90:	6823      	ldr	r3, [r4, #0]
  lockTarget = get_lockTarget_adjustment();
     d92:	4a56      	ldr	r2, [pc, #344]	; (eec <getLockData(CAN_message_t*)+0x208>)
  switch (frame->id) {
     d94:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
  lockTarget = get_lockTarget_adjustment();
     d98:	ed82 8a00 	vstr	s16, [r2]
  switch (frame->id) {
     d9c:	d05d      	beq.n	e5a <getLockData(CAN_message_t*)+0x176>
     d9e:	d83f      	bhi.n	e20 <getLockData(CAN_message_t*)+0x13c>
     da0:	f5b3 7fd0 	cmp.w	r3, #416	; 0x1a0
     da4:	d051      	beq.n	e4a <getLockData(CAN_message_t*)+0x166>
     da6:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
     daa:	d11a      	bne.n	de2 <getLockData(CAN_message_t*)+0xfe>
    case MOTOR1_ID:
      //frame->buf[0] = 0;                                  // clutch pedal etc
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
     dac:	20fa      	movs	r0, #250	; 0xfa
     dae:	f7ff ff57 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
      frame->buf[2] = 0x20;                                 // motor speed (rpm): 32 >
     db2:	f644 6320 	movw	r3, #20000	; 0x4e20
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
     db6:	4602      	mov	r2, r0
      frame->buf[3] = 0x4E;                                 // motor speed (rpm): 78 > 0.25 * 3278 = 819.5 RPM (was 0x4e)  Leave RPM the same?
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     db8:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[2] = 0x20;                                 // motor speed (rpm): 32 >
     dba:	81e3      	strh	r3, [r4, #14]
      frame->buf[1] = get_lockTarget_adjusted_value(0xFA);  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
     dbc:	7362      	strb	r2, [r4, #13]
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     dbe:	f7ff ff4f 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
     dc2:	4603      	mov	r3, r0
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
     dc4:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[4] = get_lockTarget_adjusted_value(0xFE);  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     dc6:	7423      	strb	r3, [r4, #16]
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
     dc8:	f7ff ff4a 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
     dcc:	4603      	mov	r3, r0
      frame->buf[6] = get_lockTarget_adjusted_value(0x20);  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
     dce:	2020      	movs	r0, #32
      frame->buf[5] = get_lockTarget_adjusted_value(0xFE);  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
     dd0:	7463      	strb	r3, [r4, #17]
      frame->buf[6] = get_lockTarget_adjusted_value(0x20);  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
     dd2:	f7ff ff45 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
     dd6:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // drivers moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     dd8:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[6] = get_lockTarget_adjusted_value(0x20);  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
     dda:	74a3      	strb	r3, [r4, #18]
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // drivers moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
     ddc:	f7ff ff40 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
     de0:	74e0      	strb	r0, [r4, #19]
  /*
  haldex.buf[0] = 0x00;
  haldex.buf[1] = dummy_haldexEngagement++;   // Kupplungssteifigk
  haldex.buf[2] = PNG Status (not sent?)
  */
     de2:	b006      	add	sp, #24
     de4:	ecbd 8b02 	vpop	{d8}
     de8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pedValue >= state.ped_threshold || state.ped_threshold == 0 || state.mode_override) {
     dec:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
     df0:	4a3c      	ldr	r2, [pc, #240]	; (ee4 <getLockData(CAN_message_t*)+0x200>)
     df2:	ee07 3a90 	vmov	s15, r3
     df6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     dfa:	edd2 7a00 	vldr	s15, [r2]
     dfe:	eeb4 7ae7 	vcmpe.f32	s14, s15
     e02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     e06:	d960      	bls.n	eca <getLockData(CAN_message_t*)+0x1e6>
     e08:	2b00      	cmp	r3, #0
     e0a:	d05e      	beq.n	eca <getLockData(CAN_message_t*)+0x1e6>
     e0c:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
      return 100;
     e10:	ed9f 8a35 	vldr	s16, [pc, #212]	; ee8 <getLockData(CAN_message_t*)+0x204>
     e14:	eddf 7a36 	vldr	s15, [pc, #216]	; ef0 <getLockData(CAN_message_t*)+0x20c>
     e18:	2b00      	cmp	r3, #0
     e1a:	fe08 8a27 	vseleq.f32	s16, s16, s15
     e1e:	e7b7      	b.n	d90 <getLockData(CAN_message_t*)+0xac>
  switch (frame->id) {
     e20:	f5b3 6f94 	cmp.w	r3, #1184	; 0x4a0
     e24:	d1dd      	bne.n	de2 <getLockData(CAN_message_t*)+0xfe>
      adjusted_slip = get_lockTarget_adjusted_value(0xA);          // 0xF4 = 244 in DEC.  0A = 10 in DEC.  244+10 = 254 (max speed).  255=0xFF (inplausible)
     e26:	200a      	movs	r0, #10
     e28:	f7ff ff1a 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
      frame->buf[0] = 0x0;
     e2c:	f04f 230a 	mov.w	r3, #167774720	; 0xa000a00
      frame->buf[5] = (0xFA)+adjusted_slip;       // 254+10? (5050 returns 0xA)
     e30:	3806      	subs	r0, #6
      frame->buf[4] = 0x0;
     e32:	2200      	movs	r2, #0
      frame->buf[0] = 0x0;
     e34:	60e3      	str	r3, [r4, #12]
      frame->buf[5] = (0xFA)+adjusted_slip;       // 254+10? (5050 returns 0xA)
     e36:	b2c3      	uxtb	r3, r0
      frame->buf[4] = 0x0;
     e38:	7422      	strb	r2, [r4, #16]
      frame->buf[6] = 0x0;
     e3a:	74a2      	strb	r2, [r4, #18]
      frame->buf[5] = (0xFA)+adjusted_slip;       // 254+10? (5050 returns 0xA)
     e3c:	7463      	strb	r3, [r4, #17]
      frame->buf[7] = (0xFA)+adjusted_slip;       // 254+10? was FE
     e3e:	74e3      	strb	r3, [r4, #19]
     e40:	b006      	add	sp, #24
     e42:	ecbd 8b02 	vpop	{d8}
     e46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = 0x0;
     e4a:	f44f 6320 	mov.w	r3, #2560	; 0xa00
     e4e:	81e3      	strh	r3, [r4, #14]
     e50:	b006      	add	sp, #24
     e52:	ecbd 8b02 	vpop	{d8}
     e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      frame->buf[2] = get_lockTarget_adjusted_value(0xFA);  // driving pedal (%): 0.4*(0xFA) = 100% (was 0xfa)
     e5a:	20fa      	movs	r0, #250	; 0xfa
     e5c:	f7ff ff00 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
     e60:	4603      	mov	r3, r0
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // throttle angle? (0.39 * 'FE' = 99.06) (was 0xfa)
     e62:	20fe      	movs	r0, #254	; 0xfe
      frame->buf[2] = get_lockTarget_adjusted_value(0xFA);  // driving pedal (%): 0.4*(0xFA) = 100% (was 0xfa)
     e64:	73a3      	strb	r3, [r4, #14]
      frame->buf[7] = get_lockTarget_adjusted_value(0xFE);  // throttle angle? (0.39 * 'FE' = 99.06) (was 0xfa)
     e66:	f7ff fefb 	bl	c60 <get_lockTarget_adjusted_value(unsigned char)>
     e6a:	74e0      	strb	r0, [r4, #19]
     e6c:	b006      	add	sp, #24
     e6e:	ecbd 8b02 	vpop	{d8}
     e72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e76:	ee07 8a90 	vmov	s15, r8
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e7a:	9102      	str	r1, [sp, #8]
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e7c:	1bc9      	subs	r1, r1, r7
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e7e:	9701      	str	r7, [sp, #4]
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e80:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e84:	1bdf      	subs	r7, r3, r7
     e86:	ee07 1a90 	vmov	s15, r1
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e8a:	f8cd 8000 	str.w	r8, [sp]
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e8e:	eba2 0808 	sub.w	r8, r2, r8
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     e92:	4818      	ldr	r0, [pc, #96]	; (ef4 <getLockData(CAN_message_t*)+0x210>)
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     e94:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
     e98:	ee07 7a90 	vmov	s15, r7
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     e9c:	ee06 8a90 	vmov	s13, r8
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     ea0:	7800      	ldrb	r0, [r0, #0]
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     ea2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     ea6:	4914      	ldr	r1, [pc, #80]	; (ef8 <getLockData(CAN_message_t*)+0x214>)
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     ea8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     eac:	9003      	str	r0, [sp, #12]
     eae:	4813      	ldr	r0, [pc, #76]	; (efc <getLockData(CAN_message_t*)+0x218>)
    float inter = (float)(lp_upper.speed - lp_lower.speed) / (float)(vehicleSpeed - lp_lower.speed);
     eb0:	eec7 5a87 	vdiv.f32	s11, s15, s14
    target = lp_lower.lock + ((float)(lp_upper.lock - lp_lower.lock) / inter);
     eb4:	ee86 8aa5 	vdiv.f32	s16, s13, s11
     eb8:	ee38 8a06 	vadd.f32	s16, s16, s12
    Serial.printf("lp_upper:%d@%d lp_lower:%d@%d speed:%d(0x%x) target=%0.2f\n",
     ebc:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
     ec0:	ed8d 7b04 	vstr	d7, [sp, #16]
     ec4:	f004 fdac 	bl	5a20 <Print::printf(char const*, ...)>
     ec8:	e762      	b.n	d90 <getLockData(CAN_message_t*)+0xac>
      return 100;
     eca:	ed9f 8a09 	vldr	s16, [pc, #36]	; ef0 <getLockData(CAN_message_t*)+0x20c>
     ece:	e75f      	b.n	d90 <getLockData(CAN_message_t*)+0xac>
      return lp_lower.lock;
     ed0:	ee07 8a90 	vmov	s15, r8
     ed4:	eeb8 8a67 	vcvt.f32.u32	s16, s15
     ed8:	e75a      	b.n	d90 <getLockData(CAN_message_t*)+0xac>
     eda:	bf00      	nop
     edc:	2000a580 	.word	0x2000a580
     ee0:	2000a720 	.word	0x2000a720
     ee4:	2000a510 	.word	0x2000a510
     ee8:	00000000 	.word	0x00000000
     eec:	2000a4f4 	.word	0x2000a4f4
     ef0:	42c80000 	.word	0x42c80000
     ef4:	2000a70f 	.word	0x2000a70f
     ef8:	200003f0 	.word	0x200003f0
     efc:	20001110 	.word	0x20001110

00000f00 <_GLOBAL__sub_I_lockTarget>:
     f00:	f005 b866 	b.w	5fd0 <eeprom_initialize>

00000f04 <CANListener::frameHandler(CAN_message_t&, int, unsigned char)>:
#define SIZE_LISTENERS 4

class CANListener {
  public:
    CANListener () { callbacksActive = 0; }
    virtual bool frameHandler (CAN_message_t &frame, int mailbox, uint8_t controller) { return false; }
     f04:	2000      	movs	r0, #0
     f06:	4770      	bx	lr

00000f08 <flexcan_isr_can1()>:
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
}

#if defined(__IMXRT1062__)
static void flexcan_isr_can1() {
  if ( _CAN1 ) _CAN1->flexcan_interrupt();
     f08:	4b03      	ldr	r3, [pc, #12]	; (f18 <flexcan_isr_can1()+0x10>)
     f0a:	6818      	ldr	r0, [r3, #0]
     f0c:	b110      	cbz	r0, f14 <flexcan_isr_can1()+0xc>
     f0e:	6803      	ldr	r3, [r0, #0]
     f10:	681b      	ldr	r3, [r3, #0]
     f12:	4718      	bx	r3
}
     f14:	4770      	bx	lr
     f16:	bf00      	nop
     f18:	2000a320 	.word	0x2000a320

00000f1c <flexcan_isr_can2()>:

static void flexcan_isr_can2() {
  if ( _CAN2 ) _CAN2->flexcan_interrupt();
     f1c:	4b03      	ldr	r3, [pc, #12]	; (f2c <flexcan_isr_can2()+0x10>)
     f1e:	6818      	ldr	r0, [r3, #0]
     f20:	b110      	cbz	r0, f28 <flexcan_isr_can2()+0xc>
     f22:	6803      	ldr	r3, [r0, #0]
     f24:	681b      	ldr	r3, [r3, #0]
     f26:	4718      	bx	r3
}
     f28:	4770      	bx	lr
     f2a:	bf00      	nop
     f2c:	2000a324 	.word	0x2000a324

00000f30 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     f30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
     f34:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     f38:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     f3a:	4c57      	ldr	r4, [pc, #348]	; (1098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
     f3c:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     f3e:	4b57      	ldr	r3, [pc, #348]	; (109c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
     f40:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
     f42:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     f46:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     f48:	4855      	ldr	r0, [pc, #340]	; (10a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     f4a:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     f4e:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     f50:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
     f52:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
     f56:	446b      	add	r3, sp
     f58:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
     f5c:	4b51      	ldr	r3, [pc, #324]	; (10a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
     f5e:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f62:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     f64:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     f68:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f6c:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
     f70:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
     f72:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
     f74:	6803      	ldr	r3, [r0, #0]
     f76:	01df      	lsls	r7, r3, #7
     f78:	d5fc      	bpl.n	f74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
     f7a:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     f7c:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
     f80:	d92a      	bls.n	fd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
     f82:	4660      	mov	r0, ip
     f84:	1c83      	adds	r3, r0, #2
    divisor++;
     f86:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
     f88:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
     f8c:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
     f8e:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
     f92:	d8f7      	bhi.n	f84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     f94:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
     f98:	fbb6 f3f3 	udiv	r3, r6, r3
     f9c:	1acb      	subs	r3, r1, r3
     f9e:	2b00      	cmp	r3, #0
     fa0:	bfb8      	it	lt
     fa2:	425b      	neglt	r3, r3
      if (error < bestError) {
     fa4:	42ab      	cmp	r3, r5
     fa6:	db0b      	blt.n	fc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
     fa8:	f1a7 030c 	sub.w	r3, r7, #12
     fac:	bf18      	it	ne
     fae:	f04f 0800 	movne.w	r8, #0
     fb2:	2b06      	cmp	r3, #6
     fb4:	d80a      	bhi.n	fcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
     fb6:	f1b8 0f00 	cmp.w	r8, #0
     fba:	d007      	beq.n	fcc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
     fbc:	4684      	mov	ip, r0
     fbe:	e7e1      	b.n	f84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
     fc0:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
     fc2:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
     fc6:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
     fc8:	2b06      	cmp	r3, #6
     fca:	d9f4      	bls.n	fb6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
     fcc:	2f05      	cmp	r7, #5
     fce:	d8d9      	bhi.n	f84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
     fd0:	f10c 0301 	add.w	r3, ip, #1
     fd4:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
     fd8:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
     fdc:	f1a2 0205 	sub.w	r2, r2, #5
     fe0:	dc4c      	bgt.n	107c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
     fe2:	2a14      	cmp	r2, #20
     fe4:	d84a      	bhi.n	107c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     fe6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
     fea:	4f2f      	ldr	r7, [pc, #188]	; (10a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
     fec:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
     fee:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 10a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     ff2:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
     ff6:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
     ffa:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
     ffe:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1000:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    1002:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1004:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    1006:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1008:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    100a:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    100e:	c607      	stmia	r6!, {r0, r1, r2}
    1010:	f826 3b02 	strh.w	r3, [r6], #2
    1014:	ea4f 4313 	mov.w	r3, r3, lsr #16
    1018:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    101a:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    101e:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    1022:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    1026:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    102a:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    102e:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
    1032:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    1036:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    103a:	ea43 0302 	orr.w	r3, r3, r2
    103e:	ea43 0301 	orr.w	r3, r3, r1
    1042:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    1046:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    104a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    104e:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
    1052:	f8d8 3004 	ldr.w	r3, [r8, #4]
    1056:	bf14      	ite	ne
    1058:	f023 0308 	bicne.w	r3, r3, #8
    105c:	f043 0308 	orreq.w	r3, r3, #8
    1060:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1064:	b93c      	cbnz	r4, 1076 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1066:	4a0e      	ldr	r2, [pc, #56]	; (10a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    1068:	6813      	ldr	r3, [r2, #0]
    106a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    106e:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1070:	6813      	ldr	r3, [r2, #0]
    1072:	01db      	lsls	r3, r3, #7
    1074:	d4fc      	bmi.n	1070 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
    1076:	b010      	add	sp, #64	; 0x40
    1078:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    107c:	2c00      	cmp	r4, #0
    107e:	d1fa      	bne.n	1076 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1080:	4a07      	ldr	r2, [pc, #28]	; (10a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    1082:	6813      	ldr	r3, [r2, #0]
    1084:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1088:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    108a:	6813      	ldr	r3, [r2, #0]
    108c:	01d9      	lsls	r1, r3, #7
    108e:	d4fc      	bmi.n	108a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
    1090:	b010      	add	sp, #64	; 0x40
    1092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1096:	bf00      	nop
    1098:	0050183c 	.word	0x0050183c
    109c:	400fc000 	.word	0x400fc000
    10a0:	401d0000 	.word	0x401d0000
    10a4:	000f4240 	.word	0x000f4240
    10a8:	20000370 	.word	0x20000370

000010ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>:
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
    10ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  currentBitrate = baud;
    10b0:	f500 5000 	add.w	r0, r0, #8192	; 0x2000
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
    10b4:	b090      	sub	sp, #64	; 0x40
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    10b6:	4c57      	ldr	r4, [pc, #348]	; (1214 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x168>)
FCTP_FUNC void FCTP_OPT::setBaudRate(uint32_t baud, FLEXCAN_RXTX listen_only) {
    10b8:	4696      	mov	lr, r2
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    10ba:	4b57      	ldr	r3, [pc, #348]	; (1218 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x16c>)
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    10bc:	9400      	str	r4, [sp, #0]
  currentBitrate = baud;
    10be:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    10c2:	6a1b      	ldr	r3, [r3, #32]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    10c4:	4855      	ldr	r0, [pc, #340]	; (121c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    10c6:	f3c3 2301 	ubfx	r3, r3, #8, #2
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    10ca:	6804      	ldr	r4, [r0, #0]
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    10cc:	3340      	adds	r3, #64	; 0x40
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    10ce:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    10d2:	446b      	add	r3, sp
    10d4:	f813 6c40 	ldrb.w	r6, [r3, #-64]
  uint32_t clockFreq = getClock() * 1000000;
    10d8:	4b51      	ldr	r3, [pc, #324]	; (1220 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x174>)
    10da:	fb03 f606 	mul.w	r6, r3, r6
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    10de:	6803      	ldr	r3, [r0, #0]
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
    10e0:	fbb6 f2f1 	udiv	r2, r6, r1
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
    10e4:	fbb6 f5f2 	udiv	r5, r6, r2
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    10e8:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
  int error = baud - (clockFreq / (result * (divisor + 1))), bestError = error;
    10ec:	1b4d      	subs	r5, r1, r5
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    10ee:	6003      	str	r3, [r0, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    10f0:	6803      	ldr	r3, [r0, #0]
    10f2:	01df      	lsls	r7, r3, #7
    10f4:	d5fc      	bpl.n	10f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x44>
  while (result > 5) {
    10f6:	2a05      	cmp	r2, #5
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
    10f8:	f04f 0c00 	mov.w	ip, #0
  while (result > 5) {
    10fc:	d92a      	bls.n	1154 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0xa8>
  uint32_t divisor = 0, bestDivisor = 0, result = clockFreq / baud / (divisor + 1);
    10fe:	4660      	mov	r0, ip
    1100:	1c83      	adds	r3, r0, #2
    divisor++;
    1102:	3001      	adds	r0, #1
    result = clockFreq / baud / (divisor + 1);
    1104:	fbb2 f7f3 	udiv	r7, r2, r3
    if (result <= 25) {
    1108:	2f19      	cmp	r7, #25
      error = baud - (clockFreq / (result * (divisor + 1)));
    110a:	fb07 f303 	mul.w	r3, r7, r3
    if (result <= 25) {
    110e:	d8f7      	bhi.n	1100 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
    1110:	f04f 0801 	mov.w	r8, #1
      error = baud - (clockFreq / (result * (divisor + 1)));
    1114:	fbb6 f3f3 	udiv	r3, r6, r3
    1118:	1acb      	subs	r3, r1, r3
    111a:	2b00      	cmp	r3, #0
    111c:	bfb8      	it	lt
    111e:	425b      	neglt	r3, r3
      if (error < bestError) {
    1120:	42ab      	cmp	r3, r5
    1122:	db0b      	blt.n	113c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x90>
      if ((error == bestError) && (result > 11) && (result < 19)) {
    1124:	f1a7 030c 	sub.w	r3, r7, #12
    1128:	bf18      	it	ne
    112a:	f04f 0800 	movne.w	r8, #0
    112e:	2b06      	cmp	r3, #6
    1130:	d80a      	bhi.n	1148 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
    1132:	f1b8 0f00 	cmp.w	r8, #0
    1136:	d007      	beq.n	1148 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x9c>
        bestDivisor = divisor;
    1138:	4684      	mov	ip, r0
    113a:	e7e1      	b.n	1100 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
    113c:	461d      	mov	r5, r3
      if ((error == bestError) && (result > 11) && (result < 19)) {
    113e:	f1a7 030c 	sub.w	r3, r7, #12
        bestDivisor = divisor;
    1142:	4684      	mov	ip, r0
      if ((error == bestError) && (result > 11) && (result < 19)) {
    1144:	2b06      	cmp	r3, #6
    1146:	d9f4      	bls.n	1132 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x86>
  while (result > 5) {
    1148:	2f05      	cmp	r7, #5
    114a:	d8d9      	bhi.n	1100 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x54>
  result = clockFreq / baud / (divisor + 1);
    114c:	f10c 0301 	add.w	r3, ip, #1
    1150:	fbb2 f2f3 	udiv	r2, r2, r3
  if ((result < 5) || (result > 25) || (bestError > 300)) {
    1154:	f5b5 7f96 	cmp.w	r5, #300	; 0x12c
    1158:	f1a2 0205 	sub.w	r2, r2, #5
    115c:	dc4c      	bgt.n	11f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
    115e:	2a14      	cmp	r2, #20
    1160:	d84a      	bhi.n	11f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x14c>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
    1162:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  uint8_t bitTimingTable[21][3] = {
    1166:	4f2f      	ldr	r7, [pc, #188]	; (1224 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x178>)
    1168:	466e      	mov	r6, sp
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    116a:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 121c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
    116e:	f102 0340 	add.w	r3, r2, #64	; 0x40
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
    1172:	f1be 0f02 	cmp.w	lr, #2
  }, propSeg = bitTimingTable[result][0], pSeg1 = bitTimingTable[result][1], pSeg2 = bitTimingTable[result][2];
    1176:	eb0d 0503 	add.w	r5, sp, r3
  uint8_t bitTimingTable[21][3] = {
    117a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    117c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    117e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1180:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    1182:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    1184:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    1186:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    118a:	c607      	stmia	r6!, {r0, r1, r2}
    118c:	f826 3b02 	strh.w	r3, [r6], #2
    1190:	ea4f 4313 	mov.w	r3, r3, lsr #16
    1194:	7033      	strb	r3, [r6, #0]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    1196:	f815 3c3f 	ldrb.w	r3, [r5, #-63]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    119a:	f815 2c3e 	ldrb.w	r2, [r5, #-62]
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    119e:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    11a2:	f815 1c40 	ldrb.w	r1, [r5, #-64]
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    11a6:	ea4f 4202 	mov.w	r2, r2, lsl #16
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    11aa:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
    11ae:	f001 0107 	and.w	r1, r1, #7
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    11b2:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    11b6:	ea43 0302 	orr.w	r3, r3, r2
    11ba:	ea43 0301 	orr.w	r3, r3, r1
    11be:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
                    FLEXCAN_CTRL_PSEG2(pSeg2) | FLEXCAN_CTRL_ERR_MSK | FLEXCAN_CTRL_PRESDIV(divisor));
    11c2:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    11c6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  FLEXCANb_CTRL1(_bus) = (FLEXCAN_CTRL_PROPSEG(propSeg) | FLEXCAN_CTRL_RJW(1) | FLEXCAN_CTRL_PSEG1(pSeg1) |
    11ca:	f8c8 3004 	str.w	r3, [r8, #4]
  ( listen_only != LISTEN_ONLY ) ? FLEXCANb_CTRL1(_bus) &= ~FLEXCAN_CTRL_LOM : FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen-only mode */
    11ce:	f8d8 3004 	ldr.w	r3, [r8, #4]
    11d2:	bf14      	ite	ne
    11d4:	f023 0308 	bicne.w	r3, r3, #8
    11d8:	f043 0308 	orreq.w	r3, r3, #8
    11dc:	f8c8 3004 	str.w	r3, [r8, #4]
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    11e0:	b93c      	cbnz	r4, 11f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    11e2:	4a0e      	ldr	r2, [pc, #56]	; (121c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    11e4:	6813      	ldr	r3, [r2, #0]
    11e6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    11ea:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    11ec:	6813      	ldr	r3, [r2, #0]
    11ee:	01db      	lsls	r3, r3, #7
    11f0:	d4fc      	bmi.n	11ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x140>
}
    11f2:	b010      	add	sp, #64	; 0x40
    11f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    11f8:	2c00      	cmp	r4, #0
    11fa:	d1fa      	bne.n	11f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x146>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    11fc:	4a07      	ldr	r2, [pc, #28]	; (121c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x170>)
    11fe:	6813      	ldr	r3, [r2, #0]
    1200:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1204:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1206:	6813      	ldr	r3, [r2, #0]
    1208:	01d9      	lsls	r1, r3, #7
    120a:	d4fc      	bmi.n	1206 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)+0x15a>
}
    120c:	b010      	add	sp, #64	; 0x40
    120e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1212:	bf00      	nop
    1214:	0050183c 	.word	0x0050183c
    1218:	400fc000 	.word	0x400fc000
    121c:	401d4000 	.word	0x401d4000
    1220:	000f4240 	.word	0x000f4240
    1224:	20000370 	.word	0x20000370

00001228 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3); /* input 3 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4); /* input 4 ID's to be filtered */
    bool setMBFilter(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2, uint32_t id3, uint32_t id4, uint32_t id5); /* input 5 ID's to be filtered */
    bool setMBFilterRange(FLEXCAN_MAILBOX mb_num, uint32_t id1, uint32_t id2); /* filter a range of ids */
    int write(const CAN_message_t &msg); /* use any available mailbox for transmitting */
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
    1228:	2000      	movs	r0, #0
    122a:	4770      	bx	lr

0000122c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
    122c:	2000      	movs	r0, #0
    122e:	4770      	bx	lr

00001230 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
#endif
    void enhanceFilter(FLEXCAN_MAILBOX mb_num);
    void distribute(bool state = 1) { distribution = state; }
    void enableDMA(bool state = 1);
    void disableDMA() { enableDMA(0); }
    uint8_t getFirstTxBoxSize(){ return 8; }
    1230:	2008      	movs	r0, #8
    1232:	4770      	bx	lr

00001234 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CANFD_message_t const&)>:
    int write(const CANFD_message_t &msg) { return 0; } /* to satisfy base class for external pointers */
    1234:	2000      	movs	r0, #0
    1236:	4770      	bx	lr

00001238 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::isFD()>:
    bool isFD() { return 0; }
    1238:	2000      	movs	r0, #0
    123a:	4770      	bx	lr

0000123c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::getFirstTxBoxSize()>:
    uint8_t getFirstTxBoxSize(){ return 8; }
    123c:	2008      	movs	r0, #8
    123e:	4770      	bx	lr

00001240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1240:	4910      	ldr	r1, [pc, #64]	; (1284 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    1242:	680b      	ldr	r3, [r1, #0]
    1244:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1246:	680a      	ldr	r2, [r1, #0]
    1248:	6b49      	ldr	r1, [r1, #52]	; 0x34
    124a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    124e:	f3c1 6103 	ubfx	r1, r1, #24, #4
    1252:	3201      	adds	r2, #1
    1254:	3104      	adds	r1, #4
    1256:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
    125a:	d310      	bcc.n	127e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    125c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1260:	f3c0 6003 	ubfx	r0, r0, #24, #4
    1264:	3b05      	subs	r3, #5
    1266:	3001      	adds	r0, #1
    1268:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
    126c:	b2db      	uxtb	r3, r3
    126e:	4a05      	ldr	r2, [pc, #20]	; (1284 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    1270:	6810      	ldr	r0, [r2, #0]
    1272:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    1276:	3001      	adds	r0, #1
    1278:	1ac0      	subs	r0, r0, r3
}
    127a:	b2c0      	uxtb	r0, r0
    127c:	4770      	bx	lr
    127e:	2300      	movs	r3, #0
    1280:	e7f5      	b.n	126e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
    1282:	bf00      	nop
    1284:	401d0000 	.word	0x401d0000

00001288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>:
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1288:	4910      	ldr	r1, [pc, #64]	; (12cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    128a:	680b      	ldr	r3, [r1, #0]
    128c:	6b48      	ldr	r0, [r1, #52]	; 0x34
  if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    128e:	680a      	ldr	r2, [r1, #0]
    1290:	6b49      	ldr	r1, [r1, #52]	; 0x34
    1292:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    1296:	f3c1 6103 	ubfx	r1, r1, #24, #4
    129a:	3201      	adds	r2, #1
    129c:	3104      	adds	r1, #4
    129e:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
    12a2:	d310      	bcc.n	12c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x3e>
  uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    12a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    12a8:	f3c0 6003 	ubfx	r0, r0, #24, #4
    12ac:	3b05      	subs	r3, #5
    12ae:	3001      	adds	r0, #1
    12b0:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
  return (FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes); /* otherwise return offset MB position after FIFO area */
    12b4:	b2db      	uxtb	r3, r3
    12b6:	4a05      	ldr	r2, [pc, #20]	; (12cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x44>)
    12b8:	6810      	ldr	r0, [r2, #0]
    12ba:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    12be:	3001      	adds	r0, #1
    12c0:	1ac0      	subs	r0, r0, r3
}
    12c2:	b2c0      	uxtb	r0, r0
    12c4:	4770      	bx	lr
    12c6:	2300      	movs	r3, #0
    12c8:	e7f5      	b.n	12b6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]+0x2e>
    12ca:	bf00      	nop
    12cc:	401d4000 	.word	0x401d4000

000012d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    12d0:	4a63      	ldr	r2, [pc, #396]	; (1460 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    12d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    12d6:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    12d8:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    12da:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    12de:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    12e2:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    12e4:	6813      	ldr	r3, [r2, #0]
    12e6:	01dd      	lsls	r5, r3, #7
    12e8:	d5fc      	bpl.n	12e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    12ea:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    12ec:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    12ee:	f8df c178 	ldr.w	ip, [pc, #376]	; 1468 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    12f2:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    12f6:	4f5b      	ldr	r7, [pc, #364]	; (1464 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    12f8:	4e59      	ldr	r6, [pc, #356]	; (1460 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    12fa:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    12fc:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    12fe:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    1300:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1302:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1304:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1308:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    130a:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    130c:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    130e:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1310:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1312:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1314:	6091      	str	r1, [r2, #8]
    1316:	6051      	str	r1, [r2, #4]
    1318:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    131a:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    131c:	6832      	ldr	r2, [r6, #0]
    131e:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    1322:	3201      	adds	r2, #1
    1324:	4293      	cmp	r3, r2
    1326:	d3ed      	bcc.n	1304 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    1328:	64b1      	str	r1, [r6, #72]	; 0x48
    132a:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    132c:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    132e:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    1330:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    1332:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    1334:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    1336:	2800      	cmp	r0, #0
    1338:	d149      	bne.n	13ce <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    133a:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1468 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    133e:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1340:	4e47      	ldr	r6, [pc, #284]	; (1460 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1342:	4f48      	ldr	r7, [pc, #288]	; (1464 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    1344:	e019      	b.n	137a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    1346:	6833      	ldr	r3, [r6, #0]
    1348:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    134c:	3301      	adds	r3, #1
    134e:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    1352:	bf34      	ite	cc
    1354:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    1358:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    135c:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    135e:	6b73      	ldr	r3, [r6, #52]	; 0x34
    1360:	f3c3 4300 	ubfx	r3, r3, #16, #1
    1364:	079b      	lsls	r3, r3, #30
    1366:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1368:	6833      	ldr	r3, [r6, #0]
    136a:	3501      	adds	r5, #1
    136c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1370:	b2ed      	uxtb	r5, r5
    1372:	3301      	adds	r3, #1
    1374:	4628      	mov	r0, r5
    1376:	429d      	cmp	r5, r3
    1378:	d21e      	bcs.n	13b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    137a:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    137c:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1380:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1382:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1386:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1388:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    138a:	3301      	adds	r3, #1
    138c:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    1390:	d3d9      	bcc.n	1346 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1392:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    1396:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1398:	6833      	ldr	r3, [r6, #0]
    139a:	009a      	lsls	r2, r3, #2
    139c:	d503      	bpl.n	13a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    139e:	f7ff ff4f 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    13a2:	42a8      	cmp	r0, r5
    13a4:	d8e0      	bhi.n	1368 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    13a6:	2301      	movs	r3, #1
    13a8:	2d1f      	cmp	r5, #31
    13aa:	fa03 f305 	lsl.w	r3, r3, r5
    13ae:	d84c      	bhi.n	144a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    13b0:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    13b2:	4313      	orrs	r3, r2
    13b4:	62b3      	str	r3, [r6, #40]	; 0x28
    13b6:	e7d7      	b.n	1368 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    13b8:	b93c      	cbnz	r4, 13ca <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    13ba:	4a29      	ldr	r2, [pc, #164]	; (1460 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    13bc:	6813      	ldr	r3, [r2, #0]
    13be:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    13c2:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    13c4:	6813      	ldr	r3, [r2, #0]
    13c6:	01db      	lsls	r3, r3, #7
    13c8:	d4fc      	bmi.n	13c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    13ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    13ce:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    13d2:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    13d4:	6835      	ldr	r5, [r6, #0]
    13d6:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    13da:	d03e      	beq.n	145a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    13dc:	f7ff ff30 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    13e0:	6833      	ldr	r3, [r6, #0]
    13e2:	4605      	mov	r5, r0
    13e4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    13e8:	3301      	adds	r3, #1
    13ea:	4283      	cmp	r3, r0
    13ec:	d9e4      	bls.n	13b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    13ee:	4f1e      	ldr	r7, [pc, #120]	; (1468 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    13f0:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    13f4:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1460 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    13f8:	e00d      	b.n	1416 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    13fa:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    13fe:	4313      	orrs	r3, r2
    1400:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    1404:	f8d8 3000 	ldr.w	r3, [r8]
    1408:	3501      	adds	r5, #1
    140a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    140e:	b2ed      	uxtb	r5, r5
    1410:	3301      	adds	r3, #1
    1412:	429d      	cmp	r5, r3
    1414:	d2d0      	bcs.n	13b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    1416:	19eb      	adds	r3, r5, r7
    1418:	011b      	lsls	r3, r3, #4
    141a:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    141c:	f8d8 3000 	ldr.w	r3, [r8]
    1420:	0099      	lsls	r1, r3, #2
    1422:	d503      	bpl.n	142c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    1424:	f7ff ff0c 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    1428:	4285      	cmp	r5, r0
    142a:	d3eb      	bcc.n	1404 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    142c:	2301      	movs	r3, #1
    142e:	2d1f      	cmp	r5, #31
    1430:	fa03 f305 	lsl.w	r3, r3, r5
    1434:	d9e1      	bls.n	13fa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    1436:	f1a5 0120 	sub.w	r1, r5, #32
    143a:	2301      	movs	r3, #1
    143c:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    1440:	408b      	lsls	r3, r1
    1442:	4313      	orrs	r3, r2
    1444:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    1448:	e7dc      	b.n	1404 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    144a:	f1a5 0120 	sub.w	r1, r5, #32
    144e:	2301      	movs	r3, #1
    1450:	6a72      	ldr	r2, [r6, #36]	; 0x24
    1452:	408b      	lsls	r3, r1
    1454:	4313      	orrs	r3, r2
    1456:	6273      	str	r3, [r6, #36]	; 0x24
    1458:	e786      	b.n	1368 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    145a:	6833      	ldr	r3, [r6, #0]
    145c:	e7c7      	b.n	13ee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    145e:	bf00      	nop
    1460:	401d0000 	.word	0x401d0000
    1464:	10074220 	.word	0x10074220
    1468:	0401d008 	.word	0x0401d008

0000146c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>:
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    146c:	4a63      	ldr	r2, [pc, #396]	; (15fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
FCTP_FUNC void FCTP_OPT::enableFIFO(bool status) {
    146e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1472:	6814      	ldr	r4, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    1474:	6813      	ldr	r3, [r2, #0]
  bool frz_flag_negate = !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1476:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    147a:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    147e:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    1480:	6813      	ldr	r3, [r2, #0]
    1482:	01dd      	lsls	r5, r3, #7
    1484:	d5fc      	bpl.n	1480 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x14>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1486:	6811      	ldr	r1, [r2, #0]
  FLEXCANb_IMASK2(_bus) = value >> 32;
    1488:	2300      	movs	r3, #0
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    148a:	f8df c178 	ldr.w	ip, [pc, #376]	; 1604 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    148e:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    1492:	4f5b      	ldr	r7, [pc, #364]	; (1600 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1494:	4e59      	ldr	r6, [pc, #356]	; (15fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_FEN; // Disable FIFO if already enabled for cleanup.
    1496:	6011      	str	r1, [r2, #0]
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    1498:	4619      	mov	r1, r3
  FLEXCANb_IMASK2(_bus) = value >> 32;
    149a:	6253      	str	r3, [r2, #36]	; 0x24
  FLEXCANb_IMASK1(_bus) = value;
    149c:	6293      	str	r3, [r2, #40]	; 0x28
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    149e:	6812      	ldr	r2, [r2, #0]
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    14a0:	eb03 020c 	add.w	r2, r3, ip
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    14a4:	19dd      	adds	r5, r3, r7
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    14a6:	3301      	adds	r3, #1
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    14a8:	0112      	lsls	r2, r2, #4
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    14aa:	00ad      	lsls	r5, r5, #2
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    14ac:	60d1      	str	r1, [r2, #12]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    14ae:	b2db      	uxtb	r3, r3
    mbxAddr[0] = mbxAddr[1] = mbxAddr[2] = mbxAddr[3] = 0; // code, id, word0, word1
    14b0:	6091      	str	r1, [r2, #8]
    14b2:	6051      	str	r1, [r2, #4]
    14b4:	6011      	str	r1, [r2, #0]
    FLEXCANb_RXIMR(_bus, i) = 0UL; // CLEAR MAILBOX MASKS (RXIMR)
    14b6:	6029      	str	r1, [r5, #0]
  for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    14b8:	6832      	ldr	r2, [r6, #0]
    14ba:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    14be:	3201      	adds	r2, #1
    14c0:	4293      	cmp	r3, r2
    14c2:	d3ed      	bcc.n	14a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x34>
  FLEXCANb_RXMGMASK(_bus) = FLEXCANb_RXFGMASK(_bus) = 0;
    14c4:	64b1      	str	r1, [r6, #72]	; 0x48
    14c6:	6131      	str	r1, [r6, #16]
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    14c8:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    14ca:	6b33      	ldr	r3, [r6, #48]	; 0x30
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    14cc:	62f2      	str	r2, [r6, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    14ce:	6333      	str	r3, [r6, #48]	; 0x30
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    14d0:	6833      	ldr	r3, [r6, #0]
  if ( status ) {
    14d2:	2800      	cmp	r0, #0
    14d4:	d149      	bne.n	156a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfe>
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    14d6:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1604 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    14da:	4605      	mov	r5, r0
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    14dc:	4e47      	ldr	r6, [pc, #284]	; (15fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    14de:	4f48      	ldr	r7, [pc, #288]	; (1600 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x194>)
    14e0:	e019      	b.n	1516 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xaa>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((i < (FLEXCANb_MAXMB_SIZE(_bus) / 4)) ? 0 : FLEXCAN_MB_CS_IDE | FLEXCAN_MB_CS_SRR);
    14e2:	6833      	ldr	r3, [r6, #0]
    14e4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    14e8:	3301      	adds	r3, #1
    14ea:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
    14ee:	bf34      	ite	cc
    14f0:	f04f 6380 	movcc.w	r3, #67108864	; 0x4000000
    14f4:	f04f 638c 	movcs.w	r3, #73400320	; 0x4600000
    14f8:	6013      	str	r3, [r2, #0]
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    14fa:	6b73      	ldr	r3, [r6, #52]	; 0x34
    14fc:	f3c3 4300 	ubfx	r3, r3, #16, #1
    1500:	079b      	lsls	r3, r3, #30
    1502:	600b      	str	r3, [r1, #0]
    for (uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) { // clear all mailboxes
    1504:	6833      	ldr	r3, [r6, #0]
    1506:	3501      	adds	r5, #1
    1508:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    150c:	b2ed      	uxtb	r5, r5
    150e:	3301      	adds	r3, #1
    1510:	4628      	mov	r0, r5
    1512:	429d      	cmp	r5, r3
    1514:	d21e      	bcs.n	1554 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1516:	6833      	ldr	r3, [r6, #0]
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1518:	eb05 0208 	add.w	r2, r5, r8
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    151c:	19e9      	adds	r1, r5, r7
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    151e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (i * 0x10)));
    1522:	0112      	lsls	r2, r2, #4
        FLEXCANb_RXIMR(_bus, i) = 0UL | ((FLEXCANb_CTRL2(_bus) & FLEXCAN_CTRL2_EACEN) ? (1UL << 30) : 0); // (RXIMR)
    1524:	0089      	lsls	r1, r1, #2
      if ( i < (FLEXCANb_MAXMB_SIZE(_bus) / 2) ) {
    1526:	3301      	adds	r3, #1
    1528:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
    152c:	d3d9      	bcc.n	14e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x76>
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    152e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    1532:	6013      	str	r3, [r2, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1534:	6833      	ldr	r3, [r6, #0]
    1536:	009a      	lsls	r2, r3, #2
    1538:	d503      	bpl.n	1542 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xd6>
    153a:	f7ff fea5 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    153e:	42a8      	cmp	r0, r5
    1540:	d8e0      	bhi.n	1504 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1542:	2301      	movs	r3, #1
    1544:	2d1f      	cmp	r5, #31
    1546:	fa03 f305 	lsl.w	r3, r3, r5
    154a:	d84c      	bhi.n	15e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x17a>
    154c:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    154e:	4313      	orrs	r3, r2
    1550:	62b3      	str	r3, [r6, #40]	; 0x28
    1552:	e7d7      	b.n	1504 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
  if ( frz_flag_negate ) FLEXCAN_ExitFreezeMode();
    1554:	b93c      	cbnz	r4, 1566 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xfa>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    1556:	4a29      	ldr	r2, [pc, #164]	; (15fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>)
    1558:	6813      	ldr	r3, [r2, #0]
    155a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    155e:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    1560:	6813      	ldr	r3, [r2, #0]
    1562:	01db      	lsls	r3, r3, #7
    1564:	d4fc      	bmi.n	1560 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xf4>
}
    1566:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FEN;
    156a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    156e:	6033      	str	r3, [r6, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1570:	6835      	ldr	r5, [r6, #0]
    1572:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    1576:	d03e      	beq.n	15f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x18a>
    1578:	f7ff fe86 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    157c:	6833      	ldr	r3, [r6, #0]
    157e:	4605      	mov	r5, r0
    1580:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1584:	3301      	adds	r3, #1
    1586:	4283      	cmp	r3, r0
    1588:	d9e4      	bls.n	1554 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    158a:	4f1e      	ldr	r7, [pc, #120]	; (1604 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x198>)
    158c:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    1590:	f8df 8068 	ldr.w	r8, [pc, #104]	; 15fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x190>
    1594:	e00d      	b.n	15b2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x146>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    1596:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
    159a:	4313      	orrs	r3, r2
    159c:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    15a0:	f8d8 3000 	ldr.w	r3, [r8]
    15a4:	3501      	adds	r5, #1
    15a6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    15aa:	b2ed      	uxtb	r5, r5
    15ac:	3301      	adds	r3, #1
    15ae:	429d      	cmp	r5, r3
    15b0:	d2d0      	bcs.n	1554 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0xe8>
      FLEXCANb_MBn_CS(_bus,i) = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    15b2:	19eb      	adds	r3, r5, r7
    15b4:	011b      	lsls	r3, r3, #4
    15b6:	601e      	str	r6, [r3, #0]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    15b8:	f8d8 3000 	ldr.w	r3, [r8]
    15bc:	0099      	lsls	r1, r3, #2
    15be:	d503      	bpl.n	15c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x15c>
    15c0:	f7ff fe62 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  if ( mb_num < mailboxOffset() ) return; /* mailbox not available */
    15c4:	4285      	cmp	r5, r0
    15c6:	d3eb      	bcc.n	15a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
  if ( mb_num < 32 ) (( set ) ? FLEXCANb_IMASK1(_bus) |= (1UL << mb_num) : FLEXCANb_IMASK1(_bus) &= ~(1UL << mb_num));
    15c8:	2301      	movs	r3, #1
    15ca:	2d1f      	cmp	r5, #31
    15cc:	fa03 f305 	lsl.w	r3, r3, r5
    15d0:	d9e1      	bls.n	1596 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x12a>
  else (( set ) ? FLEXCANb_IMASK2(_bus) |= (1UL << (mb_num - 32)) : FLEXCANb_IMASK2(_bus) &= ~(1UL << (mb_num - 32)));
    15d2:	f1a5 0120 	sub.w	r1, r5, #32
    15d6:	2301      	movs	r3, #1
    15d8:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    15dc:	408b      	lsls	r3, r1
    15de:	4313      	orrs	r3, r2
    15e0:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
    15e4:	e7dc      	b.n	15a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x134>
    15e6:	f1a5 0120 	sub.w	r1, r5, #32
    15ea:	2301      	movs	r3, #1
    15ec:	6a72      	ldr	r2, [r6, #36]	; 0x24
    15ee:	408b      	lsls	r3, r1
    15f0:	4313      	orrs	r3, r2
    15f2:	6273      	str	r3, [r6, #36]	; 0x24
    15f4:	e786      	b.n	1504 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x98>
    for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    15f6:	6833      	ldr	r3, [r6, #0]
    15f8:	e7c7      	b.n	158a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]+0x11e>
    15fa:	bf00      	nop
    15fc:	401d4000 	.word	0x401d4000
    1600:	10075220 	.word	0x10075220
    1604:	0401d408 	.word	0x0401d408

00001608 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    1608:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    160c:	4db7      	ldr	r5, [pc, #732]	; (18ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    160e:	682b      	ldr	r3, [r5, #0]
    1610:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    1614:	f040 819a 	bne.w	194c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    1618:	211a      	movs	r1, #26
    161a:	48b5      	ldr	r0, [pc, #724]	; (18f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    161c:	f006 fa72 	bl	7b04 <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1620:	464c      	mov	r4, r9
    1622:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1624:	4fb3      	ldr	r7, [pc, #716]	; (18f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1626:	4db4      	ldr	r5, [pc, #720]	; (18f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1628:	4eb4      	ldr	r6, [pc, #720]	; (18fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    162a:	eb04 0805 	add.w	r8, r4, r5
    162e:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1632:	f8d8 3000 	ldr.w	r3, [r8]
    1636:	f3c3 6303 	ubfx	r3, r3, #24, #4
    163a:	2b0e      	cmp	r3, #14
    163c:	f200 809e 	bhi.w	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1640:	e8df f013 	tbh	[pc, r3, lsl #1]
    1644:	01300142 	.word	0x01300142
    1648:	009c011e 	.word	0x009c011e
    164c:	009c0103 	.word	0x009c0103
    1650:	009c00f1 	.word	0x009c00f1
    1654:	00cd00df 	.word	0x00cd00df
    1658:	009c00bb 	.word	0x009c00bb
    165c:	009c000f 	.word	0x009c000f
    1660:	00a9      	.short	0x00a9
    1662:	2104      	movs	r1, #4
    1664:	48a6      	ldr	r0, [pc, #664]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1666:	f006 fa4d 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    166a:	2300      	movs	r3, #0
    166c:	4649      	mov	r1, r9
    166e:	220a      	movs	r2, #10
    1670:	48a4      	ldr	r0, [pc, #656]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1672:	f004 f9e3 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1676:	211d      	movs	r1, #29
    1678:	48a3      	ldr	r0, [pc, #652]	; (1908 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    167a:	f006 fa43 	bl	7b04 <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    167e:	f8d8 3000 	ldr.w	r3, [r8]
    1682:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1684:	029b      	lsls	r3, r3, #10
    1686:	f140 81e3 	bpl.w	1a50 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    168a:	48a0      	ldr	r0, [pc, #640]	; (190c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    168c:	f006 fa3a 	bl	7b04 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1690:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1694:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1698:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    169a:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    169e:	2107      	movs	r1, #7
    16a0:	489b      	ldr	r0, [pc, #620]	; (1910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    16a2:	f006 fa2f 	bl	7b04 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    16a6:	2300      	movs	r3, #0
    16a8:	2210      	movs	r2, #16
    16aa:	4651      	mov	r1, sl
    16ac:	4895      	ldr	r0, [pc, #596]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16ae:	f004 f9c5 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16b2:	2101      	movs	r1, #1
    16b4:	4897      	ldr	r0, [pc, #604]	; (1914 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    16b6:	f006 fa25 	bl	7b04 <usb_serial_write>
    16ba:	210a      	movs	r1, #10
    16bc:	4896      	ldr	r0, [pc, #600]	; (1918 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    16be:	f006 fa21 	bl	7b04 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    16c2:	2300      	movs	r3, #0
    16c4:	2210      	movs	r2, #16
    16c6:	ea4f 6119 	mov.w	r1, r9, lsr #24
    16ca:	488e      	ldr	r0, [pc, #568]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16cc:	f004 f9b6 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16d0:	2101      	movs	r1, #1
    16d2:	4892      	ldr	r0, [pc, #584]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    16d4:	f006 fa16 	bl	7b04 <usb_serial_write>
    16d8:	2300      	movs	r3, #0
    16da:	2210      	movs	r2, #16
    16dc:	f3c9 4107 	ubfx	r1, r9, #16, #8
    16e0:	4888      	ldr	r0, [pc, #544]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16e2:	f004 f9ab 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16e6:	2101      	movs	r1, #1
    16e8:	488c      	ldr	r0, [pc, #560]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    16ea:	f006 fa0b 	bl	7b04 <usb_serial_write>
    16ee:	2300      	movs	r3, #0
    16f0:	2210      	movs	r2, #16
    16f2:	f3c9 2107 	ubfx	r1, r9, #8, #8
    16f6:	4883      	ldr	r0, [pc, #524]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    16f8:	f004 f9a0 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    16fc:	2101      	movs	r1, #1
    16fe:	4887      	ldr	r0, [pc, #540]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1700:	f006 fa00 	bl	7b04 <usb_serial_write>
    1704:	2300      	movs	r3, #0
    1706:	2210      	movs	r2, #16
    1708:	fa5f f189 	uxtb.w	r1, r9
    170c:	487d      	ldr	r0, [pc, #500]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    170e:	f004 f995 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1712:	f858 8007 	ldr.w	r8, [r8, r7]
    1716:	2101      	movs	r1, #1
    1718:	4880      	ldr	r0, [pc, #512]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    171a:	f006 f9f3 	bl	7b04 <usb_serial_write>
    171e:	2300      	movs	r3, #0
    1720:	2210      	movs	r2, #16
    1722:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1726:	4877      	ldr	r0, [pc, #476]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1728:	f004 f988 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    172c:	2101      	movs	r1, #1
    172e:	487b      	ldr	r0, [pc, #492]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1730:	f006 f9e8 	bl	7b04 <usb_serial_write>
    1734:	2300      	movs	r3, #0
    1736:	2210      	movs	r2, #16
    1738:	f3c8 4107 	ubfx	r1, r8, #16, #8
    173c:	4871      	ldr	r0, [pc, #452]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    173e:	f004 f97d 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1742:	2101      	movs	r1, #1
    1744:	4875      	ldr	r0, [pc, #468]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1746:	f006 f9dd 	bl	7b04 <usb_serial_write>
    174a:	2300      	movs	r3, #0
    174c:	2210      	movs	r2, #16
    174e:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1752:	486c      	ldr	r0, [pc, #432]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1754:	f004 f972 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1758:	2101      	movs	r1, #1
    175a:	4870      	ldr	r0, [pc, #448]	; (191c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    175c:	f006 f9d2 	bl	7b04 <usb_serial_write>
    1760:	2300      	movs	r3, #0
    1762:	fa5f f188 	uxtb.w	r1, r8
    1766:	2210      	movs	r2, #16
    1768:	4866      	ldr	r0, [pc, #408]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    176a:	f004 f967 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    176e:	2101      	movs	r1, #1
    1770:	4868      	ldr	r0, [pc, #416]	; (1914 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1772:	f006 f9c7 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1776:	4863      	ldr	r0, [pc, #396]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1778:	f004 f936 	bl	59e8 <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    177c:	4b5b      	ldr	r3, [pc, #364]	; (18ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    177e:	3401      	adds	r4, #1
    1780:	681b      	ldr	r3, [r3, #0]
    1782:	b2e4      	uxtb	r4, r4
    1784:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1788:	46a1      	mov	r9, r4
    178a:	3301      	adds	r3, #1
    178c:	429c      	cmp	r4, r3
    178e:	f4ff af4c 	bcc.w	162a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    1792:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1796:	2104      	movs	r1, #4
    1798:	4859      	ldr	r0, [pc, #356]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    179a:	f006 f9b3 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    179e:	4649      	mov	r1, r9
    17a0:	2300      	movs	r3, #0
    17a2:	220a      	movs	r2, #10
    17a4:	4857      	ldr	r0, [pc, #348]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17a6:	f004 f949 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17aa:	2111      	movs	r1, #17
    17ac:	485c      	ldr	r0, [pc, #368]	; (1920 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    17ae:	f006 f9a9 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17b2:	4854      	ldr	r0, [pc, #336]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17b4:	f004 f918 	bl	59e8 <Print::println()>
    17b8:	e7e0      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    17ba:	2104      	movs	r1, #4
    17bc:	4850      	ldr	r0, [pc, #320]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    17be:	f006 f9a1 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17c2:	4649      	mov	r1, r9
    17c4:	2300      	movs	r3, #0
    17c6:	220a      	movs	r2, #10
    17c8:	484e      	ldr	r0, [pc, #312]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17ca:	f004 f937 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17ce:	2111      	movs	r1, #17
    17d0:	4854      	ldr	r0, [pc, #336]	; (1924 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    17d2:	f006 f997 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17d6:	484b      	ldr	r0, [pc, #300]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17d8:	f004 f906 	bl	59e8 <Print::println()>
    17dc:	e7ce      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    17de:	2104      	movs	r1, #4
    17e0:	4847      	ldr	r0, [pc, #284]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    17e2:	f006 f98f 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    17e6:	4649      	mov	r1, r9
    17e8:	2300      	movs	r3, #0
    17ea:	220a      	movs	r2, #10
    17ec:	4845      	ldr	r0, [pc, #276]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17ee:	f004 f925 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    17f2:	210f      	movs	r1, #15
    17f4:	484c      	ldr	r0, [pc, #304]	; (1928 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    17f6:	f006 f985 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    17fa:	4842      	ldr	r0, [pc, #264]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    17fc:	f004 f8f4 	bl	59e8 <Print::println()>
    1800:	e7bc      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1802:	2104      	movs	r1, #4
    1804:	483e      	ldr	r0, [pc, #248]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1806:	f006 f97d 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    180a:	4649      	mov	r1, r9
    180c:	2300      	movs	r3, #0
    180e:	220a      	movs	r2, #10
    1810:	483c      	ldr	r0, [pc, #240]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1812:	f004 f913 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1816:	2112      	movs	r1, #18
    1818:	4844      	ldr	r0, [pc, #272]	; (192c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    181a:	f006 f973 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    181e:	4839      	ldr	r0, [pc, #228]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1820:	f004 f8e2 	bl	59e8 <Print::println()>
    1824:	e7aa      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1826:	2104      	movs	r1, #4
    1828:	4835      	ldr	r0, [pc, #212]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    182a:	f006 f96b 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    182e:	4649      	mov	r1, r9
    1830:	2300      	movs	r3, #0
    1832:	220a      	movs	r2, #10
    1834:	4833      	ldr	r0, [pc, #204]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1836:	f004 f901 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    183a:	2111      	movs	r1, #17
    183c:	483c      	ldr	r0, [pc, #240]	; (1930 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    183e:	f006 f961 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1842:	4830      	ldr	r0, [pc, #192]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1844:	f004 f8d0 	bl	59e8 <Print::println()>
    1848:	e798      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    184a:	2104      	movs	r1, #4
    184c:	482c      	ldr	r0, [pc, #176]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    184e:	f006 f959 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1852:	220a      	movs	r2, #10
    1854:	4649      	mov	r1, r9
    1856:	2300      	movs	r3, #0
    1858:	482a      	ldr	r0, [pc, #168]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    185a:	f004 f8ef 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    185e:	210f      	movs	r1, #15
    1860:	4834      	ldr	r0, [pc, #208]	; (1934 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    1862:	f006 f94f 	bl	7b04 <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1866:	f8d8 3000 	ldr.w	r3, [r8]
    186a:	2111      	movs	r1, #17
    186c:	029a      	lsls	r2, r3, #10
    186e:	bf4c      	ite	mi
    1870:	4831      	ldrmi	r0, [pc, #196]	; (1938 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    1872:	4832      	ldrpl	r0, [pc, #200]	; (193c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    1874:	f006 f946 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1878:	4822      	ldr	r0, [pc, #136]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    187a:	f004 f8b5 	bl	59e8 <Print::println()>
    187e:	e77d      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1880:	2104      	movs	r1, #4
    1882:	481f      	ldr	r0, [pc, #124]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1884:	f006 f93e 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1888:	4649      	mov	r1, r9
    188a:	2300      	movs	r3, #0
    188c:	220a      	movs	r2, #10
    188e:	481d      	ldr	r0, [pc, #116]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1890:	f004 f8d4 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1894:	210e      	movs	r1, #14
    1896:	482a      	ldr	r0, [pc, #168]	; (1940 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    1898:	f006 f934 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    189c:	4819      	ldr	r0, [pc, #100]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    189e:	f004 f8a3 	bl	59e8 <Print::println()>
    18a2:	e76b      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    18a4:	2104      	movs	r1, #4
    18a6:	4816      	ldr	r0, [pc, #88]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    18a8:	f006 f92c 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    18ac:	4649      	mov	r1, r9
    18ae:	2300      	movs	r3, #0
    18b0:	220a      	movs	r2, #10
    18b2:	4814      	ldr	r0, [pc, #80]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    18b4:	f004 f8c2 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    18b8:	210e      	movs	r1, #14
    18ba:	4822      	ldr	r0, [pc, #136]	; (1944 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    18bc:	f006 f922 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    18c0:	4810      	ldr	r0, [pc, #64]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    18c2:	f004 f891 	bl	59e8 <Print::println()>
    18c6:	e759      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    18c8:	2104      	movs	r1, #4
    18ca:	480d      	ldr	r0, [pc, #52]	; (1900 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    18cc:	f006 f91a 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    18d0:	4649      	mov	r1, r9
    18d2:	2300      	movs	r3, #0
    18d4:	220a      	movs	r2, #10
    18d6:	480b      	ldr	r0, [pc, #44]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    18d8:	f004 f8b0 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    18dc:	2112      	movs	r1, #18
    18de:	481a      	ldr	r0, [pc, #104]	; (1948 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    18e0:	f006 f910 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    18e4:	4807      	ldr	r0, [pc, #28]	; (1904 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    18e6:	f004 f87f 	bl	59e8 <Print::println()>
    18ea:	e747      	b.n	177c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    18ec:	401d4000 	.word	0x401d4000
    18f0:	20000840 	.word	0x20000840
    18f4:	401d408c 	.word	0x401d408c
    18f8:	0401d408 	.word	0x0401d408
    18fc:	bfe2bf80 	.word	0xbfe2bf80
    1900:	20000710 	.word	0x20000710
    1904:	20001110 	.word	0x20001110
    1908:	200007d0 	.word	0x200007d0
    190c:	200007f0 	.word	0x200007f0
    1910:	20000818 	.word	0x20000818
    1914:	2000074c 	.word	0x2000074c
    1918:	20000820 	.word	0x20000820
    191c:	200006b4 	.word	0x200006b4
    1920:	2000082c 	.word	0x2000082c
    1924:	20000788 	.word	0x20000788
    1928:	200007c0 	.word	0x200007c0
    192c:	200007ac 	.word	0x200007ac
    1930:	20000774 	.word	0x20000774
    1934:	2000072c 	.word	0x2000072c
    1938:	2000073c 	.word	0x2000073c
    193c:	20000750 	.word	0x20000750
    1940:	20000764 	.word	0x20000764
    1944:	2000079c 	.word	0x2000079c
    1948:	20000718 	.word	0x20000718
    194c:	2111      	movs	r1, #17
    194e:	48c4      	ldr	r0, [pc, #784]	; (1c60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    1950:	f006 f8d8 	bl	7b04 <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    1954:	6aab      	ldr	r3, [r5, #40]	; 0x28
    1956:	069a      	lsls	r2, r3, #26
    1958:	f100 81fa 	bmi.w	1d50 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    195c:	2112      	movs	r1, #18
    195e:	48c1      	ldr	r0, [pc, #772]	; (1c64 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    1960:	f006 f8d0 	bl	7b04 <usb_serial_write>
    1964:	48c0      	ldr	r0, [pc, #768]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1966:	f004 f83f 	bl	59e8 <Print::println()>
    196a:	2116      	movs	r1, #22
    196c:	48bf      	ldr	r0, [pc, #764]	; (1c6c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    196e:	f006 f8c9 	bl	7b04 <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1972:	4abf      	ldr	r2, [pc, #764]	; (1c70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1974:	6814      	ldr	r4, [r2, #0]
    1976:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1978:	6813      	ldr	r3, [r2, #0]
    197a:	6b52      	ldr	r2, [r2, #52]	; 0x34
    197c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1980:	f3c2 6203 	ubfx	r2, r2, #24, #4
    1984:	3301      	adds	r3, #1
    1986:	3204      	adds	r2, #4
    1988:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    198c:	f0c0 81e8 	bcc.w	1d60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    1990:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1994:	f3c1 6103 	ubfx	r1, r1, #24, #4
    1998:	3c05      	subs	r4, #5
    199a:	3101      	adds	r1, #1
    199c:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    19a0:	b2e5      	uxtb	r5, r4
    19a2:	4eb3      	ldr	r6, [pc, #716]	; (1c70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    19a4:	48b0      	ldr	r0, [pc, #704]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    19a6:	6831      	ldr	r1, [r6, #0]
    19a8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    19ac:	3101      	adds	r1, #1
    19ae:	1b49      	subs	r1, r1, r5
    19b0:	b2c9      	uxtb	r1, r1
    19b2:	2920      	cmp	r1, #32
    19b4:	bfa8      	it	ge
    19b6:	2120      	movge	r1, #32
    19b8:	f004 f80a 	bl	59d0 <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    19bc:	48aa      	ldr	r0, [pc, #680]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    19be:	f004 f813 	bl	59e8 <Print::println()>
    19c2:	2116      	movs	r1, #22
    19c4:	48ab      	ldr	r0, [pc, #684]	; (1c74 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    19c6:	f006 f89d 	bl	7b04 <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    19ca:	6833      	ldr	r3, [r6, #0]
    19cc:	6b72      	ldr	r2, [r6, #52]	; 0x34
    19ce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    19d2:	f3c2 6203 	ubfx	r2, r2, #24, #4
    19d6:	3301      	adds	r3, #1
    19d8:	3204      	adds	r2, #4
    19da:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    19de:	d201      	bcs.n	19e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    19e0:	2500      	movs	r5, #0
    19e2:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    19e4:	2300      	movs	r3, #0
    19e6:	4621      	mov	r1, r4
    19e8:	220a      	movs	r2, #10
    19ea:	489f      	ldr	r0, [pc, #636]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    19ec:	f004 f826 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	// Print an unsigned number and newline
	size_t println(unsigned int n)			{ return print(n) + println(); }
	// Print a signed number and newline
	size_t println(long n)				{ return print(n) + println(); }
	// Print an unsigned number and newline
	size_t println(unsigned long n)			{ return print(n) + println(); }
    19f0:	489d      	ldr	r0, [pc, #628]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    19f2:	f003 fff9 	bl	59e8 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    19f6:	4b9e      	ldr	r3, [pc, #632]	; (1c70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    19f8:	681c      	ldr	r4, [r3, #0]
    19fa:	681b      	ldr	r3, [r3, #0]
    19fc:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    1a00:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1a04:	3401      	adds	r4, #1
    1a06:	3301      	adds	r3, #1
    1a08:	1b64      	subs	r4, r4, r5
    1a0a:	b2e4      	uxtb	r4, r4
    1a0c:	42a3      	cmp	r3, r4
    1a0e:	f67f aec0 	bls.w	1792 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1a12:	4d99      	ldr	r5, [pc, #612]	; (1c78 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1a14:	4e99      	ldr	r6, [pc, #612]	; (1c7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a16:	4f9a      	ldr	r7, [pc, #616]	; (1c80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1a18:	eb04 0805 	add.w	r8, r4, r5
    1a1c:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1a20:	f8d8 3000 	ldr.w	r3, [r8]
    1a24:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1a28:	2b0e      	cmp	r3, #14
    1a2a:	f200 80a9 	bhi.w	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1a2e:	e8df f013 	tbh	[pc, r3, lsl #1]
    1a32:	0147      	.short	0x0147
    1a34:	00f20104 	.word	0x00f20104
    1a38:	00d700a7 	.word	0x00d700a7
    1a3c:	016b00a7 	.word	0x016b00a7
    1a40:	015900a7 	.word	0x015900a7
    1a44:	00c5017d 	.word	0x00c5017d
    1a48:	001a00a7 	.word	0x001a00a7
    1a4c:	00b300a7 	.word	0x00b300a7
    1a50:	488c      	ldr	r0, [pc, #560]	; (1c84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    1a52:	f006 f857 	bl	7b04 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a56:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a5a:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a5e:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1a60:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    1a64:	e61b      	b.n	169e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    1a66:	2104      	movs	r1, #4
    1a68:	4887      	ldr	r0, [pc, #540]	; (1c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1a6a:	f006 f84b 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1a6e:	2300      	movs	r3, #0
    1a70:	220a      	movs	r2, #10
    1a72:	4621      	mov	r1, r4
    1a74:	487c      	ldr	r0, [pc, #496]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1a76:	f003 ffe1 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1a7a:	211d      	movs	r1, #29
    1a7c:	4883      	ldr	r0, [pc, #524]	; (1c8c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    1a7e:	f006 f841 	bl	7b04 <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1a82:	f8d8 3000 	ldr.w	r3, [r8]
    1a86:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1a88:	0298      	lsls	r0, r3, #10
    1a8a:	f140 816c 	bpl.w	1d66 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    1a8e:	4880      	ldr	r0, [pc, #512]	; (1c90 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    1a90:	f006 f838 	bl	7b04 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a94:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a98:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1a9c:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1a9e:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1aa2:	2107      	movs	r1, #7
    1aa4:	487b      	ldr	r0, [pc, #492]	; (1c94 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    1aa6:	f006 f82d 	bl	7b04 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1aaa:	2300      	movs	r3, #0
    1aac:	2210      	movs	r2, #16
    1aae:	4651      	mov	r1, sl
    1ab0:	486d      	ldr	r0, [pc, #436]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ab2:	f003 ffc3 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ab6:	2101      	movs	r1, #1
    1ab8:	4877      	ldr	r0, [pc, #476]	; (1c98 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1aba:	f006 f823 	bl	7b04 <usb_serial_write>
    1abe:	210a      	movs	r1, #10
    1ac0:	4876      	ldr	r0, [pc, #472]	; (1c9c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    1ac2:	f006 f81f 	bl	7b04 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1ac6:	2300      	movs	r3, #0
    1ac8:	2210      	movs	r2, #16
    1aca:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1ace:	4866      	ldr	r0, [pc, #408]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ad0:	f003 ffb4 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ad4:	2101      	movs	r1, #1
    1ad6:	4872      	ldr	r0, [pc, #456]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1ad8:	f006 f814 	bl	7b04 <usb_serial_write>
    1adc:	2300      	movs	r3, #0
    1ade:	2210      	movs	r2, #16
    1ae0:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1ae4:	4860      	ldr	r0, [pc, #384]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ae6:	f003 ffa9 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1aea:	2101      	movs	r1, #1
    1aec:	486c      	ldr	r0, [pc, #432]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1aee:	f006 f809 	bl	7b04 <usb_serial_write>
    1af2:	2300      	movs	r3, #0
    1af4:	2210      	movs	r2, #16
    1af6:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1afa:	485b      	ldr	r0, [pc, #364]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1afc:	f003 ff9e 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b00:	2101      	movs	r1, #1
    1b02:	4867      	ldr	r0, [pc, #412]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1b04:	f005 fffe 	bl	7b04 <usb_serial_write>
    1b08:	2300      	movs	r3, #0
    1b0a:	2210      	movs	r2, #16
    1b0c:	fa5f f189 	uxtb.w	r1, r9
    1b10:	4855      	ldr	r0, [pc, #340]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b12:	f003 ff93 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1b16:	f858 8006 	ldr.w	r8, [r8, r6]
    1b1a:	2101      	movs	r1, #1
    1b1c:	4860      	ldr	r0, [pc, #384]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1b1e:	f005 fff1 	bl	7b04 <usb_serial_write>
    1b22:	2300      	movs	r3, #0
    1b24:	2210      	movs	r2, #16
    1b26:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1b2a:	484f      	ldr	r0, [pc, #316]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b2c:	f003 ff86 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b30:	2101      	movs	r1, #1
    1b32:	485b      	ldr	r0, [pc, #364]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1b34:	f005 ffe6 	bl	7b04 <usb_serial_write>
    1b38:	2300      	movs	r3, #0
    1b3a:	2210      	movs	r2, #16
    1b3c:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1b40:	4849      	ldr	r0, [pc, #292]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b42:	f003 ff7b 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b46:	2101      	movs	r1, #1
    1b48:	4855      	ldr	r0, [pc, #340]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1b4a:	f005 ffdb 	bl	7b04 <usb_serial_write>
    1b4e:	2300      	movs	r3, #0
    1b50:	2210      	movs	r2, #16
    1b52:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1b56:	4844      	ldr	r0, [pc, #272]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b58:	f003 ff70 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b5c:	2101      	movs	r1, #1
    1b5e:	4850      	ldr	r0, [pc, #320]	; (1ca0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    1b60:	f005 ffd0 	bl	7b04 <usb_serial_write>
    1b64:	2300      	movs	r3, #0
    1b66:	fa5f f188 	uxtb.w	r1, r8
    1b6a:	2210      	movs	r2, #16
    1b6c:	483e      	ldr	r0, [pc, #248]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b6e:	f003 ff65 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1b72:	2101      	movs	r1, #1
    1b74:	4848      	ldr	r0, [pc, #288]	; (1c98 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    1b76:	f005 ffc5 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1b7a:	483b      	ldr	r0, [pc, #236]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1b7c:	f003 ff34 	bl	59e8 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1b80:	4b3b      	ldr	r3, [pc, #236]	; (1c70 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    1b82:	3401      	adds	r4, #1
    1b84:	681b      	ldr	r3, [r3, #0]
    1b86:	b2e4      	uxtb	r4, r4
    1b88:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1b8c:	3301      	adds	r3, #1
    1b8e:	429c      	cmp	r4, r3
    1b90:	f4ff af42 	bcc.w	1a18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    1b94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1b98:	2104      	movs	r1, #4
    1b9a:	483b      	ldr	r0, [pc, #236]	; (1c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1b9c:	f005 ffb2 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1ba0:	2300      	movs	r3, #0
    1ba2:	220a      	movs	r2, #10
    1ba4:	4621      	mov	r1, r4
    1ba6:	4830      	ldr	r0, [pc, #192]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1ba8:	f003 ff48 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bac:	2111      	movs	r1, #17
    1bae:	483d      	ldr	r0, [pc, #244]	; (1ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    1bb0:	f005 ffa8 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bb4:	482c      	ldr	r0, [pc, #176]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bb6:	f003 ff17 	bl	59e8 <Print::println()>
    1bba:	e7e1      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1bbc:	2104      	movs	r1, #4
    1bbe:	4832      	ldr	r0, [pc, #200]	; (1c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1bc0:	f005 ffa0 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1bc4:	2300      	movs	r3, #0
    1bc6:	220a      	movs	r2, #10
    1bc8:	4621      	mov	r1, r4
    1bca:	4827      	ldr	r0, [pc, #156]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bcc:	f003 ff36 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bd0:	2111      	movs	r1, #17
    1bd2:	4835      	ldr	r0, [pc, #212]	; (1ca8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    1bd4:	f005 ff96 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1bd8:	4823      	ldr	r0, [pc, #140]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bda:	f003 ff05 	bl	59e8 <Print::println()>
    1bde:	e7cf      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1be0:	2104      	movs	r1, #4
    1be2:	4829      	ldr	r0, [pc, #164]	; (1c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1be4:	f005 ff8e 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1be8:	220a      	movs	r2, #10
    1bea:	2300      	movs	r3, #0
    1bec:	4621      	mov	r1, r4
    1bee:	481e      	ldr	r0, [pc, #120]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1bf0:	f003 ff24 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1bf4:	210f      	movs	r1, #15
    1bf6:	482d      	ldr	r0, [pc, #180]	; (1cac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    1bf8:	f005 ff84 	bl	7b04 <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1bfc:	f8d8 3000 	ldr.w	r3, [r8]
    1c00:	2111      	movs	r1, #17
    1c02:	029b      	lsls	r3, r3, #10
    1c04:	bf4c      	ite	mi
    1c06:	482a      	ldrmi	r0, [pc, #168]	; (1cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    1c08:	482a      	ldrpl	r0, [pc, #168]	; (1cb4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    1c0a:	f005 ff7b 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c0e:	4816      	ldr	r0, [pc, #88]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1c10:	f003 feea 	bl	59e8 <Print::println()>
    1c14:	e7b4      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1c16:	2104      	movs	r1, #4
    1c18:	481b      	ldr	r0, [pc, #108]	; (1c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1c1a:	f005 ff73 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c1e:	2300      	movs	r3, #0
    1c20:	220a      	movs	r2, #10
    1c22:	4621      	mov	r1, r4
    1c24:	4810      	ldr	r0, [pc, #64]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1c26:	f003 ff09 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c2a:	210e      	movs	r1, #14
    1c2c:	4822      	ldr	r0, [pc, #136]	; (1cb8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    1c2e:	f005 ff69 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c32:	480d      	ldr	r0, [pc, #52]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1c34:	f003 fed8 	bl	59e8 <Print::println()>
    1c38:	e7a2      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1c3a:	2104      	movs	r1, #4
    1c3c:	4812      	ldr	r0, [pc, #72]	; (1c88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    1c3e:	f005 ff61 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1c42:	2300      	movs	r3, #0
    1c44:	220a      	movs	r2, #10
    1c46:	4621      	mov	r1, r4
    1c48:	4807      	ldr	r0, [pc, #28]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1c4a:	f003 fef7 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1c4e:	210e      	movs	r1, #14
    1c50:	481a      	ldr	r0, [pc, #104]	; (1cbc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    1c52:	f005 ff57 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1c56:	4804      	ldr	r0, [pc, #16]	; (1c68 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    1c58:	f003 fec6 	bl	59e8 <Print::println()>
    1c5c:	e790      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1c5e:	bf00      	nop
    1c60:	200006a4 	.word	0x200006a4
    1c64:	200006cc 	.word	0x200006cc
    1c68:	20001110 	.word	0x20001110
    1c6c:	200006e0 	.word	0x200006e0
    1c70:	401d4000 	.word	0x401d4000
    1c74:	200006f8 	.word	0x200006f8
    1c78:	0401d408 	.word	0x0401d408
    1c7c:	401d408c 	.word	0x401d408c
    1c80:	bfe2bf80 	.word	0xbfe2bf80
    1c84:	20000804 	.word	0x20000804
    1c88:	20000710 	.word	0x20000710
    1c8c:	200007d0 	.word	0x200007d0
    1c90:	200007f0 	.word	0x200007f0
    1c94:	20000818 	.word	0x20000818
    1c98:	2000074c 	.word	0x2000074c
    1c9c:	20000820 	.word	0x20000820
    1ca0:	200006b4 	.word	0x200006b4
    1ca4:	2000082c 	.word	0x2000082c
    1ca8:	20000788 	.word	0x20000788
    1cac:	2000072c 	.word	0x2000072c
    1cb0:	2000073c 	.word	0x2000073c
    1cb4:	20000750 	.word	0x20000750
    1cb8:	20000764 	.word	0x20000764
    1cbc:	2000079c 	.word	0x2000079c
    1cc0:	2104      	movs	r1, #4
    1cc2:	482e      	ldr	r0, [pc, #184]	; (1d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1cc4:	f005 ff1e 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1cc8:	2300      	movs	r3, #0
    1cca:	220a      	movs	r2, #10
    1ccc:	4621      	mov	r1, r4
    1cce:	482c      	ldr	r0, [pc, #176]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cd0:	f003 feb4 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cd4:	2112      	movs	r1, #18
    1cd6:	482b      	ldr	r0, [pc, #172]	; (1d84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    1cd8:	f005 ff14 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1cdc:	4828      	ldr	r0, [pc, #160]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cde:	f003 fe83 	bl	59e8 <Print::println()>
    1ce2:	e74d      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1ce4:	2104      	movs	r1, #4
    1ce6:	4825      	ldr	r0, [pc, #148]	; (1d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1ce8:	f005 ff0c 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1cec:	2300      	movs	r3, #0
    1cee:	220a      	movs	r2, #10
    1cf0:	4621      	mov	r1, r4
    1cf2:	4823      	ldr	r0, [pc, #140]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1cf4:	f003 fea2 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1cf8:	2112      	movs	r1, #18
    1cfa:	4823      	ldr	r0, [pc, #140]	; (1d88 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    1cfc:	f005 ff02 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1d00:	481f      	ldr	r0, [pc, #124]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1d02:	f003 fe71 	bl	59e8 <Print::println()>
    1d06:	e73b      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1d08:	2104      	movs	r1, #4
    1d0a:	481c      	ldr	r0, [pc, #112]	; (1d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1d0c:	f005 fefa 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d10:	2300      	movs	r3, #0
    1d12:	220a      	movs	r2, #10
    1d14:	4621      	mov	r1, r4
    1d16:	481a      	ldr	r0, [pc, #104]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1d18:	f003 fe90 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d1c:	2111      	movs	r1, #17
    1d1e:	481b      	ldr	r0, [pc, #108]	; (1d8c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    1d20:	f005 fef0 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1d24:	4816      	ldr	r0, [pc, #88]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1d26:	f003 fe5f 	bl	59e8 <Print::println()>
    1d2a:	e729      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1d2c:	2104      	movs	r1, #4
    1d2e:	4813      	ldr	r0, [pc, #76]	; (1d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    1d30:	f005 fee8 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1d34:	2300      	movs	r3, #0
    1d36:	220a      	movs	r2, #10
    1d38:	4621      	mov	r1, r4
    1d3a:	4811      	ldr	r0, [pc, #68]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1d3c:	f003 fe7e 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1d40:	210f      	movs	r1, #15
    1d42:	4813      	ldr	r0, [pc, #76]	; (1d90 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    1d44:	f005 fede 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1d48:	480d      	ldr	r0, [pc, #52]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1d4a:	f003 fe4d 	bl	59e8 <Print::println()>
    1d4e:	e717      	b.n	1b80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    1d50:	2111      	movs	r1, #17
    1d52:	4810      	ldr	r0, [pc, #64]	; (1d94 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    1d54:	f005 fed6 	bl	7b04 <usb_serial_write>
    1d58:	4809      	ldr	r0, [pc, #36]	; (1d80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    1d5a:	f003 fe45 	bl	59e8 <Print::println()>
    1d5e:	e604      	b.n	196a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    1d60:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    1d62:	462c      	mov	r4, r5
    1d64:	e61d      	b.n	19a2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    1d66:	480c      	ldr	r0, [pc, #48]	; (1d98 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    1d68:	f005 fecc 	bl	7b04 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1d6c:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1d70:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1d74:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    1d76:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    1d7a:	e692      	b.n	1aa2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    1d7c:	20000710 	.word	0x20000710
    1d80:	20001110 	.word	0x20001110
    1d84:	20000718 	.word	0x20000718
    1d88:	200007ac 	.word	0x200007ac
    1d8c:	20000774 	.word	0x20000774
    1d90:	200007c0 	.word	0x200007c0
    1d94:	200006b8 	.word	0x200006b8
    1d98:	20000804 	.word	0x20000804

00001d9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>:
FCTP_FUNC void FCTP_OPT::mailboxStatus() {
    1d9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    1da0:	4db7      	ldr	r5, [pc, #732]	; (2080 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1da2:	682b      	ldr	r3, [r5, #0]
    1da4:	f013 5900 	ands.w	r9, r3, #536870912	; 0x20000000
    1da8:	f040 819a 	bne.w	20e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x344>
    1dac:	211a      	movs	r1, #26
    1dae:	48b5      	ldr	r0, [pc, #724]	; (2084 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e8>)
    1db0:	f005 fea8 	bl	7b04 <usb_serial_write>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1db4:	464c      	mov	r4, r9
    1db6:	682b      	ldr	r3, [r5, #0]
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1db8:	4fb3      	ldr	r7, [pc, #716]	; (2088 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2ec>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1dba:	4db4      	ldr	r5, [pc, #720]	; (208c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f0>)
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1dbc:	4eb4      	ldr	r6, [pc, #720]	; (2090 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f4>)
    switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    1dbe:	eb04 0805 	add.w	r8, r4, r5
    1dc2:	ea4f 1808 	mov.w	r8, r8, lsl #4
    1dc6:	f8d8 3000 	ldr.w	r3, [r8]
    1dca:	f3c3 6303 	ubfx	r3, r3, #24, #4
    1dce:	2b0e      	cmp	r3, #14
    1dd0:	f200 809e 	bhi.w	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1dd4:	e8df f013 	tbh	[pc, r3, lsl #1]
    1dd8:	01300142 	.word	0x01300142
    1ddc:	009c011e 	.word	0x009c011e
    1de0:	009c0103 	.word	0x009c0103
    1de4:	009c00f1 	.word	0x009c00f1
    1de8:	00cd00df 	.word	0x00cd00df
    1dec:	009c00bb 	.word	0x009c00bb
    1df0:	009c000f 	.word	0x009c000f
    1df4:	00a9      	.short	0x00a9
    1df6:	2104      	movs	r1, #4
    1df8:	48a6      	ldr	r0, [pc, #664]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1dfa:	f005 fe83 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1dfe:	2300      	movs	r3, #0
    1e00:	4649      	mov	r1, r9
    1e02:	220a      	movs	r2, #10
    1e04:	48a4      	ldr	r0, [pc, #656]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e06:	f003 fe19 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e0a:	211d      	movs	r1, #29
    1e0c:	48a3      	ldr	r0, [pc, #652]	; (209c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x300>)
    1e0e:	f005 fe79 	bl	7b04 <usb_serial_write>
          uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    1e12:	f8d8 3000 	ldr.w	r3, [r8]
    1e16:	2110      	movs	r1, #16
          (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    1e18:	029b      	lsls	r3, r3, #10
    1e1a:	f140 81e3 	bpl.w	21e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x448>
    1e1e:	48a0      	ldr	r0, [pc, #640]	; (20a0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x304>)
    1e20:	f005 fe70 	bl	7b04 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1e24:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1e28:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    1e2c:	44b0      	add	r8, r6
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    1e2e:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    1e32:	2107      	movs	r1, #7
    1e34:	489b      	ldr	r0, [pc, #620]	; (20a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x308>)
    1e36:	f005 fe65 	bl	7b04 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    1e3a:	2300      	movs	r3, #0
    1e3c:	2210      	movs	r2, #16
    1e3e:	4651      	mov	r1, sl
    1e40:	4895      	ldr	r0, [pc, #596]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e42:	f003 fdfb 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e46:	2101      	movs	r1, #1
    1e48:	4897      	ldr	r0, [pc, #604]	; (20a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1e4a:	f005 fe5b 	bl	7b04 <usb_serial_write>
    1e4e:	210a      	movs	r1, #10
    1e50:	4896      	ldr	r0, [pc, #600]	; (20ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x310>)
    1e52:	f005 fe57 	bl	7b04 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    1e56:	2300      	movs	r3, #0
    1e58:	2210      	movs	r2, #16
    1e5a:	ea4f 6119 	mov.w	r1, r9, lsr #24
    1e5e:	488e      	ldr	r0, [pc, #568]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e60:	f003 fdec 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e64:	2101      	movs	r1, #1
    1e66:	4892      	ldr	r0, [pc, #584]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e68:	f005 fe4c 	bl	7b04 <usb_serial_write>
    1e6c:	2300      	movs	r3, #0
    1e6e:	2210      	movs	r2, #16
    1e70:	f3c9 4107 	ubfx	r1, r9, #16, #8
    1e74:	4888      	ldr	r0, [pc, #544]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e76:	f003 fde1 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e7a:	2101      	movs	r1, #1
    1e7c:	488c      	ldr	r0, [pc, #560]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e7e:	f005 fe41 	bl	7b04 <usb_serial_write>
    1e82:	2300      	movs	r3, #0
    1e84:	2210      	movs	r2, #16
    1e86:	f3c9 2107 	ubfx	r1, r9, #8, #8
    1e8a:	4883      	ldr	r0, [pc, #524]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1e8c:	f003 fdd6 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1e90:	2101      	movs	r1, #1
    1e92:	4887      	ldr	r0, [pc, #540]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1e94:	f005 fe36 	bl	7b04 <usb_serial_write>
    1e98:	2300      	movs	r3, #0
    1e9a:	2210      	movs	r2, #16
    1e9c:	fa5f f189 	uxtb.w	r1, r9
    1ea0:	487d      	ldr	r0, [pc, #500]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ea2:	f003 fdcb 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
          dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    1ea6:	f858 8007 	ldr.w	r8, [r8, r7]
    1eaa:	2101      	movs	r1, #1
    1eac:	4880      	ldr	r0, [pc, #512]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1eae:	f005 fe29 	bl	7b04 <usb_serial_write>
    1eb2:	2300      	movs	r3, #0
    1eb4:	2210      	movs	r2, #16
    1eb6:	ea4f 6118 	mov.w	r1, r8, lsr #24
    1eba:	4877      	ldr	r0, [pc, #476]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ebc:	f003 fdbe 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ec0:	2101      	movs	r1, #1
    1ec2:	487b      	ldr	r0, [pc, #492]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1ec4:	f005 fe1e 	bl	7b04 <usb_serial_write>
    1ec8:	2300      	movs	r3, #0
    1eca:	2210      	movs	r2, #16
    1ecc:	f3c8 4107 	ubfx	r1, r8, #16, #8
    1ed0:	4871      	ldr	r0, [pc, #452]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ed2:	f003 fdb3 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ed6:	2101      	movs	r1, #1
    1ed8:	4875      	ldr	r0, [pc, #468]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1eda:	f005 fe13 	bl	7b04 <usb_serial_write>
    1ede:	2300      	movs	r3, #0
    1ee0:	2210      	movs	r2, #16
    1ee2:	f3c8 2107 	ubfx	r1, r8, #8, #8
    1ee6:	486c      	ldr	r0, [pc, #432]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1ee8:	f003 fda8 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1eec:	2101      	movs	r1, #1
    1eee:	4870      	ldr	r0, [pc, #448]	; (20b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x314>)
    1ef0:	f005 fe08 	bl	7b04 <usb_serial_write>
    1ef4:	2300      	movs	r3, #0
    1ef6:	fa5f f188 	uxtb.w	r1, r8
    1efa:	2210      	movs	r2, #16
    1efc:	4866      	ldr	r0, [pc, #408]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1efe:	f003 fd9d 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f02:	2101      	movs	r1, #1
    1f04:	4868      	ldr	r0, [pc, #416]	; (20a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x30c>)
    1f06:	f005 fdfd 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f0a:	4863      	ldr	r0, [pc, #396]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f0c:	f003 fd6c 	bl	59e8 <Print::println()>
  for ( uint8_t i = 0; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    1f10:	4b5b      	ldr	r3, [pc, #364]	; (2080 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2e4>)
    1f12:	3401      	adds	r4, #1
    1f14:	681b      	ldr	r3, [r3, #0]
    1f16:	b2e4      	uxtb	r4, r4
    1f18:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    1f1c:	46a1      	mov	r9, r4
    1f1e:	3301      	adds	r3, #1
    1f20:	429c      	cmp	r4, r3
    1f22:	f4ff af4c 	bcc.w	1dbe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x22>
}
    1f26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f2a:	2104      	movs	r1, #4
    1f2c:	4859      	ldr	r0, [pc, #356]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f2e:	f005 fde9 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f32:	4649      	mov	r1, r9
    1f34:	2300      	movs	r3, #0
    1f36:	220a      	movs	r2, #10
    1f38:	4857      	ldr	r0, [pc, #348]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f3a:	f003 fd7f 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f3e:	2111      	movs	r1, #17
    1f40:	485c      	ldr	r0, [pc, #368]	; (20b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x318>)
    1f42:	f005 fddf 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f46:	4854      	ldr	r0, [pc, #336]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f48:	f003 fd4e 	bl	59e8 <Print::println()>
    1f4c:	e7e0      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f4e:	2104      	movs	r1, #4
    1f50:	4850      	ldr	r0, [pc, #320]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f52:	f005 fdd7 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f56:	4649      	mov	r1, r9
    1f58:	2300      	movs	r3, #0
    1f5a:	220a      	movs	r2, #10
    1f5c:	484e      	ldr	r0, [pc, #312]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f5e:	f003 fd6d 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f62:	2111      	movs	r1, #17
    1f64:	4854      	ldr	r0, [pc, #336]	; (20b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x31c>)
    1f66:	f005 fdcd 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f6a:	484b      	ldr	r0, [pc, #300]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f6c:	f003 fd3c 	bl	59e8 <Print::println()>
    1f70:	e7ce      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f72:	2104      	movs	r1, #4
    1f74:	4847      	ldr	r0, [pc, #284]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f76:	f005 fdc5 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f7a:	4649      	mov	r1, r9
    1f7c:	2300      	movs	r3, #0
    1f7e:	220a      	movs	r2, #10
    1f80:	4845      	ldr	r0, [pc, #276]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f82:	f003 fd5b 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1f86:	210f      	movs	r1, #15
    1f88:	484c      	ldr	r0, [pc, #304]	; (20bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x320>)
    1f8a:	f005 fdbb 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1f8e:	4842      	ldr	r0, [pc, #264]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1f90:	f003 fd2a 	bl	59e8 <Print::println()>
    1f94:	e7bc      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1f96:	2104      	movs	r1, #4
    1f98:	483e      	ldr	r0, [pc, #248]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1f9a:	f005 fdb3 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1f9e:	4649      	mov	r1, r9
    1fa0:	2300      	movs	r3, #0
    1fa2:	220a      	movs	r2, #10
    1fa4:	483c      	ldr	r0, [pc, #240]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fa6:	f003 fd49 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1faa:	2112      	movs	r1, #18
    1fac:	4844      	ldr	r0, [pc, #272]	; (20c0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x324>)
    1fae:	f005 fda9 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fb2:	4839      	ldr	r0, [pc, #228]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fb4:	f003 fd18 	bl	59e8 <Print::println()>
    1fb8:	e7aa      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1fba:	2104      	movs	r1, #4
    1fbc:	4835      	ldr	r0, [pc, #212]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1fbe:	f005 fda1 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1fc2:	4649      	mov	r1, r9
    1fc4:	2300      	movs	r3, #0
    1fc6:	220a      	movs	r2, #10
    1fc8:	4833      	ldr	r0, [pc, #204]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fca:	f003 fd37 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1fce:	2111      	movs	r1, #17
    1fd0:	483c      	ldr	r0, [pc, #240]	; (20c4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x328>)
    1fd2:	f005 fd97 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    1fd6:	4830      	ldr	r0, [pc, #192]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fd8:	f003 fd06 	bl	59e8 <Print::println()>
    1fdc:	e798      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    1fde:	2104      	movs	r1, #4
    1fe0:	482c      	ldr	r0, [pc, #176]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    1fe2:	f005 fd8f 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    1fe6:	220a      	movs	r2, #10
    1fe8:	4649      	mov	r1, r9
    1fea:	2300      	movs	r3, #0
    1fec:	482a      	ldr	r0, [pc, #168]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    1fee:	f003 fd25 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1ff2:	210f      	movs	r1, #15
    1ff4:	4834      	ldr	r0, [pc, #208]	; (20c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x32c>)
    1ff6:	f005 fd85 	bl	7b04 <usb_serial_write>
          (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    1ffa:	f8d8 3000 	ldr.w	r3, [r8]
    1ffe:	2111      	movs	r1, #17
    2000:	029a      	lsls	r2, r3, #10
    2002:	bf4c      	ite	mi
    2004:	4831      	ldrmi	r0, [pc, #196]	; (20cc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x330>)
    2006:	4832      	ldrpl	r0, [pc, #200]	; (20d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x334>)
    2008:	f005 fd7c 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    200c:	4822      	ldr	r0, [pc, #136]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    200e:	f003 fceb 	bl	59e8 <Print::println()>
    2012:	e77d      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    2014:	2104      	movs	r1, #4
    2016:	481f      	ldr	r0, [pc, #124]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    2018:	f005 fd74 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    201c:	4649      	mov	r1, r9
    201e:	2300      	movs	r3, #0
    2020:	220a      	movs	r2, #10
    2022:	481d      	ldr	r0, [pc, #116]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    2024:	f003 fd0a 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2028:	210e      	movs	r1, #14
    202a:	482a      	ldr	r0, [pc, #168]	; (20d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x338>)
    202c:	f005 fd6a 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2030:	4819      	ldr	r0, [pc, #100]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    2032:	f003 fcd9 	bl	59e8 <Print::println()>
    2036:	e76b      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    2038:	2104      	movs	r1, #4
    203a:	4816      	ldr	r0, [pc, #88]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    203c:	f005 fd62 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2040:	4649      	mov	r1, r9
    2042:	2300      	movs	r3, #0
    2044:	220a      	movs	r2, #10
    2046:	4814      	ldr	r0, [pc, #80]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    2048:	f003 fcf8 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    204c:	210e      	movs	r1, #14
    204e:	4822      	ldr	r0, [pc, #136]	; (20d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x33c>)
    2050:	f005 fd58 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2054:	4810      	ldr	r0, [pc, #64]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    2056:	f003 fcc7 	bl	59e8 <Print::println()>
    205a:	e759      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    205c:	2104      	movs	r1, #4
    205e:	480d      	ldr	r0, [pc, #52]	; (2094 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2f8>)
    2060:	f005 fd50 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2064:	4649      	mov	r1, r9
    2066:	2300      	movs	r3, #0
    2068:	220a      	movs	r2, #10
    206a:	480b      	ldr	r0, [pc, #44]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    206c:	f003 fce6 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2070:	2112      	movs	r1, #18
    2072:	481a      	ldr	r0, [pc, #104]	; (20dc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x340>)
    2074:	f005 fd46 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2078:	4807      	ldr	r0, [pc, #28]	; (2098 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x2fc>)
    207a:	f003 fcb5 	bl	59e8 <Print::println()>
    207e:	e747      	b.n	1f10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x174>
    2080:	401d0000 	.word	0x401d0000
    2084:	20000840 	.word	0x20000840
    2088:	401d008c 	.word	0x401d008c
    208c:	0401d008 	.word	0x0401d008
    2090:	bfe2ff80 	.word	0xbfe2ff80
    2094:	20000710 	.word	0x20000710
    2098:	20001110 	.word	0x20001110
    209c:	200007d0 	.word	0x200007d0
    20a0:	200007f0 	.word	0x200007f0
    20a4:	20000818 	.word	0x20000818
    20a8:	2000074c 	.word	0x2000074c
    20ac:	20000820 	.word	0x20000820
    20b0:	200006b4 	.word	0x200006b4
    20b4:	2000082c 	.word	0x2000082c
    20b8:	20000788 	.word	0x20000788
    20bc:	200007c0 	.word	0x200007c0
    20c0:	200007ac 	.word	0x200007ac
    20c4:	20000774 	.word	0x20000774
    20c8:	2000072c 	.word	0x2000072c
    20cc:	2000073c 	.word	0x2000073c
    20d0:	20000750 	.word	0x20000750
    20d4:	20000764 	.word	0x20000764
    20d8:	2000079c 	.word	0x2000079c
    20dc:	20000718 	.word	0x20000718
    20e0:	2111      	movs	r1, #17
    20e2:	48c4      	ldr	r0, [pc, #784]	; (23f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x658>)
    20e4:	f005 fd0e 	bl	7b04 <usb_serial_write>
    Serial.print("FIFO Enabled --> "); ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IFLAG1_BUF5I ) ? Serial.println("Interrupt Enabled") : Serial.println("Interrupt Disabled");
    20e8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    20ea:	069a      	lsls	r2, r3, #26
    20ec:	f100 81fa 	bmi.w	24e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x748>
    20f0:	2112      	movs	r1, #18
    20f2:	48c1      	ldr	r0, [pc, #772]	; (23f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x65c>)
    20f4:	f005 fd06 	bl	7b04 <usb_serial_write>
    20f8:	48c0      	ldr	r0, [pc, #768]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    20fa:	f003 fc75 	bl	59e8 <Print::println()>
    20fe:	2116      	movs	r1, #22
    2100:	48bf      	ldr	r0, [pc, #764]	; (2400 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x664>)
    2102:	f005 fcff 	bl	7b04 <usb_serial_write>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    2106:	4abf      	ldr	r2, [pc, #764]	; (2404 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    2108:	6814      	ldr	r4, [r2, #0]
    210a:	6b51      	ldr	r1, [r2, #52]	; 0x34
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    210c:	6813      	ldr	r3, [r2, #0]
    210e:	6b52      	ldr	r2, [r2, #52]	; 0x34
    2110:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2114:	f3c2 6203 	ubfx	r2, r2, #24, #4
    2118:	3301      	adds	r3, #1
    211a:	3204      	adds	r2, #4
    211c:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    2120:	f0c0 81e8 	bcc.w	24f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x758>
    uint32_t remaining_mailboxes = FLEXCANb_MAXMB_SIZE(_bus) - 6 /* MAXMB - FIFO */ - ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2);
    2124:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    2128:	f3c1 6103 	ubfx	r1, r1, #24, #4
    212c:	3c05      	subs	r4, #5
    212e:	3101      	adds	r1, #1
    2130:	eba4 0441 	sub.w	r4, r4, r1, lsl #1
    Serial.println(constrain((uint8_t)(FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes), 0, 32));
    2134:	b2e5      	uxtb	r5, r4
    2136:	4eb3      	ldr	r6, [pc, #716]	; (2404 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
	size_t print(int n)				{ return print((long)n); }
    2138:	48b0      	ldr	r0, [pc, #704]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    213a:	6831      	ldr	r1, [r6, #0]
    213c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2140:	3101      	adds	r1, #1
    2142:	1b49      	subs	r1, r1, r5
    2144:	b2c9      	uxtb	r1, r1
    2146:	2920      	cmp	r1, #32
    2148:	bfa8      	it	ge
    214a:	2120      	movge	r1, #32
    214c:	f003 fc40 	bl	59d0 <Print::print(long)>
	size_t println(int n)				{ return print(n) + println(); }
    2150:	48aa      	ldr	r0, [pc, #680]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2152:	f003 fc49 	bl	59e8 <Print::println()>
    2156:	2116      	movs	r1, #22
    2158:	48ab      	ldr	r0, [pc, #684]	; (2408 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x66c>)
    215a:	f005 fcd3 	bl	7b04 <usb_serial_write>
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    215e:	6833      	ldr	r3, [r6, #0]
    2160:	6b72      	ldr	r2, [r6, #52]	; 0x34
    2162:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2166:	f3c2 6203 	ubfx	r2, r2, #24, #4
    216a:	3301      	adds	r3, #1
    216c:	3204      	adds	r2, #4
    216e:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    2172:	d201      	bcs.n	2178 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x3dc>
    2174:	2500      	movs	r5, #0
    2176:	462c      	mov	r4, r5
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    2178:	2300      	movs	r3, #0
    217a:	4621      	mov	r1, r4
    217c:	220a      	movs	r2, #10
    217e:	489f      	ldr	r0, [pc, #636]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2180:	f003 fc5c 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(unsigned long n)			{ return print(n) + println(); }
    2184:	489d      	ldr	r0, [pc, #628]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2186:	f003 fc2f 	bl	59e8 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    218a:	4b9e      	ldr	r3, [pc, #632]	; (2404 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    218c:	681c      	ldr	r4, [r3, #0]
    218e:	681b      	ldr	r3, [r3, #0]
    2190:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    2194:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2198:	3401      	adds	r4, #1
    219a:	3301      	adds	r3, #1
    219c:	1b64      	subs	r4, r4, r5
    219e:	b2e4      	uxtb	r4, r4
    21a0:	42a3      	cmp	r3, r4
    21a2:	f67f aec0 	bls.w	1f26 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x18a>
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    21a6:	4d99      	ldr	r5, [pc, #612]	; (240c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x670>)
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    21a8:	4e99      	ldr	r6, [pc, #612]	; (2410 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x674>)
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    21aa:	4f9a      	ldr	r7, [pc, #616]	; (2414 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x678>)
      switch ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) ) {
    21ac:	eb04 0805 	add.w	r8, r4, r5
    21b0:	ea4f 1808 	mov.w	r8, r8, lsl #4
    21b4:	f8d8 3000 	ldr.w	r3, [r8]
    21b8:	f3c3 6303 	ubfx	r3, r3, #24, #4
    21bc:	2b0e      	cmp	r3, #14
    21be:	f200 80a9 	bhi.w	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    21c2:	e8df f013 	tbh	[pc, r3, lsl #1]
    21c6:	0147      	.short	0x0147
    21c8:	00f20104 	.word	0x00f20104
    21cc:	00d700a7 	.word	0x00d700a7
    21d0:	016b00a7 	.word	0x016b00a7
    21d4:	015900a7 	.word	0x015900a7
    21d8:	00c5017d 	.word	0x00c5017d
    21dc:	001a00a7 	.word	0x001a00a7
    21e0:	00b300a7 	.word	0x00b300a7
    21e4:	488c      	ldr	r0, [pc, #560]	; (2418 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x67c>)
    21e6:	f005 fc8d 	bl	7b04 <usb_serial_write>
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    21ea:	f8d8 9008 	ldr.w	r9, [r8, #8]
          uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    21ee:	f8d8 3004 	ldr.w	r3, [r8, #4]
          uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    21f2:	44b0      	add	r8, r6
          if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    21f4:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    21f8:	e61b      	b.n	1e32 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x96>
    21fa:	2104      	movs	r1, #4
    21fc:	4887      	ldr	r0, [pc, #540]	; (241c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    21fe:	f005 fc81 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2202:	2300      	movs	r3, #0
    2204:	220a      	movs	r2, #10
    2206:	4621      	mov	r1, r4
    2208:	487c      	ldr	r0, [pc, #496]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    220a:	f003 fc17 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    220e:	211d      	movs	r1, #29
    2210:	4883      	ldr	r0, [pc, #524]	; (2420 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x684>)
    2212:	f005 fc77 	bl	7b04 <usb_serial_write>
            uint32_t extid = (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE);
    2216:	f8d8 3000 	ldr.w	r3, [r8]
    221a:	2110      	movs	r1, #16
            (extid) ? Serial.print("(Extended Frame)") : Serial.print("(Standard Frame)");
    221c:	0298      	lsls	r0, r3, #10
    221e:	f140 816c 	bpl.w	24fa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x75e>
    2222:	4880      	ldr	r0, [pc, #512]	; (2424 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x688>)
    2224:	f005 fc6e 	bl	7b04 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2228:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    222c:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2230:	44b8      	add	r8, r7
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    2232:	f023 4a60 	bic.w	sl, r3, #3758096384	; 0xe0000000
    2236:	2107      	movs	r1, #7
    2238:	487b      	ldr	r0, [pc, #492]	; (2428 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x68c>)
    223a:	f005 fc63 	bl	7b04 <usb_serial_write>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    223e:	2300      	movs	r3, #0
    2240:	2210      	movs	r2, #16
    2242:	4651      	mov	r1, sl
    2244:	486d      	ldr	r0, [pc, #436]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2246:	f003 fbf9 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    224a:	2101      	movs	r1, #1
    224c:	4877      	ldr	r0, [pc, #476]	; (242c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    224e:	f005 fc59 	bl	7b04 <usb_serial_write>
    2252:	210a      	movs	r1, #10
    2254:	4876      	ldr	r0, [pc, #472]	; (2430 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x694>)
    2256:	f005 fc55 	bl	7b04 <usb_serial_write>
	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    225a:	2300      	movs	r3, #0
    225c:	2210      	movs	r2, #16
    225e:	ea4f 6119 	mov.w	r1, r9, lsr #24
    2262:	4866      	ldr	r0, [pc, #408]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2264:	f003 fbea 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2268:	2101      	movs	r1, #1
    226a:	4872      	ldr	r0, [pc, #456]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    226c:	f005 fc4a 	bl	7b04 <usb_serial_write>
    2270:	2300      	movs	r3, #0
    2272:	2210      	movs	r2, #16
    2274:	f3c9 4107 	ubfx	r1, r9, #16, #8
    2278:	4860      	ldr	r0, [pc, #384]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    227a:	f003 fbdf 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    227e:	2101      	movs	r1, #1
    2280:	486c      	ldr	r0, [pc, #432]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2282:	f005 fc3f 	bl	7b04 <usb_serial_write>
    2286:	2300      	movs	r3, #0
    2288:	2210      	movs	r2, #16
    228a:	f3c9 2107 	ubfx	r1, r9, #8, #8
    228e:	485b      	ldr	r0, [pc, #364]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2290:	f003 fbd4 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2294:	2101      	movs	r1, #1
    2296:	4867      	ldr	r0, [pc, #412]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    2298:	f005 fc34 	bl	7b04 <usb_serial_write>
    229c:	2300      	movs	r3, #0
    229e:	2210      	movs	r2, #16
    22a0:	fa5f f189 	uxtb.w	r1, r9
    22a4:	4855      	ldr	r0, [pc, #340]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22a6:	f003 fbc9 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
            dataIn = FLEXCANb_MBn_WORD1(_bus, i);
    22aa:	f858 8006 	ldr.w	r8, [r8, r6]
    22ae:	2101      	movs	r1, #1
    22b0:	4860      	ldr	r0, [pc, #384]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    22b2:	f005 fc27 	bl	7b04 <usb_serial_write>
    22b6:	2300      	movs	r3, #0
    22b8:	2210      	movs	r2, #16
    22ba:	ea4f 6118 	mov.w	r1, r8, lsr #24
    22be:	484f      	ldr	r0, [pc, #316]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22c0:	f003 fbbc 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    22c4:	2101      	movs	r1, #1
    22c6:	485b      	ldr	r0, [pc, #364]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    22c8:	f005 fc1c 	bl	7b04 <usb_serial_write>
    22cc:	2300      	movs	r3, #0
    22ce:	2210      	movs	r2, #16
    22d0:	f3c8 4107 	ubfx	r1, r8, #16, #8
    22d4:	4849      	ldr	r0, [pc, #292]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22d6:	f003 fbb1 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    22da:	2101      	movs	r1, #1
    22dc:	4855      	ldr	r0, [pc, #340]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    22de:	f005 fc11 	bl	7b04 <usb_serial_write>
    22e2:	2300      	movs	r3, #0
    22e4:	2210      	movs	r2, #16
    22e6:	f3c8 2107 	ubfx	r1, r8, #8, #8
    22ea:	4844      	ldr	r0, [pc, #272]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    22ec:	f003 fba6 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    22f0:	2101      	movs	r1, #1
    22f2:	4850      	ldr	r0, [pc, #320]	; (2434 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x698>)
    22f4:	f005 fc06 	bl	7b04 <usb_serial_write>
    22f8:	2300      	movs	r3, #0
    22fa:	fa5f f188 	uxtb.w	r1, r8
    22fe:	2210      	movs	r2, #16
    2300:	483e      	ldr	r0, [pc, #248]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2302:	f003 fb9b 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2306:	2101      	movs	r1, #1
    2308:	4848      	ldr	r0, [pc, #288]	; (242c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x690>)
    230a:	f005 fbfb 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    230e:	483b      	ldr	r0, [pc, #236]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2310:	f003 fb6a 	bl	59e8 <Print::println()>
    for ( uint8_t i = FLEXCANb_MAXMB_SIZE(_bus) - remaining_mailboxes; i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    2314:	4b3b      	ldr	r3, [pc, #236]	; (2404 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x668>)
    2316:	3401      	adds	r4, #1
    2318:	681b      	ldr	r3, [r3, #0]
    231a:	b2e4      	uxtb	r4, r4
    231c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2320:	3301      	adds	r3, #1
    2322:	429c      	cmp	r4, r3
    2324:	f4ff af42 	bcc.w	21ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x410>
}
    2328:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    232c:	2104      	movs	r1, #4
    232e:	483b      	ldr	r0, [pc, #236]	; (241c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    2330:	f005 fbe8 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2334:	2300      	movs	r3, #0
    2336:	220a      	movs	r2, #10
    2338:	4621      	mov	r1, r4
    233a:	4830      	ldr	r0, [pc, #192]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    233c:	f003 fb7e 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2340:	2111      	movs	r1, #17
    2342:	483d      	ldr	r0, [pc, #244]	; (2438 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x69c>)
    2344:	f005 fbde 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2348:	482c      	ldr	r0, [pc, #176]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    234a:	f003 fb4d 	bl	59e8 <Print::println()>
    234e:	e7e1      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2350:	2104      	movs	r1, #4
    2352:	4832      	ldr	r0, [pc, #200]	; (241c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    2354:	f005 fbd6 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2358:	2300      	movs	r3, #0
    235a:	220a      	movs	r2, #10
    235c:	4621      	mov	r1, r4
    235e:	4827      	ldr	r0, [pc, #156]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2360:	f003 fb6c 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2364:	2111      	movs	r1, #17
    2366:	4835      	ldr	r0, [pc, #212]	; (243c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a0>)
    2368:	f005 fbcc 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    236c:	4823      	ldr	r0, [pc, #140]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    236e:	f003 fb3b 	bl	59e8 <Print::println()>
    2372:	e7cf      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2374:	2104      	movs	r1, #4
    2376:	4829      	ldr	r0, [pc, #164]	; (241c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    2378:	f005 fbc4 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    237c:	220a      	movs	r2, #10
    237e:	2300      	movs	r3, #0
    2380:	4621      	mov	r1, r4
    2382:	481e      	ldr	r0, [pc, #120]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    2384:	f003 fb5a 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2388:	210f      	movs	r1, #15
    238a:	482d      	ldr	r0, [pc, #180]	; (2440 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a4>)
    238c:	f005 fbba 	bl	7b04 <usb_serial_write>
            (FLEXCANb_MBn_CS(_bus, i) & FLEXCAN_MB_CS_IDE) ? Serial.println("\t(Extended Frame)") : Serial.println("\t(Standard Frame)");
    2390:	f8d8 3000 	ldr.w	r3, [r8]
    2394:	2111      	movs	r1, #17
    2396:	029b      	lsls	r3, r3, #10
    2398:	bf4c      	ite	mi
    239a:	482a      	ldrmi	r0, [pc, #168]	; (2444 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6a8>)
    239c:	482a      	ldrpl	r0, [pc, #168]	; (2448 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6ac>)
    239e:	f005 fbb1 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    23a2:	4816      	ldr	r0, [pc, #88]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    23a4:	f003 fb20 	bl	59e8 <Print::println()>
    23a8:	e7b4      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    23aa:	2104      	movs	r1, #4
    23ac:	481b      	ldr	r0, [pc, #108]	; (241c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    23ae:	f005 fba9 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    23b2:	2300      	movs	r3, #0
    23b4:	220a      	movs	r2, #10
    23b6:	4621      	mov	r1, r4
    23b8:	4810      	ldr	r0, [pc, #64]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    23ba:	f003 fb3f 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    23be:	210e      	movs	r1, #14
    23c0:	4822      	ldr	r0, [pc, #136]	; (244c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b0>)
    23c2:	f005 fb9f 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    23c6:	480d      	ldr	r0, [pc, #52]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    23c8:	f003 fb0e 	bl	59e8 <Print::println()>
    23cc:	e7a2      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    23ce:	2104      	movs	r1, #4
    23d0:	4812      	ldr	r0, [pc, #72]	; (241c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x680>)
    23d2:	f005 fb97 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    23d6:	2300      	movs	r3, #0
    23d8:	220a      	movs	r2, #10
    23da:	4621      	mov	r1, r4
    23dc:	4807      	ldr	r0, [pc, #28]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    23de:	f003 fb2d 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    23e2:	210e      	movs	r1, #14
    23e4:	481a      	ldr	r0, [pc, #104]	; (2450 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x6b4>)
    23e6:	f005 fb8d 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    23ea:	4804      	ldr	r0, [pc, #16]	; (23fc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x660>)
    23ec:	f003 fafc 	bl	59e8 <Print::println()>
    23f0:	e790      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    23f2:	bf00      	nop
    23f4:	200006a4 	.word	0x200006a4
    23f8:	200006cc 	.word	0x200006cc
    23fc:	20001110 	.word	0x20001110
    2400:	200006e0 	.word	0x200006e0
    2404:	401d0000 	.word	0x401d0000
    2408:	200006f8 	.word	0x200006f8
    240c:	0401d008 	.word	0x0401d008
    2410:	401d008c 	.word	0x401d008c
    2414:	bfe2ff80 	.word	0xbfe2ff80
    2418:	20000804 	.word	0x20000804
    241c:	20000710 	.word	0x20000710
    2420:	200007d0 	.word	0x200007d0
    2424:	200007f0 	.word	0x200007f0
    2428:	20000818 	.word	0x20000818
    242c:	2000074c 	.word	0x2000074c
    2430:	20000820 	.word	0x20000820
    2434:	200006b4 	.word	0x200006b4
    2438:	2000082c 	.word	0x2000082c
    243c:	20000788 	.word	0x20000788
    2440:	2000072c 	.word	0x2000072c
    2444:	2000073c 	.word	0x2000073c
    2448:	20000750 	.word	0x20000750
    244c:	20000764 	.word	0x20000764
    2450:	2000079c 	.word	0x2000079c
    2454:	2104      	movs	r1, #4
    2456:	482e      	ldr	r0, [pc, #184]	; (2510 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    2458:	f005 fb54 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    245c:	2300      	movs	r3, #0
    245e:	220a      	movs	r2, #10
    2460:	4621      	mov	r1, r4
    2462:	482c      	ldr	r0, [pc, #176]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2464:	f003 faea 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    2468:	2112      	movs	r1, #18
    246a:	482b      	ldr	r0, [pc, #172]	; (2518 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x77c>)
    246c:	f005 fb4a 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2470:	4828      	ldr	r0, [pc, #160]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2472:	f003 fab9 	bl	59e8 <Print::println()>
    2476:	e74d      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    2478:	2104      	movs	r1, #4
    247a:	4825      	ldr	r0, [pc, #148]	; (2510 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    247c:	f005 fb42 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    2480:	2300      	movs	r3, #0
    2482:	220a      	movs	r2, #10
    2484:	4621      	mov	r1, r4
    2486:	4823      	ldr	r0, [pc, #140]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2488:	f003 fad8 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    248c:	2112      	movs	r1, #18
    248e:	4823      	ldr	r0, [pc, #140]	; (251c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x780>)
    2490:	f005 fb38 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    2494:	481f      	ldr	r0, [pc, #124]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    2496:	f003 faa7 	bl	59e8 <Print::println()>
    249a:	e73b      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    249c:	2104      	movs	r1, #4
    249e:	481c      	ldr	r0, [pc, #112]	; (2510 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    24a0:	f005 fb30 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    24a4:	2300      	movs	r3, #0
    24a6:	220a      	movs	r2, #10
    24a8:	4621      	mov	r1, r4
    24aa:	481a      	ldr	r0, [pc, #104]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    24ac:	f003 fac6 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    24b0:	2111      	movs	r1, #17
    24b2:	481b      	ldr	r0, [pc, #108]	; (2520 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x784>)
    24b4:	f005 fb26 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    24b8:	4816      	ldr	r0, [pc, #88]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    24ba:	f003 fa95 	bl	59e8 <Print::println()>
    24be:	e729      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    24c0:	2104      	movs	r1, #4
    24c2:	4813      	ldr	r0, [pc, #76]	; (2510 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x774>)
    24c4:	f005 fb1e 	bl	7b04 <usb_serial_write>
	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    24c8:	2300      	movs	r3, #0
    24ca:	220a      	movs	r2, #10
    24cc:	4621      	mov	r1, r4
    24ce:	4811      	ldr	r0, [pc, #68]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    24d0:	f003 fab4 	bl	5a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    24d4:	210f      	movs	r1, #15
    24d6:	4813      	ldr	r0, [pc, #76]	; (2524 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x788>)
    24d8:	f005 fb14 	bl	7b04 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    24dc:	480d      	ldr	r0, [pc, #52]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    24de:	f003 fa83 	bl	59e8 <Print::println()>
    24e2:	e717      	b.n	2314 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x578>
    24e4:	2111      	movs	r1, #17
    24e6:	4810      	ldr	r0, [pc, #64]	; (2528 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x78c>)
    24e8:	f005 fb0c 	bl	7b04 <usb_serial_write>
    24ec:	4809      	ldr	r0, [pc, #36]	; (2514 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x778>)
    24ee:	f003 fa7b 	bl	59e8 <Print::println()>
    24f2:	e604      	b.n	20fe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x362>
    24f4:	2500      	movs	r5, #0
    if ( FLEXCANb_MAXMB_SIZE(_bus) < (6 + ((((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 2))) remaining_mailboxes = 0;
    24f6:	462c      	mov	r4, r5
    24f8:	e61d      	b.n	2136 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x39a>
    24fa:	480c      	ldr	r0, [pc, #48]	; (252c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x790>)
    24fc:	f005 fb02 	bl	7b04 <usb_serial_write>
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2500:	f8d8 9008 	ldr.w	r9, [r8, #8]
            uint32_t id = (FLEXCANb_MBn_ID(_bus, i) & FLEXCAN_MB_ID_EXT_MASK);
    2504:	f8d8 3004 	ldr.w	r3, [r8, #4]
            uint32_t dataIn = FLEXCANb_MBn_WORD0(_bus, i);
    2508:	44b8      	add	r8, r7
            if (!extid) id >>= FLEXCAN_MB_ID_STD_BIT_NO;
    250a:	f3c3 4a8a 	ubfx	sl, r3, #18, #11
    250e:	e692      	b.n	2236 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]+0x49a>
    2510:	20000710 	.word	0x20000710
    2514:	20001110 	.word	0x20001110
    2518:	20000718 	.word	0x20000718
    251c:	200007ac 	.word	0x200007ac
    2520:	20000774 	.word	0x20000774
    2524:	200007c0 	.word	0x200007c0
    2528:	200006b8 	.word	0x200006b8
    252c:	20000804 	.word	0x20000804

00002530 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    2530:	b570      	push	{r4, r5, r6, lr}
    2532:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2534:	bb39      	cbnz	r1, 2586 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    2536:	4a3b      	ldr	r2, [pc, #236]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2538:	6a13      	ldr	r3, [r2, #32]
    253a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    253e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    2542:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    2544:	4b38      	ldr	r3, [pc, #224]	; (2628 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    2546:	6818      	ldr	r0, [r3, #0]
    2548:	b158      	cbz	r0, 2562 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    254a:	4a38      	ldr	r2, [pc, #224]	; (262c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    254c:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    2550:	6805      	ldr	r5, [r0, #0]
    2552:	6852      	ldr	r2, [r2, #4]
    2554:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    2558:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    255c:	686b      	ldr	r3, [r5, #4]
    255e:	0052      	lsls	r2, r2, #1
    2560:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    2562:	4b33      	ldr	r3, [pc, #204]	; (2630 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    2564:	6818      	ldr	r0, [r3, #0]
    2566:	2800      	cmp	r0, #0
    2568:	d05b      	beq.n	2622 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    256a:	4a30      	ldr	r2, [pc, #192]	; (262c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    256c:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2570:	6803      	ldr	r3, [r0, #0]
    2572:	6852      	ldr	r2, [r2, #4]
    2574:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    2578:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    257c:	685b      	ldr	r3, [r3, #4]
    257e:	0052      	lsls	r2, r2, #1
}
    2580:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    2584:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    2586:	2908      	cmp	r1, #8
    2588:	d107      	bne.n	259a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    258a:	4a26      	ldr	r2, [pc, #152]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    258c:	6a13      	ldr	r3, [r2, #32]
    258e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2592:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    2596:	6213      	str	r3, [r2, #32]
    2598:	e7d4      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    259a:	2910      	cmp	r1, #16
    259c:	d107      	bne.n	25ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    259e:	4a21      	ldr	r2, [pc, #132]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25a0:	6a13      	ldr	r3, [r2, #32]
    25a2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25a6:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    25aa:	6213      	str	r3, [r2, #32]
    25ac:	e7ca      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    25ae:	2918      	cmp	r1, #24
    25b0:	d107      	bne.n	25c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    25b2:	4a1c      	ldr	r2, [pc, #112]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25b4:	6a13      	ldr	r3, [r2, #32]
    25b6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    25be:	6213      	str	r3, [r2, #32]
    25c0:	e7c0      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    25c2:	2914      	cmp	r1, #20
    25c4:	d107      	bne.n	25d6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    25c6:	4a17      	ldr	r2, [pc, #92]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25c8:	6a13      	ldr	r3, [r2, #32]
    25ca:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25ce:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    25d2:	6213      	str	r3, [r2, #32]
    25d4:	e7b6      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    25d6:	291e      	cmp	r1, #30
    25d8:	d107      	bne.n	25ea <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    25da:	4a12      	ldr	r2, [pc, #72]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25dc:	6a13      	ldr	r3, [r2, #32]
    25de:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25e2:	f043 0304 	orr.w	r3, r3, #4
    25e6:	6213      	str	r3, [r2, #32]
    25e8:	e7ac      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    25ea:	2928      	cmp	r1, #40	; 0x28
    25ec:	d107      	bne.n	25fe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    25ee:	4a0d      	ldr	r2, [pc, #52]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    25f0:	6a13      	ldr	r3, [r2, #32]
    25f2:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    25f6:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    25fa:	6213      	str	r3, [r2, #32]
    25fc:	e7a2      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    25fe:	293c      	cmp	r1, #60	; 0x3c
    2600:	d105      	bne.n	260e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    2602:	4a08      	ldr	r2, [pc, #32]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2604:	6a13      	ldr	r3, [r2, #32]
    2606:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    260a:	6213      	str	r3, [r2, #32]
    260c:	e79a      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    260e:	2950      	cmp	r1, #80	; 0x50
    2610:	d198      	bne.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    2612:	4a04      	ldr	r2, [pc, #16]	; (2624 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2614:	6a13      	ldr	r3, [r2, #32]
    2616:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    261a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    261e:	6213      	str	r3, [r2, #32]
    2620:	e790      	b.n	2544 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    2622:	bd70      	pop	{r4, r5, r6, pc}
    2624:	400fc000 	.word	0x400fc000
    2628:	2000a320 	.word	0x2000a320
    262c:	401d0000 	.word	0x401d0000
    2630:	2000a324 	.word	0x2000a324

00002634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    2634:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    2636:	494e      	ldr	r1, [pc, #312]	; (2770 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    2638:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    263a:	4b4e      	ldr	r3, [pc, #312]	; (2774 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    263c:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    263e:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    2640:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    2642:	6a1b      	ldr	r3, [r3, #32]
    2644:	f3c3 2301 	ubfx	r3, r3, #8, #2
    2648:	3308      	adds	r3, #8
    264a:	446b      	add	r3, sp
    264c:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    2650:	e9c0 2201 	strd	r2, r2, [r0, #4]
    2654:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2658:	2b00      	cmp	r3, #0
    265a:	f000 8085 	beq.w	2768 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C000;
    265e:	4945      	ldr	r1, [pc, #276]	; (2774 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN1;
    2660:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    2664:	2024      	movs	r0, #36	; 0x24
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    2666:	4b44      	ldr	r3, [pc, #272]	; (2778 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    2668:	4a44      	ldr	r2, [pc, #272]	; (277c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 1;
    266a:	2401      	movs	r4, #1
    nvicIrq = IRQ_CAN1;
    266c:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    2670:	2602      	movs	r6, #2
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can1;
    2672:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    2676:	2012      	movs	r0, #18
    CCM_CCGR0 |= 0x3C000;
    2678:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    267a:	4b41      	ldr	r3, [pc, #260]	; (2780 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C000;
    267c:	f442 3270 	orr.w	r2, r2, #245760	; 0x3c000
    2680:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    2682:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 1;
    2686:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    268a:	4a3e      	ldr	r2, [pc, #248]	; (2784 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    268c:	4c3e      	ldr	r4, [pc, #248]	; (2788 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 0x12; // pin 22 T4B1+B2
    268e:	f8c3 011c 	str.w	r0, [r3, #284]	; 0x11c
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08 = 0x10B0; // pin 22 T4B1+B2
    2692:	f8c3 130c 	str.w	r1, [r3, #780]	; 0x30c
      IOMUXC_FLEXCAN1_RX_SELECT_INPUT = 0x02;
    2696:	64e6      	str	r6, [r4, #76]	; 0x4c
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 0x12; // pin 23 T4B1+B2
    2698:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09 = 0x10B0; // pin 23 T4B1+B2
    269c:	f8c3 1310 	str.w	r1, [r3, #784]	; 0x310
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    26a0:	6813      	ldr	r3, [r2, #0]
    26a2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    26a6:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    26a8:	6813      	ldr	r3, [r2, #0]
    26aa:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    26ae:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    26b0:	6813      	ldr	r3, [r2, #0]
    26b2:	01dc      	lsls	r4, r3, #7
    26b4:	d5fc      	bpl.n	26b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    26b6:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    26b8:	4932      	ldr	r1, [pc, #200]	; (2784 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    26ba:	f043 0308 	orr.w	r3, r3, #8
    26be:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    26c0:	6813      	ldr	r3, [r2, #0]
    26c2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    26c6:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    26c8:	680b      	ldr	r3, [r1, #0]
    26ca:	02d8      	lsls	r0, r3, #11
    26cc:	d4fc      	bmi.n	26c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    26ce:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    26d0:	4a2c      	ldr	r2, [pc, #176]	; (2784 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    26d2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    26d6:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    26d8:	6813      	ldr	r3, [r2, #0]
    26da:	0199      	lsls	r1, r3, #6
    26dc:	d4fc      	bmi.n	26d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    26de:	4c29      	ldr	r4, [pc, #164]	; (2784 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    26e0:	6823      	ldr	r3, [r4, #0]
    26e2:	01da      	lsls	r2, r3, #7
    26e4:	d5fc      	bpl.n	26e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    26e6:	6823      	ldr	r3, [r4, #0]
    void disableFIFO() { enableFIFO(0); }
    26e8:	2000      	movs	r0, #0
    26ea:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    26ee:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    26f0:	6823      	ldr	r3, [r4, #0]
    26f2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    26f6:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    26f8:	6823      	ldr	r3, [r4, #0]
    26fa:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    26fe:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    2700:	6823      	ldr	r3, [r4, #0]
    2702:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    2706:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    2708:	6823      	ldr	r3, [r4, #0]
    270a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    270e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    2710:	6823      	ldr	r3, [r4, #0]
    2712:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    2716:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    2718:	6823      	ldr	r3, [r4, #0]
    271a:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    271e:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    2720:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2722:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    2726:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    2728:	6823      	ldr	r3, [r4, #0]
    272a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    272e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    2730:	6823      	ldr	r3, [r4, #0]
    2732:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    2736:	6023      	str	r3, [r4, #0]
    2738:	f7fe fdca 	bl	12d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    273c:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    273e:	4a11      	ldr	r2, [pc, #68]	; (2784 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2740:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2744:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2746:	6813      	ldr	r3, [r2, #0]
    2748:	01db      	lsls	r3, r3, #7
    274a:	d4fc      	bmi.n	2746 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    274c:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    2750:	2101      	movs	r1, #1
    2752:	4b0e      	ldr	r3, [pc, #56]	; (278c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    2754:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2758:	f002 021f 	and.w	r2, r2, #31
    275c:	009b      	lsls	r3, r3, #2
    275e:	fa01 f202 	lsl.w	r2, r1, r2
    2762:	601a      	str	r2, [r3, #0]
}
    2764:	b002      	add	sp, #8
    2766:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    2768:	2118      	movs	r1, #24
    276a:	f7ff fee1 	bl	2530 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    276e:	e776      	b.n	265e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    2770:	0050183c 	.word	0x0050183c
    2774:	400fc000 	.word	0x400fc000
    2778:	20001c00 	.word	0x20001c00
    277c:	00000f09 	.word	0x00000f09
    2780:	401f8000 	.word	0x401f8000
    2784:	401d0000 	.word	0x401d0000
    2788:	401f8400 	.word	0x401f8400
    278c:	38003840 	.word	0x38003840

00002790 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>:
FCTP_FUNC void FCTP_OPT::setClock(FLEXCAN_CLOCK clock) {
    2790:	b570      	push	{r4, r5, r6, lr}
    2792:	4604      	mov	r4, r0
  if ( clock == CLK_OFF ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(3) | CCM_CSCMR2_CAN_CLK_PODF(0);
    2794:	bb39      	cbnz	r1, 27e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x56>
    2796:	4a3b      	ldr	r2, [pc, #236]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2798:	6a13      	ldr	r3, [r2, #32]
    279a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    279e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    27a2:	6213      	str	r3, [r2, #32]
  if ( _CAN1 ) _CAN1->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    27a4:	4b38      	ldr	r3, [pc, #224]	; (2888 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf8>)
    27a6:	6818      	ldr	r0, [r3, #0]
    27a8:	b158      	cbz	r0, 27c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x32>
    27aa:	4a38      	ldr	r2, [pc, #224]	; (288c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    27ac:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
    27b0:	6805      	ldr	r5, [r0, #0]
    27b2:	6852      	ldr	r2, [r2, #4]
    27b4:	f8d3 1910 	ldr.w	r1, [r3, #2320]	; 0x910
    27b8:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    27bc:	686b      	ldr	r3, [r5, #4]
    27be:	0052      	lsls	r2, r2, #1
    27c0:	4798      	blx	r3
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    27c2:	4b33      	ldr	r3, [pc, #204]	; (2890 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x100>)
    27c4:	6818      	ldr	r0, [r3, #0]
    27c6:	2800      	cmp	r0, #0
    27c8:	d05b      	beq.n	2882 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf2>
    27ca:	4a30      	ldr	r2, [pc, #192]	; (288c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xfc>)
    27cc:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    27d0:	6803      	ldr	r3, [r0, #0]
    27d2:	6852      	ldr	r2, [r2, #4]
    27d4:	f8d4 1910 	ldr.w	r1, [r4, #2320]	; 0x910
    27d8:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    27dc:	685b      	ldr	r3, [r3, #4]
    27de:	0052      	lsls	r2, r2, #1
}
    27e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if ( _CAN2 ) _CAN2->setBaudRate(currentBitrate, (( FLEXCANb_CTRL1(_bus) & FLEXCAN_CTRL_LOM ) ? LISTEN_ONLY : TX));
    27e4:	4718      	bx	r3
  if ( clock == CLK_8MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(9);
    27e6:	2908      	cmp	r1, #8
    27e8:	d107      	bne.n	27fa <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x6a>
    27ea:	4a26      	ldr	r2, [pc, #152]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    27ec:	6a13      	ldr	r3, [r2, #32]
    27ee:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    27f2:	f443 7309 	orr.w	r3, r3, #548	; 0x224
    27f6:	6213      	str	r3, [r2, #32]
    27f8:	e7d4      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_16MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(4);
    27fa:	2910      	cmp	r1, #16
    27fc:	d107      	bne.n	280e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x7e>
    27fe:	4a21      	ldr	r2, [pc, #132]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2800:	6a13      	ldr	r3, [r2, #32]
    2802:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2806:	f443 7304 	orr.w	r3, r3, #528	; 0x210
    280a:	6213      	str	r3, [r2, #32]
    280c:	e7ca      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_24MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(1) | CCM_CSCMR2_CAN_CLK_PODF(0);
    280e:	2918      	cmp	r1, #24
    2810:	d107      	bne.n	2822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x92>
    2812:	4a1c      	ldr	r2, [pc, #112]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2814:	6a13      	ldr	r3, [r2, #32]
    2816:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    281a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    281e:	6213      	str	r3, [r2, #32]
    2820:	e7c0      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_20MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(3);
    2822:	2914      	cmp	r1, #20
    2824:	d107      	bne.n	2836 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xa6>
    2826:	4a17      	ldr	r2, [pc, #92]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2828:	6a13      	ldr	r3, [r2, #32]
    282a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    282e:	f443 7303 	orr.w	r3, r3, #524	; 0x20c
    2832:	6213      	str	r3, [r2, #32]
    2834:	e7b6      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_30MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(1);
    2836:	291e      	cmp	r1, #30
    2838:	d107      	bne.n	284a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xba>
    283a:	4a12      	ldr	r2, [pc, #72]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    283c:	6a13      	ldr	r3, [r2, #32]
    283e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2842:	f043 0304 	orr.w	r3, r3, #4
    2846:	6213      	str	r3, [r2, #32]
    2848:	e7ac      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_40MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(1);
    284a:	2928      	cmp	r1, #40	; 0x28
    284c:	d107      	bne.n	285e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xce>
    284e:	4a0d      	ldr	r2, [pc, #52]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2850:	6a13      	ldr	r3, [r2, #32]
    2852:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    2856:	f443 7301 	orr.w	r3, r3, #516	; 0x204
    285a:	6213      	str	r3, [r2, #32]
    285c:	e7a2      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_60MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(0) | CCM_CSCMR2_CAN_CLK_PODF(0);
    285e:	293c      	cmp	r1, #60	; 0x3c
    2860:	d105      	bne.n	286e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xde>
    2862:	4a08      	ldr	r2, [pc, #32]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2864:	6a13      	ldr	r3, [r2, #32]
    2866:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    286a:	6213      	str	r3, [r2, #32]
    286c:	e79a      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
  if ( clock == CLK_80MHz ) CCM_CSCMR2 = (CCM_CSCMR2 & 0xFFFFFC03) | CCM_CSCMR2_CAN_CLK_SEL(2) | CCM_CSCMR2_CAN_CLK_PODF(0);
    286e:	2950      	cmp	r1, #80	; 0x50
    2870:	d198      	bne.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
    2872:	4a04      	ldr	r2, [pc, #16]	; (2884 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0xf4>)
    2874:	6a13      	ldr	r3, [r2, #32]
    2876:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    287a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    287e:	6213      	str	r3, [r2, #32]
    2880:	e790      	b.n	27a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)+0x14>
}
    2882:	bd70      	pop	{r4, r5, r6, pc}
    2884:	400fc000 	.word	0x400fc000
    2888:	2000a320 	.word	0x2000a320
    288c:	401d4000 	.word	0x401d4000
    2890:	2000a324 	.word	0x2000a324

00002894 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>:
FCTP_FUNC void FCTP_OPT::begin() {
    2894:	b570      	push	{r4, r5, r6, lr}
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    2896:	494e      	ldr	r1, [pc, #312]	; (29d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x13c>)
FCTP_FUNC void FCTP_OPT::begin() {
    2898:	b082      	sub	sp, #8
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    289a:	4b4e      	ldr	r3, [pc, #312]	; (29d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    289c:	2200      	movs	r2, #0
  const uint8_t clocksrc[4] = {60, 24, 80, 0};
    289e:	9101      	str	r1, [sp, #4]
FCTP_FUNC void FCTP_OPT::begin() {
    28a0:	4605      	mov	r5, r0
  return clocksrc[(CCM_CSCMR2 & 0x300) >> 8];
    28a2:	6a1b      	ldr	r3, [r3, #32]
    28a4:	f3c3 2301 	ubfx	r3, r3, #8, #2
    28a8:	3308      	adds	r3, #8
    28aa:	446b      	add	r3, sp
    28ac:	f813 3c04 	ldrb.w	r3, [r3, #-4]
  for (uint8_t i = 0; i < SIZE_LISTENERS; i++) listener[i] = nullptr;
    28b0:	e9c0 2201 	strd	r2, r2, [r0, #4]
    28b4:	e9c0 2203 	strd	r2, r2, [r0, #12]
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    28b8:	2b00      	cmp	r3, #0
    28ba:	f000 8085 	beq.w	29c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x134>
    CCM_CCGR0 |= 0x3C0000;
    28be:	4945      	ldr	r1, [pc, #276]	; (29d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x140>)
    nvicIrq = IRQ_CAN2;
    28c0:	f505 5500 	add.w	r5, r5, #8192	; 0x2000
    28c4:	2025      	movs	r0, #37	; 0x25
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    28c6:	4b44      	ldr	r3, [pc, #272]	; (29d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x144>)
    28c8:	4a44      	ldr	r2, [pc, #272]	; (29dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x148>)
    busNumber = 2;
    28ca:	2402      	movs	r4, #2
    nvicIrq = IRQ_CAN2;
    28cc:	f8c5 090c 	str.w	r0, [r5, #2316]	; 0x90c
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    28d0:	2601      	movs	r6, #1
    _VectorsRam[16 + nvicIrq] = flexcan_isr_can2;
    28d2:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    28d6:	2010      	movs	r0, #16
    CCM_CCGR0 |= 0x3C0000;
    28d8:	6e8a      	ldr	r2, [r1, #104]	; 0x68
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    28da:	4b41      	ldr	r3, [pc, #260]	; (29e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x14c>)
    CCM_CCGR0 |= 0x3C0000;
    28dc:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
    28e0:	668a      	str	r2, [r1, #104]	; 0x68
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    28e2:	f241 01b0 	movw	r1, #4272	; 0x10b0
    busNumber = 2;
    28e6:	f885 4915 	strb.w	r4, [r5, #2325]	; 0x915
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    28ea:	4a3e      	ldr	r2, [pc, #248]	; (29e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    28ec:	4c3e      	ldr	r4, [pc, #248]	; (29e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x154>)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02 = 0x10; // pin 1 T4B1+B2
    28ee:	f8c3 00c4 	str.w	r0, [r3, #196]	; 0xc4
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02 = 0x10B0; // pin 1 T4B1+B2
    28f2:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
      IOMUXC_FLEXCAN2_RX_SELECT_INPUT = 0x01;
    28f6:	6526      	str	r6, [r4, #80]	; 0x50
      IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03 = 0x10; // pin 0 T4B1+B2
    28f8:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8
      IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03 = 0x10B0; // pin 0 T4B1+B2
    28fc:	f8c3 12b8 	str.w	r1, [r3, #696]	; 0x2b8
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_MDIS; /* enable module */
    2900:	6813      	ldr	r3, [r2, #0]
    2902:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    2906:	6013      	str	r3, [r2, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2908:	6813      	ldr	r3, [r2, #0]
    290a:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    290e:	6013      	str	r3, [r2, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2910:	6813      	ldr	r3, [r2, #0]
    2912:	01dc      	lsls	r4, r3, #7
    2914:	d5fc      	bpl.n	2910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x7c>
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    2916:	6853      	ldr	r3, [r2, #4]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2918:	4932      	ldr	r1, [pc, #200]	; (29e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_CTRL1(_bus) |= FLEXCAN_CTRL_LOM; /* listen only mode */
    291a:	f043 0308 	orr.w	r3, r3, #8
    291e:	6053      	str	r3, [r2, #4]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ; /* enable freeze bit */
    2920:	6813      	ldr	r3, [r2, #0]
    2922:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    2926:	6013      	str	r3, [r2, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_LPM_ACK);
    2928:	680b      	ldr	r3, [r1, #0]
    292a:	02d8      	lsls	r0, r3, #11
    292c:	d4fc      	bmi.n	2928 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x94>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    292e:	680b      	ldr	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2930:	4a2c      	ldr	r2, [pc, #176]	; (29e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SOFT_RST;
    2932:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    2936:	600b      	str	r3, [r1, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_SOFT_RST);
    2938:	6813      	ldr	r3, [r2, #0]
    293a:	0199      	lsls	r1, r3, #6
    293c:	d4fc      	bmi.n	2938 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xa4>
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    293e:	4c29      	ldr	r4, [pc, #164]	; (29e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
    2940:	6823      	ldr	r3, [r4, #0]
    2942:	01da      	lsls	r2, r3, #7
    2944:	d5fc      	bpl.n	2940 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0xac>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SRX_DIS; /* Disable self-reception */
    2946:	6823      	ldr	r3, [r4, #0]
    2948:	2000      	movs	r0, #0
    294a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    294e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_IRMQ; // individual mailbox masking
    2950:	6823      	ldr	r3, [r4, #0]
    2952:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    2956:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_AEN; // TX ABORT FEATURE
    2958:	6823      	ldr	r3, [r4, #0]
    295a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    295e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_LPRIO_EN; // TX PRIORITY FEATURE
    2960:	6823      	ldr	r3, [r4, #0]
    2962:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    2966:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_SLF_WAK; // SELF-WAKE UP FEATURE	
    2968:	6823      	ldr	r3, [r4, #0]
    296a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    296e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_SRC; // WAKE-UP LOW-PASS FILTER
    2970:	6823      	ldr	r3, [r4, #0]
    2972:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    2976:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) &= ~0x8800; // disable DMA and FD (valid bits are reserved in legacy controllers)
    2978:	6823      	ldr	r3, [r4, #0]
    297a:	f423 4308 	bic.w	r3, r3, #34816	; 0x8800
    297e:	6023      	str	r3, [r4, #0]
  FLEXCANb_CTRL2(_bus) |= FLEXCAN_CTRL2_RRS | // store remote frames
    2980:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2982:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    2986:	6363      	str	r3, [r4, #52]	; 0x34
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WRN_EN;
    2988:	6823      	ldr	r3, [r4, #0]
    298a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    298e:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_WAK_MSK;
    2990:	6823      	ldr	r3, [r4, #0]
    2992:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    2996:	6023      	str	r3, [r4, #0]
    2998:	f7fe fd68 	bl	146c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    299c:	6823      	ldr	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    299e:	4a11      	ldr	r2, [pc, #68]	; (29e4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x150>)
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    29a0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    29a4:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    29a6:	6813      	ldr	r3, [r2, #0]
    29a8:	01db      	lsls	r3, r3, #7
    29aa:	d4fc      	bmi.n	29a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x112>
  NVIC_ENABLE_IRQ(nvicIrq);
    29ac:	f8d5 290c 	ldr.w	r2, [r5, #2316]	; 0x90c
    29b0:	2101      	movs	r1, #1
    29b2:	4b0e      	ldr	r3, [pc, #56]	; (29ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x158>)
    29b4:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    29b8:	f002 021f 	and.w	r2, r2, #31
    29bc:	009b      	lsls	r3, r3, #2
    29be:	fa01 f202 	lsl.w	r2, r1, r2
    29c2:	601a      	str	r2, [r3, #0]
}
    29c4:	b002      	add	sp, #8
    29c6:	bd70      	pop	{r4, r5, r6, pc}
  if ( !getClock() ) setClock(CLK_24MHz); /* no clock enabled, enable osc clock */
    29c8:	2118      	movs	r1, #24
    29ca:	f7ff fee1 	bl	2790 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
    29ce:	e776      	b.n	28be <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()+0x2a>
    29d0:	0050183c 	.word	0x0050183c
    29d4:	400fc000 	.word	0x400fc000
    29d8:	20001c00 	.word	0x20001c00
    29dc:	00000f1d 	.word	0x00000f1d
    29e0:	401f8000 	.word	0x401f8000
    29e4:	401d4000 	.word	0x401d4000
    29e8:	401f8400 	.word	0x401f8400
    29ec:	38003840 	.word	0x38003840

000029f0 <canInit()>:
#include "openhaldex.h"
FlexCAN_T4<CAN1, RX_SIZE_256, TX_SIZE_16> HaldexCAN;
FlexCAN_T4<CAN2, RX_SIZE_256, TX_SIZE_16> ChassisCAN;

void canInit(void) {
    29f0:	b538      	push	{r3, r4, r5, lr}
  // setup Haldex CAN module (using FlexCAN T4)
  HaldexCAN.begin();
    29f2:	484a      	ldr	r0, [pc, #296]	; (2b1c <canInit()+0x12c>)
    29f4:	f7ff fe1e 	bl	2634 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    29f8:	4c49      	ldr	r4, [pc, #292]	; (2b20 <canInit()+0x130>)
  HaldexCAN.setClock(CLK_60MHz);
    29fa:	213c      	movs	r1, #60	; 0x3c
    29fc:	4847      	ldr	r0, [pc, #284]	; (2b1c <canInit()+0x12c>)
    29fe:	f7ff fd97 	bl	2530 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  HaldexCAN.setBaudRate(500000);
    2a02:	2200      	movs	r2, #0
    2a04:	4947      	ldr	r1, [pc, #284]	; (2b24 <canInit()+0x134>)
    2a06:	4845      	ldr	r0, [pc, #276]	; (2b1c <canInit()+0x12c>)
    2a08:	f7fe fa92 	bl	f30 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    2a0c:	6823      	ldr	r3, [r4, #0]
    2a0e:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    2a12:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2a14:	6823      	ldr	r3, [r4, #0]
    2a16:	01dd      	lsls	r5, r3, #7
    2a18:	d5fc      	bpl.n	2a14 <canInit()+0x24>
    2a1a:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    2a1c:	6825      	ldr	r5, [r4, #0]
    2a1e:	f7fe fc57 	bl	12d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    2a22:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2a24:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    2a26:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    2a28:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    2a2a:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    2a2c:	6823      	ldr	r3, [r4, #0]
    2a2e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    2a32:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    2a34:	6823      	ldr	r3, [r4, #0]
    2a36:	f043 030f 	orr.w	r3, r3, #15
    2a3a:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    2a3c:	d469      	bmi.n	2b12 <canInit()+0x122>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2a3e:	4c38      	ldr	r4, [pc, #224]	; (2b20 <canInit()+0x130>)
    2a40:	6823      	ldr	r3, [r4, #0]
    2a42:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2a46:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2a48:	6823      	ldr	r3, [r4, #0]
    2a4a:	01d9      	lsls	r1, r3, #7
    2a4c:	d4fc      	bmi.n	2a48 <canInit()+0x58>
  _mainHandler = handler;
    2a4e:	4b36      	ldr	r3, [pc, #216]	; (2b28 <canInit()+0x138>)
  HaldexCAN.setMaxMB(16);
  HaldexCAN.onReceive(onHaldexRX);
  HaldexCAN.enableFIFO();
    2a50:	2001      	movs	r0, #1
    2a52:	4a36      	ldr	r2, [pc, #216]	; (2b2c <canInit()+0x13c>)
    2a54:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    2a58:	f7fe fc3a 	bl	12d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    2a5c:	6823      	ldr	r3, [r4, #0]
    2a5e:	009a      	lsls	r2, r3, #2
    2a60:	d50a      	bpl.n	2a78 <canInit()+0x88>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    2a62:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a64:	069b      	lsls	r3, r3, #26
    2a66:	d407      	bmi.n	2a78 <canInit()+0x88>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    2a68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a6a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2a6e:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2a70:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a72:	f043 0320 	orr.w	r3, r3, #32
    2a76:	62a3      	str	r3, [r4, #40]	; 0x28
  HaldexCAN.enableFIFOInterrupt();
  HaldexCAN.mailboxStatus();
    2a78:	f7ff f990 	bl	1d9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>

  // setup Chassis CAN module (using FlexCAN T4)
  ChassisCAN.begin();
    2a7c:	482c      	ldr	r0, [pc, #176]	; (2b30 <canInit()+0x140>)
    2a7e:	f7ff ff09 	bl	2894 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::begin()>
  FLEXCANb_MCR(_bus) |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
    2a82:	4c2c      	ldr	r4, [pc, #176]	; (2b34 <canInit()+0x144>)
  ChassisCAN.setClock(CLK_60MHz);
    2a84:	213c      	movs	r1, #60	; 0x3c
    2a86:	482a      	ldr	r0, [pc, #168]	; (2b30 <canInit()+0x140>)
    2a88:	f7ff fe82 	bl	2790 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setClock(FLEXCAN_CLOCK)>
  ChassisCAN.setBaudRate(500000);
    2a8c:	2200      	movs	r2, #0
    2a8e:	4925      	ldr	r1, [pc, #148]	; (2b24 <canInit()+0x134>)
    2a90:	4827      	ldr	r0, [pc, #156]	; (2b30 <canInit()+0x140>)
    2a92:	f7fe fb0b 	bl	10ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::setBaudRate(unsigned long, FLEXCAN_RXTX)>
    2a96:	6823      	ldr	r3, [r4, #0]
    2a98:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    2a9c:	6023      	str	r3, [r4, #0]
  while (!(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK));
    2a9e:	6823      	ldr	r3, [r4, #0]
    2aa0:	01dd      	lsls	r5, r3, #7
    2aa2:	d5fc      	bpl.n	2a9e <canInit()+0xae>
    2aa4:	2000      	movs	r0, #0
  bool fifo_was_cleared = FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN;
    2aa6:	6825      	ldr	r5, [r4, #0]
    2aa8:	f7fe fce0 	bl	146c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    2aac:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2aae:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ( fifo_was_cleared ) enableFIFO();
    2ab0:	00a8      	lsls	r0, r5, #2
  FLEXCANb_IFLAG2(_bus) = value >> 32;
    2ab2:	62e2      	str	r2, [r4, #44]	; 0x2c
  FLEXCANb_IFLAG1(_bus) = value;
    2ab4:	6323      	str	r3, [r4, #48]	; 0x30
  FLEXCANb_MCR(_bus) &= ~0x7F; // clear current value
    2ab6:	6823      	ldr	r3, [r4, #0]
    2ab8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    2abc:	6023      	str	r3, [r4, #0]
  FLEXCANb_MCR(_bus) |= last; // set mailbox max
    2abe:	6823      	ldr	r3, [r4, #0]
    2ac0:	f043 030f 	orr.w	r3, r3, #15
    2ac4:	6023      	str	r3, [r4, #0]
  if ( fifo_was_cleared ) enableFIFO();
    2ac6:	d420      	bmi.n	2b0a <canInit()+0x11a>
  FLEXCANb_MCR(_bus) &= ~FLEXCAN_MCR_HALT;
    2ac8:	4c1a      	ldr	r4, [pc, #104]	; (2b34 <canInit()+0x144>)
    2aca:	6823      	ldr	r3, [r4, #0]
    2acc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    2ad0:	6023      	str	r3, [r4, #0]
  while (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FRZ_ACK);
    2ad2:	6823      	ldr	r3, [r4, #0]
    2ad4:	01d9      	lsls	r1, r3, #7
    2ad6:	d4fc      	bmi.n	2ad2 <canInit()+0xe2>
  _mainHandler = handler;
    2ad8:	4b17      	ldr	r3, [pc, #92]	; (2b38 <canInit()+0x148>)
  ChassisCAN.setMaxMB(16);
  ChassisCAN.onReceive(onBodyRX);
  ChassisCAN.enableFIFO();
    2ada:	2001      	movs	r0, #1
    2adc:	4a17      	ldr	r2, [pc, #92]	; (2b3c <canInit()+0x14c>)
    2ade:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
    2ae2:	f7fe fcc3 	bl	146c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) ) return; /* FIFO must be enabled first */
    2ae6:	6823      	ldr	r3, [r4, #0]
    2ae8:	009a      	lsls	r2, r3, #2
    2aea:	d50a      	bpl.n	2b02 <canInit()+0x112>
  if ( FLEXCANb_IMASK1(_bus) & FLEXCAN_IMASK1_BUF5M ) return; /* FIFO interrupts already enabled */
    2aec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2aee:	069b      	lsls	r3, r3, #26
    2af0:	d407      	bmi.n	2b02 <canInit()+0x112>
  FLEXCANb_IMASK1(_bus) &= ~0xFF; /* disable FIFO interrupt flags */
    2af2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2af4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2af8:	62a3      	str	r3, [r4, #40]	; 0x28
  if ( status ) FLEXCANb_IMASK1(_bus) |= FLEXCAN_IMASK1_BUF5M; /* enable FIFO interrupt */
    2afa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2afc:	f043 0320 	orr.w	r3, r3, #32
    2b00:	62a3      	str	r3, [r4, #40]	; 0x28
  ChassisCAN.enableFIFOInterrupt();
  ChassisCAN.mailboxStatus();
}
    2b02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ChassisCAN.mailboxStatus();
    2b06:	f7fe bd7f 	b.w	1608 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
  if ( fifo_was_cleared ) enableFIFO();
    2b0a:	2001      	movs	r0, #1
    2b0c:	f7fe fcae 	bl	146c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2b10:	e7da      	b.n	2ac8 <canInit()+0xd8>
    2b12:	2001      	movs	r0, #1
    2b14:	f7fe fbdc 	bl	12d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::enableFIFO(bool) [clone .isra.0]>
    2b18:	e791      	b.n	2a3e <canInit()+0x4e>
    2b1a:	bf00      	nop
    2b1c:	200079a0 	.word	0x200079a0
    2b20:	401d0000 	.word	0x401d0000
    2b24:	0007a120 	.word	0x0007a120
    2b28:	200099a0 	.word	0x200099a0
    2b2c:	0000375d 	.word	0x0000375d
    2b30:	20005088 	.word	0x20005088
    2b34:	401d4000 	.word	0x401d4000
    2b38:	20007088 	.word	0x20007088
    2b3c:	00003291 	.word	0x00003291

00002b40 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
}
#endif


FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
  if ( mb_num == FIFO ) {
    2b40:	780b      	ldrb	r3, [r1, #0]
    2b42:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2b44:	b510      	push	{r4, lr}
    2b46:	4604      	mov	r4, r0
    2b48:	b082      	sub	sp, #8
    2b4a:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2b4c:	d013      	beq.n	2b76 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    if ( _mainHandler ) _mainHandler(msg);
    return;
  }
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2b4e:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    2b52:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2b56:	685b      	ldr	r3, [r3, #4]
    2b58:	b113      	cbz	r3, 2b60 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2b5a:	9201      	str	r2, [sp, #4]
    2b5c:	4798      	blx	r3
    2b5e:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2b60:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2b64:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2b68:	b11b      	cbz	r3, 2b72 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2b6a:	b002      	add	sp, #8
    2b6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2b70:	4718      	bx	r3
}
    2b72:	b002      	add	sp, #8
    2b74:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    2b76:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2b7a:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    2b7e:	2b00      	cmp	r3, #0
    2b80:	d0f0      	beq.n	2b64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2b82:	9201      	str	r2, [sp, #4]
    2b84:	4798      	blx	r3
    2b86:	9801      	ldr	r0, [sp, #4]
    2b88:	e7ec      	b.n	2b64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2b8a:	bf00      	nop

00002b8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2b8c:	291f      	cmp	r1, #31
    2b8e:	481c      	ldr	r0, [pc, #112]	; (2c00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    2b90:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2b92:	d823      	bhi.n	2bdc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    2b94:	2301      	movs	r3, #1
    2b96:	6b04      	ldr	r4, [r0, #48]	; 0x30
    2b98:	408b      	lsls	r3, r1
    2b9a:	4323      	orrs	r3, r4
    2b9c:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2b9e:	4b19      	ldr	r3, [pc, #100]	; (2c04 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2ba0:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2ba4:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2ba6:	440b      	add	r3, r1
    2ba8:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2baa:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bac:	b1f8      	cbz	r0, 2bee <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    2bae:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bb0:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    2bb2:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bb4:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2bb8:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bbc:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2bbe:	68d0      	ldr	r0, [r2, #12]
}
    2bc0:	f85d 4b04 	ldr.w	r4, [sp], #4
    2bc4:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2bc6:	6098      	str	r0, [r3, #8]
    2bc8:	6910      	ldr	r0, [r2, #16]
    2bca:	ba00      	rev	r0, r0
    2bcc:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    2bce:	7ad2      	ldrb	r2, [r2, #11]
    2bd0:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2bd4:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2bd8:	601a      	str	r2, [r3, #0]
}
    2bda:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2bdc:	f1a1 0c20 	sub.w	ip, r1, #32
    2be0:	2301      	movs	r3, #1
    2be2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2be4:	fa03 f30c 	lsl.w	r3, r3, ip
    2be8:	4323      	orrs	r3, r4
    2bea:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2bec:	e7d7      	b.n	2b9e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bee:	6814      	ldr	r4, [r2, #0]
    2bf0:	4805      	ldr	r0, [pc, #20]	; (2c08 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    2bf2:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bf4:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2bf8:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2bfa:	6058      	str	r0, [r3, #4]
    2bfc:	e7df      	b.n	2bbe <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2bfe:	bf00      	nop
    2c00:	401d0000 	.word	0x401d0000
    2c04:	0401d008 	.word	0x0401d008
    2c08:	1ffc0000 	.word	0x1ffc0000

00002c0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2c0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2c10:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2c14:	b08f      	sub	sp, #60	; 0x3c
    2c16:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2c18:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2c1c:	b913      	cbnz	r3, 2c24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2c1e:	2301      	movs	r3, #1
    2c20:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        T readBytes(T *buffer, uint16_t length);
        void flush() { clear(); }
        void clear() { head = tail = _available = 0; }
        void print(const char *p);
        void println(const char *p);
        uint16_t size() { return _available; }
    2c24:	8b23      	ldrh	r3, [r4, #24]
    2c26:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2c28:	2b00      	cmp	r3, #0
    2c2a:	d157      	bne.n	2cdc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2c2c:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2c30:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2c34:	4b72      	ldr	r3, [pc, #456]	; (2e00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2c36:	f002 011f 	and.w	r1, r2, #31
    2c3a:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2c3e:	2201      	movs	r2, #1
    2c40:	009b      	lsls	r3, r3, #2
    2c42:	408a      	lsls	r2, r1
    2c44:	601a      	str	r2, [r3, #0]
    2c46:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2c4a:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2c4c:	b383      	cbz	r3, 2cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>


template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::peek_front(T *buffer, uint16_t length, uint32_t entry) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2c4e:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2c52:	221a      	movs	r2, #26
    2c54:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    2c56:	f10d 0c08 	add.w	ip, sp, #8
    2c5a:	f003 030f 	and.w	r3, r3, #15
    2c5e:	46ae      	mov	lr, r5
    2c60:	fb02 4303 	mla	r3, r2, r3, r4
    2c64:	f641 3232 	movw	r2, #6962	; 0x1b32
    2c68:	eb03 0802 	add.w	r8, r3, r2
    2c6c:	5898      	ldr	r0, [r3, r2]
    2c6e:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2c72:	f8d8 2008 	ldr.w	r2, [r8, #8]
    2c76:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2c7a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2c7c:	f8d8 0010 	ldr.w	r0, [r8, #16]
    2c80:	f8d8 1014 	ldr.w	r1, [r8, #20]
    2c84:	c503      	stmia	r5!, {r0, r1}
    2c86:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2c8a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2c8e:	e89e 0003 	ldmia.w	lr, {r0, r1}
    2c92:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    2c96:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    2c9a:	1c4b      	adds	r3, r1, #1
    2c9c:	d054      	beq.n	2d48 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2c9e:	4b59      	ldr	r3, [pc, #356]	; (2e04 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    2ca0:	440b      	add	r3, r1
    2ca2:	011b      	lsls	r3, r3, #4
    2ca4:	681b      	ldr	r3, [r3, #0]
    2ca6:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2caa:	2b08      	cmp	r3, #8
    2cac:	f000 808b 	beq.w	2dc6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    2cb0:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2cb4:	4b54      	ldr	r3, [pc, #336]	; (2e08 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2cb6:	f002 011f 	and.w	r1, r2, #31
    2cba:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2cbe:	2201      	movs	r2, #1
    2cc0:	009b      	lsls	r3, r3, #2
    2cc2:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2cc4:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2cc6:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2cc8:	8b23      	ldrh	r3, [r4, #24]
    2cca:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2cce:	b29b      	uxth	r3, r3
    2cd0:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2cd2:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2cd6:	b00f      	add	sp, #60	; 0x3c
    2cd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
}

template<typename T, uint16_t _size, uint16_t multi>
T Circular_Buffer<T,_size,multi>::readBytes(T *buffer, uint16_t length) {
  if ( multi ) {
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2cdc:	8aa6      	ldrh	r6, [r4, #20]
    2cde:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2ce0:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2ce4:	ad08      	add	r5, sp, #32
    2ce6:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2ce8:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2cec:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2cf0:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2cf4:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2cf8:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2cfc:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2d00:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2d04:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2d06:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2d0a:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2d0e:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2d12:	8b23      	ldrh	r3, [r4, #24]
    2d14:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2d16:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2d18:	b11b      	cbz	r3, 2d22 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2d1a:	8b23      	ldrh	r3, [r4, #24]
    2d1c:	3b01      	subs	r3, #1
    2d1e:	b29b      	uxth	r3, r3
    2d20:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2d22:	ad08      	add	r5, sp, #32
    2d24:	ae02      	add	r6, sp, #8
    2d26:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d28:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2d2a:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2d2e:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    2d30:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2d34:	f89d 301c 	ldrb.w	r3, [sp, #28]
    2d38:	f10d 0107 	add.w	r1, sp, #7
    2d3c:	4620      	mov	r0, r4
    2d3e:	f88d 3007 	strb.w	r3, [sp, #7]
    2d42:	f7ff fefd 	bl	2b40 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    2d46:	e771      	b.n	2c2c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    2d48:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2e0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2d4c:	f8d8 5000 	ldr.w	r5, [r8]
    2d50:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    2d54:	d050      	beq.n	2df8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    2d56:	f7fe fa73 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d5a:	f8d8 3000 	ldr.w	r3, [r8]
    2d5e:	4605      	mov	r5, r0
    2d60:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2d64:	3301      	adds	r3, #1
    2d66:	4283      	cmp	r3, r0
    2d68:	d9a2      	bls.n	2cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2d6a:	f8df 9098 	ldr.w	r9, [pc, #152]	; 2e04 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2d6e:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2e0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    2d72:	e008      	b.n	2d86 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    2d74:	f8d8 3000 	ldr.w	r3, [r8]
    2d78:	3501      	adds	r5, #1
    2d7a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2d7e:	b2ed      	uxtb	r5, r5
    2d80:	3301      	adds	r3, #1
    2d82:	429d      	cmp	r5, r3
    2d84:	d294      	bcs.n	2cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2d86:	eb05 0309 	add.w	r3, r5, r9
    2d8a:	011b      	lsls	r3, r3, #4
    2d8c:	681b      	ldr	r3, [r3, #0]
    2d8e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2d92:	2b08      	cmp	r3, #8
    2d94:	d1ee      	bne.n	2d74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    2d96:	aa02      	add	r2, sp, #8
    2d98:	4629      	mov	r1, r5
    2d9a:	4620      	mov	r0, r4
    2d9c:	f7ff fef6 	bl	2b8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2da0:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2da4:	3301      	adds	r3, #1
    2da6:	f003 031f 	and.w	r3, r3, #31
    2daa:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2dae:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2db2:	b29b      	uxth	r3, r3
    2db4:	2b00      	cmp	r3, #0
    2db6:	d0dd      	beq.n	2d74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    2db8:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2dbc:	3b01      	subs	r3, #1
    2dbe:	b29b      	uxth	r3, r3
    2dc0:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2dc4:	e7d6      	b.n	2d74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    2dc6:	aa02      	add	r2, sp, #8
    2dc8:	b2c9      	uxtb	r1, r1
    2dca:	4620      	mov	r0, r4
    2dcc:	f7ff fede 	bl	2b8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    2dd0:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2dd4:	3301      	adds	r3, #1
    2dd6:	f003 031f 	and.w	r3, r3, #31
    2dda:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    2dde:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2de2:	b29b      	uxth	r3, r3
    2de4:	2b00      	cmp	r3, #0
    2de6:	f43f af63 	beq.w	2cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    2dea:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2dee:	3b01      	subs	r3, #1
    2df0:	b29b      	uxth	r3, r3
    2df2:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    2df6:	e75b      	b.n	2cb0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    2df8:	f8d8 3000 	ldr.w	r3, [r8]
    2dfc:	e7b5      	b.n	2d6a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    2dfe:	bf00      	nop
    2e00:	38003860 	.word	0x38003860
    2e04:	0401d008 	.word	0x0401d008
    2e08:	38003840 	.word	0x38003840
    2e0c:	401d0000 	.word	0x401d0000

00002e10 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>:
  if ( mb_num == FIFO ) {
    2e10:	780b      	ldrb	r3, [r1, #0]
    2e12:	2b63      	cmp	r3, #99	; 0x63
FCTP_FUNC void FCTP_OPT::mbCallbacks(const FLEXCAN_MAILBOX &mb_num, const CAN_message_t &msg) {
    2e14:	b510      	push	{r4, lr}
    2e16:	4604      	mov	r4, r0
    2e18:	b082      	sub	sp, #8
    2e1a:	4610      	mov	r0, r2
  if ( mb_num == FIFO ) {
    2e1c:	d013      	beq.n	2e46 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x36>
  if ( _mbHandlers[mb_num] ) _mbHandlers[mb_num](msg);
    2e1e:	f503 631c 	add.w	r3, r3, #2496	; 0x9c0
    2e22:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    2e26:	685b      	ldr	r3, [r3, #4]
    2e28:	b113      	cbz	r3, 2e30 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x20>
    2e2a:	9201      	str	r2, [sp, #4]
    2e2c:	4798      	blx	r3
    2e2e:	9801      	ldr	r0, [sp, #4]
  if ( _mainHandler ) _mainHandler(msg);
    2e30:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2e34:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
    2e38:	b11b      	cbz	r3, 2e42 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x32>
}
    2e3a:	b002      	add	sp, #8
    2e3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if ( _mainHandler ) _mainHandler(msg);
    2e40:	4718      	bx	r3
}
    2e42:	b002      	add	sp, #8
    2e44:	bd10      	pop	{r4, pc}
    if ( _mbHandlers[0] ) _mbHandlers[0](msg);
    2e46:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    2e4a:	f8d4 3704 	ldr.w	r3, [r4, #1796]	; 0x704
    2e4e:	2b00      	cmp	r3, #0
    2e50:	d0f0      	beq.n	2e34 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2e52:	9201      	str	r2, [sp, #4]
    2e54:	4798      	blx	r3
    2e56:	9801      	ldr	r0, [sp, #4]
    2e58:	e7ec      	b.n	2e34 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)+0x24>
    2e5a:	bf00      	nop

00002e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>:
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2e5c:	291f      	cmp	r1, #31
    2e5e:	481c      	ldr	r0, [pc, #112]	; (2ed0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x74>)
FCTP_FUNC void FCTP_OPT::writeTxMailbox(uint8_t mb_num, const CAN_message_t &msg) {
    2e60:	b410      	push	{r4}
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    2e62:	d823      	bhi.n	2eac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x50>
    2e64:	2301      	movs	r3, #1
    2e66:	6b04      	ldr	r4, [r0, #48]	; 0x30
    2e68:	408b      	lsls	r3, r1
    2e6a:	4323      	orrs	r3, r4
    2e6c:	6303      	str	r3, [r0, #48]	; 0x30
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2e6e:	4b19      	ldr	r3, [pc, #100]	; (2ed4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x78>)
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2e70:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e74:	79d0      	ldrb	r0, [r2, #7]
  volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    2e76:	440b      	add	r3, r1
    2e78:	011b      	lsls	r3, r3, #4
  mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
    2e7a:	601c      	str	r4, [r3, #0]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e7c:	b1f8      	cbz	r0, 2ebe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x62>
  if ( msg.flags.remote ) code |= (1UL << 20);
    2e7e:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e80:	6810      	ldr	r0, [r2, #0]
  if ( msg.flags.remote ) code |= (1UL << 20);
    2e82:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e84:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
  if ( msg.flags.extended ) code |= (3UL << 21);
    2e88:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2e8c:	6058      	str	r0, [r3, #4]
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2e8e:	68d0      	ldr	r0, [r2, #12]
}
    2e90:	f85d 4b04 	ldr.w	r4, [sp], #4
    2e94:	ba00      	rev	r0, r0
  for ( uint8_t i = 0; i < (8 >> 2); i++ ) mbxAddr[2 + i] = (msg.buf[0 + i * 4] << 24) | (msg.buf[1 + i * 4] << 16) | (msg.buf[2 + i * 4] << 8) | msg.buf[3 + i * 4];
    2e96:	6098      	str	r0, [r3, #8]
    2e98:	6910      	ldr	r0, [r2, #16]
    2e9a:	ba00      	rev	r0, r0
    2e9c:	60d8      	str	r0, [r3, #12]
  code |= msg.len << 16;
    2e9e:	7ad2      	ldrb	r2, [r2, #11]
    2ea0:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  mbxAddr[0] = code | FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE);
    2ea4:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
    2ea8:	601a      	str	r2, [r3, #0]
}
    2eaa:	4770      	bx	lr
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    2eac:	f1a1 0c20 	sub.w	ip, r1, #32
    2eb0:	2301      	movs	r3, #1
    2eb2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2eb4:	fa03 f30c 	lsl.w	r3, r3, ip
    2eb8:	4323      	orrs	r3, r4
    2eba:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    2ebc:	e7d7      	b.n	2e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x12>
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2ebe:	6814      	ldr	r4, [r2, #0]
    2ec0:	4805      	ldr	r0, [pc, #20]	; (2ed8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x7c>)
  if ( msg.flags.remote ) code |= (1UL << 20);
    2ec2:	7a11      	ldrb	r1, [r2, #8]
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2ec4:	ea00 4084 	and.w	r0, r0, r4, lsl #18
  if ( msg.flags.remote ) code |= (1UL << 20);
    2ec8:	0509      	lsls	r1, r1, #20
  mbxAddr[1] = (( msg.flags.extended ) ? ( msg.id & FLEXCAN_MB_ID_EXT_MASK ) : FLEXCAN_MB_ID_IDSTD(msg.id));
    2eca:	6058      	str	r0, [r3, #4]
    2ecc:	e7df      	b.n	2e8e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)+0x32>
    2ece:	bf00      	nop
    2ed0:	401d4000 	.word	0x401d4000
    2ed4:	0401d408 	.word	0x0401d408
    2ed8:	1ffc0000 	.word	0x1ffc0000

00002edc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()>:
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2edc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if ( !isEventsUsed ) isEventsUsed = 1;
    2ee0:	f500 5700 	add.w	r7, r0, #8192	; 0x2000
FCTP_FUNC uint64_t FCTP_OPT::events() {
    2ee4:	b08f      	sub	sp, #60	; 0x3c
    2ee6:	4604      	mov	r4, r0
  if ( !isEventsUsed ) isEventsUsed = 1;
    2ee8:	f897 3700 	ldrb.w	r3, [r7, #1792]	; 0x700
    2eec:	b913      	cbnz	r3, 2ef4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x18>
    2eee:	2301      	movs	r3, #1
    2ef0:	f887 3700 	strb.w	r3, [r7, #1792]	; 0x700
        uint16_t size() { return _available; }
    2ef4:	8b23      	ldrh	r3, [r4, #24]
    2ef6:	b29b      	uxth	r3, r3
  if ( rxBuffer.size() ) {
    2ef8:	2b00      	cmp	r3, #0
    2efa:	d157      	bne.n	2fac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xd0>
  NVIC_DISABLE_IRQ(nvicIrq);
    2efc:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2f00:	f504 5680 	add.w	r6, r4, #4096	; 0x1000
    2f04:	4b72      	ldr	r3, [pc, #456]	; (30d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f4>)
    2f06:	f002 011f 	and.w	r1, r2, #31
    2f0a:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2f0e:	2201      	movs	r2, #1
    2f10:	009b      	lsls	r3, r3, #2
    2f12:	408a      	lsls	r2, r1
    2f14:	601a      	str	r2, [r3, #0]
    2f16:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    2f1a:	b29b      	uxth	r3, r3
  if ( txBuffer.size() ) {
    2f1c:	b383      	cbz	r3, 2f80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2f1e:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    2f22:	221a      	movs	r2, #26
    2f24:	ad08      	add	r5, sp, #32
    memmove(&frame, buf, sizeof(frame));
    2f26:	f10d 0c08 	add.w	ip, sp, #8
    2f2a:	f003 030f 	and.w	r3, r3, #15
    2f2e:	46ae      	mov	lr, r5
    2f30:	fb02 4303 	mla	r3, r2, r3, r4
    2f34:	f641 3232 	movw	r2, #6962	; 0x1b32
    2f38:	eb03 0802 	add.w	r8, r3, r2
    2f3c:	5898      	ldr	r0, [r3, r2]
    2f3e:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2f42:	f8d8 2008 	ldr.w	r2, [r8, #8]
    2f46:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2f4a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2f4c:	f8d8 0010 	ldr.w	r0, [r8, #16]
    2f50:	f8d8 1014 	ldr.w	r1, [r8, #20]
    2f54:	c503      	stmia	r5!, {r0, r1}
    2f56:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    2f5a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2f5e:	e89e 0003 	ldmia.w	lr, {r0, r1}
    2f62:	e88c 0003 	stmia.w	ip, {r0, r1}
    if ( frame.mb == -1 ) {
    2f66:	f99d 101c 	ldrsb.w	r1, [sp, #28]
    2f6a:	1c4b      	adds	r3, r1, #1
    2f6c:	d054      	beq.n	3018 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x13c>
    else if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, frame.mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    2f6e:	4b59      	ldr	r3, [pc, #356]	; (30d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>)
    2f70:	440b      	add	r3, r1
    2f72:	011b      	lsls	r3, r3, #4
    2f74:	681b      	ldr	r3, [r3, #0]
    2f76:	f3c3 6303 	ubfx	r3, r3, #24, #4
    2f7a:	2b08      	cmp	r3, #8
    2f7c:	f000 808b 	beq.w	3096 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ba>
  NVIC_ENABLE_IRQ(nvicIrq);
    2f80:	f8d7 290c 	ldr.w	r2, [r7, #2316]	; 0x90c
    2f84:	4b54      	ldr	r3, [pc, #336]	; (30d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1fc>)
    2f86:	f002 011f 	and.w	r1, r2, #31
    2f8a:	eb03 1352 	add.w	r3, r3, r2, lsr #5
    2f8e:	2201      	movs	r2, #1
    2f90:	009b      	lsls	r3, r3, #2
    2f92:	408a      	lsls	r2, r1
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2f94:	2100      	movs	r1, #0
  NVIC_ENABLE_IRQ(nvicIrq);
    2f96:	601a      	str	r2, [r3, #0]
        uint16_t size() { return _available; }
    2f98:	8b23      	ldrh	r3, [r4, #24]
    2f9a:	f8b6 0b1e 	ldrh.w	r0, [r6, #2846]	; 0xb1e
    2f9e:	b29b      	uxth	r3, r3
    2fa0:	b280      	uxth	r0, r0
  return (uint64_t)(rxBuffer.size() << 12) | txBuffer.size();
    2fa2:	ea40 3003 	orr.w	r0, r0, r3, lsl #12
}
    2fa6:	b00f      	add	sp, #60	; 0x3c
    2fa8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2fac:	8aa6      	ldrh	r6, [r4, #20]
    2fae:	231a      	movs	r3, #26
    head = ((head + 1)&(2*_size-1));
    2fb0:	f8b4 c014 	ldrh.w	ip, [r4, #20]
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2fb4:	ad08      	add	r5, sp, #32
    2fb6:	b2f6      	uxtb	r6, r6
    head = ((head + 1)&(2*_size-1));
    2fb8:	f10c 0c01 	add.w	ip, ip, #1
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2fbc:	fb03 4606 	mla	r6, r3, r6, r4
    head = ((head + 1)&(2*_size-1));
    2fc0:	f3cc 0c08 	ubfx	ip, ip, #0, #9
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2fc4:	f8d6 011c 	ldr.w	r0, [r6, #284]	; 0x11c
    2fc8:	f8d6 1120 	ldr.w	r1, [r6, #288]	; 0x120
    2fcc:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
    2fd0:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    2fd4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    2fd6:	f8d6 012c 	ldr.w	r0, [r6, #300]	; 0x12c
    2fda:	f8d6 1130 	ldr.w	r1, [r6, #304]	; 0x130
    head = ((head + 1)&(2*_size-1));
    2fde:	f8a4 c014 	strh.w	ip, [r4, #20]
    if ( _available ) _available--;
    2fe2:	8b23      	ldrh	r3, [r4, #24]
    2fe4:	b29b      	uxth	r3, r3
    memmove(&buffer[0],&_cabuf[((head)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    2fe6:	c503      	stmia	r5!, {r0, r1}
    if ( _available ) _available--;
    2fe8:	b11b      	cbz	r3, 2ff2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x116>
    2fea:	8b23      	ldrh	r3, [r4, #24]
    2fec:	3b01      	subs	r3, #1
    2fee:	b29b      	uxth	r3, r3
    2ff0:	8323      	strh	r3, [r4, #24]
    memmove(&frame, buf, sizeof(frame));
    2ff2:	ad08      	add	r5, sp, #32
    2ff4:	ae02      	add	r6, sp, #8
    2ff6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2ff8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    2ffa:	e895 0003 	ldmia.w	r5, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    2ffe:	aa02      	add	r2, sp, #8
    memmove(&frame, buf, sizeof(frame));
    3000:	e886 0003 	stmia.w	r6, {r0, r1}
    mbCallbacks((FLEXCAN_MAILBOX)frame.mb, frame);
    3004:	f89d 301c 	ldrb.w	r3, [sp, #28]
    3008:	f10d 0107 	add.w	r1, sp, #7
    300c:	4620      	mov	r0, r4
    300e:	f88d 3007 	strb.w	r3, [sp, #7]
    3012:	f7ff fefd 	bl	2e10 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
    3016:	e771      	b.n	2efc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x20>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3018:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 30dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    301c:	f8d8 5000 	ldr.w	r5, [r8]
    3020:	f015 5500 	ands.w	r5, r5, #536870912	; 0x20000000
    3024:	d050      	beq.n	30c8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1ec>
    3026:	f7fe f92f 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    302a:	f8d8 3000 	ldr.w	r3, [r8]
    302e:	4605      	mov	r5, r0
    3030:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3034:	3301      	adds	r3, #1
    3036:	4283      	cmp	r3, r0
    3038:	d9a2      	bls.n	2f80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    303a:	f8df 9098 	ldr.w	r9, [pc, #152]	; 30d4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x1f8>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    303e:	f8df 809c 	ldr.w	r8, [pc, #156]	; 30dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x200>
    3042:	e008      	b.n	3056 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x17a>
    3044:	f8d8 3000 	ldr.w	r3, [r8]
    3048:	3501      	adds	r5, #1
    304a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    304e:	b2ed      	uxtb	r5, r5
    3050:	3301      	adds	r3, #1
    3052:	429d      	cmp	r5, r3
    3054:	d294      	bcs.n	2f80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
        if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3056:	eb05 0309 	add.w	r3, r5, r9
    305a:	011b      	lsls	r3, r3, #4
    305c:	681b      	ldr	r3, [r3, #0]
    305e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3062:	2b08      	cmp	r3, #8
    3064:	d1ee      	bne.n	3044 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
          writeTxMailbox(i, frame);
    3066:	aa02      	add	r2, sp, #8
    3068:	4629      	mov	r1, r5
    306a:	4620      	mov	r0, r4
    306c:	f7ff fef6 	bl	2e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    3070:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    3074:	3301      	adds	r3, #1
    3076:	f003 031f 	and.w	r3, r3, #31
    307a:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    307e:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    3082:	b29b      	uxth	r3, r3
    3084:	2b00      	cmp	r3, #0
    3086:	d0dd      	beq.n	3044 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
    3088:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    308c:	3b01      	subs	r3, #1
    308e:	b29b      	uxth	r3, r3
    3090:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    3094:	e7d6      	b.n	3044 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x168>
      writeTxMailbox(frame.mb, frame);
    3096:	aa02      	add	r2, sp, #8
    3098:	b2c9      	uxtb	r1, r1
    309a:	4620      	mov	r0, r4
    309c:	f7ff fede 	bl	2e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    30a0:	f8b6 3b1a 	ldrh.w	r3, [r6, #2842]	; 0xb1a
    30a4:	3301      	adds	r3, #1
    30a6:	f003 031f 	and.w	r3, r3, #31
    30aa:	f8a6 3b1a 	strh.w	r3, [r6, #2842]	; 0xb1a
    if ( _available ) _available--;
    30ae:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    30b2:	b29b      	uxth	r3, r3
    30b4:	2b00      	cmp	r3, #0
    30b6:	f43f af63 	beq.w	2f80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
    30ba:	f8b6 3b1e 	ldrh.w	r3, [r6, #2846]	; 0xb1e
    30be:	3b01      	subs	r3, #1
    30c0:	b29b      	uxth	r3, r3
    30c2:	f8a6 3b1e 	strh.w	r3, [r6, #2846]	; 0xb1e
    30c6:	e75b      	b.n	2f80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0xa4>
      for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    30c8:	f8d8 3000 	ldr.w	r3, [r8]
    30cc:	e7b5      	b.n	303a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::events()+0x15e>
    30ce:	bf00      	nop
    30d0:	38003860 	.word	0x38003860
    30d4:	0401d408 	.word	0x0401d408
    30d8:	38003840 	.word	0x38003840
    30dc:	401d4000 	.word	0x401d4000

000030e0 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    30e0:	8843      	ldrh	r3, [r0, #2]
    30e2:	f04f 0c1a 	mov.w	ip, #26
    30e6:	f003 030f 	and.w	r3, r3, #15
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    30ea:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    30ec:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    30f0:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    30f2:	2000      	movs	r0, #0
    30f4:	7598      	strb	r0, [r3, #22]
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    30f6:	8863      	ldrh	r3, [r4, #2]
    30f8:	f003 030f 	and.w	r3, r3, #15
    30fc:	fb0c 4303 	mla	r3, ip, r3, r4
    3100:	75da      	strb	r2, [r3, #23]
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    3102:	8860      	ldrh	r0, [r4, #2]
    3104:	f000 000f 	and.w	r0, r0, #15
    3108:	fb0c 4000 	mla	r0, ip, r0, r4
    310c:	3018      	adds	r0, #24
    310e:	f005 fc2d 	bl	896c <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3112:	8862      	ldrh	r2, [r4, #2]
    3114:	8823      	ldrh	r3, [r4, #0]
    3116:	b292      	uxth	r2, r2
    3118:	b29b      	uxth	r3, r3
    311a:	f083 0310 	eor.w	r3, r3, #16
    311e:	429a      	cmp	r2, r3
    3120:	d104      	bne.n	312c <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    3122:	8823      	ldrh	r3, [r4, #0]
    3124:	3301      	adds	r3, #1
    3126:	f003 031f 	and.w	r3, r3, #31
    312a:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    312c:	8863      	ldrh	r3, [r4, #2]
    312e:	3301      	adds	r3, #1
    3130:	f003 031f 	and.w	r3, r3, #31
    3134:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    3136:	88a3      	ldrh	r3, [r4, #4]
    3138:	b29b      	uxth	r3, r3
    313a:	2b0f      	cmp	r3, #15
    313c:	d803      	bhi.n	3146 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    313e:	88a3      	ldrh	r3, [r4, #4]
    3140:	3301      	adds	r3, #1
    3142:	b29b      	uxth	r3, r3
    3144:	80a3      	strh	r3, [r4, #4]
}
    3146:	bd10      	pop	{r4, pc}

00003148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    3148:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    314a:	b5f0      	push	{r4, r5, r6, r7, lr}
    314c:	460d      	mov	r5, r1
    314e:	b08d      	sub	sp, #52	; 0x34
    3150:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3152:	4e4b      	ldr	r6, [pc, #300]	; (3280 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    3154:	2b00      	cmp	r3, #0
    3156:	d14c      	bne.n	31f2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3158:	6833      	ldr	r3, [r6, #0]
    315a:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    315e:	d025      	beq.n	31ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    3160:	f7fe f86e 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3164:	6833      	ldr	r3, [r6, #0]
    3166:	4684      	mov	ip, r0
    3168:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    316c:	3301      	adds	r3, #1
    316e:	4298      	cmp	r0, r3
    3170:	d21e      	bcs.n	31b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3172:	4944      	ldr	r1, [pc, #272]	; (3284 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3174:	4842      	ldr	r0, [pc, #264]	; (3280 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    3176:	e007      	b.n	3188 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    3178:	6803      	ldr	r3, [r0, #0]
    317a:	fa5f fc82 	uxtb.w	ip, r2
    317e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3182:	3301      	adds	r3, #1
    3184:	459c      	cmp	ip, r3
    3186:	d213      	bcs.n	31b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3188:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    318c:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3190:	011b      	lsls	r3, r3, #4
    3192:	681b      	ldr	r3, [r3, #0]
    3194:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3198:	2b08      	cmp	r3, #8
    319a:	d1ed      	bne.n	3178 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    319c:	4620      	mov	r0, r4
    319e:	462a      	mov	r2, r5
    31a0:	4661      	mov	r1, ip
    31a2:	f7ff fcf3 	bl	2b8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    31a6:	2001      	movs	r0, #1
}
    31a8:	b00d      	add	sp, #52	; 0x34
    31aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31ac:	6833      	ldr	r3, [r6, #0]
    31ae:	e7e0      	b.n	3172 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    31b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    31b2:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    31b4:	27ff      	movs	r7, #255	; 0xff
    31b6:	466e      	mov	r6, sp
    31b8:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    31bc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    31c0:	e895 0003 	ldmia.w	r5, {r0, r1}
    31c4:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    31c8:	f88d 7014 	strb.w	r7, [sp, #20]
    31cc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    31ce:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    31d2:	e89c 0003 	ldmia.w	ip, {r0, r1}
    31d6:	e88e 0003 	stmia.w	lr, {r0, r1}
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    31da:	2218      	movs	r2, #24
    31dc:	f641 301a 	movw	r0, #6938	; 0x1b1a
    31e0:	eb0d 0102 	add.w	r1, sp, r2
    31e4:	4420      	add	r0, r4
    31e6:	f7ff ff7b 	bl	30e0 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    31ea:	f04f 30ff 	mov.w	r0, #4294967295
}
    31ee:	b00d      	add	sp, #52	; 0x34
    31f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    31f2:	6830      	ldr	r0, [r6, #0]
    31f4:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    31f8:	d040      	beq.n	327c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    31fa:	f7fe f821 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    31fe:	6833      	ldr	r3, [r6, #0]
    3200:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3204:	3301      	adds	r3, #1
    3206:	4283      	cmp	r3, r0
    3208:	d927      	bls.n	325a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    320a:	491e      	ldr	r1, [pc, #120]	; (3284 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    320c:	4e1c      	ldr	r6, [pc, #112]	; (3280 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    320e:	e005      	b.n	321c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    3210:	6833      	ldr	r3, [r6, #0]
    3212:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3216:	3301      	adds	r3, #1
    3218:	4298      	cmp	r0, r3
    321a:	d21e      	bcs.n	325a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    321c:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    321e:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    3220:	4684      	mov	ip, r0
    3222:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3224:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    3226:	681a      	ldr	r2, [r3, #0]
    3228:	0112      	lsls	r2, r2, #4
    322a:	d5f1      	bpl.n	3210 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    322c:	681b      	ldr	r3, [r3, #0]
    322e:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3232:	2b08      	cmp	r3, #8
    3234:	d019      	beq.n	326a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    3236:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    3238:	466f      	mov	r7, sp
    323a:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    323e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3240:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    3242:	e895 0003 	ldmia.w	r5, {r0, r1}
    3246:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    324a:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    324e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3250:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3254:	e896 0003 	ldmia.w	r6, {r0, r1}
    3258:	e7bd      	b.n	31d6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    325a:	4b0b      	ldr	r3, [pc, #44]	; (3288 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    325c:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3260:	681b      	ldr	r3, [r3, #0]
    3262:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3266:	2b08      	cmp	r3, #8
    3268:	d1e5      	bne.n	3236 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    326a:	4620      	mov	r0, r4
    326c:	462a      	mov	r2, r5
    326e:	fa5f f18c 	uxtb.w	r1, ip
    3272:	f7ff fc8b 	bl	2b8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    3276:	2001      	movs	r0, #1
}
    3278:	b00d      	add	sp, #52	; 0x34
    327a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    327c:	6833      	ldr	r3, [r6, #0]
    327e:	e7c4      	b.n	320a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    3280:	401d0000 	.word	0x401d0000
    3284:	0401d008 	.word	0x0401d008
    3288:	401d0070 	.word	0x401d0070
    328c:	00000000 	.word	0x00000000

00003290 <onBodyRX(CAN_message_t const&)>:
    ChassisCAN.mailboxStatus();
  }
#endif
}

void onBodyRX(const CAN_message_t &frame) {
    3290:	b5f0      	push	{r4, r5, r6, r7, lr}
  CAN_message_t frame_out;
    3292:	4c3d      	ldr	r4, [pc, #244]	; (3388 <onBodyRX(CAN_message_t const&)+0xf8>)
void onBodyRX(const CAN_message_t &frame) {
    3294:	b087      	sub	sp, #28
  frame_out.id = frame.id;
  frame_out.flags = frame.flags;
  frame_out.len = frame.len;
    3296:	7ac7      	ldrb	r7, [r0, #11]
void onBodyRX(const CAN_message_t &frame) {
    3298:	4605      	mov	r5, r0
  frame_out.id = frame.id;
    329a:	6806      	ldr	r6, [r0, #0]
  CAN_message_t frame_out;
    329c:	46ec      	mov	ip, sp
  frame_out.flags = frame.flags;
    329e:	f8d0 e007 	ldr.w	lr, [r0, #7]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    32a2:	2f08      	cmp	r7, #8
  CAN_message_t frame_out;
    32a4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    32a6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    32aa:	e894 0003 	ldmia.w	r4, {r0, r1}
  frame_out.flags = frame.flags;
    32ae:	f8cd e007 	str.w	lr, [sp, #7]
  frame_out.id = frame.id;
    32b2:	9600      	str	r6, [sp, #0]
  frame_out.len = frame.len;
    32b4:	f88d 700b 	strb.w	r7, [sp, #11]
  CAN_message_t frame_out;
    32b8:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    32bc:	d958      	bls.n	3370 <onBodyRX(CAN_message_t const&)+0xe0>

  // Anything which has come from the car.. i.e. everything except Haldex
  /*  check to see if the frames come in one at a time or all at once.  Is there a possiblity that it's reading 'motor1_id' once, and by the time it's got through the other 
      frames another 'motor1_id' frame has got to the Haldex.  For loop to go through all of the frames at once?
  */
  switch (frame.id) {
    32be:	f5b6 7f20 	cmp.w	r6, #640	; 0x280
    32c2:	d03c      	beq.n	333e <onBodyRX(CAN_message_t const&)+0xae>
    32c4:	f5b6 7f22 	cmp.w	r6, #648	; 0x288
    32c8:	d10d      	bne.n	32e6 <onBodyRX(CAN_message_t const&)+0x56>
    case MOTOR1_ID:
      pedValue = frame.buf[5] * 0.4;
      break;
    case MOTOR2_ID:
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    32ca:	f44f 5248 	mov.w	r2, #12800	; 0x3200
    32ce:	7beb      	ldrb	r3, [r5, #15]
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    32d0:	492e      	ldr	r1, [pc, #184]	; (338c <onBodyRX(CAN_message_t const&)+0xfc>)
      int calc_speed = (frame.buf[3] * 100 * 128) / 10000;
    32d2:	fb02 f303 	mul.w	r3, r2, r3
    32d6:	4a2e      	ldr	r2, [pc, #184]	; (3390 <onBodyRX(CAN_message_t const&)+0x100>)
    32d8:	fba2 2303 	umull	r2, r3, r2, r3
    32dc:	0b5b      	lsrs	r3, r3, #13
      vehicleSpeed = (byte)(calc_speed >= 255 ? 255 : calc_speed);
    32de:	2bff      	cmp	r3, #255	; 0xff
    32e0:	bfa8      	it	ge
    32e2:	23ff      	movge	r3, #255	; 0xff
    32e4:	700b      	strb	r3, [r1, #0]
      break;
  }

  if (state.mode == MODE_STOCK) {
    32e6:	4c2b      	ldr	r4, [pc, #172]	; (3394 <onBodyRX(CAN_message_t const&)+0x104>)
    32e8:	7823      	ldrb	r3, [r4, #0]
    32ea:	2b00      	cmp	r3, #0
    32ec:	d039      	beq.n	3362 <onBodyRX(CAN_message_t const&)+0xd2>
    memcpy(frame_out.buf, frame.buf, frame.len);
  }

  if (state.mode == MODE_FWD) {
    32ee:	2b01      	cmp	r3, #1
    32f0:	d01d      	beq.n	332e <onBodyRX(CAN_message_t const&)+0x9e>
    // If FWD mode then literally zero out everything going from chassis to haldex
    //sendEmptyFrame();
    getLockData(&frame_out);
  }

  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    32f2:	3b02      	subs	r3, #2
    32f4:	2b01      	cmp	r3, #1
    32f6:	d906      	bls.n	3306 <onBodyRX(CAN_message_t const&)+0x76>

  // state.mode == MODE_STOCK
  // pass every message to the Haldex?

#if !canTestData
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    32f8:	4669      	mov	r1, sp
    32fa:	4827      	ldr	r0, [pc, #156]	; (3398 <onBodyRX(CAN_message_t const&)+0x108>)
    32fc:	f7ff ff24 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3300:	b150      	cbz	r0, 3318 <onBodyRX(CAN_message_t const&)+0x88>
    Serial.println(F("Haldex CAN TX Fail!"));  // if writing is unsuccessful, there is something wrong with the Haldex(!) Possibly flash red LED?
    HaldexCAN.mailboxStatus();                 // print the mailbox status if there's a failure
  }
#endif
}
    3302:	b007      	add	sp, #28
    3304:	bdf0      	pop	{r4, r5, r6, r7, pc}
    getLockData(&frame_out);
    3306:	4668      	mov	r0, sp
    3308:	f7fd fcec 	bl	ce4 <getLockData(CAN_message_t*)>
  if (!HaldexCAN.write(frame_out)) {           // write CAN frame from the body to the Haldex
    330c:	4669      	mov	r1, sp
    330e:	4822      	ldr	r0, [pc, #136]	; (3398 <onBodyRX(CAN_message_t const&)+0x108>)
    3310:	f7ff ff1a 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    3314:	2800      	cmp	r0, #0
    3316:	d1f4      	bne.n	3302 <onBodyRX(CAN_message_t const&)+0x72>
    3318:	2113      	movs	r1, #19
    331a:	4820      	ldr	r0, [pc, #128]	; (339c <onBodyRX(CAN_message_t const&)+0x10c>)
    331c:	f004 fbf2 	bl	7b04 <usb_serial_write>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    3320:	481f      	ldr	r0, [pc, #124]	; (33a0 <onBodyRX(CAN_message_t const&)+0x110>)
    3322:	f002 fb61 	bl	59e8 <Print::println()>
    HaldexCAN.mailboxStatus();                 // print the mailbox status if there's a failure
    3326:	f7fe fd39 	bl	1d9c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    332a:	b007      	add	sp, #28
    332c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    getLockData(&frame_out);
    332e:	4668      	mov	r0, sp
    3330:	f7fd fcd8 	bl	ce4 <getLockData(CAN_message_t*)>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    3334:	7823      	ldrb	r3, [r4, #0]
    3336:	3b02      	subs	r3, #2
    3338:	2b01      	cmp	r3, #1
    333a:	d8dd      	bhi.n	32f8 <onBodyRX(CAN_message_t const&)+0x68>
    333c:	e7e3      	b.n	3306 <onBodyRX(CAN_message_t const&)+0x76>
      pedValue = frame.buf[5] * 0.4;
    333e:	7c6b      	ldrb	r3, [r5, #17]
  if (state.mode == MODE_STOCK) {
    3340:	4c14      	ldr	r4, [pc, #80]	; (3394 <onBodyRX(CAN_message_t const&)+0x104>)
      pedValue = frame.buf[5] * 0.4;
    3342:	ee07 3a10 	vmov	s14, r3
    3346:	4b17      	ldr	r3, [pc, #92]	; (33a4 <onBodyRX(CAN_message_t const&)+0x114>)
    3348:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 3380 <onBodyRX(CAN_message_t const&)+0xf0>
    334c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    3350:	ee27 7b06 	vmul.f64	d7, d7, d6
    3354:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    3358:	ed83 7a00 	vstr	s14, [r3]
  if (state.mode == MODE_STOCK) {
    335c:	7823      	ldrb	r3, [r4, #0]
    335e:	2b00      	cmp	r3, #0
    3360:	d1c5      	bne.n	32ee <onBodyRX(CAN_message_t const&)+0x5e>
    memcpy(frame_out.buf, frame.buf, frame.len);
    3362:	463a      	mov	r2, r7
    3364:	f105 010c 	add.w	r1, r5, #12
    3368:	a803      	add	r0, sp, #12
    336a:	f003 f883 	bl	6474 <memcpy>
  if (state.mode == MODE_5050 || state.mode == MODE_CUSTOM) {
    336e:	e7c3      	b.n	32f8 <onBodyRX(CAN_message_t const&)+0x68>
    memcpy(frame_out.buf, frame.buf, frame.len);
    3370:	463a      	mov	r2, r7
    3372:	f105 010c 	add.w	r1, r5, #12
    3376:	a803      	add	r0, sp, #12
    3378:	f003 f87c 	bl	6474 <memcpy>
    337c:	e79f      	b.n	32be <onBodyRX(CAN_message_t const&)+0x2e>
    337e:	bf00      	nop
    3380:	9999999a 	.word	0x9999999a
    3384:	3fd99999 	.word	0x3fd99999
    3388:	200003b0 	.word	0x200003b0
    338c:	2000a720 	.word	0x2000a720
    3390:	d1b71759 	.word	0xd1b71759
    3394:	2000a580 	.word	0x2000a580
    3398:	200079a0 	.word	0x200079a0
    339c:	200005c0 	.word	0x200005c0
    33a0:	20001110 	.word	0x20001110
    33a4:	2000a510 	.word	0x2000a510

000033a8 <sendOpenFrame()>:
    }
  }
  return true;
}

void sendOpenFrame() {
    33a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // write an empty frame to every ID, will stop all comms to the Haldex pump
  CAN_message_t motor1;
    33ac:	4c44      	ldr	r4, [pc, #272]	; (34c0 <sendOpenFrame()+0x118>)
void sendOpenFrame() {
    33ae:	b09f      	sub	sp, #124	; 0x7c
  motor1.buf[3] = 0x4E;  // motor speed (rpm): 78 > 0.25 * 3278 = 819.5 RPM (was 0x4e)  Leave RPM the same?
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
  motor1.buf[5] = 0xFE;  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
  motor1.buf[6] = 0x20;  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
  motor1.buf[7] = 0xFE;  // drivers moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
  HaldexCAN.write(motor1);
    33b0:	4d44      	ldr	r5, [pc, #272]	; (34c4 <sendOpenFrame()+0x11c>)
  motor1.id = MOTOR1_ID;
    33b2:	f44f 7b20 	mov.w	fp, #640	; 0x280
  CAN_message_t motor1;
    33b6:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    33ba:	46ec      	mov	ip, sp
  motor1.buf[1] = 0xFA;  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
    33bc:	f04f 0afa 	mov.w	sl, #250	; 0xfa
  motor1.buf[2] = 0x20;  // motor speed (rpm): 32 >
    33c0:	f644 6920 	movw	r9, #20000	; 0x4e20

  CAN_message_t motor3;
  motor3.id = MOTOR3_ID;
  motor3.len = 1;
    33c4:	f04f 0801 	mov.w	r8, #1
  motor3.buf[0] = 0xff;
    33c8:	27ff      	movs	r7, #255	; 0xff
  brakes1.id = BRAKES1_ID;
  brakes1.len = 4;
  brakes1.buf[0] = 0;
  brakes1.buf[1] = 0;
  brakes1.buf[2] = 0x0;
  brakes1.buf[3] = 0xa;
    33ca:	260a      	movs	r6, #10
  CAN_message_t motor1;
    33cc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    33d0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    33d4:	e89e 0003 	ldmia.w	lr, {r0, r1}
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
    33d8:	4b3b      	ldr	r3, [pc, #236]	; (34c8 <sendOpenFrame()+0x120>)
  motor1.buf[1] = 0xFA;  // inner engine moment (%): 0.39*(0xF0) = 93.6%  (make FE?) (was 0xf0)
    33da:	f88d a00d 	strb.w	sl, [sp, #13]
  brakes1.id = BRAKES1_ID;
    33de:	f44f 7ad0 	mov.w	sl, #416	; 0x1a0
  motor1.buf[2] = 0x20;  // motor speed (rpm): 32 >
    33e2:	f8ad 900e 	strh.w	r9, [sp, #14]
  motor3.id = MOTOR3_ID;
    33e6:	f44f 7960 	mov.w	r9, #896	; 0x380
  motor1.id = MOTOR1_ID;
    33ea:	f8cd b000 	str.w	fp, [sp]
  CAN_message_t motor1;
    33ee:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(motor1);
    33f2:	4669      	mov	r1, sp
    33f4:	4628      	mov	r0, r5
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
    33f6:	9304      	str	r3, [sp, #16]
  HaldexCAN.write(motor1);
    33f8:	f7ff fea6 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t motor3;
    33fc:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    3400:	f10d 0c18 	add.w	ip, sp, #24
    3404:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3408:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    340c:	e89e 0003 	ldmia.w	lr, {r0, r1}
  motor3.id = MOTOR3_ID;
    3410:	f8cd 9018 	str.w	r9, [sp, #24]
  brakes1.len = 4;
    3414:	f04f 0904 	mov.w	r9, #4
  motor3.len = 1;
    3418:	f88d 8023 	strb.w	r8, [sp, #35]	; 0x23
  motor3.buf[0] = 0xff;
    341c:	f88d 7024 	strb.w	r7, [sp, #36]	; 0x24
  CAN_message_t motor3;
    3420:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(motor3);
    3424:	a906      	add	r1, sp, #24
    3426:	4628      	mov	r0, r5
    3428:	f7ff fe8e 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes1;
    342c:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    3430:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
    3434:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3438:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    343c:	e89e 0003 	ldmia.w	lr, {r0, r1}
  brakes1.len = 4;
    3440:	f88d 903b 	strb.w	r9, [sp, #59]	; 0x3b
  HaldexCAN.write(brakes1);

  CAN_message_t brakes3;
  brakes3.id = BRAKES3_ID;
    3444:	f44f 6994 	mov.w	r9, #1184	; 0x4a0
  brakes1.buf[3] = 0xa;
    3448:	f88d 603f 	strb.w	r6, [sp, #63]	; 0x3f
  brakes1.id = BRAKES1_ID;
    344c:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
  CAN_message_t brakes1;
    3450:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(brakes1);
    3454:	a90c      	add	r1, sp, #48	; 0x30
    3456:	4628      	mov	r0, r5
    3458:	f7ff fe76 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes3;
    345c:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    3460:	f10d 0c48 	add.w	ip, sp, #72	; 0x48
  brakes3.buf[5] = 0xA;  // 254+10? (5050 returns 0xA)
  brakes3.buf[6] = 0x0;
  brakes3.buf[7] = 0xA;  // 254+10? was FE
  HaldexCAN.write(brakes3);

  CAN_message_t brakes5;
    3464:	3440      	adds	r4, #64	; 0x40
  CAN_message_t brakes3;
    3466:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    346a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    346e:	e89e 0003 	ldmia.w	lr, {r0, r1}
  brakes3.buf[1] = 0xA;
    3472:	f88d 6055 	strb.w	r6, [sp, #85]	; 0x55
  brakes3.buf[3] = 0xA;
    3476:	f88d 6057 	strb.w	r6, [sp, #87]	; 0x57
  brakes3.id = BRAKES3_ID;
    347a:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
  CAN_message_t brakes3;
    347e:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(brakes3);
    3482:	a912      	add	r1, sp, #72	; 0x48
    3484:	4628      	mov	r0, r5
  brakes3.buf[5] = 0xA;  // 254+10? (5050 returns 0xA)
    3486:	f88d 6059 	strb.w	r6, [sp, #89]	; 0x59
  brakes3.buf[7] = 0xA;  // 254+10? was FE
    348a:	f88d 605b 	strb.w	r6, [sp, #91]	; 0x5b
  HaldexCAN.write(brakes3);
    348e:	f7ff fe5b 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes5;
    3492:	ae18      	add	r6, sp, #96	; 0x60
  brakes5.id = BRAKES5_ID;
    3494:	f44f 6cb4 	mov.w	ip, #1440	; 0x5a0
  CAN_message_t brakes5;
    3498:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    349a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    349c:	e894 0003 	ldmia.w	r4, {r0, r1}
  brakes5.id = BRAKES5_ID;
    34a0:	f8cd c060 	str.w	ip, [sp, #96]	; 0x60
  brakes5.len = 1;
    34a4:	f88d 806b 	strb.w	r8, [sp, #107]	; 0x6b
  brakes5.buf[0] = 0xff;
    34a8:	f88d 706c 	strb.w	r7, [sp, #108]	; 0x6c
  CAN_message_t brakes5;
    34ac:	e886 0003 	stmia.w	r6, {r0, r1}
  HaldexCAN.write(brakes5);
    34b0:	a918      	add	r1, sp, #96	; 0x60
    34b2:	4628      	mov	r0, r5
    34b4:	f7ff fe48 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
}
    34b8:	b01f      	add	sp, #124	; 0x7c
    34ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    34be:	bf00      	nop
    34c0:	20000370 	.word	0x20000370
    34c4:	200079a0 	.word	0x200079a0
    34c8:	fe20fefe 	.word	0xfe20fefe

000034cc <send5050Frame()>:

void send5050Frame() {
    34cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#define BRAKES5_ID                0x5A0
#define MOTOR1_ID                 0x280
#define MOTOR2_ID                 0x288
#define MOTOR3_ID                 0x380*/

  CAN_message_t motor1;
    34d0:	4c3f      	ldr	r4, [pc, #252]	; (35d0 <send5050Frame()+0x104>)
void send5050Frame() {
    34d2:	b099      	sub	sp, #100	; 0x64
  motor1.buf[3] = 0x4E;  // motor speed (rpm): 78 > (high byte) : 0.25 * (32 78) = 819.5 RPM (was 0x4e)  Leave RPM the same?
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
  motor1.buf[5] = 0xFE;  // driving pedal (%): 0.39*(0xF0) = 93.6%  (make FE?)
  motor1.buf[6] = 0x20;  // torque loss (%): 0.39*(0x20) = 12.48%? (make FE?) slippage?
  motor1.buf[7] = 0xFE;  // drivers moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
  HaldexCAN.write(motor1);
    34d4:	4d3f      	ldr	r5, [pc, #252]	; (35d4 <send5050Frame()+0x108>)
  motor1.id = MOTOR1_ID;
    34d6:	f44f 7920 	mov.w	r9, #640	; 0x280
  CAN_message_t motor1;
    34da:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    34de:	46ec      	mov	ip, sp
  motor1.buf[0] = 0x01;  // various individual bits ('space gas', driving pedal, kick down, clutch, timeout brake, brake intervention, drinks-torque intervention?)
    34e0:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 35dc <send5050Frame()+0x110>

  CAN_message_t motor3;
  motor3.id = MOTOR3_ID;
    34e4:	f44f 7b60 	mov.w	fp, #896	; 0x380
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
    34e8:	4f3b      	ldr	r7, [pc, #236]	; (35d8 <send5050Frame()+0x10c>)
  motor3.len = 8;
  motor3.buf[0] = 0x00;  // various individual bits ('motor has been launched, only in diesel')
  motor3.buf[1] = 0x50;  // outdoor temperature
    34ea:	f04f 0a50 	mov.w	sl, #80	; 0x50

  brakes1.len = 8;
  brakes1.buf[0] = 0x80;  // asr req
  brakes1.buf[1] = 0x41;
  brakes1.buf[2] = 0x00;
  brakes1.buf[3] = 0x0A;
    34ee:	260a      	movs	r6, #10
  CAN_message_t motor1;
    34f0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    34f4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    34f8:	e89e 0003 	ldmia.w	lr, {r0, r1}
  motor1.id = MOTOR1_ID;
    34fc:	f8cd 9000 	str.w	r9, [sp]
  motor3.buf[2] = 0xFA;  // pedal
    3500:	f643 69fa 	movw	r9, #16122	; 0x3efa
  motor1.buf[0] = 0x01;  // various individual bits ('space gas', driving pedal, kick down, clutch, timeout brake, brake intervention, drinks-torque intervention?)
    3504:	f8cd 800c 	str.w	r8, [sp, #12]
  motor3.buf[4] = 0xA0;  // wheel command torque (high byte).  If SY_ASG
    3508:	f04f 08a0 	mov.w	r8, #160	; 0xa0
  CAN_message_t motor1;
    350c:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(motor1);
    3510:	4669      	mov	r1, sp
    3512:	4628      	mov	r0, r5
  motor1.buf[4] = 0xFE;  // inner moment (%): 0.39*(0xF0) = 93.6%  (make FE?)
    3514:	9704      	str	r7, [sp, #16]
  HaldexCAN.write(motor1);
    3516:	f7ff fe17 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t motor3;
    351a:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    351e:	f10d 0c18 	add.w	ip, sp, #24
  motor3.buf[7] = 0xFE;  // throttle angle
    3522:	27fe      	movs	r7, #254	; 0xfe
  CAN_message_t motor3;
    3524:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3528:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    352c:	e89e 0003 	ldmia.w	lr, {r0, r1}
  motor3.buf[1] = 0x50;  // outdoor temperature
    3530:	f88d a025 	strb.w	sl, [sp, #37]	; 0x25
  brakes1.id = BRAKES1_ID;
    3534:	f44f 7ad0 	mov.w	sl, #416	; 0x1a0
  motor3.buf[2] = 0xFA;  // pedal
    3538:	f8ad 9026 	strh.w	r9, [sp, #38]	; 0x26
  brakes1.buf[0] = 0x80;  // asr req
    353c:	f44f 4983 	mov.w	r9, #16768	; 0x4180
  motor3.id = MOTOR3_ID;
    3540:	f8cd b018 	str.w	fp, [sp, #24]
  CAN_message_t motor3;
    3544:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(motor3);
    3548:	a906      	add	r1, sp, #24
    354a:	4628      	mov	r0, r5
  motor3.buf[4] = 0xA0;  // wheel command torque (high byte).  If SY_ASG
    354c:	f88d 8028 	strb.w	r8, [sp, #40]	; 0x28
  brakes1.buf[4] = 0xFE;
    3550:	f64f 68fe 	movw	r8, #65278	; 0xfefe
  motor3.buf[7] = 0xFE;  // throttle angle
    3554:	f88d 702b 	strb.w	r7, [sp, #43]	; 0x2b
  HaldexCAN.write(motor3);
    3558:	f7ff fdf6 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes1;
    355c:	f104 0e40 	add.w	lr, r4, #64	; 0x40
    3560:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
  brakes1.buf[5] = 0xFE;
  brakes1.buf[6] = 0x00;
  brakes1.buf[7] = 0x1E;
    3564:	271e      	movs	r7, #30
  CAN_message_t brakes1;
    3566:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    356a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    356e:	e89e 0003 	ldmia.w	lr, {r0, r1}
  brakes1.id = BRAKES1_ID;
    3572:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
  brakes1.buf[0] = 0x80;  // asr req
    3576:	f8ad 903c 	strh.w	r9, [sp, #60]	; 0x3c
  brakes1.buf[3] = 0x0A;
    357a:	f88d 603f 	strb.w	r6, [sp, #63]	; 0x3f
  CAN_message_t brakes1;
    357e:	e88c 0003 	stmia.w	ip, {r0, r1}
  HaldexCAN.write(brakes1);
    3582:	a90c      	add	r1, sp, #48	; 0x30
    3584:	4628      	mov	r0, r5
  brakes1.buf[7] = 0x1E;
    3586:	f88d 7043 	strb.w	r7, [sp, #67]	; 0x43

  CAN_message_t brakes3;
  brakes3.id = BRAKES3_ID;
    358a:	f44f 6794 	mov.w	r7, #1184	; 0x4a0
  brakes1.buf[4] = 0xFE;
    358e:	f8ad 8040 	strh.w	r8, [sp, #64]	; 0x40
  HaldexCAN.write(brakes1);
    3592:	f7ff fdd9 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
  CAN_message_t brakes3;
    3596:	f104 0c40 	add.w	ip, r4, #64	; 0x40
    359a:	ac12      	add	r4, sp, #72	; 0x48

  brakes3.buf[2] = 0x0;   // low byte, RIGHT Front
  brakes3.buf[3] = 0xA;   // high byte, RIGHT Front

  brakes3.buf[4] = 0x0;   // low byte, LEFT Rear
  brakes3.buf[5] = 0x04;  // high byte, LEFT Rear // 254+10? (5050 returns 0xA)
    359c:	f04f 0e04 	mov.w	lr, #4
  CAN_message_t brakes3;
    35a0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    35a4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    35a6:	e89c 0003 	ldmia.w	ip, {r0, r1}
  brakes3.id = BRAKES3_ID;
    35aa:	9712      	str	r7, [sp, #72]	; 0x48
  brakes3.buf[1] = 0xA;   // high byte, LEFT Front
    35ac:	f88d 6055 	strb.w	r6, [sp, #85]	; 0x55
  brakes3.buf[3] = 0xA;   // high byte, RIGHT Front
    35b0:	f88d 6057 	strb.w	r6, [sp, #87]	; 0x57
  CAN_message_t brakes3;
    35b4:	e884 0003 	stmia.w	r4, {r0, r1}

  brakes3.buf[6] = 0x0;   // low byte, RIGHT Rear
  brakes3.buf[7] = 0x04;  // low byte, RIGHT Rear  // 254+10?
  HaldexCAN.write(brakes3);
    35b8:	a912      	add	r1, sp, #72	; 0x48
    35ba:	4628      	mov	r0, r5
  brakes3.buf[5] = 0x04;  // high byte, LEFT Rear // 254+10? (5050 returns 0xA)
    35bc:	f88d e059 	strb.w	lr, [sp, #89]	; 0x59
  brakes3.buf[7] = 0x04;  // low byte, RIGHT Rear  // 254+10?
    35c0:	f88d e05b 	strb.w	lr, [sp, #91]	; 0x5b
  HaldexCAN.write(brakes3);
    35c4:	f7ff fdc0 	bl	3148 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
}
    35c8:	b019      	add	sp, #100	; 0x64
    35ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    35ce:	bf00      	nop
    35d0:	20000370 	.word	0x20000370
    35d4:	200079a0 	.word	0x200079a0
    35d8:	fe20fefe 	.word	0xfe20fefe
    35dc:	4e20fa01 	.word	0x4e20fa01

000035e0 <sendStandaloneCAN(void*)>:
  if (isStandalone) {
    35e0:	4b0b      	ldr	r3, [pc, #44]	; (3610 <sendStandaloneCAN(void*)+0x30>)
    35e2:	781b      	ldrb	r3, [r3, #0]
    35e4:	b143      	cbz	r3, 35f8 <sendStandaloneCAN(void*)+0x18>
bool sendStandaloneCAN(void *params) {
    35e6:	b510      	push	{r4, lr}
    if (state.mode == MODE_FWD) {
    35e8:	4c0a      	ldr	r4, [pc, #40]	; (3614 <sendStandaloneCAN(void*)+0x34>)
    35ea:	7823      	ldrb	r3, [r4, #0]
    35ec:	2b01      	cmp	r3, #1
    35ee:	d009      	beq.n	3604 <sendStandaloneCAN(void*)+0x24>
    if (state.mode == MODE_5050) {
    35f0:	2b02      	cmp	r3, #2
    35f2:	d003      	beq.n	35fc <sendStandaloneCAN(void*)+0x1c>
}
    35f4:	2001      	movs	r0, #1
    35f6:	bd10      	pop	{r4, pc}
    35f8:	2001      	movs	r0, #1
    35fa:	4770      	bx	lr
      send5050Frame();
    35fc:	f7ff ff66 	bl	34cc <send5050Frame()>
}
    3600:	2001      	movs	r0, #1
    3602:	bd10      	pop	{r4, pc}
      sendOpenFrame();
    3604:	f7ff fed0 	bl	33a8 <sendOpenFrame()>
    if (state.mode == MODE_5050) {
    3608:	7823      	ldrb	r3, [r4, #0]
    360a:	2b02      	cmp	r3, #2
    360c:	d1f2      	bne.n	35f4 <sendStandaloneCAN(void*)+0x14>
    360e:	e7f5      	b.n	35fc <sendStandaloneCAN(void*)+0x1c>
    3610:	2000a715 	.word	0x2000a715
    3614:	2000a580 	.word	0x2000a580

00003618 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>:
  if ( msg.seq ) {
    3618:	7d8b      	ldrb	r3, [r1, #22]
FCTP_FUNC int FCTP_OPT::write(const CAN_message_t &msg) {
    361a:	b5f0      	push	{r4, r5, r6, r7, lr}
    361c:	460d      	mov	r5, r1
    361e:	b08d      	sub	sp, #52	; 0x34
    3620:	4604      	mov	r4, r0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3622:	4e4b      	ldr	r6, [pc, #300]	; (3750 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
  if ( msg.seq ) {
    3624:	2b00      	cmp	r3, #0
    3626:	d14c      	bne.n	36c2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xaa>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3628:	6833      	ldr	r3, [r6, #0]
    362a:	f013 5c00 	ands.w	ip, r3, #536870912	; 0x20000000
    362e:	d025      	beq.n	367c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x64>
    3630:	f7fd fe2a 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3634:	6833      	ldr	r3, [r6, #0]
    3636:	4684      	mov	ip, r0
    3638:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    363c:	3301      	adds	r3, #1
    363e:	4298      	cmp	r0, r3
    3640:	d21e      	bcs.n	3680 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3642:	4944      	ldr	r1, [pc, #272]	; (3754 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    3644:	4842      	ldr	r0, [pc, #264]	; (3750 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    3646:	e007      	b.n	3658 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x40>
    3648:	6803      	ldr	r3, [r0, #0]
    364a:	fa5f fc82 	uxtb.w	ip, r2
    364e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3652:	3301      	adds	r3, #1
    3654:	459c      	cmp	ip, r3
    3656:	d213      	bcs.n	3680 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x68>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3658:	eb0c 0301 	add.w	r3, ip, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    365c:	f10c 0201 	add.w	r2, ip, #1
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3660:	011b      	lsls	r3, r3, #4
    3662:	681b      	ldr	r3, [r3, #0]
    3664:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3668:	2b08      	cmp	r3, #8
    366a:	d1ed      	bne.n	3648 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x30>
      writeTxMailbox(i, msg);
    366c:	4620      	mov	r0, r4
    366e:	462a      	mov	r2, r5
    3670:	4661      	mov	r1, ip
    3672:	f7ff fbf3 	bl	2e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    3676:	2001      	movs	r0, #1
}
    3678:	b00d      	add	sp, #52	; 0x34
    367a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    367c:	6833      	ldr	r3, [r6, #0]
    367e:	e7e0      	b.n	3642 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x2a>
  CAN_message_t msg_copy = msg;
    3680:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3682:	46ec      	mov	ip, sp
  memmove(buf, &msg, sizeof(msg));
    3684:	27ff      	movs	r7, #255	; 0xff
    3686:	466e      	mov	r6, sp
    3688:	f10d 0e18 	add.w	lr, sp, #24
  CAN_message_t msg_copy = msg;
    368c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3690:	e895 0003 	ldmia.w	r5, {r0, r1}
    3694:	e88c 0003 	stmia.w	ip, {r0, r1}
  memmove(buf, &msg, sizeof(msg));
    3698:	f88d 7014 	strb.w	r7, [sp, #20]
    369c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    369e:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    36a2:	e89c 0003 	ldmia.w	ip, {r0, r1}
    36a6:	e88e 0003 	stmia.w	lr, {r0, r1}
    36aa:	2218      	movs	r2, #24
    36ac:	f641 301a 	movw	r0, #6938	; 0x1b1a
    36b0:	eb0d 0102 	add.w	r1, sp, r2
    36b4:	4420      	add	r0, r4
    36b6:	f7ff fd13 	bl	30e0 <Circular_Buffer<unsigned char, (unsigned short)16, (unsigned short)24>::write(unsigned char const*, unsigned short)>
  return -1; /* transmit entry failed, no mailboxes available, queued */
    36ba:	f04f 30ff 	mov.w	r0, #4294967295
}
    36be:	b00d      	add	sp, #52	; 0x34
    36c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    36c2:	6830      	ldr	r0, [r6, #0]
    36c4:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
    36c8:	d040      	beq.n	374c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x134>
    36ca:	f7fd fddd 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    36ce:	6833      	ldr	r3, [r6, #0]
    36d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    36d4:	3301      	adds	r3, #1
    36d6:	4283      	cmp	r3, r0
    36d8:	d927      	bls.n	372a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    36da:	491e      	ldr	r1, [pc, #120]	; (3754 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x13c>)
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    36dc:	4e1c      	ldr	r6, [pc, #112]	; (3750 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x138>)
    36de:	e005      	b.n	36ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xd4>
    36e0:	6833      	ldr	r3, [r6, #0]
    36e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    36e6:	3301      	adds	r3, #1
    36e8:	4298      	cmp	r0, r3
    36ea:	d21e      	bcs.n	372a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x112>
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    36ec:	1843      	adds	r3, r0, r1
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    36ee:	1c42      	adds	r2, r0, #1
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    36f0:	4684      	mov	ip, r0
    36f2:	011b      	lsls	r3, r3, #4
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    36f4:	b2d0      	uxtb	r0, r2
    if ( (FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, i)) >> 3) ) return i; // if TX
    36f6:	681a      	ldr	r2, [r3, #0]
    36f8:	0112      	lsls	r2, r2, #4
    36fa:	d5f1      	bpl.n	36e0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc8>
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    36fc:	681b      	ldr	r3, [r3, #0]
    36fe:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3702:	2b08      	cmp	r3, #8
    3704:	d019      	beq.n	373a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x122>
      CAN_message_t msg_copy = msg;
    3706:	466e      	mov	r6, sp
  memmove(buf, &msg, sizeof(msg));
    3708:	466f      	mov	r7, sp
    370a:	f10d 0e18 	add.w	lr, sp, #24
      CAN_message_t msg_copy = msg;
    370e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3710:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    3712:	e895 0003 	ldmia.w	r5, {r0, r1}
    3716:	e886 0003 	stmia.w	r6, {r0, r1}
      msg_copy.mb = first_tx_mb;
    371a:	f88d c014 	strb.w	ip, [sp, #20]
  memmove(buf, &msg, sizeof(msg));
    371e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3720:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    3724:	e896 0003 	ldmia.w	r6, {r0, r1}
    3728:	e7bd      	b.n	36a6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x8e>
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    372a:	4b0b      	ldr	r3, [pc, #44]	; (3758 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0x140>)
  return -1;
    372c:	f04f 3cff 	mov.w	ip, #4294967295
    if ( FLEXCAN_get_code(FLEXCANb_MBn_CS(_bus, first_tx_mb)) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    3730:	681b      	ldr	r3, [r3, #0]
    3732:	f3c3 6303 	ubfx	r3, r3, #24, #4
    3736:	2b08      	cmp	r3, #8
    3738:	d1e5      	bne.n	3706 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xee>
      writeTxMailbox(first_tx_mb, msg);
    373a:	4620      	mov	r0, r4
    373c:	462a      	mov	r2, r5
    373e:	fa5f f18c 	uxtb.w	r1, ip
    3742:	f7ff fb8b 	bl	2e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
      return 1; /* transmit entry accepted */
    3746:	2001      	movs	r0, #1
}
    3748:	b00d      	add	sp, #52	; 0x34
    374a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++) {
    374c:	6833      	ldr	r3, [r6, #0]
    374e:	e7c4      	b.n	36da <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)+0xc2>
    3750:	401d4000 	.word	0x401d4000
    3754:	0401d408 	.word	0x0401d408
    3758:	401d4070 	.word	0x401d4070

0000375c <onHaldexRX(CAN_message_t const&)>:
void onHaldexRX(const CAN_message_t &frame) {
    375c:	b570      	push	{r4, r5, r6, lr}
  haldexState = frame.buf[0];
    375e:	4b1d      	ldr	r3, [pc, #116]	; (37d4 <onHaldexRX(CAN_message_t const&)+0x78>)
void onHaldexRX(const CAN_message_t &frame) {
    3760:	b086      	sub	sp, #24
  haldexState = frame.buf[0];
    3762:	7b02      	ldrb	r2, [r0, #12]
void onHaldexRX(const CAN_message_t &frame) {
    3764:	4686      	mov	lr, r0
  CAN_message_t frame_out;
    3766:	4c1c      	ldr	r4, [pc, #112]	; (37d8 <onHaldexRX(CAN_message_t const&)+0x7c>)
    3768:	46ec      	mov	ip, sp
  haldexState = frame.buf[0];
    376a:	701a      	strb	r2, [r3, #0]
  haldexEngagement = frame.buf[1];
    376c:	4b1b      	ldr	r3, [pc, #108]	; (37dc <onHaldexRX(CAN_message_t const&)+0x80>)
    376e:	7b42      	ldrb	r2, [r0, #13]
  frame_out.len = frame.len;
    3770:	7ac5      	ldrb	r5, [r0, #11]
  frame_out.flags = frame.flags;
    3772:	f8d0 6007 	ldr.w	r6, [r0, #7]
  haldexEngagement = frame.buf[1];
    3776:	701a      	strb	r2, [r3, #0]
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3778:	2d08      	cmp	r5, #8
  CAN_message_t frame_out;
    377a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    377c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  frame_out.id = frame.id;
    3780:	f8de 3000 	ldr.w	r3, [lr]
  frame_out.flags = frame.flags;
    3784:	f8cd 6007 	str.w	r6, [sp, #7]
  frame_out.id = frame.id;
    3788:	9300      	str	r3, [sp, #0]
  frame_out.len = frame.len;
    378a:	f88d 500b 	strb.w	r5, [sp, #11]
  CAN_message_t frame_out;
    378e:	e894 0003 	ldmia.w	r4, {r0, r1}
    3792:	e88c 0003 	stmia.w	ip, {r0, r1}
  if (frame.len <= ARRAY_SIZE(frame_out.buf)) {
    3796:	d906      	bls.n	37a6 <onHaldexRX(CAN_message_t const&)+0x4a>
  if (!ChassisCAN.write(frame_out)) {
    3798:	4669      	mov	r1, sp
    379a:	4811      	ldr	r0, [pc, #68]	; (37e0 <onHaldexRX(CAN_message_t const&)+0x84>)
    379c:	f7ff ff3c 	bl	3618 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    37a0:	b168      	cbz	r0, 37be <onHaldexRX(CAN_message_t const&)+0x62>
}
    37a2:	b006      	add	sp, #24
    37a4:	bd70      	pop	{r4, r5, r6, pc}
    memcpy(frame_out.buf, frame.buf, frame.len);
    37a6:	f10e 010c 	add.w	r1, lr, #12
    37aa:	462a      	mov	r2, r5
    37ac:	a803      	add	r0, sp, #12
    37ae:	f002 fe61 	bl	6474 <memcpy>
  if (!ChassisCAN.write(frame_out)) {
    37b2:	4669      	mov	r1, sp
    37b4:	480a      	ldr	r0, [pc, #40]	; (37e0 <onHaldexRX(CAN_message_t const&)+0x84>)
    37b6:	f7ff ff2f 	bl	3618 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::write(CAN_message_t const&)>
    37ba:	2800      	cmp	r0, #0
    37bc:	d1f1      	bne.n	37a2 <onHaldexRX(CAN_message_t const&)+0x46>
    37be:	2111      	movs	r1, #17
    37c0:	4808      	ldr	r0, [pc, #32]	; (37e4 <onHaldexRX(CAN_message_t const&)+0x88>)
    37c2:	f004 f99f 	bl	7b04 <usb_serial_write>
    37c6:	4808      	ldr	r0, [pc, #32]	; (37e8 <onHaldexRX(CAN_message_t const&)+0x8c>)
    37c8:	f002 f90e 	bl	59e8 <Print::println()>
    ChassisCAN.mailboxStatus();
    37cc:	f7fd ff1c 	bl	1608 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxStatus() [clone .isra.0]>
}
    37d0:	b006      	add	sp, #24
    37d2:	bd70      	pop	{r4, r5, r6, pc}
    37d4:	2000a711 	.word	0x2000a711
    37d8:	200003b0 	.word	0x200003b0
    37dc:	2000a710 	.word	0x2000a710
    37e0:	20005088 	.word	0x20005088
    37e4:	200003dc 	.word	0x200003dc
    37e8:	20001110 	.word	0x20001110

000037ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( mb_num == FIFO ) fifo_filter_table[0][0] |= (1UL << 28); /* enable fifo enhancement */
  else mb_filter_table[mb_num][0] |= (1UL << 28); /* enable mb enhancement */
}

FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    37ec:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    37f0:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    37f4:	00db      	lsls	r3, r3, #3
    37f6:	d569      	bpl.n	38cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    37f8:	4b37      	ldr	r3, [pc, #220]	; (38d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    37fa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    37fe:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    3800:	f04f 0e00 	mov.w	lr, #0
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    }
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3804:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3808:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    380c:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3810:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3814:	00f6      	lsls	r6, r6, #3
    3816:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3818:	e009      	b.n	382e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    381a:	6813      	ldr	r3, [r2, #0]
    381c:	0f5b      	lsrs	r3, r3, #29
    381e:	2b05      	cmp	r3, #5
    3820:	d034      	beq.n	388c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3822:	f10e 0e01 	add.w	lr, lr, #1
    3826:	fa5f f38e 	uxtb.w	r3, lr
    382a:	429e      	cmp	r6, r3
    382c:	d950      	bls.n	38d0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    382e:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    3832:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    3836:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    383a:	6813      	ldr	r3, [r2, #0]
    383c:	0f5b      	lsrs	r3, r3, #29
    383e:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3840:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3842:	d00d      	beq.n	3860 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3844:	0f5b      	lsrs	r3, r3, #29
    3846:	2b02      	cmp	r3, #2
    3848:	d1e7      	bne.n	381a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    384a:	f85c 3007 	ldr.w	r3, [ip, r7]
    384e:	428b      	cmp	r3, r1
    3850:	d8e7      	bhi.n	3822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3852:	f85c 3008 	ldr.w	r3, [ip, r8]
    3856:	428b      	cmp	r3, r1
    3858:	d3e3      	bcc.n	3822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    385a:	2001      	movs	r0, #1
      }
    }
  }
  return 0;
}
    385c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3860:	f413 7f60 	tst.w	r3, #896	; 0x380
    3864:	d0dd      	beq.n	3822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3866:	006d      	lsls	r5, r5, #1
    3868:	2300      	movs	r3, #0
    386a:	e004      	b.n	3876 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    386c:	6814      	ldr	r4, [r2, #0]
    386e:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3872:	4563      	cmp	r3, ip
    3874:	d2d5      	bcs.n	3822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3876:	3301      	adds	r3, #1
    3878:	eb05 0c03 	add.w	ip, r5, r3
    387c:	b2db      	uxtb	r3, r3
    387e:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    3882:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3886:	428c      	cmp	r4, r1
    3888:	d1f0      	bne.n	386c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    388a:	e7e6      	b.n	385a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    388c:	6813      	ldr	r3, [r2, #0]
    388e:	f413 7f60 	tst.w	r3, #896	; 0x380
    3892:	d0c6      	beq.n	3822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3894:	44cc      	add	ip, r9
    3896:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3898:	2401      	movs	r4, #1
    389a:	e005      	b.n	38a8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    389c:	6813      	ldr	r3, [r2, #0]
    389e:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    38a2:	3301      	adds	r3, #1
    38a4:	429c      	cmp	r4, r3
    38a6:	d2bc      	bcs.n	3822 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    38a8:	192b      	adds	r3, r5, r4
    38aa:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    38ae:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    38b0:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    38b4:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    38b8:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    38ba:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    38be:	f8dc b000 	ldr.w	fp, [ip]
    38c2:	ea03 030b 	and.w	r3, r3, fp
    38c6:	459a      	cmp	sl, r3
    38c8:	d1e8      	bne.n	389c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    38ca:	e7c6      	b.n	385a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    38cc:	2001      	movs	r0, #1
}
    38ce:	4770      	bx	lr
  return 0;
    38d0:	2000      	movs	r0, #0
}
    38d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    38d6:	bf00      	nop
    38d8:	401d4000 	.word	0x401d4000

000038dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:

FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    38dc:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    38e0:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    38e2:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    38e6:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    38ea:	f8de 3000 	ldr.w	r3, [lr]
    38ee:	00db      	lsls	r3, r3, #3
    38f0:	d528      	bpl.n	3944 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    38f2:	f8de 3000 	ldr.w	r3, [lr]
    38f6:	0f5b      	lsrs	r3, r3, #29
    38f8:	2b01      	cmp	r3, #1
    38fa:	d00b      	beq.n	3914 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    38fc:	f8de 3000 	ldr.w	r3, [lr]
    3900:	0f5b      	lsrs	r3, r3, #29
    3902:	2b02      	cmp	r3, #2
    3904:	d042      	beq.n	398c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
  }
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    3906:	f8de 3000 	ldr.w	r3, [lr]
    390a:	0f5b      	lsrs	r3, r3, #29
    390c:	2b05      	cmp	r3, #5
    390e:	d01b      	beq.n	3948 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    }
  }
  return 0;
    3910:	2000      	movs	r0, #0
}
    3912:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    3914:	f8de 4000 	ldr.w	r4, [lr]
    3918:	f414 7f60 	tst.w	r4, #896	; 0x380
    391c:	d0f8      	beq.n	3910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    391e:	2300      	movs	r3, #0
    3920:	004d      	lsls	r5, r1, #1
    3922:	e005      	b.n	3930 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    3924:	f8de 1000 	ldr.w	r1, [lr]
    3928:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    392c:	4563      	cmp	r3, ip
    392e:	d2ef      	bcs.n	3910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3930:	3301      	adds	r3, #1
    3932:	eb05 0c03 	add.w	ip, r5, r3
    3936:	b2db      	uxtb	r3, r3
    3938:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    393c:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3940:	4294      	cmp	r4, r2
    3942:	d1ef      	bne.n	3924 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3944:	2001      	movs	r0, #1
}
    3946:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3948:	f8de 5000 	ldr.w	r5, [lr]
    394c:	f415 7f60 	tst.w	r5, #896	; 0x380
    3950:	d0de      	beq.n	3910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3952:	f242 1514 	movw	r5, #8468	; 0x2114
    3956:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3958:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    395a:	4425      	add	r5, r4
    395c:	e007      	b.n	396e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    395e:	f8de 4000 	ldr.w	r4, [lr]
    3962:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3966:	f10c 0c01 	add.w	ip, ip, #1
    396a:	4563      	cmp	r3, ip
    396c:	d2d0      	bcs.n	3910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    396e:	682c      	ldr	r4, [r5, #0]
    3970:	ea04 0c02 	and.w	ip, r4, r2
    3974:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3976:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3978:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    397c:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    397e:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    3982:	682e      	ldr	r6, [r5, #0]
    3984:	4034      	ands	r4, r6
    3986:	45a4      	cmp	ip, r4
    3988:	d1e9      	bne.n	395e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    398a:	e7db      	b.n	3944 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    398c:	f242 1304 	movw	r3, #8452	; 0x2104
    3990:	58e3      	ldr	r3, [r4, r3]
    3992:	4293      	cmp	r3, r2
    3994:	d8bc      	bhi.n	3910 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3996:	f242 1308 	movw	r3, #8456	; 0x2108
    399a:	58e0      	ldr	r0, [r4, r3]
    399c:	4290      	cmp	r0, r2
    399e:	bf34      	ite	cc
    39a0:	2000      	movcc	r0, #0
    39a2:	2001      	movcs	r0, #1
}
    39a4:	bd70      	pop	{r4, r5, r6, pc}
    39a6:	bf00      	nop

000039a8 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>:
  if ( _available < _size ) _available++;
    39a8:	8883      	ldrh	r3, [r0, #4]
    39aa:	b29b      	uxth	r3, r3
    39ac:	2b0f      	cmp	r3, #15
    39ae:	d803      	bhi.n	39b8 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x10>
    39b0:	8883      	ldrh	r3, [r0, #4]
    39b2:	3301      	adds	r3, #1
    39b4:	b29b      	uxth	r3, r3
    39b6:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    39b8:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    39ba:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    39be:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    39c0:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    39c4:	fa1f fc8c 	uxth.w	ip, ip
    39c8:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    39ca:	3202      	adds	r2, #2
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    39cc:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    39d0:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    39d4:	459c      	cmp	ip, r3
    39d6:	d104      	bne.n	39e2 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)+0x3a>
    39d8:	8803      	ldrh	r3, [r0, #0]
    39da:	3301      	adds	r3, #1
    39dc:	f003 031f 	and.w	r3, r3, #31
    39e0:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    39e2:	8843      	ldrh	r3, [r0, #2]
    39e4:	3301      	adds	r3, #1
    39e6:	f003 031f 	and.w	r3, r3, #31
    39ea:	8043      	strh	r3, [r0, #2]
}
    39ec:	4770      	bx	lr
    39ee:	bf00      	nop

000039f0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>:
  if ( _available < _size ) _available++;
    39f0:	8883      	ldrh	r3, [r0, #4]
    39f2:	b29b      	uxth	r3, r3
    39f4:	2b0f      	cmp	r3, #15
    39f6:	d803      	bhi.n	3a00 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x10>
    39f8:	8883      	ldrh	r3, [r0, #4]
    39fa:	3301      	adds	r3, #1
    39fc:	b29b      	uxth	r3, r3
    39fe:	8083      	strh	r3, [r0, #4]
  _cbuf[((tail)&(_size-1))] = value;
    3a00:	8842      	ldrh	r2, [r0, #2]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3a02:	f8b0 c002 	ldrh.w	ip, [r0, #2]
    3a06:	8803      	ldrh	r3, [r0, #0]
  _cbuf[((tail)&(_size-1))] = value;
    3a08:	f002 020f 	and.w	r2, r2, #15
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3a0c:	fa1f fc8c 	uxth.w	ip, ip
    3a10:	b29b      	uxth	r3, r3
  _cbuf[((tail)&(_size-1))] = value;
    3a12:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3a16:	f083 0310 	eor.w	r3, r3, #16
  _cbuf[((tail)&(_size-1))] = value;
    3a1a:	80d1      	strh	r1, [r2, #6]
  if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3a1c:	459c      	cmp	ip, r3
    3a1e:	d104      	bne.n	3a2a <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)+0x3a>
    3a20:	8803      	ldrh	r3, [r0, #0]
    3a22:	3301      	adds	r3, #1
    3a24:	f003 031f 	and.w	r3, r3, #31
    3a28:	8003      	strh	r3, [r0, #0]
  tail = ((tail + 1)&(2*_size-1));
    3a2a:	8843      	ldrh	r3, [r0, #2]
    3a2c:	3301      	adds	r3, #1
    3a2e:	f003 031f 	and.w	r3, r3, #31
    3a32:	8043      	strh	r3, [r0, #2]
}
    3a34:	4770      	bx	lr
    3a36:	bf00      	nop

00003a38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>:
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3a38:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
    3a3c:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
    3a40:	00db      	lsls	r3, r3, #3
    3a42:	d569      	bpl.n	3b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe0>
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3a44:	4b37      	ldr	r3, [pc, #220]	; (3b24 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xec>)
FCTP_FUNC volatile bool FCTP_OPT::fifo_filter_match(uint32_t id) {
    3a46:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3a4a:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    3a4c:	f04f 0e00 	mov.w	lr, #0
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3a50:	f641 6914 	movw	r9, #7700	; 0x1e14
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3a54:	f641 6704 	movw	r7, #7684	; 0x1e04
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3a58:	f3c6 6603 	ubfx	r6, r6, #24, #4
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3a5c:	f641 6808 	movw	r8, #7688	; 0x1e08
  uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3a60:	00f6      	lsls	r6, r6, #3
    3a62:	3608      	adds	r6, #8
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3a64:	e009      	b.n	3a7a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x42>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    3a66:	6813      	ldr	r3, [r2, #0]
    3a68:	0f5b      	lsrs	r3, r3, #29
    3a6a:	2b05      	cmp	r3, #5
    3a6c:	d034      	beq.n	3ad8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xa0>
  for (uint8_t mb_num = 0; mb_num < max_fifo_filters; mb_num++) { /* check fifo filters */
    3a6e:	f10e 0e01 	add.w	lr, lr, #1
    3a72:	fa5f f38e 	uxtb.w	r3, lr
    3a76:	429e      	cmp	r6, r3
    3a78:	d950      	bls.n	3b1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xe4>
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3a7a:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
    3a7e:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
    3a82:	f50c 52f0 	add.w	r2, ip, #7680	; 0x1e00
    3a86:	6813      	ldr	r3, [r2, #0]
    3a88:	0f5b      	lsrs	r3, r3, #29
    3a8a:	2b01      	cmp	r3, #1
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3a8c:	6813      	ldr	r3, [r2, #0]
    if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3a8e:	d00d      	beq.n	3aac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x74>
    else if ( (fifo_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3a90:	0f5b      	lsrs	r3, r3, #29
    3a92:	2b02      	cmp	r3, #2
    3a94:	d1e7      	bne.n	3a66 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x2e>
      if ( id >= fifo_filter_table[mb_num][1] && id <= fifo_filter_table[mb_num][2] ) return 1;
    3a96:	f85c 3007 	ldr.w	r3, [ip, r7]
    3a9a:	428b      	cmp	r3, r1
    3a9c:	d8e7      	bhi.n	3a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3a9e:	f85c 3008 	ldr.w	r3, [ip, r8]
    3aa2:	428b      	cmp	r3, r1
    3aa4:	d3e3      	bcc.n	3a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3aa6:	2001      	movs	r0, #1
}
    3aa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for ( uint8_t i = 0; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == fifo_filter_table[mb_num][i+1] ) return 1;
    3aac:	f413 7f60 	tst.w	r3, #896	; 0x380
    3ab0:	d0dd      	beq.n	3a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3ab2:	006d      	lsls	r5, r5, #1
    3ab4:	2300      	movs	r3, #0
    3ab6:	e004      	b.n	3ac2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x8a>
    3ab8:	6814      	ldr	r4, [r2, #0]
    3aba:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3abe:	4563      	cmp	r3, ip
    3ac0:	d2d5      	bcs.n	3a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
    3ac2:	3301      	adds	r3, #1
    3ac4:	eb05 0c03 	add.w	ip, r5, r3
    3ac8:	b2db      	uxtb	r3, r3
    3aca:	f50c 6cf0 	add.w	ip, ip, #1920	; 0x780
    3ace:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3ad2:	428c      	cmp	r4, r1
    3ad4:	d1f0      	bne.n	3ab8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x80>
    3ad6:	e7e6      	b.n	3aa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3ad8:	6813      	ldr	r3, [r2, #0]
    3ada:	f413 7f60 	tst.w	r3, #896	; 0x380
    3ade:	d0c6      	beq.n	3a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3ae0:	44cc      	add	ip, r9
    3ae2:	006d      	lsls	r5, r5, #1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3ae4:	2401      	movs	r4, #1
    3ae6:	e005      	b.n	3af4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xbc>
    3ae8:	6813      	ldr	r3, [r2, #0]
    3aea:	f3c3 13c2 	ubfx	r3, r3, #7, #3
    3aee:	3301      	adds	r3, #1
    3af0:	429c      	cmp	r4, r3
    3af2:	d2bc      	bcs.n	3a6e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x36>
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3af4:	192b      	adds	r3, r5, r4
    3af6:	f8dc a000 	ldr.w	sl, [ip]
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3afa:	3401      	adds	r4, #1
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3afc:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    3b00:	ea0a 0a01 	and.w	sl, sl, r1
      for ( uint8_t i = 1; i < ((fifo_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3b04:	b2e4      	uxtb	r4, r4
        if ( (id & fifo_filter_table[mb_num][5]) == (fifo_filter_table[mb_num][i] & fifo_filter_table[mb_num][5]) ) return 1;
    3b06:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    3b0a:	f8dc b000 	ldr.w	fp, [ip]
    3b0e:	ea03 030b 	and.w	r3, r3, fp
    3b12:	459a      	cmp	sl, r3
    3b14:	d1e8      	bne.n	3ae8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0xb0>
    3b16:	e7c6      	b.n	3aa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)+0x6e>
  if ( !(fifo_filter_table[0][0] & 0x10000000) ) return 1;
    3b18:	2001      	movs	r0, #1
}
    3b1a:	4770      	bx	lr
  return 0;
    3b1c:	2000      	movs	r0, #0
}
    3b1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3b22:	bf00      	nop
    3b24:	401d0000 	.word	0x401d0000

00003b28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>:
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3b28:	eb01 0141 	add.w	r1, r1, r1, lsl #1
FCTP_FUNC volatile bool FCTP_OPT::filter_match(FLEXCAN_MAILBOX mb_num, uint32_t id) {
    3b2c:	b570      	push	{r4, r5, r6, lr}
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3b2e:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    3b32:	f504 5e04 	add.w	lr, r4, #8448	; 0x2100
    3b36:	f8de 3000 	ldr.w	r3, [lr]
    3b3a:	00db      	lsls	r3, r3, #3
    3b3c:	d528      	bpl.n	3b90 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
  if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_MULTI ) {
    3b3e:	f8de 3000 	ldr.w	r3, [lr]
    3b42:	0f5b      	lsrs	r3, r3, #29
    3b44:	2b01      	cmp	r3, #1
    3b46:	d00b      	beq.n	3b60 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x38>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_RANGE ) {
    3b48:	f8de 3000 	ldr.w	r3, [lr]
    3b4c:	0f5b      	lsrs	r3, r3, #29
    3b4e:	2b02      	cmp	r3, #2
    3b50:	d042      	beq.n	3bd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0xb0>
  else if ( (mb_filter_table[mb_num][0] >> 29) == FLEXCAN_USERMASK ) {
    3b52:	f8de 3000 	ldr.w	r3, [lr]
    3b56:	0f5b      	lsrs	r3, r3, #29
    3b58:	2b05      	cmp	r3, #5
    3b5a:	d01b      	beq.n	3b94 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x6c>
  return 0;
    3b5c:	2000      	movs	r0, #0
}
    3b5e:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 0; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7); i++) if ( id == mb_filter_table[mb_num][i+1] ) return 1;
    3b60:	f8de 4000 	ldr.w	r4, [lr]
    3b64:	f414 7f60 	tst.w	r4, #896	; 0x380
    3b68:	d0f8      	beq.n	3b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3b6a:	2300      	movs	r3, #0
    3b6c:	004d      	lsls	r5, r1, #1
    3b6e:	e005      	b.n	3b7c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x54>
    3b70:	f8de 1000 	ldr.w	r1, [lr]
    3b74:	f3c1 1cc2 	ubfx	ip, r1, #7, #3
    3b78:	4563      	cmp	r3, ip
    3b7a:	d2ef      	bcs.n	3b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3b7c:	3301      	adds	r3, #1
    3b7e:	eb05 0c03 	add.w	ip, r5, r3
    3b82:	b2db      	uxtb	r3, r3
    3b84:	f50c 6c04 	add.w	ip, ip, #2112	; 0x840
    3b88:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
    3b8c:	4294      	cmp	r4, r2
    3b8e:	d1ef      	bne.n	3b70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x48>
  if ( !(mb_filter_table[mb_num][0] & 0x10000000) ) return 1;
    3b90:	2001      	movs	r0, #1
}
    3b92:	bd70      	pop	{r4, r5, r6, pc}
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3b94:	f8de 5000 	ldr.w	r5, [lr]
    3b98:	f415 7f60 	tst.w	r5, #896	; 0x380
    3b9c:	d0de      	beq.n	3b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3b9e:	f242 1514 	movw	r5, #8468	; 0x2114
    3ba2:	0049      	lsls	r1, r1, #1
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3ba4:	2301      	movs	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3ba6:	4425      	add	r5, r4
    3ba8:	e007      	b.n	3bba <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x92>
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3baa:	f8de 4000 	ldr.w	r4, [lr]
    3bae:	f3c4 1cc2 	ubfx	ip, r4, #7, #3
    3bb2:	f10c 0c01 	add.w	ip, ip, #1
    3bb6:	4563      	cmp	r3, ip
    3bb8:	d2d0      	bcs.n	3b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3bba:	682c      	ldr	r4, [r5, #0]
    3bbc:	ea04 0c02 	and.w	ip, r4, r2
    3bc0:	18cc      	adds	r4, r1, r3
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3bc2:	3301      	adds	r3, #1
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3bc4:	f504 6404 	add.w	r4, r4, #2112	; 0x840
    for ( uint8_t i = 1; i < ((mb_filter_table[mb_num][0] & 0x380) >> 7) + 1; i++) {
    3bc8:	b2db      	uxtb	r3, r3
      if ( (id & mb_filter_table[mb_num][5]) == (mb_filter_table[mb_num][i] & mb_filter_table[mb_num][5]) ) return 1;
    3bca:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
    3bce:	682e      	ldr	r6, [r5, #0]
    3bd0:	4034      	ands	r4, r6
    3bd2:	45a4      	cmp	ip, r4
    3bd4:	d1e9      	bne.n	3baa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x82>
    3bd6:	e7db      	b.n	3b90 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x68>
    if ( id >= mb_filter_table[mb_num][1] && id <= mb_filter_table[mb_num][2] ) return 1;
    3bd8:	f242 1304 	movw	r3, #8452	; 0x2104
    3bdc:	58e3      	ldr	r3, [r4, r3]
    3bde:	4293      	cmp	r3, r2
    3be0:	d8bc      	bhi.n	3b5c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)+0x34>
    3be2:	f242 1308 	movw	r3, #8456	; 0x2108
    3be6:	58e0      	ldr	r0, [r4, r3]
    3be8:	4290      	cmp	r0, r2
    3bea:	bf34      	ite	cc
    3bec:	2000      	movcc	r0, #0
    3bee:	2001      	movcs	r0, #1
}
    3bf0:	bd70      	pop	{r4, r5, r6, pc}
    3bf2:	bf00      	nop

00003bf4 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>:
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3bf4:	8843      	ldrh	r3, [r0, #2]
    3bf6:	f04f 0c1a 	mov.w	ip, #26
    3bfa:	b2db      	uxtb	r3, r3
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    3bfc:	b510      	push	{r4, lr}
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3bfe:	fb0c 0303 	mla	r3, ip, r3, r0
void Circular_Buffer<T,_size,multi>::write(const T *buffer, uint16_t length) {
    3c02:	4604      	mov	r4, r0
    _cabuf[((tail)&(_size-1))][0] = length & 0xFF00;
    3c04:	2000      	movs	r0, #0
    3c06:	f883 0106 	strb.w	r0, [r3, #262]	; 0x106
    _cabuf[((tail)&(_size-1))][1] = length & 0xFF;
    3c0a:	8863      	ldrh	r3, [r4, #2]
    3c0c:	b2db      	uxtb	r3, r3
    3c0e:	fb0c 4303 	mla	r3, ip, r3, r4
    3c12:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
    memmove(_cabuf[((tail)&(_size-1))]+2,buffer,length*sizeof(T));
    3c16:	8860      	ldrh	r0, [r4, #2]
    3c18:	b2c0      	uxtb	r0, r0
    3c1a:	fb0c 4000 	mla	r0, ip, r0, r4
    3c1e:	f500 7084 	add.w	r0, r0, #264	; 0x108
    3c22:	f004 fea3 	bl	896c <memmove>
    if ( tail == ((head ^ _size)) ) head = ((head + 1)&(2*_size-1));
    3c26:	8862      	ldrh	r2, [r4, #2]
    3c28:	8823      	ldrh	r3, [r4, #0]
    3c2a:	b292      	uxth	r2, r2
    3c2c:	b29b      	uxth	r3, r3
    3c2e:	f483 7380 	eor.w	r3, r3, #256	; 0x100
    3c32:	429a      	cmp	r2, r3
    3c34:	d104      	bne.n	3c40 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x4c>
    3c36:	8823      	ldrh	r3, [r4, #0]
    3c38:	3301      	adds	r3, #1
    3c3a:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3c3e:	8023      	strh	r3, [r4, #0]
    tail = ((tail + 1)&(2*_size-1));
    3c40:	8863      	ldrh	r3, [r4, #2]
    3c42:	3301      	adds	r3, #1
    3c44:	f3c3 0308 	ubfx	r3, r3, #0, #9
    3c48:	8063      	strh	r3, [r4, #2]
    if ( _available < _size ) _available++;
    3c4a:	88a3      	ldrh	r3, [r4, #4]
    3c4c:	b29b      	uxth	r3, r3
    3c4e:	2bff      	cmp	r3, #255	; 0xff
    3c50:	d803      	bhi.n	3c5a <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)+0x66>
    3c52:	88a3      	ldrh	r3, [r4, #4]
    3c54:	3301      	adds	r3, #1
    3c56:	b29b      	uxth	r3, r3
    3c58:	80a3      	strh	r3, [r4, #4]
}
    3c5a:	bd10      	pop	{r4, pc}

00003c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    3c5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    3c60:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    3c62:	b08d      	sub	sp, #52	; 0x34
    3c64:	460e      	mov	r6, r1
    3c66:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    3c68:	466c      	mov	r4, sp
    3c6a:	4605      	mov	r5, r0
    3c6c:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3c70:	f04f 0901 	mov.w	r9, #1
    3c74:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 3d18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    3c78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    3c7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3c7e:	e89c 0003 	ldmia.w	ip, {r0, r1}
    3c82:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    3c86:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    3c8a:	b15c      	cbz	r4, 3ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3c8c:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    3c90:	68a3      	ldr	r3, [r4, #8]
    3c92:	fa09 f102 	lsl.w	r1, r9, r2
    3c96:	4219      	tst	r1, r3
    3c98:	d023      	beq.n	3ce2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    3c9a:	6823      	ldr	r3, [r4, #0]
    3c9c:	f8d3 b000 	ldr.w	fp, [r3]
    3ca0:	45d3      	cmp	fp, sl
    3ca2:	d119      	bne.n	3cd8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    3ca4:	4545      	cmp	r5, r8
    3ca6:	d1ee      	bne.n	3c86 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    3ca8:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    3cac:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    3cb0:	b33b      	cbz	r3, 3d02 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    3cb2:	6830      	ldr	r0, [r6, #0]
    3cb4:	ac06      	add	r4, sp, #24
    3cb6:	6871      	ldr	r1, [r6, #4]
    3cb8:	68b2      	ldr	r2, [r6, #8]
    3cba:	68f3      	ldr	r3, [r6, #12]
    3cbc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3cbe:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    3cc0:	2218      	movs	r2, #24
    3cc2:	6971      	ldr	r1, [r6, #20]
    3cc4:	c403      	stmia	r4!, {r0, r1}
    3cc6:	eb0d 0102 	add.w	r1, sp, r2
    3cca:	f107 0014 	add.w	r0, r7, #20
    3cce:	f7ff ff91 	bl	3bf4 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    3cd2:	b00d      	add	sp, #52	; 0x34
    3cd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    3cd8:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3cdc:	4669      	mov	r1, sp
    3cde:	4620      	mov	r0, r4
    3ce0:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    3ce2:	7c23      	ldrb	r3, [r4, #16]
    3ce4:	2b00      	cmp	r3, #0
    3ce6:	d0dd      	beq.n	3ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    3ce8:	6823      	ldr	r3, [r4, #0]
    3cea:	f8d3 b000 	ldr.w	fp, [r3]
    3cee:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3cf2:	45d3      	cmp	fp, sl
    3cf4:	d0d6      	beq.n	3ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    3cf6:	4620      	mov	r0, r4
    3cf8:	f04f 32ff 	mov.w	r2, #4294967295
    3cfc:	4669      	mov	r1, sp
    3cfe:	47d8      	blx	fp
    3d00:	e7d0      	b.n	3ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    3d02:	7d33      	ldrb	r3, [r6, #20]
    3d04:	4632      	mov	r2, r6
    3d06:	a906      	add	r1, sp, #24
    3d08:	4638      	mov	r0, r7
    3d0a:	f88d 3018 	strb.w	r3, [sp, #24]
    3d0e:	f7ff f87f 	bl	2e10 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    3d12:	b00d      	add	sp, #52	; 0x34
    3d14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3d18:	00000f05 	.word	0x00000f05

00003d1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  mb_filter_table[mb_num][4] = id4; // id4
  mb_filter_table[mb_num][5] = id5; // id5
}

FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
  if ( !distribution ) return; /* distribution not enabled */
    3d1c:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    3d20:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    3d24:	2b00      	cmp	r3, #0
    3d26:	f000 80db 	beq.w	3ee0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  CAN_message_t frame = msg;

  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3d2a:	f8df c26c 	ldr.w	ip, [pc, #620]	; 3f98 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    3d2e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    3d32:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    3d34:	b089      	sub	sp, #36	; 0x24
    3d36:	4605      	mov	r5, r0
    3d38:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    3d3a:	ac02      	add	r4, sp, #8
    3d3c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    3d3e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3d40:	e897 0003 	ldmia.w	r7, {r0, r1}
    3d44:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    3d48:	f8dc 3000 	ldr.w	r3, [ip]
    3d4c:	009b      	lsls	r3, r3, #2
    3d4e:	d552      	bpl.n	3df6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3d50:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    3d54:	2400      	movs	r4, #0
        }
      }
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
            frame.mb = FIFO;
    3d56:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    3d5a:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    3d5e:	4622      	mov	r2, r4
    3d60:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    3d64:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3d68:	e00c      	b.n	3d84 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3d6a:	0f5b      	lsrs	r3, r3, #29
    3d6c:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3d6e:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3d70:	f000 809a 	beq.w	3ea8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    3d74:	0f5b      	lsrs	r3, r3, #29
    3d76:	2b05      	cmp	r3, #5
    3d78:	f000 80dd 	beq.w	3f36 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    3d7c:	3401      	adds	r4, #1
    3d7e:	b2e2      	uxtb	r2, r4
    3d80:	4592      	cmp	sl, r2
    3d82:	d938      	bls.n	3df6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    3d84:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3d88:	2b63      	cmp	r3, #99	; 0x63
    3d8a:	d034      	beq.n	3df6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    3d8c:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    3d90:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    3d94:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    3d98:	683b      	ldr	r3, [r7, #0]
    3d9a:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3d9e:	d0ed      	beq.n	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3da0:	683b      	ldr	r3, [r7, #0]
    3da2:	0f5b      	lsrs	r3, r3, #29
    3da4:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3da6:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3da8:	d1df      	bne.n	3d6a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3daa:	f3c3 4300 	ubfx	r3, r3, #16, #1
    3dae:	79f2      	ldrb	r2, [r6, #7]
    3db0:	429a      	cmp	r2, r3
    3db2:	d1e3      	bne.n	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3db4:	683b      	ldr	r3, [r7, #0]
    3db6:	f413 7f60 	tst.w	r3, #896	; 0x380
    3dba:	d0df      	beq.n	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    3dbc:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    3dc0:	2300      	movs	r3, #0
    3dc2:	e006      	b.n	3dd2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    3dc4:	683a      	ldr	r2, [r7, #0]
    3dc6:	fa5f f388 	uxtb.w	r3, r8
    3dca:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    3dce:	4293      	cmp	r3, r2
    3dd0:	d2d4      	bcs.n	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    3dd2:	f103 0801 	add.w	r8, r3, #1
    3dd6:	9a02      	ldr	r2, [sp, #8]
    3dd8:	eb0b 0308 	add.w	r3, fp, r8
    3ddc:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    3de0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    3de4:	429a      	cmp	r2, r3
    3de6:	d1ed      	bne.n	3dc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    3de8:	a902      	add	r1, sp, #8
    3dea:	4628      	mov	r0, r5
            frame.mb = FIFO;
    3dec:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    3df0:	f7ff ff34 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3df4:	e7e6      	b.n	3dc4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
        }
      }
    } /* end of fifo scan */
  } /* end of fifo checking */

  frame.idhit = 0;
    3df6:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3df8:	4f67      	ldr	r7, [pc, #412]	; (3f98 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    3dfa:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3dfe:	683c      	ldr	r4, [r7, #0]
    3e00:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    3e04:	d03f      	beq.n	3e86 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    3e06:	f7fd fa3f 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>

  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3e0a:	683b      	ldr	r3, [r7, #0]
    3e0c:	4604      	mov	r4, r0
    3e0e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3e12:	3301      	adds	r3, #1
    3e14:	4283      	cmp	r3, r0
    3e16:	d933      	bls.n	3e80 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
          struct2queueRx(frame);
        }
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    3e18:	f242 1704 	movw	r7, #8452	; 0x2104
    3e1c:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3e20:	f8df 9174 	ldr.w	r9, [pc, #372]	; 3f98 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    3e24:	f996 3014 	ldrsb.w	r3, [r6, #20]
    3e28:	42a3      	cmp	r3, r4
    3e2a:	d020      	beq.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    3e2c:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    3e30:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    3e34:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    3e38:	f8da 3000 	ldr.w	r3, [sl]
    3e3c:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    3e40:	d015      	beq.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    3e42:	f8da 3000 	ldr.w	r3, [sl]
    3e46:	79f0      	ldrb	r0, [r6, #7]
    3e48:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    3e4c:	4298      	cmp	r0, r3
    3e4e:	d10e      	bne.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3e50:	f8da 3000 	ldr.w	r3, [sl]
    3e54:	0f5b      	lsrs	r3, r3, #29
    3e56:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3e58:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    3e5c:	d041      	beq.n	3ee2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    3e5e:	0f5b      	lsrs	r3, r3, #29
    3e60:	2b02      	cmp	r3, #2
    3e62:	d012      	beq.n	3e8a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    3e64:	f8da 3000 	ldr.w	r3, [sl]
    3e68:	0f5b      	lsrs	r3, r3, #29
    3e6a:	2b05      	cmp	r3, #5
    3e6c:	d05b      	beq.n	3f26 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3e6e:	f8d9 3000 	ldr.w	r3, [r9]
    3e72:	3401      	adds	r4, #1
    3e74:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    3e78:	b2e4      	uxtb	r4, r4
    3e7a:	3301      	adds	r3, #1
    3e7c:	429c      	cmp	r4, r3
    3e7e:	d3d1      	bcc.n	3e24 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
        frame.mb = i;
        struct2queueRx(frame);
      }
    }
  } /* end of mb scan */
}
    3e80:	b009      	add	sp, #36	; 0x24
    3e82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    3e86:	683b      	ldr	r3, [r7, #0]
    3e88:	e7c6      	b.n	3e18 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    3e8a:	59d1      	ldr	r1, [r2, r7]
    3e8c:	9b02      	ldr	r3, [sp, #8]
    3e8e:	428b      	cmp	r3, r1
    3e90:	d3ed      	bcc.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3e92:	f852 2008 	ldr.w	r2, [r2, r8]
    3e96:	4293      	cmp	r3, r2
    3e98:	d8e9      	bhi.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    3e9a:	a902      	add	r1, sp, #8
    3e9c:	4628      	mov	r0, r5
        frame.mb = i;
    3e9e:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    3ea2:	f7ff fedb 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3ea6:	e7e2      	b.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    3ea8:	f3c3 4300 	ubfx	r3, r3, #16, #1
    3eac:	79f2      	ldrb	r2, [r6, #7]
    3eae:	429a      	cmp	r2, r3
    3eb0:	f47f af64 	bne.w	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    3eb4:	f641 6304 	movw	r3, #7684	; 0x1e04
    3eb8:	f85b 2003 	ldr.w	r2, [fp, r3]
    3ebc:	9b02      	ldr	r3, [sp, #8]
    3ebe:	4293      	cmp	r3, r2
    3ec0:	f4ff af5c 	bcc.w	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    3ec4:	f641 6208 	movw	r2, #7688	; 0x1e08
    3ec8:	f85b 2002 	ldr.w	r2, [fp, r2]
    3ecc:	4293      	cmp	r3, r2
    3ece:	f63f af55 	bhi.w	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    3ed2:	a902      	add	r1, sp, #8
    3ed4:	4628      	mov	r0, r5
          frame.mb = FIFO;
    3ed6:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    3eda:	f7ff febf 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3ede:	e74d      	b.n	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    3ee0:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3ee2:	f413 7f60 	tst.w	r3, #896	; 0x380
    3ee6:	d0c2      	beq.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    3ee8:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    3eea:	2300      	movs	r3, #0
    3eec:	e007      	b.n	3efe <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    3eee:	f8da 1000 	ldr.w	r1, [sl]
    3ef2:	fa5f f38b 	uxtb.w	r3, fp
    3ef6:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    3efa:	428b      	cmp	r3, r1
    3efc:	d2b7      	bcs.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    3efe:	f103 0b01 	add.w	fp, r3, #1
    3f02:	9902      	ldr	r1, [sp, #8]
    3f04:	eb02 030b 	add.w	r3, r2, fp
    3f08:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    3f0c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    3f10:	4299      	cmp	r1, r3
    3f12:	d1ec      	bne.n	3eee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    3f14:	a902      	add	r1, sp, #8
    3f16:	4628      	mov	r0, r5
    3f18:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    3f1a:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    3f1e:	f7ff fe9d 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3f22:	9a00      	ldr	r2, [sp, #0]
    3f24:	e7e3      	b.n	3eee <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    3f26:	9a02      	ldr	r2, [sp, #8]
    3f28:	4621      	mov	r1, r4
    3f2a:	4628      	mov	r0, r5
    3f2c:	f7ff fcd6 	bl	38dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    3f30:	2800      	cmp	r0, #0
    3f32:	d09c      	beq.n	3e6e <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    3f34:	e7b1      	b.n	3e9a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3f36:	683b      	ldr	r3, [r7, #0]
    3f38:	f413 7f60 	tst.w	r3, #896	; 0x380
    3f3c:	f43f af1e 	beq.w	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3f40:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3f44:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3f46:	445b      	add	r3, fp
    3f48:	e00a      	b.n	3f60 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    3f4a:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    3f4e:	3701      	adds	r7, #1
    3f50:	6809      	ldr	r1, [r1, #0]
    3f52:	b2ff      	uxtb	r7, r7
    3f54:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    3f58:	3101      	adds	r1, #1
    3f5a:	428f      	cmp	r7, r1
    3f5c:	f4bf af0e 	bcs.w	3d7c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    3f60:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    3f64:	6818      	ldr	r0, [r3, #0]
    3f66:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    3f6a:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    3f6e:	9902      	ldr	r1, [sp, #8]
    3f70:	f8d3 c000 	ldr.w	ip, [r3]
    3f74:	4008      	ands	r0, r1
    3f76:	ea0e 010c 	and.w	r1, lr, ip
    3f7a:	4288      	cmp	r0, r1
    3f7c:	d1e5      	bne.n	3f4a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    3f7e:	a902      	add	r1, sp, #8
    3f80:	4628      	mov	r0, r5
    3f82:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    3f84:	f88d 200e 	strb.w	r2, [sp, #14]
    3f88:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    3f8a:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    3f8e:	f7ff fe65 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    3f92:	e9dd 2300 	ldrd	r2, r3, [sp]
    3f96:	e7d8      	b.n	3f4a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    3f98:	401d4000 	.word	0x401d4000

00003f9c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3f9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    3fa0:	4d94      	ldr	r5, [pc, #592]	; (41f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3fa2:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3fa4:	4f94      	ldr	r7, [pc, #592]	; (41f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    3fa6:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    3fa8:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    3faa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3fac:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3fae:	e895 0003 	ldmia.w	r5, {r0, r1}
    3fb2:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3fb6:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    3fb8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3fba:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    3fbe:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3fc0:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    3fc2:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3fc4:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    3fc8:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    3fca:	d103      	bne.n	3fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    3fcc:	683a      	ldr	r2, [r7, #0]
    3fce:	0094      	lsls	r4, r2, #2
    3fd0:	f100 811a 	bmi.w	4208 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3fd4:	9b03      	ldr	r3, [sp, #12]
    3fd6:	f043 0301 	orr.w	r3, r3, #1
    3fda:	f1bb 0f00 	cmp.w	fp, #0
    3fde:	f000 8105 	beq.w	41ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    3fe2:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3fe6:	4d84      	ldr	r5, [pc, #528]	; (41f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3fe8:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3fec:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3fee:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ff0:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    3ff4:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    3ff6:	f000 8284 	beq.w	4502 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    3ffa:	f7fd f945 	bl	1288 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    3ffe:	682b      	ldr	r3, [r5, #0]
    4000:	4604      	mov	r4, r0
    4002:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4006:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    4008:	4283      	cmp	r3, r0
    400a:	f240 80c2 	bls.w	4192 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    400e:	4287      	cmp	r7, r0
    4010:	f240 80bf 	bls.w	4192 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    4014:	9b04      	ldr	r3, [sp, #16]
    4016:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4018:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 41f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    401c:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    4020:	b2fd      	uxtb	r5, r7
    4022:	9305      	str	r3, [sp, #20]
    4024:	e018      	b.n	4058 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    4026:	2a04      	cmp	r2, #4
    4028:	f000 8162 	beq.w	42f0 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    402c:	2a08      	cmp	r2, #8
    402e:	f000 8203 	beq.w	4438 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4032:	f8d9 3000 	ldr.w	r3, [r9]
    4036:	b2fc      	uxtb	r4, r7
    4038:	9a01      	ldr	r2, [sp, #4]
    403a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    403e:	3301      	adds	r3, #1
    4040:	42a2      	cmp	r2, r4
    4042:	bf88      	it	hi
    4044:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    4046:	f105 0501 	add.w	r5, r5, #1
    404a:	bf94      	ite	ls
    404c:	2301      	movls	r3, #1
    404e:	2300      	movhi	r3, #0
    4050:	2b00      	cmp	r3, #0
    4052:	f040 809e 	bne.w	4192 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    4056:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    4058:	f1c4 0220 	rsb	r2, r4, #32
    405c:	9b02      	ldr	r3, [sp, #8]
    405e:	f1a4 0a20 	sub.w	sl, r4, #32
    4062:	fa06 f102 	lsl.w	r1, r6, r2
    4066:	40e3      	lsrs	r3, r4
    4068:	430b      	orrs	r3, r1
    406a:	fa26 f10a 	lsr.w	r1, r6, sl
    406e:	430b      	orrs	r3, r1
    4070:	07d8      	lsls	r0, r3, #31
    4072:	d5de      	bpl.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    4074:	9b03      	ldr	r3, [sp, #12]
    4076:	fa0b f202 	lsl.w	r2, fp, r2
    407a:	40e3      	lsrs	r3, r4
    407c:	4313      	orrs	r3, r2
    407e:	fa2b f20a 	lsr.w	r2, fp, sl
    4082:	4313      	orrs	r3, r2
    4084:	07d9      	lsls	r1, r3, #31
    4086:	d5d4      	bpl.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    4088:	f8df 8178 	ldr.w	r8, [pc, #376]	; 4204 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    408c:	44a0      	add	r8, r4
    408e:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    4092:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    4096:	0e19      	lsrs	r1, r3, #24
    4098:	f3c3 6203 	ubfx	r2, r3, #24, #4
    409c:	f001 010b 	and.w	r1, r1, #11
    40a0:	2902      	cmp	r1, #2
    40a2:	d1c0      	bne.n	4026 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    40a4:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    40a8:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    40ac:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    40b0:	2800      	cmp	r0, #0
    40b2:	bf12      	itee	ne
    40b4:	f04f 0c01 	movne.w	ip, #1
    40b8:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    40bc:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    40be:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    40c0:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    40c4:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    40c6:	d102      	bne.n	40ce <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    40c8:	2201      	movs	r2, #1
    40ca:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    40ce:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    40d2:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    40d6:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    40da:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    40dc:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    40e0:	9b05      	ldr	r3, [sp, #20]
    40e2:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    40e6:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    40ea:	f8d8 3008 	ldr.w	r3, [r8, #8]
    40ee:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    40f2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    40f6:	ea4f 2313 	mov.w	r3, r3, lsr #8
    40fa:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    40fe:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4102:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4106:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    410a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    410e:	ea4f 6313 	mov.w	r3, r3, lsr #24
    4112:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4116:	f8d8 300c 	ldr.w	r3, [r8, #12]
    411a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    411e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4122:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4126:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    412a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    412e:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4132:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4136:	f8d8 300c 	ldr.w	r3, [r8, #12]
    413a:	ea4f 6313 	mov.w	r3, r3, lsr #24
    413e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    4142:	bf14      	ite	ne
    4144:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    4148:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    414c:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    414e:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    4152:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4156:	f04f 0301 	mov.w	r3, #1
    415a:	d834      	bhi.n	41c6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    415c:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4160:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4162:	4621      	mov	r1, r4
    4164:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4166:	4313      	orrs	r3, r2
    4168:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    416c:	9a08      	ldr	r2, [sp, #32]
    416e:	f7ff fbb5 	bl	38dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4172:	2800      	cmp	r0, #0
    4174:	d135      	bne.n	41e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    4176:	a908      	add	r1, sp, #32
    4178:	9804      	ldr	r0, [sp, #16]
    417a:	f7ff fdcf 	bl	3d1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    417e:	a808      	add	r0, sp, #32
    4180:	f3af 8000 	nop.w
      ext_output2(msg);
    4184:	a808      	add	r0, sp, #32
    4186:	f3af 8000 	nop.w
      ext_output3(msg);
    418a:	a808      	add	r0, sp, #32
    418c:	f3af 8000 	nop.w
    4190:	e74f      	b.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    4192:	4e19      	ldr	r6, [pc, #100]	; (41f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4194:	4d19      	ldr	r5, [pc, #100]	; (41fc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    4196:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4198:	682a      	ldr	r2, [r5, #0]
    419a:	4b19      	ldr	r3, [pc, #100]	; (4200 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    419c:	4062      	eors	r2, r4
    419e:	4013      	ands	r3, r2
    41a0:	b143      	cbz	r3, 41b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    41a2:	9b04      	ldr	r3, [sp, #16]
    41a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    41a8:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    41ac:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    41ae:	2b0f      	cmp	r3, #15
    41b0:	f240 81a9 	bls.w	4506 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    41b4:	4a10      	ldr	r2, [pc, #64]	; (41f8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    41b6:	6a13      	ldr	r3, [r2, #32]
    41b8:	4323      	orrs	r3, r4
    41ba:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    41bc:	f3bf 8f4f 	dsb	sy
}
    41c0:	b01b      	add	sp, #108	; 0x6c
    41c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    41c6:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    41ca:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    41ce:	4621      	mov	r1, r4
    41d0:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    41d2:	4313      	orrs	r3, r2
    41d4:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    41d8:	9a08      	ldr	r2, [sp, #32]
    41da:	f7ff fb7f 	bl	38dc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    41de:	2800      	cmp	r0, #0
    41e0:	d0c9      	beq.n	4176 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    41e2:	a908      	add	r1, sp, #32
    41e4:	9804      	ldr	r0, [sp, #16]
    41e6:	f7ff fd39 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    41ea:	e7c4      	b.n	4176 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    41ec:	fab3 f383 	clz	r3, r3
    41f0:	3320      	adds	r3, #32
    41f2:	e6f8      	b.n	3fe6 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    41f4:	200003b0 	.word	0x200003b0
    41f8:	401d4000 	.word	0x401d4000
    41fc:	2000a358 	.word	0x2000a358
    4200:	0007ffbf 	.word	0x0007ffbf
    4204:	0401d408 	.word	0x0401d408
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    4208:	0689      	lsls	r1, r1, #26
    420a:	f57f aee3 	bpl.w	3fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    420e:	0682      	lsls	r2, r0, #26
    4210:	f57f aee0 	bpl.w	3fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    4214:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4218:	4cc3      	ldr	r4, [pc, #780]	; (4528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    421a:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    421e:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    4222:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    4226:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    4228:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    422c:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    4230:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4234:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    4238:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    423c:	bf18      	it	ne
    423e:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4240:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    4244:	bf08      	it	eq
    4246:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    4248:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    424c:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4250:	bf08      	it	eq
    4252:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4254:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    4258:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    425a:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    425c:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    4260:	40d1      	lsrs	r1, r2
    4262:	3208      	adds	r2, #8
    4264:	2a20      	cmp	r2, #32
    4266:	f800 1d01 	strb.w	r1, [r0, #-1]!
    426a:	d1f7      	bne.n	425c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    426c:	a80d      	add	r0, sp, #52	; 0x34
    426e:	49ae      	ldr	r1, [pc, #696]	; (4528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    4270:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    4274:	40da      	lsrs	r2, r3
    4276:	3308      	adds	r3, #8
    4278:	2b20      	cmp	r3, #32
    427a:	f800 2d01 	strb.w	r2, [r0, #-1]!
    427e:	d1f7      	bne.n	4270 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    4280:	9b04      	ldr	r3, [sp, #16]
    4282:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    4286:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    428a:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    428e:	2363      	movs	r3, #99	; 0x63
    4290:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    4294:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4296:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4298:	f043 0320 	orr.w	r3, r3, #32
    429c:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    429e:	9b03      	ldr	r3, [sp, #12]
    42a0:	065d      	lsls	r5, r3, #25
    42a2:	d503      	bpl.n	42ac <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    42a4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    42a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    42aa:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    42ac:	9b03      	ldr	r3, [sp, #12]
    42ae:	061c      	lsls	r4, r3, #24
    42b0:	d504      	bpl.n	42bc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    42b2:	4a9d      	ldr	r2, [pc, #628]	; (4528 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    42b4:	6b13      	ldr	r3, [r2, #48]	; 0x30
    42b6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    42ba:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    42bc:	9c04      	ldr	r4, [sp, #16]
    42be:	a908      	add	r1, sp, #32
    42c0:	4620      	mov	r0, r4
    42c2:	f7ff fd2b 	bl	3d1c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    42c6:	a808      	add	r0, sp, #32
    42c8:	f3af 8000 	nop.w
      ext_output2(msg);
    42cc:	a808      	add	r0, sp, #32
    42ce:	f3af 8000 	nop.w
      ext_output3(msg);
    42d2:	a808      	add	r0, sp, #32
    42d4:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    42d8:	9908      	ldr	r1, [sp, #32]
    42da:	4620      	mov	r0, r4
    42dc:	f7ff fa86 	bl	37ec <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    42e0:	2800      	cmp	r0, #0
    42e2:	f43f ae77 	beq.w	3fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    42e6:	a908      	add	r1, sp, #32
    42e8:	9804      	ldr	r0, [sp, #16]
    42ea:	f7ff fcb7 	bl	3c5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    42ee:	e671      	b.n	3fd4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    42f0:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    42f4:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    42f6:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    42fa:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    42fe:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4302:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4306:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    430a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    430e:	bf18      	it	ne
    4310:	2101      	movne	r1, #1
      msg.bus = busNumber;
    4312:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4314:	bf04      	itt	eq
    4316:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4318:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    431a:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    431e:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4320:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4324:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4328:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    432a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    432e:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4332:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4336:	0a1b      	lsrs	r3, r3, #8
    4338:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    433c:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4340:	0c1b      	lsrs	r3, r3, #16
    4342:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4346:	f8d8 3008 	ldr.w	r3, [r8, #8]
    434a:	0e1b      	lsrs	r3, r3, #24
    434c:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4350:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4354:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4358:	f8d8 300c 	ldr.w	r3, [r8, #12]
    435c:	0a1b      	lsrs	r3, r3, #8
    435e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4362:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4366:	0c1b      	lsrs	r3, r3, #16
    4368:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    436c:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    4370:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4374:	f8d8 200c 	ldr.w	r2, [r8, #12]
    4378:	0e12      	lsrs	r2, r2, #24
    437a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    437e:	b10b      	cbz	r3, 4384 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    4380:	a808      	add	r0, sp, #32
    4382:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4384:	9b05      	ldr	r3, [sp, #20]
    4386:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    438a:	b10b      	cbz	r3, 4390 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    438c:	a808      	add	r0, sp, #32
    438e:	4798      	blx	r3
    4390:	9904      	ldr	r1, [sp, #16]
    4392:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4396:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    439a:	9207      	str	r2, [sp, #28]
    439c:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    439e:	2b00      	cmp	r3, #0
    43a0:	f000 80c4 	beq.w	452c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    43a4:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    43a8:	221a      	movs	r2, #26
    43aa:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    43ae:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    43b2:	46e0      	mov	r8, ip
    43b4:	fb02 1303 	mla	r3, r2, r3, r1
    43b8:	f641 3232 	movw	r2, #6962	; 0x1b32
    43bc:	a90e      	add	r1, sp, #56	; 0x38
    43be:	eb03 0a02 	add.w	sl, r3, r2
    43c2:	9106      	str	r1, [sp, #24]
    43c4:	468e      	mov	lr, r1
    43c6:	5898      	ldr	r0, [r3, r2]
    43c8:	f8da 1004 	ldr.w	r1, [sl, #4]
    43cc:	f8da 2008 	ldr.w	r2, [sl, #8]
    43d0:	f8da 300c 	ldr.w	r3, [sl, #12]
    43d4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    43d8:	f8da 0010 	ldr.w	r0, [sl, #16]
    43dc:	f8da 1014 	ldr.w	r1, [sl, #20]
    43e0:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    43e4:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    43e8:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    43ec:	e898 0003 	ldmia.w	r8, {r0, r1}
    43f0:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    43f4:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    43f8:	1c5a      	adds	r2, r3, #1
    43fa:	f000 80a6 	beq.w	454a <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    43fe:	429c      	cmp	r4, r3
    4400:	f47f ae17 	bne.w	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    4404:	9a06      	ldr	r2, [sp, #24]
    4406:	b2e1      	uxtb	r1, r4
    4408:	9804      	ldr	r0, [sp, #16]
    440a:	f7fe fd27 	bl	2e5c <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    440e:	9a07      	ldr	r2, [sp, #28]
    4410:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4414:	3301      	adds	r3, #1
    4416:	f003 031f 	and.w	r3, r3, #31
    441a:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    441e:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4422:	b29b      	uxth	r3, r3
    4424:	2b00      	cmp	r3, #0
    4426:	f43f ae04 	beq.w	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    442a:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    442e:	3b01      	subs	r3, #1
    4430:	b29b      	uxth	r3, r3
    4432:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4436:	e5fc      	b.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4438:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    443c:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    443e:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4442:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4446:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    444a:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    444e:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4452:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4456:	bf18      	it	ne
    4458:	2101      	movne	r1, #1
      msg.bus = busNumber;
    445a:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    445c:	bf04      	itt	eq
    445e:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4460:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4462:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4466:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4468:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    446c:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4470:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4472:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4476:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    447a:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    447e:	0a1b      	lsrs	r3, r3, #8
    4480:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4484:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4488:	0c1b      	lsrs	r3, r3, #16
    448a:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    448e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4492:	0e1b      	lsrs	r3, r3, #24
    4494:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4498:	f8d8 300c 	ldr.w	r3, [r8, #12]
    449c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    44a0:	f8d8 300c 	ldr.w	r3, [r8, #12]
    44a4:	0a1b      	lsrs	r3, r3, #8
    44a6:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    44aa:	f8d8 300c 	ldr.w	r3, [r8, #12]
    44ae:	0c1b      	lsrs	r3, r3, #16
    44b0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    44b4:	f8d8 300c 	ldr.w	r3, [r8, #12]
    44b8:	0e1b      	lsrs	r3, r3, #24
    44ba:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    44be:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    44c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    44c6:	b10b      	cbz	r3, 44cc <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    44c8:	a808      	add	r0, sp, #32
    44ca:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    44cc:	9b05      	ldr	r3, [sp, #20]
    44ce:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    44d2:	b10b      	cbz	r3, 44d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    44d4:	a808      	add	r0, sp, #32
    44d6:	4798      	blx	r3
        uint16_t size() { return _available; }
    44d8:	9904      	ldr	r1, [sp, #16]
    44da:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    44de:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    44e2:	9207      	str	r2, [sp, #28]
    44e4:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    44e6:	2b00      	cmp	r3, #0
    44e8:	f47f af5c 	bne.w	43a4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    44ec:	2c1f      	cmp	r4, #31
    44ee:	f04f 0301 	mov.w	r3, #1
    44f2:	d835      	bhi.n	4560 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    44f4:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    44f8:	40a3      	lsls	r3, r4
    44fa:	4313      	orrs	r3, r2
    44fc:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    4500:	e597      	b.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4502:	682b      	ldr	r3, [r5, #0]
    4504:	e586      	b.n	4014 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    4506:	9f04      	ldr	r7, [sp, #16]
    4508:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    450c:	4621      	mov	r1, r4
    450e:	4438      	add	r0, r7
    4510:	f7ff fa4a 	bl	39a8 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    4514:	69f1      	ldr	r1, [r6, #28]
    4516:	f641 5098 	movw	r0, #7576	; 0x1d98
    451a:	b289      	uxth	r1, r1
    451c:	4438      	add	r0, r7
    451e:	f7ff fa67 	bl	39f0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    4522:	602c      	str	r4, [r5, #0]
    4524:	e646      	b.n	41b4 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    4526:	bf00      	nop
    4528:	401d4000 	.word	0x401d4000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    452c:	2c1f      	cmp	r4, #31
    452e:	f04f 0301 	mov.w	r3, #1
    4532:	d80d      	bhi.n	4550 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    4534:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4538:	40a3      	lsls	r3, r4
    453a:	4313      	orrs	r3, r2
    453c:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4540:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    4544:	f8c8 3000 	str.w	r3, [r8]
    4548:	e573      	b.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    454a:	9a06      	ldr	r2, [sp, #24]
    454c:	4621      	mov	r1, r4
    454e:	e75b      	b.n	4408 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4550:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4554:	fa03 f30a 	lsl.w	r3, r3, sl
    4558:	4313      	orrs	r3, r2
    455a:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    455e:	e7ef      	b.n	4540 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4560:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4564:	fa03 f30a 	lsl.w	r3, r3, sl
    4568:	4313      	orrs	r3, r2
    456a:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    456e:	e560      	b.n	4032 <FlexCAN_T4<(CAN_DEV_TABLE)1075658752, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

00004570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>:
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    4570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t cl = msg;
    4574:	468c      	mov	ip, r1
FCTP_FUNC void FCTP_OPT::struct2queueRx(const CAN_message_t &msg) {
    4576:	b08d      	sub	sp, #52	; 0x34
    4578:	460e      	mov	r6, r1
    457a:	4607      	mov	r7, r0
  CAN_message_t cl = msg;
    457c:	466c      	mov	r4, sp
    457e:	4605      	mov	r5, r0
    4580:	f100 0810 	add.w	r8, r0, #16
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    4584:	f04f 0901 	mov.w	r9, #1
    4588:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 462c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xbc>
  CAN_message_t cl = msg;
    458c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    4590:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4592:	e89c 0003 	ldmia.w	ip, {r0, r1}
    4596:	e884 0003 	stmia.w	r4, {r0, r1}
    thisListener = listener[listenerPos];
    459a:	f855 4f04 	ldr.w	r4, [r5, #4]!
    if (thisListener != nullptr) {
    459e:	b15c      	cbz	r4, 45b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    45a0:	f99d 2014 	ldrsb.w	r2, [sp, #20]
    45a4:	68a3      	ldr	r3, [r4, #8]
    45a6:	fa09 f102 	lsl.w	r1, r9, r2
    45aa:	4219      	tst	r1, r3
    45ac:	d023      	beq.n	45f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x86>
    45ae:	6823      	ldr	r3, [r4, #0]
    45b0:	f8d3 b000 	ldr.w	fp, [r3]
    45b4:	45d3      	cmp	fp, sl
    45b6:	d119      	bne.n	45ec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x7c>
  for (uint8_t listenerPos = 0; listenerPos < SIZE_LISTENERS; listenerPos++) {
    45b8:	4545      	cmp	r5, r8
    45ba:	d1ee      	bne.n	459a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x2a>
  if ( !isEventsUsed ) {
    45bc:	f507 5300 	add.w	r3, r7, #8192	; 0x2000
    45c0:	f893 3700 	ldrb.w	r3, [r3, #1792]	; 0x700
    45c4:	b33b      	cbz	r3, 4616 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0xa6>
  memmove(buf, &msg, sizeof(msg));
    45c6:	6830      	ldr	r0, [r6, #0]
    45c8:	ac06      	add	r4, sp, #24
    45ca:	6871      	ldr	r1, [r6, #4]
    45cc:	68b2      	ldr	r2, [r6, #8]
    45ce:	68f3      	ldr	r3, [r6, #12]
    45d0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    45d2:	6930      	ldr	r0, [r6, #16]
        void push_back(const T *buffer, uint16_t length) { write(buffer, length); }
    45d4:	2218      	movs	r2, #24
    45d6:	6971      	ldr	r1, [r6, #20]
    45d8:	c403      	stmia	r4!, {r0, r1}
    45da:	eb0d 0102 	add.w	r1, sp, r2
    45de:	f107 0014 	add.w	r0, r7, #20
    45e2:	f7ff fb07 	bl	3bf4 <Circular_Buffer<unsigned char, (unsigned short)256, (unsigned short)24>::write(unsigned char const*, unsigned short)>
}
    45e6:	b00d      	add	sp, #52	; 0x34
    45e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (thisListener->callbacksActive & (1UL << cl.mb)) thisListener->frameHandler (cl, cl.mb, cl.bus);
    45ec:	f89d 3015 	ldrb.w	r3, [sp, #21]
    45f0:	4669      	mov	r1, sp
    45f2:	4620      	mov	r0, r4
    45f4:	47d8      	blx	fp
      if (thisListener->generalCallbackActive) thisListener->frameHandler (cl, -1, cl.bus);
    45f6:	7c23      	ldrb	r3, [r4, #16]
    45f8:	2b00      	cmp	r3, #0
    45fa:	d0dd      	beq.n	45b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    45fc:	6823      	ldr	r3, [r4, #0]
    45fe:	f8d3 b000 	ldr.w	fp, [r3]
    4602:	f89d 3015 	ldrb.w	r3, [sp, #21]
    4606:	45d3      	cmp	fp, sl
    4608:	d0d6      	beq.n	45b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    460a:	4620      	mov	r0, r4
    460c:	f04f 32ff 	mov.w	r2, #4294967295
    4610:	4669      	mov	r1, sp
    4612:	47d8      	blx	fp
    4614:	e7d0      	b.n	45b8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)+0x48>
    mbCallbacks((FLEXCAN_MAILBOX)msg.mb, msg);	
    4616:	7d33      	ldrb	r3, [r6, #20]
    4618:	4632      	mov	r2, r6
    461a:	a906      	add	r1, sp, #24
    461c:	4638      	mov	r0, r7
    461e:	f88d 3018 	strb.w	r3, [sp, #24]
    4622:	f7fe fa8d 	bl	2b40 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mbCallbacks(FLEXCAN_MAILBOX const&, CAN_message_t const&)>
}
    4626:	b00d      	add	sp, #52	; 0x34
    4628:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    462c:	00000f05 	.word	0x00000f05

00004630 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>:
  if ( !distribution ) return; /* distribution not enabled */
    4630:	f500 5300 	add.w	r3, r0, #8192	; 0x2000
    4634:	f893 3701 	ldrb.w	r3, [r3, #1793]	; 0x701
    4638:	2b00      	cmp	r3, #0
    463a:	f000 80db 	beq.w	47f4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c4>
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    463e:	f8df c26c 	ldr.w	ip, [pc, #620]	; 48ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    4642:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t frame = msg;
    4646:	460f      	mov	r7, r1
FCTP_FUNC volatile void FCTP_OPT::frame_distribution(CAN_message_t &msg) {
    4648:	b089      	sub	sp, #36	; 0x24
    464a:	4605      	mov	r5, r0
    464c:	460e      	mov	r6, r1
  CAN_message_t frame = msg;
    464e:	ac02      	add	r4, sp, #8
    4650:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    4652:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4654:	e897 0003 	ldmia.w	r7, {r0, r1}
    4658:	e884 0003 	stmia.w	r4, {r0, r1}
  if ( FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) {
    465c:	f8dc 3000 	ldr.w	r3, [ip]
    4660:	009b      	lsls	r3, r3, #2
    4662:	d552      	bpl.n	470a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    4664:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
    4668:	2400      	movs	r4, #0
            frame.mb = FIFO;
    466a:	f04f 0963 	mov.w	r9, #99	; 0x63
    uint8_t max_fifo_filters = (((FLEXCANb_CTRL2(_bus) >> FLEXCAN_CTRL2_RFFN_BIT_NO) & 0xF) + 1) * 8; // 8->128
    466e:	f3c3 6a03 	ubfx	sl, r3, #24, #4
    4672:	4622      	mov	r2, r4
    4674:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    4678:	f10a 0a08 	add.w	sl, sl, #8
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    467c:	e00c      	b.n	4698 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x68>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    467e:	0f5b      	lsrs	r3, r3, #29
    4680:	2b02      	cmp	r3, #2
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    4682:	683b      	ldr	r3, [r7, #0]
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    4684:	f000 809a 	beq.w	47bc <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x18c>
      else if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    4688:	0f5b      	lsrs	r3, r3, #29
    468a:	2b05      	cmp	r3, #5
    468c:	f000 80dd 	beq.w	484a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x21a>
    for (uint8_t i = 0; i < max_fifo_filters; i++) { /* check fifo filters */
    4690:	3401      	adds	r4, #1
    4692:	b2e2      	uxtb	r2, r4
    4694:	4592      	cmp	sl, r2
    4696:	d938      	bls.n	470a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( msg.mb == FIFO ) break; // don't distribute to fifo if fifo was the source
    4698:	f996 3014 	ldrsb.w	r3, [r6, #20]
    469c:	2b63      	cmp	r3, #99	; 0x63
    469e:	d034      	beq.n	470a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xda>
      if ( !(fifo_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    46a0:	eb04 0844 	add.w	r8, r4, r4, lsl #1
    46a4:	eb05 0bc8 	add.w	fp, r5, r8, lsl #3
    46a8:	f50b 57f0 	add.w	r7, fp, #7680	; 0x1e00
    46ac:	683b      	ldr	r3, [r7, #0]
    46ae:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    46b2:	d0ed      	beq.n	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    46b4:	683b      	ldr	r3, [r7, #0]
    46b6:	0f5b      	lsrs	r3, r3, #29
    46b8:	2b01      	cmp	r3, #1
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    46ba:	683b      	ldr	r3, [r7, #0]
      if ( (fifo_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    46bc:	d1df      	bne.n	467e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x4e>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    46be:	f3c3 4300 	ubfx	r3, r3, #16, #1
    46c2:	79f2      	ldrb	r2, [r6, #7]
    46c4:	429a      	cmp	r2, r3
    46c6:	d1e3      	bne.n	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    46c8:	683b      	ldr	r3, [r7, #0]
    46ca:	f413 7f60 	tst.w	r3, #896	; 0x380
    46ce:	d0df      	beq.n	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    46d0:	ea4f 0b48 	mov.w	fp, r8, lsl #1
        for ( uint8_t p = 0; p < ((fifo_filter_table[i][0] & 0x380) >> 7); p++) {
    46d4:	2300      	movs	r3, #0
    46d6:	e006      	b.n	46e6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xb6>
    46d8:	683a      	ldr	r2, [r7, #0]
    46da:	fa5f f388 	uxtb.w	r3, r8
    46de:	f3c2 12c2 	ubfx	r2, r2, #7, #3
    46e2:	4293      	cmp	r3, r2
    46e4:	d2d4      	bcs.n	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( frame.id == fifo_filter_table[i][p+1] ) {
    46e6:	f103 0801 	add.w	r8, r3, #1
    46ea:	9a02      	ldr	r2, [sp, #8]
    46ec:	eb0b 0308 	add.w	r3, fp, r8
    46f0:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
    46f4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    46f8:	429a      	cmp	r2, r3
    46fa:	d1ed      	bne.n	46d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
            struct2queueRx(frame);
    46fc:	a902      	add	r1, sp, #8
    46fe:	4628      	mov	r0, r5
            frame.mb = FIFO;
    4700:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    4704:	f7ff ff34 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4708:	e7e6      	b.n	46d8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xa8>
  frame.idhit = 0;
    470a:	2300      	movs	r3, #0
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    470c:	4f67      	ldr	r7, [pc, #412]	; (48ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>)
  frame.idhit = 0;
    470e:	f88d 300e 	strb.w	r3, [sp, #14]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4712:	683c      	ldr	r4, [r7, #0]
    4714:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
    4718:	d03f      	beq.n	479a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16a>
    471a:	f7fc fd91 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    471e:	683b      	ldr	r3, [r7, #0]
    4720:	4604      	mov	r4, r0
    4722:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4726:	3301      	adds	r3, #1
    4728:	4283      	cmp	r3, r0
    472a:	d933      	bls.n	4794 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x164>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    472c:	f242 1704 	movw	r7, #8452	; 0x2104
    4730:	f242 1808 	movw	r8, #8456	; 0x2108
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    4734:	f8df 9174 	ldr.w	r9, [pc, #372]	; 48ac <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x27c>
    if ( msg.mb == i ) continue; // don't distribute to same mailbox
    4738:	f996 3014 	ldrsb.w	r3, [r6, #20]
    473c:	42a3      	cmp	r3, r4
    473e:	d020      	beq.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( !(mb_filter_table[i][0] & 0xE0000000) ) continue; // skip unset filters
    4740:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    4744:	eb05 02c1 	add.w	r2, r5, r1, lsl #3
    4748:	f502 5a04 	add.w	sl, r2, #8448	; 0x2100
    474c:	f8da 3000 	ldr.w	r3, [sl]
    4750:	f013 4f60 	tst.w	r3, #3758096384	; 0xe0000000
    4754:	d015      	beq.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (bool)(mb_filter_table[i][0] & (1UL << 27)) != msg.flags.extended ) continue; /* extended flag check */
    4756:	f8da 3000 	ldr.w	r3, [sl]
    475a:	79f0      	ldrb	r0, [r6, #7]
    475c:	f3c3 63c0 	ubfx	r3, r3, #27, #1
    4760:	4298      	cmp	r0, r3
    4762:	d10e      	bne.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4764:	f8da 3000 	ldr.w	r3, [sl]
    4768:	0f5b      	lsrs	r3, r3, #29
    476a:	2b01      	cmp	r3, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    476c:	f8da 3000 	ldr.w	r3, [sl]
    if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_MULTI ) {
    4770:	d041      	beq.n	47f6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1c6>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_RANGE ) {
    4772:	0f5b      	lsrs	r3, r3, #29
    4774:	2b02      	cmp	r3, #2
    4776:	d012      	beq.n	479e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x16e>
    else if ( (mb_filter_table[i][0] >> 29) == FLEXCAN_USERMASK ) {
    4778:	f8da 3000 	ldr.w	r3, [sl]
    477c:	0f5b      	lsrs	r3, r3, #29
    477e:	2b05      	cmp	r3, #5
    4780:	d05b      	beq.n	483a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x20a>
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    4782:	f8d9 3000 	ldr.w	r3, [r9]
    4786:	3401      	adds	r4, #1
    4788:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    478c:	b2e4      	uxtb	r4, r4
    478e:	3301      	adds	r3, #1
    4790:	429c      	cmp	r4, r3
    4792:	d3d1      	bcc.n	4738 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x108>
}
    4794:	b009      	add	sp, #36	; 0x24
    4796:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for ( uint8_t i = mailboxOffset(); i < FLEXCANb_MAXMB_SIZE(_bus); i++ ) {
    479a:	683b      	ldr	r3, [r7, #0]
    479c:	e7c6      	b.n	472c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0xfc>
      if ( frame.id >= mb_filter_table[i][1] && frame.id <= mb_filter_table[i][2] ) {
    479e:	59d1      	ldr	r1, [r2, r7]
    47a0:	9b02      	ldr	r3, [sp, #8]
    47a2:	428b      	cmp	r3, r1
    47a4:	d3ed      	bcc.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    47a6:	f852 2008 	ldr.w	r2, [r2, r8]
    47aa:	4293      	cmp	r3, r2
    47ac:	d8e9      	bhi.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        struct2queueRx(frame);
    47ae:	a902      	add	r1, sp, #8
    47b0:	4628      	mov	r0, r5
        frame.mb = i;
    47b2:	f88d 401c 	strb.w	r4, [sp, #28]
        struct2queueRx(frame);
    47b6:	f7ff fedb 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    47ba:	e7e2      	b.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( (bool)(fifo_filter_table[i][0] & (1UL << 16)) != msg.flags.extended ) continue; /* extended flag check */
    47bc:	f3c3 4300 	ubfx	r3, r3, #16, #1
    47c0:	79f2      	ldrb	r2, [r6, #7]
    47c2:	429a      	cmp	r2, r3
    47c4:	f47f af64 	bne.w	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
        if ( frame.id >= fifo_filter_table[i][1] && frame.id <= fifo_filter_table[i][2] ) {
    47c8:	f641 6304 	movw	r3, #7684	; 0x1e04
    47cc:	f85b 2003 	ldr.w	r2, [fp, r3]
    47d0:	9b02      	ldr	r3, [sp, #8]
    47d2:	4293      	cmp	r3, r2
    47d4:	f4ff af5c 	bcc.w	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    47d8:	f641 6208 	movw	r2, #7688	; 0x1e08
    47dc:	f85b 2002 	ldr.w	r2, [fp, r2]
    47e0:	4293      	cmp	r3, r2
    47e2:	f63f af55 	bhi.w	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          struct2queueRx(frame);
    47e6:	a902      	add	r1, sp, #8
    47e8:	4628      	mov	r0, r5
          frame.mb = FIFO;
    47ea:	f88d 901c 	strb.w	r9, [sp, #28]
          struct2queueRx(frame);
    47ee:	f7ff febf 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    47f2:	e74d      	b.n	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
    47f4:	4770      	bx	lr
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    47f6:	f413 7f60 	tst.w	r3, #896	; 0x380
    47fa:	d0c2      	beq.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    47fc:	004a      	lsls	r2, r1, #1
      for ( uint8_t p = 0; p < ((mb_filter_table[i][0] & 0x380) >> 7); p++) {
    47fe:	2300      	movs	r3, #0
    4800:	e007      	b.n	4812 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1e2>
    4802:	f8da 1000 	ldr.w	r1, [sl]
    4806:	fa5f f38b 	uxtb.w	r3, fp
    480a:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    480e:	428b      	cmp	r3, r1
    4810:	d2b7      	bcs.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
        if ( frame.id == mb_filter_table[i][p+1] ) {
    4812:	f103 0b01 	add.w	fp, r3, #1
    4816:	9902      	ldr	r1, [sp, #8]
    4818:	eb02 030b 	add.w	r3, r2, fp
    481c:	f503 6304 	add.w	r3, r3, #2112	; 0x840
    4820:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    4824:	4299      	cmp	r1, r3
    4826:	d1ec      	bne.n	4802 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
          struct2queueRx(frame);
    4828:	a902      	add	r1, sp, #8
    482a:	4628      	mov	r0, r5
    482c:	9200      	str	r2, [sp, #0]
          frame.mb = i;
    482e:	f88d 401c 	strb.w	r4, [sp, #28]
          struct2queueRx(frame);
    4832:	f7ff fe9d 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4836:	9a00      	ldr	r2, [sp, #0]
    4838:	e7e3      	b.n	4802 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x1d2>
      if ( filter_match((FLEXCAN_MAILBOX)i, frame.id) ) {
    483a:	9a02      	ldr	r2, [sp, #8]
    483c:	4621      	mov	r1, r4
    483e:	4628      	mov	r0, r5
    4840:	f7ff f972 	bl	3b28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4844:	2800      	cmp	r0, #0
    4846:	d09c      	beq.n	4782 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x152>
    4848:	e7b1      	b.n	47ae <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x17e>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    484a:	683b      	ldr	r3, [r7, #0]
    484c:	f413 7f60 	tst.w	r3, #896	; 0x380
    4850:	f43f af1e 	beq.w	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    4854:	f641 6314 	movw	r3, #7700	; 0x1e14
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    4858:	2701      	movs	r7, #1
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    485a:	445b      	add	r3, fp
    485c:	e00a      	b.n	4874 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x244>
        for ( uint8_t p = 1; p < ((fifo_filter_table[i][0] & 0x380) >> 7) + 1; p++) {
    485e:	f50b 51f0 	add.w	r1, fp, #7680	; 0x1e00
    4862:	3701      	adds	r7, #1
    4864:	6809      	ldr	r1, [r1, #0]
    4866:	b2ff      	uxtb	r7, r7
    4868:	f3c1 11c2 	ubfx	r1, r1, #7, #3
    486c:	3101      	adds	r1, #1
    486e:	428f      	cmp	r7, r1
    4870:	f4bf af0e 	bcs.w	4690 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x60>
          if ( (frame.id & fifo_filter_table[i][5]) == (fifo_filter_table[i][p] & fifo_filter_table[i][5]) ) {
    4874:	eb07 0148 	add.w	r1, r7, r8, lsl #1
    4878:	6818      	ldr	r0, [r3, #0]
    487a:	f501 61f0 	add.w	r1, r1, #1920	; 0x780
    487e:	f855 e021 	ldr.w	lr, [r5, r1, lsl #2]
    4882:	9902      	ldr	r1, [sp, #8]
    4884:	f8d3 c000 	ldr.w	ip, [r3]
    4888:	4008      	ands	r0, r1
    488a:	ea0e 010c 	and.w	r1, lr, ip
    488e:	4288      	cmp	r0, r1
    4890:	d1e5      	bne.n	485e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
            struct2queueRx(frame);
    4892:	a902      	add	r1, sp, #8
    4894:	4628      	mov	r0, r5
    4896:	9301      	str	r3, [sp, #4]
            frame.idhit = i;
    4898:	f88d 200e 	strb.w	r2, [sp, #14]
    489c:	9200      	str	r2, [sp, #0]
            frame.mb = FIFO;
    489e:	f88d 901c 	strb.w	r9, [sp, #28]
            struct2queueRx(frame);
    48a2:	f7ff fe65 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    48a6:	e9dd 2300 	ldrd	r2, r3, [sp]
    48aa:	e7d8      	b.n	485e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)+0x22e>
    48ac:	401d0000 	.word	0x401d0000

000048b0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()>:
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    48b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CAN_message_t msg; // setup a temporary storage buffer
    48b4:	4d94      	ldr	r5, [pc, #592]	; (4b08 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x258>)
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    48b6:	b09b      	sub	sp, #108	; 0x6c
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    48b8:	4f94      	ldr	r7, [pc, #592]	; (4b0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  CAN_message_t msg; // setup a temporary storage buffer
    48ba:	ac08      	add	r4, sp, #32
FCTP_FUNC void FCTP_OPT::flexcan_interrupt() {
    48bc:	9004      	str	r0, [sp, #16]
  CAN_message_t msg; // setup a temporary storage buffer
    48be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    48c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    48c2:	e895 0003 	ldmia.w	r5, {r0, r1}
    48c6:	e884 0003 	stmia.w	r4, {r0, r1}
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    48ca:	6a7e      	ldr	r6, [r7, #36]	; 0x24
    48cc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    48ce:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
    48d2:	6b38      	ldr	r0, [r7, #48]	; 0x30
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    48d4:	683b      	ldr	r3, [r7, #0]
  return (((uint64_t)FLEXCANb_IMASK2(_bus) << 32) | FLEXCANb_IMASK1(_bus));
    48d6:	9102      	str	r1, [sp, #8]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    48d8:	f413 4300 	ands.w	r3, r3, #32768	; 0x8000
  return (((uint64_t)FLEXCANb_IFLAG2(_bus) << 32) | FLEXCANb_IFLAG1(_bus));
    48dc:	9003      	str	r0, [sp, #12]
  if ( !(FLEXCANb_MCR(_bus) & (1UL << 15)) ) { /* if DMA is disabled, ONLY THEN you can handle FIFO in ISR */
    48de:	d103      	bne.n	48e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    48e0:	683a      	ldr	r2, [r7, #0]
    48e2:	0094      	lsls	r4, r2, #2
    48e4:	f100 811a 	bmi.w	4b1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x26c>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    48e8:	9b03      	ldr	r3, [sp, #12]
    48ea:	f043 0301 	orr.w	r3, r3, #1
    48ee:	f1bb 0f00 	cmp.w	fp, #0
    48f2:	f000 8105 	beq.w	4b00 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x250>
    48f6:	fabb f38b 	clz	r3, fp
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    48fa:	4d84      	ldr	r5, [pc, #528]	; (4b0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    48fc:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4900:	682c      	ldr	r4, [r5, #0]
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4902:	b2df      	uxtb	r7, r3
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    4904:	f014 5400 	ands.w	r4, r4, #536870912	; 0x20000000
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4908:	9701      	str	r7, [sp, #4]
  if ( !(FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN ) ) return 0; /* return offset 0 since FIFO is disabled */
    490a:	f000 8284 	beq.w	4e16 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x566>
    490e:	f7fc fc97 	bl	1240 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::mailboxOffset() [clone .part.0]>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4912:	682b      	ldr	r3, [r5, #0]
    4914:	4604      	mov	r4, r0
    4916:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    491a:	3301      	adds	r3, #1
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    491c:	4283      	cmp	r3, r0
    491e:	f240 80c2 	bls.w	4aa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    4922:	4287      	cmp	r7, r0
    4924:	f240 80bf 	bls.w	4aa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
      msg.bus = busNumber;
    4928:	9b04      	ldr	r3, [sp, #16]
    492a:	1c67      	adds	r7, r4, #1
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    492c:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4b0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>
      msg.bus = busNumber;
    4930:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    4934:	b2fd      	uxtb	r5, r7
    4936:	9305      	str	r3, [sp, #20]
    4938:	e018      	b.n	496c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0xbc>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_EMPTY ) {
    493a:	2a04      	cmp	r2, #4
    493c:	f000 8162 	beq.w	4c04 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x354>
    else if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_TX_INACTIVE ) {
    4940:	2a08      	cmp	r2, #8
    4942:	f000 8203 	beq.w	4d4c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x49c>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4946:	f8d9 3000 	ldr.w	r3, [r9]
    494a:	b2fc      	uxtb	r4, r7
    494c:	9a01      	ldr	r2, [sp, #4]
    494e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    4952:	3301      	adds	r3, #1
    4954:	42a2      	cmp	r2, r4
    4956:	bf88      	it	hi
    4958:	42ab      	cmphi	r3, r5
    if ( mb_num >= exit_point ) break; /* early exit from higher unflagged mailboxes */
    495a:	f105 0501 	add.w	r5, r5, #1
    495e:	bf94      	ite	ls
    4960:	2301      	movls	r3, #1
    4962:	2300      	movhi	r3, #0
    4964:	2b00      	cmp	r3, #0
    4966:	f040 809e 	bne.w	4aa6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1f6>
    496a:	1c67      	adds	r7, r4, #1
    if (!(imask & (1ULL << mb_num))) continue; /* don't read non-interrupt mailboxes */
    496c:	f1c4 0220 	rsb	r2, r4, #32
    4970:	9b02      	ldr	r3, [sp, #8]
    4972:	f1a4 0a20 	sub.w	sl, r4, #32
    4976:	fa06 f102 	lsl.w	r1, r6, r2
    497a:	40e3      	lsrs	r3, r4
    497c:	430b      	orrs	r3, r1
    497e:	fa26 f10a 	lsr.w	r1, r6, sl
    4982:	430b      	orrs	r3, r1
    4984:	07d8      	lsls	r0, r3, #31
    4986:	d5de      	bpl.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    if (!(iflag & (1ULL << mb_num))) continue; /* don't read unflagged mailboxes */
    4988:	9b03      	ldr	r3, [sp, #12]
    498a:	fa0b f202 	lsl.w	r2, fp, r2
    498e:	40e3      	lsrs	r3, r4
    4990:	4313      	orrs	r3, r2
    4992:	fa2b f20a 	lsr.w	r2, fp, sl
    4996:	4313      	orrs	r3, r2
    4998:	07d9      	lsls	r1, r3, #31
    499a:	d5d4      	bpl.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    volatile uint32_t *mbxAddr = &(*(volatile uint32_t*)(_bus + 0x80 + (mb_num * 0x10)));
    499c:	f8df 8178 	ldr.w	r8, [pc, #376]	; 4b18 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x268>
    49a0:	44a0      	add	r8, r4
    49a2:	ea4f 1808 	mov.w	r8, r8, lsl #4
    uint32_t code = mbxAddr[0];
    49a6:	f8d8 3000 	ldr.w	r3, [r8]
    if ( ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_FULL ) ||
    49aa:	0e19      	lsrs	r1, r3, #24
    49ac:	f3c3 6203 	ubfx	r2, r3, #24, #4
    49b0:	f001 010b 	and.w	r1, r1, #11
    49b4:	2902      	cmp	r1, #2
    49b6:	d1c0      	bne.n	493a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x8a>
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    49b8:	f8d8 1004 	ldr.w	r1, [r8, #4]
      msg.flags.extended = (bool)(code & (1UL << 21));
    49bc:	f403 1000 	and.w	r0, r3, #2097152	; 0x200000
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    49c0:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    49c4:	2800      	cmp	r0, #0
    49c6:	bf12      	itee	ne
    49c8:	f04f 0c01 	movne.w	ip, #1
    49cc:	f04f 0c00 	moveq.w	ip, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    49d0:	0c89      	lsreq	r1, r1, #18
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    49d2:	2a06      	cmp	r2, #6
      msg.flags.extended = (bool)(code & (1UL << 21));
    49d4:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    49d8:	9108      	str	r1, [sp, #32]
      if ( FLEXCAN_get_code(code) == FLEXCAN_MB_CODE_RX_OVERRUN ) msg.flags.overrun = 1;
    49da:	d102      	bne.n	49e2 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x132>
    49dc:	2201      	movs	r2, #1
    49de:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
      msg.timestamp = code & 0xFFFF;
    49e2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    49e6:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    49ea:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    49ee:	2800      	cmp	r0, #0
      msg.len = (code & 0xF0000) >> 16;
    49f0:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.bus = busNumber;
    49f4:	9b05      	ldr	r3, [sp, #20]
    49f6:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    49fa:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    49fe:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4a02:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4a06:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4a0a:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4a0e:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4a12:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4a16:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4a1a:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4a1e:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4a22:	ea4f 6313 	mov.w	r3, r3, lsr #24
    4a26:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4a2a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4a2e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4a32:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4a36:	ea4f 2313 	mov.w	r3, r3, lsr #8
    4a3a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4a3e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4a42:	ea4f 4313 	mov.w	r3, r3, lsr #16
    4a46:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4a4a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4a4e:	ea4f 6313 	mov.w	r3, r3, lsr #24
    4a52:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    4a56:	bf14      	ite	ne
    4a58:	f04f 638c 	movne.w	r3, #73400320	; 0x4600000
    4a5c:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4a60:	2c1f      	cmp	r4, #31
      mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY) | ((msg.flags.extended) ? (FLEXCAN_MB_CS_SRR | FLEXCAN_MB_CS_IDE) : 0);
    4a62:	f8c8 3000 	str.w	r3, [r8]
      (void)FLEXCANb_TIMER(_bus);
    4a66:	f8d9 3008 	ldr.w	r3, [r9, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4a6a:	f04f 0301 	mov.w	r3, #1
    4a6e:	d834      	bhi.n	4ada <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x22a>
    4a70:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4a74:	40a3      	lsls	r3, r4
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4a76:	4621      	mov	r1, r4
    4a78:	9804      	ldr	r0, [sp, #16]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4a7a:	4313      	orrs	r3, r2
    4a7c:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4a80:	9a08      	ldr	r2, [sp, #32]
    4a82:	f7ff f851 	bl	3b28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4a86:	2800      	cmp	r0, #0
    4a88:	d135      	bne.n	4af6 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x246>
      frame_distribution(msg);
    4a8a:	a908      	add	r1, sp, #32
    4a8c:	9804      	ldr	r0, [sp, #16]
    4a8e:	f7ff fdcf 	bl	4630 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    4a92:	a808      	add	r0, sp, #32
    4a94:	f3af 8000 	nop.w
      ext_output2(msg);
    4a98:	a808      	add	r0, sp, #32
    4a9a:	f3af 8000 	nop.w
      ext_output3(msg);
    4a9e:	a808      	add	r0, sp, #32
    4aa0:	f3af 8000 	nop.w
    4aa4:	e74f      	b.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    4aa6:	4e19      	ldr	r6, [pc, #100]	; (4b0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4aa8:	4d19      	ldr	r5, [pc, #100]	; (4b10 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x260>)
  uint32_t esr1 = FLEXCANb_ESR1(_bus);
    4aaa:	6a34      	ldr	r4, [r6, #32]
  if ( (last_esr1 & 0x7FFBF) != (esr1 & 0x7FFBF) ) {
    4aac:	682a      	ldr	r2, [r5, #0]
    4aae:	4b19      	ldr	r3, [pc, #100]	; (4b14 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x264>)
    4ab0:	4062      	eors	r2, r4
    4ab2:	4013      	ands	r3, r2
    4ab4:	b143      	cbz	r3, 4ac8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
        uint16_t size() { return _available; }
    4ab6:	9b04      	ldr	r3, [sp, #16]
    4ab8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    4abc:	f8b3 3cd4 	ldrh.w	r3, [r3, #3284]	; 0xcd4
    4ac0:	b29b      	uxth	r3, r3
    if ( busESR1.size() < busESR1.capacity() ) {
    4ac2:	2b0f      	cmp	r3, #15
    4ac4:	f240 81a9 	bls.w	4e1a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x56a>
  FLEXCANb_ESR1(_bus) |= esr1;
    4ac8:	4a10      	ldr	r2, [pc, #64]	; (4b0c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x25c>)
    4aca:	6a13      	ldr	r3, [r2, #32]
    4acc:	4323      	orrs	r3, r4
    4ace:	6213      	str	r3, [r2, #32]
  asm volatile ("dsb");	
    4ad0:	f3bf 8f4f 	dsb	sy
}
    4ad4:	b01b      	add	sp, #108	; 0x6c
    4ad6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4ada:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4ade:	fa03 f30a 	lsl.w	r3, r3, sl
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4ae2:	4621      	mov	r1, r4
    4ae4:	9804      	ldr	r0, [sp, #16]
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4ae6:	4313      	orrs	r3, r2
    4ae8:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
      if ( filter_match((FLEXCAN_MAILBOX)mb_num, msg.id) ) struct2queueRx(msg); /* store frame in queue */
    4aec:	9a08      	ldr	r2, [sp, #32]
    4aee:	f7ff f81b 	bl	3b28 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::filter_match(FLEXCAN_MAILBOX, unsigned long)>
    4af2:	2800      	cmp	r0, #0
    4af4:	d0c9      	beq.n	4a8a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
    4af6:	a908      	add	r1, sp, #32
    4af8:	9804      	ldr	r0, [sp, #16]
    4afa:	f7ff fd39 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4afe:	e7c4      	b.n	4a8a <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x1da>
  uint8_t exit_point = 64 - __builtin_clzll(iflag | 1); /* break from MSB's if unset, add 1 to prevent undefined behaviour in clz for 0 check */
    4b00:	fab3 f383 	clz	r3, r3
    4b04:	3320      	adds	r3, #32
    4b06:	e6f8      	b.n	48fa <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x4a>
    4b08:	200003b0 	.word	0x200003b0
    4b0c:	401d0000 	.word	0x401d0000
    4b10:	2000a354 	.word	0x2000a354
    4b14:	0007ffbf 	.word	0x0007ffbf
    4b18:	0401d008 	.word	0x0401d008
    if ( (FLEXCANb_MCR(_bus) & FLEXCAN_MCR_FEN) && (imask & FLEXCAN_IMASK1_BUF5M) && (iflag & FLEXCAN_IFLAG1_BUF5I) ) { /* FIFO is enabled, capture frames if triggered */
    4b1c:	0689      	lsls	r1, r1, #26
    4b1e:	f57f aee3 	bpl.w	48e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    4b22:	0682      	lsls	r2, r0, #26
    4b24:	f57f aee0 	bpl.w	48e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      uint32_t code = mbxAddr[0];
    4b28:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4b2c:	4cc3      	ldr	r4, [pc, #780]	; (4e3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
      msg.flags.extended = (bool)(code & (1UL << 21));
    4b2e:	f402 1100 	and.w	r1, r2, #2097152	; 0x200000
      msg.flags.remote = (bool)(code & (1UL << 20));
    4b32:	f3c2 5000 	ubfx	r0, r2, #20, #1
      msg.timestamp = code & 0xFFFF;
    4b36:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
      msg.flags.extended = (bool)(code & (1UL << 21));
    4b3a:	2900      	cmp	r1, #0
      msg.len = (code & 0xF0000) >> 16;
    4b3c:	f3c2 4103 	ubfx	r1, r2, #16, #4
      msg.idhit = code >> 23;
    4b40:	ea4f 52d2 	mov.w	r2, r2, lsr #23
      msg.len = (code & 0xF0000) >> 16;
    4b44:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4b48:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      msg.flags.remote = (bool)(code & (1UL << 20));
    4b4c:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
      msg.flags.extended = (bool)(code & (1UL << 21));
    4b50:	bf18      	it	ne
    4b52:	2001      	movne	r0, #1
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4b54:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
      msg.flags.extended = (bool)(code & (1UL << 21));
    4b58:	bf08      	it	eq
    4b5a:	2000      	moveq	r0, #0
      msg.idhit = code >> 23;
    4b5c:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    4b60:	f04f 0200 	mov.w	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4b64:	bf08      	it	eq
    4b66:	0c89      	lsreq	r1, r1, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4b68:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
    4b6c:	a80c      	add	r0, sp, #48	; 0x30
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4b6e:	9108      	str	r1, [sp, #32]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4b70:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    4b74:	40d1      	lsrs	r1, r2
    4b76:	3208      	adds	r2, #8
    4b78:	2a20      	cmp	r2, #32
    4b7a:	f800 1d01 	strb.w	r1, [r0, #-1]!
    4b7e:	d1f7      	bne.n	4b70 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2c0>
    4b80:	a80d      	add	r0, sp, #52	; 0x34
    4b82:	49ae      	ldr	r1, [pc, #696]	; (4e3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    4b84:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    4b88:	40da      	lsrs	r2, r3
    4b8a:	3308      	adds	r3, #8
    4b8c:	2b20      	cmp	r3, #32
    4b8e:	f800 2d01 	strb.w	r2, [r0, #-1]!
    4b92:	d1f7      	bne.n	4b84 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x2d4>
      msg.bus = busNumber;
    4b94:	9b04      	ldr	r3, [sp, #16]
    4b96:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    4b9a:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
    4b9e:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      msg.mb = FIFO; /* store the mailbox the message came from (for callback reference) */
    4ba2:	2363      	movs	r3, #99	; 0x63
    4ba4:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
      (void)FLEXCANb_TIMER(_bus);
    4ba8:	688b      	ldr	r3, [r1, #8]
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4baa:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4bac:	f043 0320 	orr.w	r3, r3, #32
    4bb0:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF6I ) writeIFLAGBit(6); /* clear FIFO bit only! */
    4bb2:	9b03      	ldr	r3, [sp, #12]
    4bb4:	065d      	lsls	r5, r3, #25
    4bb6:	d503      	bpl.n	4bc0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x310>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4bb8:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4bba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4bbe:	630b      	str	r3, [r1, #48]	; 0x30
      if ( iflag & FLEXCAN_IFLAG1_BUF7I ) writeIFLAGBit(7); /* clear FIFO bit only! */
    4bc0:	9b03      	ldr	r3, [sp, #12]
    4bc2:	061c      	lsls	r4, r3, #24
    4bc4:	d504      	bpl.n	4bd0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x320>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4bc6:	4a9d      	ldr	r2, [pc, #628]	; (4e3c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x58c>)
    4bc8:	6b13      	ldr	r3, [r2, #48]	; 0x30
    4bca:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4bce:	6313      	str	r3, [r2, #48]	; 0x30
      frame_distribution(msg);
    4bd0:	9c04      	ldr	r4, [sp, #16]
    4bd2:	a908      	add	r1, sp, #32
    4bd4:	4620      	mov	r0, r4
    4bd6:	f7ff fd2b 	bl	4630 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::frame_distribution(CAN_message_t&)>
      ext_output1(msg);
    4bda:	a808      	add	r0, sp, #32
    4bdc:	f3af 8000 	nop.w
      ext_output2(msg);
    4be0:	a808      	add	r0, sp, #32
    4be2:	f3af 8000 	nop.w
      ext_output3(msg);
    4be6:	a808      	add	r0, sp, #32
    4be8:	f3af 8000 	nop.w
      if (fifo_filter_match(msg.id)) struct2queueRx(msg);
    4bec:	9908      	ldr	r1, [sp, #32]
    4bee:	4620      	mov	r0, r4
    4bf0:	f7fe ff22 	bl	3a38 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::fifo_filter_match(unsigned long)>
    4bf4:	2800      	cmp	r0, #0
    4bf6:	f43f ae77 	beq.w	48e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
    4bfa:	a908      	add	r1, sp, #32
    4bfc:	9804      	ldr	r0, [sp, #16]
    4bfe:	f7ff fcb7 	bl	4570 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::struct2queueRx(CAN_message_t const&)>
    4c02:	e671      	b.n	48e8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x38>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4c04:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4c08:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4c0a:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4c0e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4c12:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4c16:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4c1a:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4c1e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4c22:	bf18      	it	ne
    4c24:	2101      	movne	r1, #1
      msg.bus = busNumber;
    4c26:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4c28:	bf04      	itt	eq
    4c2a:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4c2c:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4c2e:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4c32:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4c34:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4c38:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4c3c:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4c3e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4c42:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4c46:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4c4a:	0a1b      	lsrs	r3, r3, #8
    4c4c:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4c50:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4c54:	0c1b      	lsrs	r3, r3, #16
    4c56:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4c5a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4c5e:	0e1b      	lsrs	r3, r3, #24
    4c60:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4c64:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4c68:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4c6c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4c70:	0a1b      	lsrs	r3, r3, #8
    4c72:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4c76:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4c7a:	0c1b      	lsrs	r3, r3, #16
    4c7c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4c80:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    4c84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4c88:	f8d8 200c 	ldr.w	r2, [r8, #12]
    4c8c:	0e12      	lsrs	r2, r2, #24
    4c8e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4c92:	b10b      	cbz	r3, 4c98 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3e8>
    4c94:	a808      	add	r0, sp, #32
    4c96:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4c98:	9b05      	ldr	r3, [sp, #20]
    4c9a:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    4c9e:	b10b      	cbz	r3, 4ca4 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x3f4>
    4ca0:	a808      	add	r0, sp, #32
    4ca2:	4798      	blx	r3
    4ca4:	9904      	ldr	r1, [sp, #16]
    4ca6:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4caa:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4cae:	9207      	str	r2, [sp, #28]
    4cb0:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    4cb2:	2b00      	cmp	r3, #0
    4cb4:	f000 80c4 	beq.w	4e40 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x590>
    memmove(&buffer[0],&_cabuf[((head+entry)&(_size-1))][2],length*sizeof(T)); // update CA buffer
    4cb8:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4cbc:	221a      	movs	r2, #26
    4cbe:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
    4cc2:	f003 030f 	and.w	r3, r3, #15
        memmove(&frame, buf, sizeof(frame));
    4cc6:	46e0      	mov	r8, ip
    4cc8:	fb02 1303 	mla	r3, r2, r3, r1
    4ccc:	f641 3232 	movw	r2, #6962	; 0x1b32
    4cd0:	a90e      	add	r1, sp, #56	; 0x38
    4cd2:	eb03 0a02 	add.w	sl, r3, r2
    4cd6:	9106      	str	r1, [sp, #24]
    4cd8:	468e      	mov	lr, r1
    4cda:	5898      	ldr	r0, [r3, r2]
    4cdc:	f8da 1004 	ldr.w	r1, [sl, #4]
    4ce0:	f8da 2008 	ldr.w	r2, [sl, #8]
    4ce4:	f8da 300c 	ldr.w	r3, [sl, #12]
    4ce8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    4cec:	f8da 0010 	ldr.w	r0, [sl, #16]
    4cf0:	f8da 1014 	ldr.w	r1, [sl, #20]
    4cf4:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    4cf8:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
    4cfc:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    4d00:	e898 0003 	ldmia.w	r8, {r0, r1}
    4d04:	e88e 0003 	stmia.w	lr, {r0, r1}
        if ( frame.mb == -1 ) {
    4d08:	f99d 304c 	ldrsb.w	r3, [sp, #76]	; 0x4c
    4d0c:	1c5a      	adds	r2, r3, #1
    4d0e:	f000 80a6 	beq.w	4e5e <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5ae>
        else if ( frame.mb == mb_num ) {
    4d12:	429c      	cmp	r4, r3
    4d14:	f47f ae17 	bne.w	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(frame.mb, frame);
    4d18:	9a06      	ldr	r2, [sp, #24]
    4d1a:	b2e1      	uxtb	r1, r4
    4d1c:	9804      	ldr	r0, [sp, #16]
    4d1e:	f7fd ff35 	bl	2b8c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::writeTxMailbox(unsigned char, CAN_message_t const&)>
    head = ((head + 1)&(2*_size-1));
    4d22:	9a07      	ldr	r2, [sp, #28]
    4d24:	f8b2 3b1a 	ldrh.w	r3, [r2, #2842]	; 0xb1a
    4d28:	3301      	adds	r3, #1
    4d2a:	f003 031f 	and.w	r3, r3, #31
    4d2e:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    if ( _available ) _available--;
    4d32:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4d36:	b29b      	uxth	r3, r3
    4d38:	2b00      	cmp	r3, #0
    4d3a:	f43f ae04 	beq.w	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
    4d3e:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4d42:	3b01      	subs	r3, #1
    4d44:	b29b      	uxth	r3, r3
    4d46:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4d4a:	e5fc      	b.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
      msg.flags.extended = (bool)(code & (1UL << 21));
    4d4c:	f403 1200 	and.w	r2, r3, #2097152	; 0x200000
    4d50:	2a00      	cmp	r2, #0
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4d52:	f8d8 2004 	ldr.w	r2, [r8, #4]
      msg.timestamp = code & 0xFFFF;
    4d56:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      msg.len = (code & 0xF0000) >> 16;
    4d5a:	f3c3 4303 	ubfx	r3, r3, #16, #4
      msg.mb = mb_num;
    4d5e:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4d62:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
      msg.len = (code & 0xF0000) >> 16;
    4d66:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
      msg.flags.extended = (bool)(code & (1UL << 21));
    4d6a:	bf18      	it	ne
    4d6c:	2101      	movne	r1, #1
      msg.bus = busNumber;
    4d6e:	9b05      	ldr	r3, [sp, #20]
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4d70:	bf04      	itt	eq
    4d72:	0c92      	lsreq	r2, r2, #18
      msg.flags.extended = (bool)(code & (1UL << 21));
    4d74:	2100      	moveq	r1, #0
      msg.bus = busNumber;
    4d76:	f893 3915 	ldrb.w	r3, [r3, #2325]	; 0x915
      msg.id = (mbxAddr[1] & 0x1FFFFFFF) >> ((msg.flags.extended) ? 0 : 18);
    4d7a:	9208      	str	r2, [sp, #32]
      msg.bus = busNumber;
    4d7c:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4d80:	f8d8 3008 	ldr.w	r3, [r8, #8]
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4d84:	9a04      	ldr	r2, [sp, #16]
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4d86:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    4d8a:	f8d8 3008 	ldr.w	r3, [r8, #8]
      msg.flags.extended = (bool)(code & (1UL << 21));
    4d8e:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
      for ( uint8_t i = 0; i < (8 >> 2); i++ ) for ( int8_t d = 0; d < 4 ; d++ ) msg.buf[(4 * i) + 3 - d] = (uint8_t)(mbxAddr[2 + i] >> (8 * d));
    4d92:	0a1b      	lsrs	r3, r3, #8
    4d94:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    4d98:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4d9c:	0c1b      	lsrs	r3, r3, #16
    4d9e:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    4da2:	f8d8 3008 	ldr.w	r3, [r8, #8]
    4da6:	0e1b      	lsrs	r3, r3, #24
    4da8:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    4dac:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4db0:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    4db4:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4db8:	0a1b      	lsrs	r3, r3, #8
    4dba:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    4dbe:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4dc2:	0c1b      	lsrs	r3, r3, #16
    4dc4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    4dc8:	f8d8 300c 	ldr.w	r3, [r8, #12]
    4dcc:	0e1b      	lsrs	r3, r3, #24
    4dce:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        if ( _mbTxHandlers[mb_num] ) _mbTxHandlers[mb_num](msg);
    4dd2:	f604 2302 	addw	r3, r4, #2562	; 0xa02
    4dd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4dda:	b10b      	cbz	r3, 4de0 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x530>
    4ddc:	a808      	add	r0, sp, #32
    4dde:	4798      	blx	r3
        if ( _mainTxHandler ) _mainTxHandler(msg);
    4de0:	9b05      	ldr	r3, [sp, #20]
    4de2:	f8d3 3908 	ldr.w	r3, [r3, #2312]	; 0x908
    4de6:	b10b      	cbz	r3, 4dec <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x53c>
    4de8:	a808      	add	r0, sp, #32
    4dea:	4798      	blx	r3
        uint16_t size() { return _available; }
    4dec:	9904      	ldr	r1, [sp, #16]
    4dee:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    4df2:	f8b2 3b1e 	ldrh.w	r3, [r2, #2846]	; 0xb1e
    4df6:	9207      	str	r2, [sp, #28]
    4df8:	b29b      	uxth	r3, r3
      if ( txBuffer.size() ) {
    4dfa:	2b00      	cmp	r3, #0
    4dfc:	f47f af5c 	bne.w	4cb8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x408>
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4e00:	2c1f      	cmp	r4, #31
    4e02:	f04f 0301 	mov.w	r3, #1
    4e06:	d835      	bhi.n	4e74 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5c4>
    4e08:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4e0c:	40a3      	lsls	r3, r4
    4e0e:	4313      	orrs	r3, r2
    4e10:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
    4e14:	e597      	b.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
  for ( uint8_t mb_num = mailboxOffset(); mb_num < FLEXCANb_MAXMB_SIZE(_bus); mb_num++ ) {
    4e16:	682b      	ldr	r3, [r5, #0]
    4e18:	e586      	b.n	4928 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x78>
      busESR1.write(esr1);
    4e1a:	9f04      	ldr	r7, [sp, #16]
    4e1c:	f641 40d0 	movw	r0, #7376	; 0x1cd0
    4e20:	4621      	mov	r1, r4
    4e22:	4438      	add	r0, r7
    4e24:	f7fe fdc0 	bl	39a8 <Circular_Buffer<unsigned long, (unsigned short)16, (unsigned short)0>::write(unsigned long)>
      busECR.write(FLEXCANb_ECR(_bus));
    4e28:	69f1      	ldr	r1, [r6, #28]
    4e2a:	f641 5098 	movw	r0, #7576	; 0x1d98
    4e2e:	b289      	uxth	r1, r1
    4e30:	4438      	add	r0, r7
    4e32:	f7fe fddd 	bl	39f0 <Circular_Buffer<unsigned short, (unsigned short)16, (unsigned short)0>::write(unsigned short)>
      last_esr1 = esr1;
    4e36:	602c      	str	r4, [r5, #0]
    4e38:	e646      	b.n	4ac8 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x218>
    4e3a:	bf00      	nop
    4e3c:	401d0000 	.word	0x401d0000
  if ( mb_num < 32 ) FLEXCANb_IFLAG1(_bus) |= (1UL << mb_num);
    4e40:	2c1f      	cmp	r4, #31
    4e42:	f04f 0301 	mov.w	r3, #1
    4e46:	d80d      	bhi.n	4e64 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5b4>
    4e48:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    4e4c:	40a3      	lsls	r3, r4
    4e4e:	4313      	orrs	r3, r2
    4e50:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
        mbxAddr[0] = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE); /* set it back to a TX mailbox */
    4e54:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    4e58:	f8c8 3000 	str.w	r3, [r8]
    4e5c:	e573      	b.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>
          writeTxMailbox(mb_num, frame);
    4e5e:	9a06      	ldr	r2, [sp, #24]
    4e60:	4621      	mov	r1, r4
    4e62:	e75b      	b.n	4d1c <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x46c>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4e64:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4e68:	fa03 f30a 	lsl.w	r3, r3, sl
    4e6c:	4313      	orrs	r3, r2
    4e6e:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4e72:	e7ef      	b.n	4e54 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x5a4>
  else FLEXCANb_IFLAG2(_bus) |= (1UL << (mb_num - 32));
    4e74:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
    4e78:	fa03 f30a 	lsl.w	r3, r3, sl
    4e7c:	4313      	orrs	r3, r2
    4e7e:	f8c9 302c 	str.w	r3, [r9, #44]	; 0x2c
}
    4e82:	e560      	b.n	4946 <FlexCAN_T4<(CAN_DEV_TABLE)1075642368, (FLEXCAN_RXQUEUE_TABLE)256, (FLEXCAN_TXQUEUE_TABLE)16>::flexcan_interrupt()+0x96>

00004e84 <_GLOBAL__sub_I_HaldexCAN>:
}
    4e84:	b538      	push	{r3, r4, r5, lr}
    4e86:	f001 f8a3 	bl	5fd0 <eeprom_initialize>
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4e8a:	4829      	ldr	r0, [pc, #164]	; (4f30 <_GLOBAL__sub_I_HaldexCAN+0xac>)
    4e8c:	4929      	ldr	r1, [pc, #164]	; (4f34 <_GLOBAL__sub_I_HaldexCAN+0xb0>)
class Circular_Buffer {
    4e8e:	2300      	movs	r3, #0
    4e90:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
  if ( _bus == CAN1 ) _CAN1 = this;
    4e94:	4c28      	ldr	r4, [pc, #160]	; (4f38 <_GLOBAL__sub_I_HaldexCAN+0xb4>)
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4e96:	6001      	str	r1, [r0, #0]
    4e98:	f500 5c00 	add.w	ip, r0, #8192	; 0x2000
    4e9c:	4927      	ldr	r1, [pc, #156]	; (4f3c <_GLOBAL__sub_I_HaldexCAN+0xb8>)
    4e9e:	8283      	strh	r3, [r0, #20]
  if ( _bus == CAN1 ) _CAN1 = this;
    4ea0:	6020      	str	r0, [r4, #0]
    4ea2:	82c3      	strh	r3, [r0, #22]
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4ea4:	4d26      	ldr	r5, [pc, #152]	; (4f40 <_GLOBAL__sub_I_HaldexCAN+0xbc>)
    4ea6:	8303      	strh	r3, [r0, #24]
    4ea8:	f501 5000 	add.w	r0, r1, #8192	; 0x2000
    4eac:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
  if ( _bus == CAN2 ) _CAN2 = this;
    4eb0:	4c24      	ldr	r4, [pc, #144]	; (4f44 <_GLOBAL__sub_I_HaldexCAN+0xc0>)
    4eb2:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    4eb6:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4eba:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    4ebe:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    4ec2:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    4ec6:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    4eca:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    4ece:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    4ed2:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
FCTP_FUNC FCTP_OPT::FlexCAN_T4() {
    4ed6:	f88c 3700 	strb.w	r3, [ip, #1792]	; 0x700
    4eda:	f8cc 390c 	str.w	r3, [ip, #2316]	; 0x90c
    4ede:	f88c 3701 	strb.w	r3, [ip, #1793]	; 0x701
    4ee2:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
    4ee6:	828b      	strh	r3, [r1, #20]
    4ee8:	f88c 3914 	strb.w	r3, [ip, #2324]	; 0x914
    4eec:	82cb      	strh	r3, [r1, #22]
    4eee:	600d      	str	r5, [r1, #0]
    4ef0:	830b      	strh	r3, [r1, #24]
    4ef2:	f8a2 3b1a 	strh.w	r3, [r2, #2842]	; 0xb1a
    4ef6:	f8a2 3b1c 	strh.w	r3, [r2, #2844]	; 0xb1c
    4efa:	f8a2 3b1e 	strh.w	r3, [r2, #2846]	; 0xb1e
    4efe:	f8a2 3cd0 	strh.w	r3, [r2, #3280]	; 0xcd0
    4f02:	f8a2 3cd2 	strh.w	r3, [r2, #3282]	; 0xcd2
    4f06:	f8a2 3cd4 	strh.w	r3, [r2, #3284]	; 0xcd4
    4f0a:	f8a2 3d98 	strh.w	r3, [r2, #3480]	; 0xd98
    4f0e:	f8a2 3d9a 	strh.w	r3, [r2, #3482]	; 0xd9a
    4f12:	f8a2 3d9c 	strh.w	r3, [r2, #3484]	; 0xd9c
    4f16:	f880 3700 	strb.w	r3, [r0, #1792]	; 0x700
    4f1a:	f880 3701 	strb.w	r3, [r0, #1793]	; 0x701
    4f1e:	f8c0 390c 	str.w	r3, [r0, #2316]	; 0x90c
    4f22:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
    4f26:	f880 3914 	strb.w	r3, [r0, #2324]	; 0x914
  if ( _bus == CAN2 ) _CAN2 = this;
    4f2a:	6021      	str	r1, [r4, #0]
    4f2c:	bd38      	pop	{r3, r4, r5, pc}
    4f2e:	bf00      	nop
    4f30:	200079a0 	.word	0x200079a0
    4f34:	20000864 	.word	0x20000864
    4f38:	2000a320 	.word	0x2000a320
    4f3c:	20005088 	.word	0x20005088
    4f40:	20000888 	.word	0x20000888
    4f44:	2000a324 	.word	0x2000a324

00004f48 <readEEP()>:
    4f48:	2114      	movs	r1, #20
    4f4a:	483a      	ldr	r0, [pc, #232]	; (5034 <readEEP()+0xec>)
#include "openhaldex.h"

void readEEP() {
    4f4c:	b510      	push	{r4, lr}
    4f4e:	f002 fdd9 	bl	7b04 <usb_serial_write>
    4f52:	4839      	ldr	r0, [pc, #228]	; (5038 <readEEP()+0xf0>)
    4f54:	f000 fd48 	bl	59e8 <Print::println()>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4f58:	2000      	movs	r0, #0
    4f5a:	f001 f85d 	bl	6018 <eeprom_read_byte>
#if stateDebug
  Serial.println(F("EEPROM initialising!"));
#endif /* stateDebug */

  if (EEPROM.read(0) == 255) {
    4f5e:	28ff      	cmp	r0, #255	; 0xff
    4f60:	d014      	beq.n	4f8c <readEEP()+0x44>
    EERef( const int index )
    4f62:	4603      	mov	r3, r0
    EEPROM.write(1, 0);                    // EEP Address 1: isCustom
    EEPROM.write(2, 0);                    // EEP Address 2: lastMode
    EEPROM.write(3, 0);                    // EEP Address 2: isStandalone
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
  } else {
    softwareVersion = EEPROM.read(0);
    4f64:	4a35      	ldr	r2, [pc, #212]	; (503c <readEEP()+0xf4>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4f66:	2001      	movs	r0, #1
    4f68:	6013      	str	r3, [r2, #0]
    4f6a:	f001 f855 	bl	6018 <eeprom_read_byte>
    4f6e:	4603      	mov	r3, r0
    isCustom = EEPROM.read(1);
    4f70:	4a33      	ldr	r2, [pc, #204]	; (5040 <readEEP()+0xf8>)
    4f72:	2002      	movs	r0, #2
    4f74:	3b00      	subs	r3, #0
    4f76:	bf18      	it	ne
    4f78:	2301      	movne	r3, #1
    4f7a:	7013      	strb	r3, [r2, #0]
    4f7c:	f001 f84c 	bl	6018 <eeprom_read_byte>

    switch (EEPROM.read(2)) {
    4f80:	2803      	cmp	r0, #3
    4f82:	d854      	bhi.n	502e <readEEP()+0xe6>
    4f84:	e8df f000 	tbb	[pc, r0]
    4f88:	2b504842 	.word	0x2b504842
    4f8c:	213b      	movs	r1, #59	; 0x3b
    4f8e:	482d      	ldr	r0, [pc, #180]	; (5044 <readEEP()+0xfc>)
    4f90:	f002 fdb8 	bl	7b04 <usb_serial_write>
    4f94:	4828      	ldr	r0, [pc, #160]	; (5038 <readEEP()+0xf0>)
    4f96:	f000 fd27 	bl	59e8 <Print::println()>
    btInit();
    4f9a:	f7fb fbbd 	bl	718 <btInit()>
    EEPROM.write(0, softwareVersion);      // EEP Address 0: SW Version
    4f9e:	4b27      	ldr	r3, [pc, #156]	; (503c <readEEP()+0xf4>)
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    4fa0:	2000      	movs	r0, #0
    4fa2:	7819      	ldrb	r1, [r3, #0]
    4fa4:	f001 f944 	bl	6230 <eeprom_write_byte>
    4fa8:	2100      	movs	r1, #0
    4faa:	2001      	movs	r0, #1
    4fac:	f001 f940 	bl	6230 <eeprom_write_byte>
    4fb0:	2100      	movs	r1, #0
    4fb2:	2002      	movs	r0, #2
    4fb4:	f001 f93c 	bl	6230 <eeprom_write_byte>
    4fb8:	2100      	movs	r1, #0
    4fba:	2003      	movs	r0, #3
    4fbc:	f001 f938 	bl	6230 <eeprom_write_byte>
    EEPROM.write(4, state.ped_threshold);  // EEP Address 3: Pedal Threshold
    4fc0:	4b21      	ldr	r3, [pc, #132]	; (5048 <readEEP()+0x100>)
    4fc2:	2004      	movs	r0, #4
    4fc4:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
    4fc8:	f001 f932 	bl	6230 <eeprom_write_byte>
    4fcc:	2113      	movs	r1, #19
    4fce:	481f      	ldr	r0, [pc, #124]	; (504c <readEEP()+0x104>)
    4fd0:	f002 fd98 	bl	7b04 <usb_serial_write>
    4fd4:	4818      	ldr	r0, [pc, #96]	; (5038 <readEEP()+0xf0>)
    state.ped_threshold = EEPROM.read(4);
  }
#if stateDebug
  Serial.println(F("EEPROM initialised!"));
#endif /* stateDebug */
}
    4fd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4fda:	f000 bd05 	b.w	59e8 <Print::println()>
        state.mode_override = true;
    4fde:	4c1a      	ldr	r4, [pc, #104]	; (5048 <readEEP()+0x100>)
        state.mode = MODE_CUSTOM;
    4fe0:	2303      	movs	r3, #3
        state.mode_override = true;
    4fe2:	2101      	movs	r1, #1
        lastMode = 3;
    4fe4:	4a1a      	ldr	r2, [pc, #104]	; (5050 <readEEP()+0x108>)
        state.mode = MODE_CUSTOM;
    4fe6:	7023      	strb	r3, [r4, #0]
        state.mode_override = true;
    4fe8:	f884 1023 	strb.w	r1, [r4, #35]	; 0x23
        lastMode = 3;
    4fec:	6013      	str	r3, [r2, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    4fee:	2003      	movs	r0, #3
    4ff0:	f001 f812 	bl	6018 <eeprom_read_byte>
    4ff4:	4603      	mov	r3, r0
    isStandalone = EEPROM.read(3);
    4ff6:	4a17      	ldr	r2, [pc, #92]	; (5054 <readEEP()+0x10c>)
    4ff8:	2004      	movs	r0, #4
    4ffa:	3b00      	subs	r3, #0
    4ffc:	bf18      	it	ne
    4ffe:	2301      	movne	r3, #1
    5000:	7013      	strb	r3, [r2, #0]
    5002:	f001 f809 	bl	6018 <eeprom_read_byte>
    state.ped_threshold = EEPROM.read(4);
    5006:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
    500a:	e7df      	b.n	4fcc <readEEP()+0x84>
        state.mode = MODE_STOCK;
    500c:	2300      	movs	r3, #0
    500e:	4c0e      	ldr	r4, [pc, #56]	; (5048 <readEEP()+0x100>)
        lastMode = 0;
    5010:	4a0f      	ldr	r2, [pc, #60]	; (5050 <readEEP()+0x108>)
        state.mode = MODE_STOCK;
    5012:	7023      	strb	r3, [r4, #0]
        lastMode = 0;
    5014:	6013      	str	r3, [r2, #0]
        break;
    5016:	e7ea      	b.n	4fee <readEEP()+0xa6>
        state.mode_override = true;
    5018:	2301      	movs	r3, #1
    501a:	4c0b      	ldr	r4, [pc, #44]	; (5048 <readEEP()+0x100>)
        lastMode = 1;
    501c:	4a0c      	ldr	r2, [pc, #48]	; (5050 <readEEP()+0x108>)
        state.mode_override = true;
    501e:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
        state.mode = MODE_FWD;
    5022:	7023      	strb	r3, [r4, #0]
        lastMode = 1;
    5024:	6013      	str	r3, [r2, #0]
        break;
    5026:	e7e2      	b.n	4fee <readEEP()+0xa6>
        state.mode_override = true;
    5028:	4c07      	ldr	r4, [pc, #28]	; (5048 <readEEP()+0x100>)
        state.mode = MODE_5050;
    502a:	2302      	movs	r3, #2
    502c:	e7d9      	b.n	4fe2 <readEEP()+0x9a>
    502e:	4c06      	ldr	r4, [pc, #24]	; (5048 <readEEP()+0x100>)
    5030:	e7dd      	b.n	4fee <readEEP()+0xa6>
    5032:	bf00      	nop
    5034:	20000558 	.word	0x20000558
    5038:	20001110 	.word	0x20001110
    503c:	200019c0 	.word	0x200019c0
    5040:	2000a713 	.word	0x2000a713
    5044:	20000570 	.word	0x20000570
    5048:	2000a580 	.word	0x2000a580
    504c:	200005ac 	.word	0x200005ac
    5050:	2000a4ec 	.word	0x2000a4ec
    5054:	2000a715 	.word	0x2000a715

00005058 <writeEEP(void*)>:

bool writeEEP(void *params) {
    5058:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  // only update if the value has changed
  switch (state.mode) {
    505c:	4c42      	ldr	r4, [pc, #264]	; (5168 <writeEEP(void*)+0x110>)
bool writeEEP(void *params) {
    505e:	b082      	sub	sp, #8
    5060:	4d42      	ldr	r5, [pc, #264]	; (516c <writeEEP(void*)+0x114>)
  switch (state.mode) {
    5062:	7823      	ldrb	r3, [r4, #0]
    5064:	2b03      	cmp	r3, #3
    5066:	d805      	bhi.n	5074 <writeEEP(void*)+0x1c>
    5068:	e8df f003 	tbb	[pc, r3]
    506c:	0275787b 	.word	0x0275787b
      break;
    case MODE_5050:
      lastMode = 2;
      break;
    case MODE_CUSTOM:
      lastMode = 3;
    5070:	2303      	movs	r3, #3
    5072:	602b      	str	r3, [r5, #0]
      break;
  }

  // update EEP only if changes have been made
  EEPROM.update(0, softwareVersion);
    5074:	4f3e      	ldr	r7, [pc, #248]	; (5170 <writeEEP(void*)+0x118>)
    5076:	2000      	movs	r0, #0
    5078:	f000 ffce 	bl	6018 <eeprom_read_byte>
    507c:	7839      	ldrb	r1, [r7, #0]
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    507e:	4281      	cmp	r1, r0
    5080:	d002      	beq.n	5088 <writeEEP(void*)+0x30>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    5082:	2000      	movs	r0, #0
    5084:	f001 f8d4 	bl	6230 <eeprom_write_byte>
  EEPROM.update(1, isCustom);
    5088:	4b3a      	ldr	r3, [pc, #232]	; (5174 <writeEEP(void*)+0x11c>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    508a:	2001      	movs	r0, #1
    508c:	781e      	ldrb	r6, [r3, #0]
    508e:	f000 ffc3 	bl	6018 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    5092:	4286      	cmp	r6, r0
    5094:	d003      	beq.n	509e <writeEEP(void*)+0x46>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    5096:	4631      	mov	r1, r6
    5098:	2001      	movs	r0, #1
    509a:	f001 f8c9 	bl	6230 <eeprom_write_byte>
  EEPROM.update(2, lastMode);
    509e:	782e      	ldrb	r6, [r5, #0]
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    50a0:	2002      	movs	r0, #2
    50a2:	f000 ffb9 	bl	6018 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    50a6:	4286      	cmp	r6, r0
    50a8:	d003      	beq.n	50b2 <writeEEP(void*)+0x5a>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    50aa:	4631      	mov	r1, r6
    50ac:	2002      	movs	r0, #2
    50ae:	f001 f8bf 	bl	6230 <eeprom_write_byte>
  EEPROM.update(3, isStandalone);
    50b2:	4e31      	ldr	r6, [pc, #196]	; (5178 <writeEEP(void*)+0x120>)
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    50b4:	2003      	movs	r0, #3
    50b6:	f000 ffaf 	bl	6018 <eeprom_read_byte>
    50ba:	f896 8000 	ldrb.w	r8, [r6]
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    50be:	4580      	cmp	r8, r0
    50c0:	d003      	beq.n	50ca <writeEEP(void*)+0x72>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    50c2:	4641      	mov	r1, r8
    50c4:	2003      	movs	r0, #3
    50c6:	f001 f8b3 	bl	6230 <eeprom_write_byte>
  EEPROM.update(4, state.ped_threshold);
    50ca:	f894 8022 	ldrb.w	r8, [r4, #34]	; 0x22
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    50ce:	2004      	movs	r0, #4
    50d0:	f000 ffa2 	bl	6018 <eeprom_read_byte>
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    50d4:	4580      	cmp	r8, r0
    50d6:	d003      	beq.n	50e0 <writeEEP(void*)+0x88>
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    50d8:	4641      	mov	r1, r8
    50da:	2004      	movs	r0, #4
    50dc:	f001 f8a8 	bl	6230 <eeprom_write_byte>

#if stateDebug
  Serial.printf("Software Version: %d.%d%d%\n", (softwareVersion / 100) % 10, (softwareVersion / 10) % 10, (softwareVersion / 1) % 10);
    50e0:	683a      	ldr	r2, [r7, #0]
    50e2:	4b26      	ldr	r3, [pc, #152]	; (517c <writeEEP(void*)+0x124>)
    50e4:	4826      	ldr	r0, [pc, #152]	; (5180 <writeEEP(void*)+0x128>)
    50e6:	fb83 c702 	smull	ip, r7, r3, r2
    50ea:	fb80 1002 	smull	r1, r0, r0, r2
    50ee:	17d1      	asrs	r1, r2, #31
    50f0:	ebc1 1060 	rsb	r0, r1, r0, asr #5
    50f4:	ebc1 01a7 	rsb	r1, r1, r7, asr #2
    50f8:	fb83 7c00 	smull	r7, ip, r3, r0
    50fc:	fb83 3e01 	smull	r3, lr, r3, r1
    5100:	17cb      	asrs	r3, r1, #31
    5102:	ebc3 03ae 	rsb	r3, r3, lr, asr #2
    5106:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    510a:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
    510e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    5112:	eba2 0241 	sub.w	r2, r2, r1, lsl #1
    5116:	491b      	ldr	r1, [pc, #108]	; (5184 <writeEEP(void*)+0x12c>)
    5118:	9200      	str	r2, [sp, #0]
    511a:	17c2      	asrs	r2, r0, #31
    511c:	ebc2 02ac 	rsb	r2, r2, ip, asr #2
    5120:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    5124:	eba0 0242 	sub.w	r2, r0, r2, lsl #1
    5128:	4817      	ldr	r0, [pc, #92]	; (5188 <writeEEP(void*)+0x130>)
    512a:	f000 fc79 	bl	5a20 <Print::printf(char const*, ...)>
  Serial.printf("Last Mode: %d\n", lastMode);
    512e:	682a      	ldr	r2, [r5, #0]
    5130:	4916      	ldr	r1, [pc, #88]	; (518c <writeEEP(void*)+0x134>)
    5132:	4815      	ldr	r0, [pc, #84]	; (5188 <writeEEP(void*)+0x130>)
    5134:	f000 fc74 	bl	5a20 <Print::printf(char const*, ...)>
  Serial.printf("Is Standalone: %d\n", isStandalone);
    5138:	7832      	ldrb	r2, [r6, #0]
    513a:	4915      	ldr	r1, [pc, #84]	; (5190 <writeEEP(void*)+0x138>)
    513c:	4812      	ldr	r0, [pc, #72]	; (5188 <writeEEP(void*)+0x130>)
    513e:	f000 fc6f 	bl	5a20 <Print::printf(char const*, ...)>
  Serial.printf("Minimum Pedal: %d%\n", state.ped_threshold);
    5142:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
    5146:	4913      	ldr	r1, [pc, #76]	; (5194 <writeEEP(void*)+0x13c>)
    5148:	480f      	ldr	r0, [pc, #60]	; (5188 <writeEEP(void*)+0x130>)
    514a:	f000 fc69 	bl	5a20 <Print::printf(char const*, ...)>
#endif /* stateDebug */

  return true;
}
    514e:	2001      	movs	r0, #1
    5150:	b002      	add	sp, #8
    5152:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      lastMode = 2;
    5156:	2302      	movs	r3, #2
    5158:	602b      	str	r3, [r5, #0]
      break;
    515a:	e78b      	b.n	5074 <writeEEP(void*)+0x1c>
      lastMode = 1;
    515c:	2301      	movs	r3, #1
    515e:	602b      	str	r3, [r5, #0]
      break;
    5160:	e788      	b.n	5074 <writeEEP(void*)+0x1c>
      lastMode = 0;
    5162:	2300      	movs	r3, #0
    5164:	602b      	str	r3, [r5, #0]
      break;
    5166:	e785      	b.n	5074 <writeEEP(void*)+0x1c>
    5168:	2000a580 	.word	0x2000a580
    516c:	2000a4ec 	.word	0x2000a4ec
    5170:	200019c0 	.word	0x200019c0
    5174:	2000a713 	.word	0x2000a713
    5178:	2000a715 	.word	0x2000a715
    517c:	66666667 	.word	0x66666667
    5180:	51eb851f 	.word	0x51eb851f
    5184:	200005d4 	.word	0x200005d4
    5188:	20001110 	.word	0x20001110
    518c:	200005f0 	.word	0x200005f0
    5190:	2000046c 	.word	0x2000046c
    5194:	20000600 	.word	0x20000600

00005198 <_GLOBAL__sub_I__Z7readEEPv>:
    EEPROMClass()                        { eeprom_initialize(); }
    5198:	f000 bf1a 	b.w	5fd0 <eeprom_initialize>

0000519c <EventResponder::runFromInterrupt()>:
{
    519c:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    519e:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    51a2:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    51a4:	4c0c      	ldr	r4, [pc, #48]	; (51d8 <EventResponder::runFromInterrupt()+0x3c>)
    51a6:	6820      	ldr	r0, [r4, #0]
		if (first) {
    51a8:	b180      	cbz	r0, 51cc <EventResponder::runFromInterrupt()+0x30>
				lastInterrupt = nullptr;
    51aa:	4e0c      	ldr	r6, [pc, #48]	; (51dc <EventResponder::runFromInterrupt()+0x40>)
				firstInterrupt->_prev = nullptr;
    51ac:	2500      	movs	r5, #0
			firstInterrupt = first->_next;
    51ae:	6943      	ldr	r3, [r0, #20]
    51b0:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    51b2:	b173      	cbz	r3, 51d2 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    51b4:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    51b6:	b902      	cbnz	r2, 51ba <EventResponder::runFromInterrupt()+0x1e>
    51b8:	b662      	cpsie	i
			(*(first->_function))(*first);
    51ba:	6883      	ldr	r3, [r0, #8]
			first->_triggered = false;
    51bc:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    51be:	4798      	blx	r3
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    51c0:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    51c4:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    51c6:	6820      	ldr	r0, [r4, #0]
		if (first) {
    51c8:	2800      	cmp	r0, #0
    51ca:	d1f0      	bne.n	51ae <EventResponder::runFromInterrupt()+0x12>
		if (doit) __enable_irq();
    51cc:	b902      	cbnz	r2, 51d0 <EventResponder::runFromInterrupt()+0x34>
    51ce:	b662      	cpsie	i
}
    51d0:	bd70      	pop	{r4, r5, r6, pc}
				lastInterrupt = nullptr;
    51d2:	6033      	str	r3, [r6, #0]
    51d4:	e7ef      	b.n	51b6 <EventResponder::runFromInterrupt()+0x1a>
    51d6:	bf00      	nop
    51d8:	2000a330 	.word	0x2000a330
    51dc:	2000a32c 	.word	0x2000a32c

000051e0 <pendablesrvreq_isr>:
	EventResponder::runFromInterrupt();
    51e0:	f7ff bfdc 	b.w	519c <EventResponder::runFromInterrupt()>

000051e4 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    51e4:	4904      	ldr	r1, [pc, #16]	; (51f8 <systick_isr+0x14>)
	systick_millis_count++;
    51e6:	4a05      	ldr	r2, [pc, #20]	; (51fc <systick_isr+0x18>)
	systick_cycle_count = ARM_DWT_CYCCNT;
    51e8:	6849      	ldr	r1, [r1, #4]
    51ea:	4b05      	ldr	r3, [pc, #20]	; (5200 <systick_isr+0x1c>)
    51ec:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    51ee:	6813      	ldr	r3, [r2, #0]
    51f0:	3301      	adds	r3, #1
    51f2:	6013      	str	r3, [r2, #0]
}
    51f4:	4770      	bx	lr
    51f6:	bf00      	nop
    51f8:	e0001000 	.word	0xe0001000
    51fc:	2000a5a8 	.word	0x2000a5a8
    5200:	2000a5a4 	.word	0x2000a5a4

00005204 <HardwareSerialIMXRT::operator bool()>:
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	*/

	operator bool()			{ return true; }
    5204:	2001      	movs	r0, #1
    5206:	4770      	bx	lr

00005208 <HardwareSerialIMXRT::availableForWrite()>:

int HardwareSerialIMXRT::availableForWrite(void)
{
	uint32_t head, tail;

	head = tx_buffer_head_;
    5208:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
	tail = tx_buffer_tail_;
    520c:	f8b0 2048 	ldrh.w	r2, [r0, #72]	; 0x48
	head = tx_buffer_head_;
    5210:	b29b      	uxth	r3, r3
	tail = tx_buffer_tail_;
    5212:	b292      	uxth	r2, r2
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    5214:	4293      	cmp	r3, r2
    5216:	d202      	bcs.n	521e <HardwareSerialIMXRT::availableForWrite()+0x16>
	return tail - head - 1;
    5218:	3a01      	subs	r2, #1
    521a:	1ad0      	subs	r0, r2, r3
}
    521c:	4770      	bx	lr
	if (head >= tail) return tx_buffer_total_size_ - 1 - head + tail;
    521e:	6b41      	ldr	r1, [r0, #52]	; 0x34
    5220:	3901      	subs	r1, #1
    5222:	440a      	add	r2, r1
    5224:	1ad0      	subs	r0, r2, r3
    5226:	4770      	bx	lr

00005228 <HardwareSerialIMXRT::available()>:



int HardwareSerialIMXRT::available(void)
{
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5228:	6901      	ldr	r1, [r0, #16]
	uint32_t head, tail;

	// WATER> 0 so IDLE involved may want to check if port has already has RX data to retrieve
	__disable_irq();
    522a:	b672      	cpsid	i
	head = rx_buffer_head_;
    522c:	f8b0 204a 	ldrh.w	r2, [r0, #74]	; 0x4a
	tail = rx_buffer_tail_;
    5230:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    5234:	b292      	uxth	r2, r2
	tail = rx_buffer_tail_;
    5236:	b29b      	uxth	r3, r3
	int avail;
	if (head >= tail) avail = head - tail;
    5238:	429a      	cmp	r2, r3
	else avail = rx_buffer_total_size_ + head - tail;	
    523a:	bf3c      	itt	cc
    523c:	6b80      	ldrcc	r0, [r0, #56]	; 0x38
    523e:	1812      	addcc	r2, r2, r0
	avail += (port->WATER >> 24) & 0x7;
    5240:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
	else avail = rx_buffer_total_size_ + head - tail;	
    5242:	1ad3      	subs	r3, r2, r3
	__enable_irq();
    5244:	b662      	cpsie	i
	avail += (port->WATER >> 24) & 0x7;
    5246:	f3c0 6002 	ubfx	r0, r0, #24, #3
	return avail;
}
    524a:	4418      	add	r0, r3
    524c:	4770      	bx	lr
    524e:	bf00      	nop

00005250 <HardwareSerialIMXRT::peek()>:
int HardwareSerialIMXRT::peek(void)
{
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
	uint32_t head, tail;

	head = rx_buffer_head_;
    5250:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    5254:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    5256:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    525a:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    525c:	b29b      	uxth	r3, r3
	if (head == tail) {
    525e:	4299      	cmp	r1, r3
{
    5260:	b410      	push	{r4}
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5262:	6904      	ldr	r4, [r0, #16]
	if (head == tail) {
    5264:	d014      	beq.n	5290 <HardwareSerialIMXRT::peek()+0x40>
			return c;
		}
		__enable_irq();

	} 
	if (++tail >= rx_buffer_total_size_) tail = 0;
    5266:	3301      	adds	r3, #1
    5268:	6b90      	ldr	r0, [r2, #56]	; 0x38
	if (tail < rx_buffer_size_) {
    526a:	6b11      	ldr	r1, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    526c:	4298      	cmp	r0, r3
    526e:	bf98      	it	ls
    5270:	2300      	movls	r3, #0
	if (tail < rx_buffer_size_) {
    5272:	4299      	cmp	r1, r3
    5274:	d806      	bhi.n	5284 <HardwareSerialIMXRT::peek()+0x34>
		return rx_buffer_[tail];
	} else {
		return rx_buffer_storage_[tail-rx_buffer_size_];
    5276:	1a5b      	subs	r3, r3, r1
    5278:	6a52      	ldr	r2, [r2, #36]	; 0x24
    527a:	5cd0      	ldrb	r0, [r2, r3]
    527c:	b2c0      	uxtb	r0, r0
	}
}
    527e:	f85d 4b04 	ldr.w	r4, [sp], #4
    5282:	4770      	bx	lr
		return rx_buffer_[tail];
    5284:	6a12      	ldr	r2, [r2, #32]
}
    5286:	f85d 4b04 	ldr.w	r4, [sp], #4
		return rx_buffer_[tail];
    528a:	5cd0      	ldrb	r0, [r2, r3]
    528c:	b2c0      	uxtb	r0, r0
}
    528e:	4770      	bx	lr
		__disable_irq();
    5290:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    5292:	f8b0 004a 	ldrh.w	r0, [r0, #74]	; 0x4a
    5296:	b280      	uxth	r0, r0
		if (head == tail) {
    5298:	4281      	cmp	r1, r0
    529a:	d001      	beq.n	52a0 <HardwareSerialIMXRT::peek()+0x50>
		__enable_irq();
    529c:	b662      	cpsie	i
    529e:	e7e2      	b.n	5266 <HardwareSerialIMXRT::peek()+0x16>
			if (port->WATER & 0x7000000) {
    52a0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    52a2:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
    52a6:	d103      	bne.n	52b0 <HardwareSerialIMXRT::peek()+0x60>
			int c = -1;	// assume nothing to return
    52a8:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    52ac:	b662      	cpsie	i
			return c;
    52ae:	e7e6      	b.n	527e <HardwareSerialIMXRT::peek()+0x2e>
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    52b0:	69e3      	ldr	r3, [r4, #28]
				rx_buffer_head_ = 1;
    52b2:	2001      	movs	r0, #1
				rx_buffer_tail_ = 0; 
    52b4:	2400      	movs	r4, #0
				rx_buffer_[1] = c;
    52b6:	6a11      	ldr	r1, [r2, #32]
				rx_buffer_head_ = 1;
    52b8:	f8a2 004a 	strh.w	r0, [r2, #74]	; 0x4a
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    52bc:	f3c3 0009 	ubfx	r0, r3, #0, #10
				rx_buffer_[1] = c;
    52c0:	b2db      	uxtb	r3, r3
				rx_buffer_tail_ = 0; 
    52c2:	f8a2 404c 	strh.w	r4, [r2, #76]	; 0x4c
				rx_buffer_[1] = c;
    52c6:	704b      	strb	r3, [r1, #1]
    52c8:	e7f0      	b.n	52ac <HardwareSerialIMXRT::peek()+0x5c>
    52ca:	bf00      	nop

000052cc <HardwareSerialIMXRT::read()>:
{
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
	uint32_t head, tail;
	int c;

	head = rx_buffer_head_;
    52cc:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
{
    52d0:	4602      	mov	r2, r0
	tail = rx_buffer_tail_;
    52d2:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
	head = rx_buffer_head_;
    52d6:	b289      	uxth	r1, r1
	tail = rx_buffer_tail_;
    52d8:	b29b      	uxth	r3, r3
	if (head == tail) {
    52da:	4299      	cmp	r1, r3
{
    52dc:	b430      	push	{r4, r5}
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    52de:	6904      	ldr	r4, [r0, #16]
	if (head == tail) {
    52e0:	d025      	beq.n	532e <HardwareSerialIMXRT::read()+0x62>
			return c;
		}
		__enable_irq();

	}
	if (++tail >= rx_buffer_total_size_) tail = 0;
    52e2:	3301      	adds	r3, #1
    52e4:	6b94      	ldr	r4, [r2, #56]	; 0x38
    52e6:	429c      	cmp	r4, r3
    52e8:	d916      	bls.n	5318 <HardwareSerialIMXRT::read()+0x4c>
	if (tail < rx_buffer_size_) {
    52ea:	6b10      	ldr	r0, [r2, #48]	; 0x30
		c = rx_buffer_[tail];
	} else {
		c = rx_buffer_storage_[tail-rx_buffer_size_];
	}
	rx_buffer_tail_ = tail;
    52ec:	fa1f fc83 	uxth.w	ip, r3
	if (tail < rx_buffer_size_) {
    52f0:	4298      	cmp	r0, r3
    52f2:	d917      	bls.n	5324 <HardwareSerialIMXRT::read()+0x58>
		c = rx_buffer_[tail];
    52f4:	6a10      	ldr	r0, [r2, #32]
    52f6:	5cc0      	ldrb	r0, [r0, r3]
    52f8:	b2c0      	uxtb	r0, r0
	if (rts_pin_baseReg_) {
    52fa:	6d95      	ldr	r5, [r2, #88]	; 0x58
	rx_buffer_tail_ = tail;
    52fc:	f8a2 c04c 	strh.w	ip, [r2, #76]	; 0x4c
	if (rts_pin_baseReg_) {
    5300:	b145      	cbz	r5, 5314 <HardwareSerialIMXRT::read()+0x48>
		uint32_t avail;
		if (head >= tail) avail = head - tail;
    5302:	4299      	cmp	r1, r3
    5304:	d31c      	bcc.n	5340 <HardwareSerialIMXRT::read()+0x74>
    5306:	1acb      	subs	r3, r1, r3
		else avail = rx_buffer_total_size_ + head - tail;

		if (avail <= rts_low_watermark_) rts_assert();
    5308:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
    530a:	4299      	cmp	r1, r3
    530c:	d302      	bcc.n	5314 <HardwareSerialIMXRT::read()+0x48>
	DIRECT_WRITE_LOW(rts_pin_baseReg_, rts_pin_bitmask_);
    530e:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    5310:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
	}
	return c;
}	
    5314:	bc30      	pop	{r4, r5}
    5316:	4770      	bx	lr
    5318:	f04f 0c00 	mov.w	ip, #0
	if (tail < rx_buffer_size_) {
    531c:	6b10      	ldr	r0, [r2, #48]	; 0x30
	if (++tail >= rx_buffer_total_size_) tail = 0;
    531e:	4663      	mov	r3, ip
	if (tail < rx_buffer_size_) {
    5320:	4298      	cmp	r0, r3
    5322:	d8e7      	bhi.n	52f4 <HardwareSerialIMXRT::read()+0x28>
		c = rx_buffer_storage_[tail-rx_buffer_size_];
    5324:	1a18      	subs	r0, r3, r0
    5326:	6a55      	ldr	r5, [r2, #36]	; 0x24
    5328:	5c28      	ldrb	r0, [r5, r0]
    532a:	b2c0      	uxtb	r0, r0
    532c:	e7e5      	b.n	52fa <HardwareSerialIMXRT::read()+0x2e>
    532e:	4608      	mov	r0, r1
		__disable_irq();
    5330:	b672      	cpsid	i
		head = rx_buffer_head_;  // reread head to make sure no ISR happened
    5332:	f8b2 104a 	ldrh.w	r1, [r2, #74]	; 0x4a
    5336:	b289      	uxth	r1, r1
		if (head == tail) {
    5338:	4288      	cmp	r0, r1
    533a:	d004      	beq.n	5346 <HardwareSerialIMXRT::read()+0x7a>
		__enable_irq();
    533c:	b662      	cpsie	i
    533e:	e7d0      	b.n	52e2 <HardwareSerialIMXRT::read()+0x16>
		else avail = rx_buffer_total_size_ + head - tail;
    5340:	440c      	add	r4, r1
    5342:	1ae3      	subs	r3, r4, r3
    5344:	e7e0      	b.n	5308 <HardwareSerialIMXRT::read()+0x3c>
			if (port->WATER & 0x7000000) {
    5346:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5348:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
    534c:	d103      	bne.n	5356 <HardwareSerialIMXRT::read()+0x8a>
			c = -1;	// assume nothing to return
    534e:	f04f 30ff 	mov.w	r0, #4294967295
			__enable_irq();
    5352:	b662      	cpsie	i
			return c;
    5354:	e7de      	b.n	5314 <HardwareSerialIMXRT::read()+0x48>
				c = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    5356:	69e0      	ldr	r0, [r4, #28]
    5358:	f3c0 0009 	ubfx	r0, r0, #0, #10
    535c:	e7f9      	b.n	5352 <HardwareSerialIMXRT::read()+0x86>
    535e:	bf00      	nop

00005360 <HardwareSerialIMXRT::flush()>:

void HardwareSerialIMXRT::flush(void)
{
	while (transmitting_) yield(); // wait
    5360:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
    5364:	b143      	cbz	r3, 5378 <HardwareSerialIMXRT::flush()+0x18>
{
    5366:	b510      	push	{r4, lr}
    5368:	4604      	mov	r4, r0
	while (transmitting_) yield(); // wait
    536a:	f002 fc49 	bl	7c00 <yield>
    536e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    5372:	2b00      	cmp	r3, #0
    5374:	d1f9      	bne.n	536a <HardwareSerialIMXRT::flush()+0xa>
}
    5376:	bd10      	pop	{r4, pc}
    5378:	4770      	bx	lr
    537a:	bf00      	nop

0000537c <HardwareSerialIMXRT::end()>:
{
    537c:	b538      	push	{r3, r4, r5, lr}
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    537e:	e9d0 5304 	ldrd	r5, r3, [r0, #16]
	if (!(hardware->ccm_register & hardware->ccm_value)) return;
    5382:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
    5386:	6809      	ldr	r1, [r1, #0]
    5388:	4211      	tst	r1, r2
    538a:	d028      	beq.n	53de <HardwareSerialIMXRT::end()+0x62>
	while (transmitting_) yield();  // wait for buffered data to send
    538c:	f890 2044 	ldrb.w	r2, [r0, #68]	; 0x44
    5390:	4604      	mov	r4, r0
    5392:	b132      	cbz	r2, 53a2 <HardwareSerialIMXRT::end()+0x26>
    5394:	f002 fc34 	bl	7c00 <yield>
    5398:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    539c:	2b00      	cmp	r3, #0
    539e:	d1f9      	bne.n	5394 <HardwareSerialIMXRT::end()+0x18>
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    53a0:	6963      	ldr	r3, [r4, #20]
	port->CTRL = 0;	// disable the TX and RX ...
    53a2:	2100      	movs	r1, #0
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    53a4:	4a0e      	ldr	r2, [pc, #56]	; (53e0 <HardwareSerialIMXRT::end()+0x64>)
	port->CTRL = 0;	// disable the TX and RX ...
    53a6:	61a9      	str	r1, [r5, #24]
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = 5;
    53a8:	7e20      	ldrb	r0, [r4, #24]
    53aa:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    53ae:	7d00      	ldrb	r0, [r0, #20]
    53b0:	eb02 1000 	add.w	r0, r2, r0, lsl #4
    53b4:	6845      	ldr	r5, [r0, #4]
    53b6:	2005      	movs	r0, #5
    53b8:	6028      	str	r0, [r5, #0]
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    53ba:	7e65      	ldrb	r5, [r4, #25]
    53bc:	eb03 1305 	add.w	r3, r3, r5, lsl #4
    53c0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
    53c4:	eb02 1203 	add.w	r2, r2, r3, lsl #4
	if (rts_pin_baseReg_) rts_deassert();
    53c8:	6da3      	ldr	r3, [r4, #88]	; 0x58
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = 5;
    53ca:	6852      	ldr	r2, [r2, #4]
    53cc:	6010      	str	r0, [r2, #0]
	rx_buffer_head_ = 0;
    53ce:	f8a4 104a 	strh.w	r1, [r4, #74]	; 0x4a
	rx_buffer_tail_ = 0;
    53d2:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
	if (rts_pin_baseReg_) rts_deassert();
    53d6:	b113      	cbz	r3, 53de <HardwareSerialIMXRT::end()+0x62>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    53d8:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    53da:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    53de:	bd38      	pop	{r3, r4, r5, pc}
    53e0:	20000b7c 	.word	0x20000b7c

000053e4 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)>:
	float base = (float)UART_CLOCK / (float)baud;
    53e4:	ee07 1a90 	vmov	s15, r1
    53e8:	ed9f 7a9a 	vldr	s14, [pc, #616]	; 5654 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x270>
	for (int osr=4; osr <= 32; osr++) {
    53ec:	2104      	movs	r1, #4
		int divint = (int)(div + 0.5f);
    53ee:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
	float base = (float)UART_CLOCK / (float)baud;
    53f2:	eef8 7a67 	vcvt.f32.u32	s15, s15
	float besterr = 1e20;
    53f6:	ed9f 6a98 	vldr	s12, [pc, #608]	; 5658 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x274>
    53fa:	f641 7cff 	movw	ip, #8191	; 0x1fff
	float base = (float)UART_CLOCK / (float)baud;
    53fe:	eec7 5a27 	vdiv.f32	s11, s14, s15
{
    5402:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int bestosr = 4;
    5406:	468e      	mov	lr, r1
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    5408:	6905      	ldr	r5, [r0, #16]
	int bestdiv = 1;
    540a:	2401      	movs	r4, #1
		float div = base / (float)osr;
    540c:	ee07 1a90 	vmov	s15, r1
    5410:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    5414:	ee85 7aa7 	vdiv.f32	s14, s11, s15
		int divint = (int)(div + 0.5f);
    5418:	ee77 7a05 	vadd.f32	s15, s14, s10
    541c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    5420:	ee17 3a90 	vmov	r3, s15
    5424:	4563      	cmp	r3, ip
    5426:	bfa8      	it	ge
    5428:	4663      	movge	r3, ip
    542a:	2b01      	cmp	r3, #1
    542c:	bfb8      	it	lt
    542e:	2301      	movlt	r3, #1
		float err = ((float)divint - div) / div;
    5430:	ee07 3a90 	vmov	s15, r3
    5434:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    5438:	ee76 6ac7 	vsub.f32	s13, s13, s14
    543c:	eec6 7a87 	vdiv.f32	s15, s13, s14
		if (err < 0.0f) err = -err;
    5440:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    5444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5448:	bf48      	it	mi
    544a:	eef1 7a67 	vnegmi.f32	s15, s15
		if (err <= besterr) {
    544e:	eef4 7ac6 	vcmpe.f32	s15, s12
    5452:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5456:	d803      	bhi.n	5460 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x7c>
			besterr = err;
    5458:	eeb0 6a67 	vmov.f32	s12, s15
		if (err <= besterr) {
    545c:	468e      	mov	lr, r1
			bestdiv = divint;
    545e:	461c      	mov	r4, r3
	for (int osr=4; osr <= 32; osr++) {
    5460:	3101      	adds	r1, #1
    5462:	2921      	cmp	r1, #33	; 0x21
    5464:	d1d2      	bne.n	540c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x28>
	rx_buffer_head_ = 0;
    5466:	2100      	movs	r1, #0
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    5468:	6943      	ldr	r3, [r0, #20]
    546a:	f402 7600 	and.w	r6, r2, #512	; 0x200
	rx_buffer_head_ = 0;
    546e:	f8a0 104a 	strh.w	r1, [r0, #74]	; 0x4a
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    5472:	f8b3 c05a 	ldrh.w	ip, [r3, #90]	; 0x5a
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    5476:	428e      	cmp	r6, r1
	rx_buffer_tail_ = 0;
    5478:	f8a0 104c 	strh.w	r1, [r0, #76]	; 0x4c
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    547c:	f8b3 6058 	ldrh.w	r6, [r3, #88]	; 0x58
	tx_buffer_head_ = 0;
    5480:	f8a0 1046 	strh.w	r1, [r0, #70]	; 0x46
	tx_buffer_tail_ = 0;
    5484:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	transmitting_ = 0;
    5488:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    548c:	6b81      	ldr	r1, [r0, #56]	; 0x38
	hardware->ccm_register |= hardware->ccm_value;
    548e:	68df      	ldr	r7, [r3, #12]
	rts_low_watermark_ = rx_buffer_total_size_ - hardware->rts_low_watermark;
    5490:	eba1 0606 	sub.w	r6, r1, r6
	rts_high_watermark_ = rx_buffer_total_size_ - hardware->rts_high_watermark;
    5494:	eba1 010c 	sub.w	r1, r1, ip
    5498:	e9c0 610f 	strd	r6, r1, [r0, #60]	; 0x3c
	hardware->ccm_register |= hardware->ccm_value;
    549c:	6839      	ldr	r1, [r7, #0]
    549e:	691e      	ldr	r6, [r3, #16]
    54a0:	ea41 0106 	orr.w	r1, r1, r6
    54a4:	6039      	str	r1, [r7, #0]
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
    54a6:	bf14      	ite	ne
    54a8:	2101      	movne	r1, #1
    54aa:	2100      	moveq	r1, #0
    54ac:	7681      	strb	r1, [r0, #26]
	if (!half_duplex_mode_)  {
    54ae:	f040 80ac 	bne.w	560a <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x226>
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    54b2:	7e01      	ldrb	r1, [r0, #24]
    54b4:	4e69      	ldr	r6, [pc, #420]	; (565c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x278>)
    54b6:	eb03 1801 	add.w	r8, r3, r1, lsl #4
    54ba:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 567c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x298>
    54be:	f898 7014 	ldrb.w	r7, [r8, #20]
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
    54c2:	f8d8 a01c 	ldr.w	sl, [r8, #28]
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    54c6:	eb06 1707 	add.w	r7, r6, r7, lsl #4
    54ca:	68b9      	ldr	r1, [r7, #8]
    54cc:	f8c1 9000 	str.w	r9, [r1]
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
    54d0:	6879      	ldr	r1, [r7, #4]
    54d2:	f8d8 7018 	ldr.w	r7, [r8, #24]
    54d6:	600f      	str	r7, [r1, #0]
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
    54d8:	f1ba 0f00 	cmp.w	sl, #0
    54dc:	d003      	beq.n	54e6 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x102>
		 	*(hardware->rx_pins[rx_pin_index_].select_input_register) =  hardware->rx_pins[rx_pin_index_].select_val;		
    54de:	f8d8 1020 	ldr.w	r1, [r8, #32]
    54e2:	f8ca 1000 	str.w	r1, [sl]
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
    54e6:	7e47      	ldrb	r7, [r0, #25]
    54e8:	21d9      	movs	r1, #217	; 0xd9
    54ea:	eb03 1807 	add.w	r8, r3, r7, lsl #4
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    54ee:	f898 c034 	ldrb.w	ip, [r8, #52]	; 0x34
    54f2:	eb06 1c0c 	add.w	ip, r6, ip, lsl #4
    54f6:	f8dc 7008 	ldr.w	r7, [ip, #8]
    54fa:	6039      	str	r1, [r7, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
    54fc:	f8dc 1004 	ldr.w	r1, [ip, #4]
    5500:	f8d8 7038 	ldr.w	r7, [r8, #56]	; 0x38
    5504:	600f      	str	r7, [r1, #0]
	if (hardware->tx_pins[tx_pin_index_].select_input_register) {
    5506:	7e41      	ldrb	r1, [r0, #25]
    5508:	eb03 1101 	add.w	r1, r3, r1, lsl #4
    550c:	6bcf      	ldr	r7, [r1, #60]	; 0x3c
    550e:	b10f      	cbz	r7, 5514 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x130>
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
    5510:	6c09      	ldr	r1, [r1, #64]	; 0x40
    5512:	6039      	str	r1, [r7, #0]
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    5514:	f10e 31ff 	add.w	r1, lr, #4294967295
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    5518:	f1be 0f08 	cmp.w	lr, #8
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    551c:	ea4f 6101 	mov.w	r1, r1, lsl #24
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    5520:	bfcc      	ite	gt
    5522:	f04f 0e00 	movgt.w	lr, #0
    5526:	f04f 0e01 	movle.w	lr, #1
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    552a:	f001 51f8 	and.w	r1, r1, #520093696	; 0x1f000000
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
    552e:	ea44 444e 	orr.w	r4, r4, lr, lsl #17
    5532:	4321      	orrs	r1, r4
	attachInterruptVector(hardware->irq, hardware->irq_handler);
    5534:	685c      	ldr	r4, [r3, #4]
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
    5536:	6129      	str	r1, [r5, #16]
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    5538:	7859      	ldrb	r1, [r3, #1]
    553a:	f101 0310 	add.w	r3, r1, #16
	port->PINCFG = 0;
    553e:	2100      	movs	r1, #0
    5540:	60e9      	str	r1, [r5, #12]
    5542:	4947      	ldr	r1, [pc, #284]	; (5660 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x27c>)
    5544:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    5548:	6941      	ldr	r1, [r0, #20]
	NVIC_ENABLE_IRQ(hardware->irq);
    554a:	f04f 0e01 	mov.w	lr, #1
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    554e:	4c45      	ldr	r4, [pc, #276]	; (5664 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x280>)
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    5550:	f002 0c03 	and.w	ip, r2, #3
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    5554:	784f      	ldrb	r7, [r1, #1]
    5556:	f891 1056 	ldrb.w	r1, [r1, #86]	; 0x56
	NVIC_ENABLE_IRQ(hardware->irq);
    555a:	4b43      	ldr	r3, [pc, #268]	; (5668 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x284>)
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
    555c:	5539      	strb	r1, [r7, r4]
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
    555e:	f04f 1702 	mov.w	r7, #131074	; 0x20002
	NVIC_ENABLE_IRQ(hardware->irq);
    5562:	6944      	ldr	r4, [r0, #20]
    5564:	7861      	ldrb	r1, [r4, #1]
    5566:	eb03 1351 	add.w	r3, r3, r1, lsr #5
    556a:	f001 011f 	and.w	r1, r1, #31
    556e:	009b      	lsls	r3, r3, #2
    5570:	fa0e f101 	lsl.w	r1, lr, r1
    5574:	6019      	str	r1, [r3, #0]
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
    5576:	62ef      	str	r7, [r5, #44]	; 0x2c
	port->FIFO |= LPUART_FIFO_TXFE | LPUART_FIFO_RXFE;
    5578:	6aab      	ldr	r3, [r5, #40]	; 0x28
    557a:	f043 0388 	orr.w	r3, r3, #136	; 0x88
    557e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    5580:	0753      	lsls	r3, r2, #29
    5582:	d43e      	bmi.n	5602 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x21e>
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
    5584:	f44c 1370 	orr.w	r3, ip, #3932160	; 0x3c0000
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
    5588:	f002 010f 	and.w	r1, r2, #15
    558c:	2904      	cmp	r1, #4
    558e:	bf08      	it	eq
    5590:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
	if (format & 0x20) {
    5594:	0697      	lsls	r7, r2, #26
    5596:	d52e      	bpl.n	55f6 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x212>
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    5598:	7e81      	ldrb	r1, [r0, #26]
		ctrl |= LPUART_CTRL_TXINV;		// tx invert
    559a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    559e:	2900      	cmp	r1, #0
    55a0:	d13a      	bne.n	5618 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x234>
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    55a2:	0716      	lsls	r6, r2, #28
	port->CTRL = ctrl;
    55a4:	61ab      	str	r3, [r5, #24]
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
    55a6:	d503      	bpl.n	55b0 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1cc>
    55a8:	692b      	ldr	r3, [r5, #16]
    55aa:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    55ae:	612b      	str	r3, [r5, #16]
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    55b0:	696b      	ldr	r3, [r5, #20]
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    55b2:	06d1      	lsls	r1, r2, #27
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
    55b4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
    55b8:	bf48      	it	mi
    55ba:	f043 5380 	orrmi.w	r3, r3, #268435456	; 0x10000000
	port->STAT = c;
    55be:	616b      	str	r3, [r5, #20]
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
    55c0:	05d3      	lsls	r3, r2, #23
    55c2:	d503      	bpl.n	55cc <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1e8>
    55c4:	692b      	ldr	r3, [r5, #16]
    55c6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    55ca:	612b      	str	r3, [r5, #16]
	if (hardware->_serialEvent) addToSerialEventsList();
    55cc:	68a3      	ldr	r3, [r4, #8]
    55ce:	b183      	cbz	r3, 55f2 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x20e>
	//digitalWrite(4, LOW);
}


void HardwareSerialIMXRT::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    55d0:	4e26      	ldr	r6, [pc, #152]	; (566c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x288>)
    55d2:	7834      	ldrb	r4, [r6, #0]
    55d4:	2c00      	cmp	r4, #0
    55d6:	d03a      	beq.n	564e <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x26a>
    55d8:	1e61      	subs	r1, r4, #1
    55da:	4d25      	ldr	r5, [pc, #148]	; (5670 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x28c>)
    55dc:	b2c9      	uxtb	r1, r1
    55de:	1f2b      	subs	r3, r5, #4
    55e0:	eb05 0181 	add.w	r1, r5, r1, lsl #2
    55e4:	e001      	b.n	55ea <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x206>
    55e6:	4299      	cmp	r1, r3
    55e8:	d025      	beq.n	5636 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x252>
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
    55ea:	f853 2f04 	ldr.w	r2, [r3, #4]!
    55ee:	4290      	cmp	r0, r2
    55f0:	d1f9      	bne.n	55e6 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x202>
};
    55f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    55f6:	7e81      	ldrb	r1, [r0, #26]
    55f8:	2900      	cmp	r1, #0
    55fa:	d0d2      	beq.n	55a2 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1be>
    55fc:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
    5600:	e7cf      	b.n	55a2 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1be>
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
    5602:	4b1c      	ldr	r3, [pc, #112]	; (5674 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x290>)
    5604:	ea4c 0303 	orr.w	r3, ip, r3
    5608:	e7be      	b.n	5588 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1a4>
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
    560a:	7e47      	ldrb	r7, [r0, #25]
    560c:	f24f 01d9 	movw	r1, #61657	; 0xf0d9
    5610:	4e12      	ldr	r6, [pc, #72]	; (565c <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x278>)
    5612:	eb03 1807 	add.w	r8, r3, r7, lsl #4
    5616:	e76a      	b.n	54ee <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x10a>
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    5618:	7e41      	ldrb	r1, [r0, #25]
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    561a:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
		if (half_duplex_mode_) *(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) &=  ~IOMUXC_PAD_PUS(3);
    561e:	eb04 1101 	add.w	r1, r4, r1, lsl #4
    5622:	f891 1034 	ldrb.w	r1, [r1, #52]	; 0x34
    5626:	eb06 1601 	add.w	r6, r6, r1, lsl #4
    562a:	68b6      	ldr	r6, [r6, #8]
    562c:	6831      	ldr	r1, [r6, #0]
    562e:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    5632:	6031      	str	r1, [r6, #0]
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
    5634:	e7b5      	b.n	55a2 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x1be>
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    5636:	1c63      	adds	r3, r4, #1
    5638:	b2db      	uxtb	r3, r3
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    563a:	4a0f      	ldr	r2, [pc, #60]	; (5678 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x294>)
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    563c:	7033      	strb	r3, [r6, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    563e:	7813      	ldrb	r3, [r2, #0]
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
    5640:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
    5644:	f043 0302 	orr.w	r3, r3, #2
    5648:	7013      	strb	r3, [r2, #0]
};
    564a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    564e:	2301      	movs	r3, #1
    5650:	4d07      	ldr	r5, [pc, #28]	; (5670 <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x28c>)
    5652:	e7f2      	b.n	563a <HardwareSerialIMXRT::begin(unsigned long, unsigned short)+0x256>
    5654:	4bb71b00 	.word	0x4bb71b00
    5658:	60ad78ec 	.word	0x60ad78ec
    565c:	20000b7c 	.word	0x20000b7c
    5660:	20001c00 	.word	0x20001c00
    5664:	e000e400 	.word	0xe000e400
    5668:	38003840 	.word	0x38003840
    566c:	2000a70b 	.word	0x2000a70b
    5670:	2000a338 	.word	0x2000a338
    5674:	003c0010 	.word	0x003c0010
    5678:	2000a721 	.word	0x2000a721
    567c:	0001f038 	.word	0x0001f038

00005680 <nvic_execution_priority()>:
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
    5680:	f3ef 8013 	mrs	r0, FAULTMASK
	if (faultmask) return -1;
    5684:	b9b8      	cbnz	r0, 56b6 <nvic_execution_priority()+0x36>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    5686:	f3ef 8310 	mrs	r3, PRIMASK
	if (primask) return 0;
    568a:	b94b      	cbnz	r3, 56a0 <nvic_execution_priority()+0x20>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    568c:	f3ef 8205 	mrs	r2, IPSR
	if (ipsr) {
    5690:	b93a      	cbnz	r2, 56a2 <nvic_execution_priority()+0x22>
	uint32_t priority=256;
    5692:	f44f 7380 	mov.w	r3, #256	; 0x100
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    5696:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    569a:	b150      	cbz	r0, 56b2 <nvic_execution_priority()+0x32>
    569c:	4298      	cmp	r0, r3
    569e:	d208      	bcs.n	56b2 <nvic_execution_priority()+0x32>
}
    56a0:	4770      	bx	lr
		if (ipsr < 16) priority = 0; // could be non-zero
    56a2:	2a0f      	cmp	r2, #15
    56a4:	d9f7      	bls.n	5696 <nvic_execution_priority()+0x16>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
    56a6:	4b05      	ldr	r3, [pc, #20]	; (56bc <nvic_execution_priority()+0x3c>)
    56a8:	5c9b      	ldrb	r3, [r3, r2]
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    56aa:	f3ef 8011 	mrs	r0, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    56ae:	2800      	cmp	r0, #0
    56b0:	d1f4      	bne.n	569c <nvic_execution_priority()+0x1c>
    56b2:	4618      	mov	r0, r3
	return priority;
    56b4:	4770      	bx	lr
	if (faultmask) return -1;
    56b6:	f04f 30ff 	mov.w	r0, #4294967295
    56ba:	e7f1      	b.n	56a0 <nvic_execution_priority()+0x20>
    56bc:	e000e3f0 	.word	0xe000e3f0

000056c0 <HardwareSerialIMXRT::write9bit(unsigned long)>:
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    56c0:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
    56c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    56c6:	4604      	mov	r4, r0
    56c8:	460f      	mov	r7, r1
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    56ca:	6906      	ldr	r6, [r0, #16]
	if (transmit_pin_baseReg_) DIRECT_WRITE_HIGH(transmit_pin_baseReg_, transmit_pin_bitmask_);
    56cc:	b113      	cbz	r3, 56d4 <HardwareSerialIMXRT::write9bit(unsigned long)+0x14>
    56ce:	6d42      	ldr	r2, [r0, #84]	; 0x54
    56d0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	if(half_duplex_mode_) {		
    56d4:	7ea3      	ldrb	r3, [r4, #26]
    56d6:	b12b      	cbz	r3, 56e4 <HardwareSerialIMXRT::write9bit(unsigned long)+0x24>
		__disable_irq();
    56d8:	b672      	cpsid	i
	    port->CTRL |= LPUART_CTRL_TXDIR;
    56da:	69b3      	ldr	r3, [r6, #24]
    56dc:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    56e0:	61b3      	str	r3, [r6, #24]
		__enable_irq();
    56e2:	b662      	cpsie	i
	head = tx_buffer_head_;
    56e4:	f8b4 5046 	ldrh.w	r5, [r4, #70]	; 0x46
	if (++head >= tx_buffer_total_size_) head = 0;
    56e8:	6b63      	ldr	r3, [r4, #52]	; 0x34
	head = tx_buffer_head_;
    56ea:	b2ad      	uxth	r5, r5
	if (++head >= tx_buffer_total_size_) head = 0;
    56ec:	3501      	adds	r5, #1
    56ee:	42ab      	cmp	r3, r5
    56f0:	d84c      	bhi.n	578c <HardwareSerialIMXRT::write9bit(unsigned long)+0xcc>
    56f2:	f04f 0800 	mov.w	r8, #0
    56f6:	4645      	mov	r5, r8
	while (tx_buffer_tail_ == head) {
    56f8:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    56fc:	b29b      	uxth	r3, r3
    56fe:	429d      	cmp	r5, r3
    5700:	d019      	beq.n	5736 <HardwareSerialIMXRT::write9bit(unsigned long)+0x76>
    5702:	e028      	b.n	5756 <HardwareSerialIMXRT::write9bit(unsigned long)+0x96>
			if ((port->STAT & LPUART_STAT_TDRE)) {
    5704:	6973      	ldr	r3, [r6, #20]
    5706:	021b      	lsls	r3, r3, #8
    5708:	d510      	bpl.n	572c <HardwareSerialIMXRT::write9bit(unsigned long)+0x6c>
				uint32_t tail = tx_buffer_tail_;
    570a:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
				if (++tail >= tx_buffer_total_size_) tail = 0;
    570e:	6b62      	ldr	r2, [r4, #52]	; 0x34
				uint32_t tail = tx_buffer_tail_;
    5710:	b29b      	uxth	r3, r3
				if (++tail >= tx_buffer_total_size_) tail = 0;
    5712:	3301      	adds	r3, #1
    5714:	429a      	cmp	r2, r3
    5716:	d936      	bls.n	5786 <HardwareSerialIMXRT::write9bit(unsigned long)+0xc6>
				tx_buffer_tail_ = tail;
    5718:	b29a      	uxth	r2, r3
				if (tail < tx_buffer_size_) {
    571a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    571c:	4299      	cmp	r1, r3
    571e:	d92d      	bls.n	577c <HardwareSerialIMXRT::write9bit(unsigned long)+0xbc>
					n = tx_buffer_[tail];
    5720:	69e1      	ldr	r1, [r4, #28]
    5722:	5ccb      	ldrb	r3, [r1, r3]
    5724:	b2db      	uxtb	r3, r3
				port->DATA  = n;
    5726:	61f3      	str	r3, [r6, #28]
				tx_buffer_tail_ = tail;
    5728:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
	while (tx_buffer_tail_ == head) {
    572c:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    5730:	b29b      	uxth	r3, r3
    5732:	42ab      	cmp	r3, r5
    5734:	d10f      	bne.n	5756 <HardwareSerialIMXRT::write9bit(unsigned long)+0x96>
		int priority = nvic_execution_priority();
    5736:	f7ff ffa3 	bl	5680 <nvic_execution_priority()>
		if (priority <= hardware->irq_priority) {
    573a:	6963      	ldr	r3, [r4, #20]
    573c:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
    5740:	4283      	cmp	r3, r0
    5742:	dadf      	bge.n	5704 <HardwareSerialIMXRT::write9bit(unsigned long)+0x44>
		} else if (priority >= 256) 
    5744:	28ff      	cmp	r0, #255	; 0xff
    5746:	ddf1      	ble.n	572c <HardwareSerialIMXRT::write9bit(unsigned long)+0x6c>
			yield(); // wait
    5748:	f002 fa5a 	bl	7c00 <yield>
	while (tx_buffer_tail_ == head) {
    574c:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    5750:	b29b      	uxth	r3, r3
    5752:	42ab      	cmp	r3, r5
    5754:	d0ef      	beq.n	5736 <HardwareSerialIMXRT::write9bit(unsigned long)+0x76>
	if (head < tx_buffer_size_) {
    5756:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5758:	42ab      	cmp	r3, r5
    575a:	d91a      	bls.n	5792 <HardwareSerialIMXRT::write9bit(unsigned long)+0xd2>
		tx_buffer_[head] = c;
    575c:	b2ff      	uxtb	r7, r7
    575e:	69e3      	ldr	r3, [r4, #28]
    5760:	555f      	strb	r7, [r3, r5]
	__disable_irq();
    5762:	b672      	cpsid	i
	transmitting_ = 1;
    5764:	2001      	movs	r0, #1
    5766:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
	tx_buffer_head_ = head;
    576a:	f8a4 8046 	strh.w	r8, [r4, #70]	; 0x46
	port->CTRL |= LPUART_CTRL_TIE; // (may need to handle this issue)BITBAND_SET_BIT(LPUART0_CTRL, TIE_BIT);
    576e:	69b3      	ldr	r3, [r6, #24]
    5770:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    5774:	61b3      	str	r3, [r6, #24]
	__enable_irq();
    5776:	b662      	cpsie	i
}
    5778:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					n = tx_buffer_storage_[tail-tx_buffer_size_];
    577c:	1a5b      	subs	r3, r3, r1
    577e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    5780:	5ccb      	ldrb	r3, [r1, r3]
    5782:	b2db      	uxtb	r3, r3
    5784:	e7cf      	b.n	5726 <HardwareSerialIMXRT::write9bit(unsigned long)+0x66>
    5786:	2200      	movs	r2, #0
				if (++tail >= tx_buffer_total_size_) tail = 0;
    5788:	4613      	mov	r3, r2
    578a:	e7c6      	b.n	571a <HardwareSerialIMXRT::write9bit(unsigned long)+0x5a>
	tx_buffer_head_ = head;
    578c:	fa1f f885 	uxth.w	r8, r5
    5790:	e7b2      	b.n	56f8 <HardwareSerialIMXRT::write9bit(unsigned long)+0x38>
		tx_buffer_storage_[head - tx_buffer_size_] = c;
    5792:	1aed      	subs	r5, r5, r3
    5794:	b2ff      	uxtb	r7, r7
    5796:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    5798:	555f      	strb	r7, [r3, r5]
    579a:	e7e2      	b.n	5762 <HardwareSerialIMXRT::write9bit(unsigned long)+0xa2>

0000579c <HardwareSerialIMXRT::write(unsigned char)>:
	return write9bit(c);
    579c:	f7ff bf90 	b.w	56c0 <HardwareSerialIMXRT::write9bit(unsigned long)>

000057a0 <HardwareSerialIMXRT::IRQHandler()>:
	IMXRT_LPUART_t *port = (IMXRT_LPUART_t *)port_addr;
    57a0:	6902      	ldr	r2, [r0, #16]
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    57a2:	6953      	ldr	r3, [r2, #20]
    57a4:	f413 1f40 	tst.w	r3, #3145728	; 0x300000
{
    57a8:	b570      	push	{r4, r5, r6, lr}
	if (port->STAT & (LPUART_STAT_RDRF | LPUART_STAT_IDLE)) {
    57aa:	d043      	beq.n	5834 <HardwareSerialIMXRT::IRQHandler()+0x94>
		uint8_t avail = (port->WATER >> 24) & 0x7;
    57ac:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
		if (avail) {
    57ae:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
		uint8_t avail = (port->WATER >> 24) & 0x7;
    57b2:	f3c3 6e02 	ubfx	lr, r3, #24, #3
		if (avail) {
    57b6:	d03a      	beq.n	582e <HardwareSerialIMXRT::IRQHandler()+0x8e>
			head = rx_buffer_head_;
    57b8:	f8b0 504a 	ldrh.w	r5, [r0, #74]	; 0x4a
			tail = rx_buffer_tail_;
    57bc:	f8b0 604c 	ldrh.w	r6, [r0, #76]	; 0x4c
			head = rx_buffer_head_;
    57c0:	b2ad      	uxth	r5, r5
			tail = rx_buffer_tail_;
    57c2:	b2b6      	uxth	r6, r6
    57c4:	e007      	b.n	57d6 <HardwareSerialIMXRT::IRQHandler()+0x36>
						rx_buffer_[head] = n;
    57c6:	6a01      	ldr	r1, [r0, #32]
    57c8:	f801 c003 	strb.w	ip, [r1, r3]
			} while (--avail > 0) ;
    57cc:	f10e 33ff 	add.w	r3, lr, #4294967295
    57d0:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    57d4:	d01d      	beq.n	5812 <HardwareSerialIMXRT::IRQHandler()+0x72>
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    57d6:	69d1      	ldr	r1, [r2, #28]
				newhead = head + 1;
    57d8:	1c6b      	adds	r3, r5, #1
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    57da:	6b84      	ldr	r4, [r0, #56]	; 0x38
				if (newhead != rx_buffer_tail_) {
    57dc:	f8b0 c04c 	ldrh.w	ip, [r0, #76]	; 0x4c
				n = port->DATA & 0x3ff;		// Use only up to 10 bits of data
    57e0:	f3c1 0109 	ubfx	r1, r1, #0, #10
				if (newhead >= rx_buffer_total_size_) newhead = 0;
    57e4:	429c      	cmp	r4, r3
    57e6:	bf98      	it	ls
    57e8:	2300      	movls	r3, #0
				if (newhead != rx_buffer_tail_) {
    57ea:	fa1f fc8c 	uxth.w	ip, ip
    57ee:	459c      	cmp	ip, r3
    57f0:	d0ec      	beq.n	57cc <HardwareSerialIMXRT::IRQHandler()+0x2c>
					if (newhead < rx_buffer_size_) {
    57f2:	6b04      	ldr	r4, [r0, #48]	; 0x30
						rx_buffer_[head] = n;
    57f4:	fa5f fc81 	uxtb.w	ip, r1
    57f8:	461d      	mov	r5, r3
					if (newhead < rx_buffer_size_) {
    57fa:	429c      	cmp	r4, r3
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    57fc:	eba3 0404 	sub.w	r4, r3, r4
					if (newhead < rx_buffer_size_) {
    5800:	d8e1      	bhi.n	57c6 <HardwareSerialIMXRT::IRQHandler()+0x26>
						rx_buffer_storage_[head-rx_buffer_size_] = n;
    5802:	6a43      	ldr	r3, [r0, #36]	; 0x24
    5804:	f803 c004 	strb.w	ip, [r3, r4]
			} while (--avail > 0) ;
    5808:	f10e 33ff 	add.w	r3, lr, #4294967295
    580c:	f013 0eff 	ands.w	lr, r3, #255	; 0xff
    5810:	d1e1      	bne.n	57d6 <HardwareSerialIMXRT::IRQHandler()+0x36>
			rx_buffer_head_ = head;
    5812:	b2ab      	uxth	r3, r5
    5814:	f8a0 304a 	strh.w	r3, [r0, #74]	; 0x4a
			if (rts_pin_baseReg_) {
    5818:	6d83      	ldr	r3, [r0, #88]	; 0x58
    581a:	b143      	cbz	r3, 582e <HardwareSerialIMXRT::IRQHandler()+0x8e>
				if (head >= tail) avail = head - tail;
    581c:	42b5      	cmp	r5, r6
    581e:	d354      	bcc.n	58ca <HardwareSerialIMXRT::IRQHandler()+0x12a>
    5820:	1bad      	subs	r5, r5, r6
				if (avail >= rts_high_watermark_) rts_deassert();
    5822:	6c01      	ldr	r1, [r0, #64]	; 0x40
    5824:	42a9      	cmp	r1, r5
    5826:	d802      	bhi.n	582e <HardwareSerialIMXRT::IRQHandler()+0x8e>
	DIRECT_WRITE_HIGH(rts_pin_baseReg_, rts_pin_bitmask_);
    5828:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
    582a:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
		if (port->STAT & LPUART_STAT_IDLE) {
    582e:	6953      	ldr	r3, [r2, #20]
    5830:	02d9      	lsls	r1, r3, #11
    5832:	d445      	bmi.n	58c0 <HardwareSerialIMXRT::IRQHandler()+0x120>
	ctrl = port->CTRL;
    5834:	6996      	ldr	r6, [r2, #24]
	if ((ctrl & LPUART_CTRL_TIE) && (port->STAT & LPUART_STAT_TDRE))
    5836:	0233      	lsls	r3, r6, #8
    5838:	d528      	bpl.n	588c <HardwareSerialIMXRT::IRQHandler()+0xec>
    583a:	6953      	ldr	r3, [r2, #20]
    583c:	021d      	lsls	r5, r3, #8
    583e:	d525      	bpl.n	588c <HardwareSerialIMXRT::IRQHandler()+0xec>
		head = tx_buffer_head_;
    5840:	f8b0 5046 	ldrh.w	r5, [r0, #70]	; 0x46
		tail = tx_buffer_tail_;
    5844:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
		head = tx_buffer_head_;
    5848:	b2ad      	uxth	r5, r5
		tail = tx_buffer_tail_;
    584a:	b29b      	uxth	r3, r3
    584c:	e006      	b.n	585c <HardwareSerialIMXRT::IRQHandler()+0xbc>
				n = tx_buffer_[tail];
    584e:	69c1      	ldr	r1, [r0, #28]
    5850:	5cc9      	ldrb	r1, [r1, r3]
    5852:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    5854:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    5856:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    5858:	054c      	lsls	r4, r1, #21
    585a:	d412      	bmi.n	5882 <HardwareSerialIMXRT::IRQHandler()+0xe2>
			if (head == tail) break;
    585c:	42ab      	cmp	r3, r5
    585e:	d038      	beq.n	58d2 <HardwareSerialIMXRT::IRQHandler()+0x132>
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5860:	6b44      	ldr	r4, [r0, #52]	; 0x34
    5862:	3301      	adds	r3, #1
			if (tail < tx_buffer_size_) {
    5864:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
			if (++tail >= tx_buffer_total_size_) tail = 0;
    5866:	429c      	cmp	r4, r3
    5868:	bf98      	it	ls
    586a:	2300      	movls	r3, #0
			if (tail < tx_buffer_size_) {
    586c:	4299      	cmp	r1, r3
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    586e:	eba3 0401 	sub.w	r4, r3, r1
			if (tail < tx_buffer_size_) {
    5872:	d8ec      	bhi.n	584e <HardwareSerialIMXRT::IRQHandler()+0xae>
				n = tx_buffer_storage_[tail-tx_buffer_size_];
    5874:	6a81      	ldr	r1, [r0, #40]	; 0x28
    5876:	5d09      	ldrb	r1, [r1, r4]
    5878:	b2c9      	uxtb	r1, r1
			port->DATA = n;
    587a:	61d1      	str	r1, [r2, #28]
		} while (((port->WATER >> 8) & 0x7) < 4); 	// need to computer properly
    587c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    587e:	054c      	lsls	r4, r1, #21
    5880:	d5ec      	bpl.n	585c <HardwareSerialIMXRT::IRQHandler()+0xbc>
		tx_buffer_tail_ = tail;
    5882:	b299      	uxth	r1, r3
		if (head == tail) {
    5884:	42ab      	cmp	r3, r5
		tx_buffer_tail_ = tail;
    5886:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
		if (head == tail) {
    588a:	d025      	beq.n	58d8 <HardwareSerialIMXRT::IRQHandler()+0x138>
	if ((ctrl & LPUART_CTRL_TCIE) && (port->STAT & LPUART_STAT_TC))
    588c:	0271      	lsls	r1, r6, #9
    588e:	d516      	bpl.n	58be <HardwareSerialIMXRT::IRQHandler()+0x11e>
    5890:	6953      	ldr	r3, [r2, #20]
    5892:	025b      	lsls	r3, r3, #9
    5894:	d513      	bpl.n	58be <HardwareSerialIMXRT::IRQHandler()+0x11e>
		transmitting_ = 0;
    5896:	2100      	movs	r1, #0
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    5898:	6d03      	ldr	r3, [r0, #80]	; 0x50
		transmitting_ = 0;
    589a:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
		if (transmit_pin_baseReg_) DIRECT_WRITE_LOW(transmit_pin_baseReg_, transmit_pin_bitmask_);
    589e:	b113      	cbz	r3, 58a6 <HardwareSerialIMXRT::IRQHandler()+0x106>
    58a0:	6d41      	ldr	r1, [r0, #84]	; 0x54
    58a2:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
		if(half_duplex_mode_) {		
    58a6:	7e83      	ldrb	r3, [r0, #26]
    58a8:	b12b      	cbz	r3, 58b6 <HardwareSerialIMXRT::IRQHandler()+0x116>
			__disable_irq();
    58aa:	b672      	cpsid	i
		    port->CTRL &= ~LPUART_CTRL_TXDIR;
    58ac:	6993      	ldr	r3, [r2, #24]
    58ae:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
    58b2:	6193      	str	r3, [r2, #24]
			__enable_irq();
    58b4:	b662      	cpsie	i
		port->CTRL &= ~LPUART_CTRL_TCIE;
    58b6:	6993      	ldr	r3, [r2, #24]
    58b8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
    58bc:	6193      	str	r3, [r2, #24]
}
    58be:	bd70      	pop	{r4, r5, r6, pc}
			port->STAT |= LPUART_STAT_IDLE;	// writing a 1 to idle should clear it. 
    58c0:	6953      	ldr	r3, [r2, #20]
    58c2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    58c6:	6153      	str	r3, [r2, #20]
    58c8:	e7b4      	b.n	5834 <HardwareSerialIMXRT::IRQHandler()+0x94>
				else avail = rx_buffer_total_size_ + head - tail;
    58ca:	6b81      	ldr	r1, [r0, #56]	; 0x38
    58cc:	1b89      	subs	r1, r1, r6
    58ce:	440d      	add	r5, r1
    58d0:	e7a7      	b.n	5822 <HardwareSerialIMXRT::IRQHandler()+0x82>
		tx_buffer_tail_ = tail;
    58d2:	b29b      	uxth	r3, r3
    58d4:	f8a0 3048 	strh.w	r3, [r0, #72]	; 0x48
			port->CTRL &= ~LPUART_CTRL_TIE; 
    58d8:	6993      	ldr	r3, [r2, #24]
    58da:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    58de:	6193      	str	r3, [r2, #24]
  			port->CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
    58e0:	6993      	ldr	r3, [r2, #24]
    58e2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    58e6:	6193      	str	r3, [r2, #24]
    58e8:	e7d0      	b.n	588c <HardwareSerialIMXRT::IRQHandler()+0xec>
    58ea:	bf00      	nop

000058ec <IRQHandler_Serial2>:
#define IRQ_PRIORITY  64  // 0 = highest priority, 255 = lowest


void IRQHandler_Serial2()
{
	Serial2.IRQHandler();
    58ec:	4801      	ldr	r0, [pc, #4]	; (58f4 <IRQHandler_Serial2+0x8>)
    58ee:	f7ff bf57 	b.w	57a0 <HardwareSerialIMXRT::IRQHandler()>
    58f2:	bf00      	nop
    58f4:	20001120 	.word	0x20001120

000058f8 <usb_serial_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    58f8:	4608      	mov	r0, r1
    58fa:	f002 b8ed 	b.w	7ad8 <usb_serial_putchar>
    58fe:	bf00      	nop

00005900 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>:
		base = 10;
    5900:	2a01      	cmp	r2, #1
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    5902:	b570      	push	{r4, r5, r6, lr}
		base = 10;
    5904:	bf08      	it	eq
    5906:	220a      	moveq	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
    5908:	b08a      	sub	sp, #40	; 0x28
	if (n == 0) {
    590a:	b391      	cbz	r1, 5972 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x72>
		i = sizeof(buf) - 1;
    590c:	f04f 0e21 	mov.w	lr, #33	; 0x21
    5910:	e001      	b.n	5916 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x16>
			i--;
    5912:	fa5f fe86 	uxtb.w	lr, r6
    5916:	f10e 36ff 	add.w	r6, lr, #4294967295
			digit = n % base;
    591a:	fbb1 f5f2 	udiv	r5, r1, r2
    591e:	fb02 1415 	mls	r4, r2, r5, r1
    5922:	fa5f fc84 	uxtb.w	ip, r4
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5926:	2c09      	cmp	r4, #9
    5928:	f10c 0437 	add.w	r4, ip, #55	; 0x37
    592c:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    5930:	bf98      	it	ls
    5932:	fa5f f48c 	uxtbls.w	r4, ip
    5936:	f10e 0c28 	add.w	ip, lr, #40	; 0x28
    593a:	bf88      	it	hi
    593c:	b2e4      	uxtbhi	r4, r4
			if (n == 0) break;
    593e:	4291      	cmp	r1, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5940:	44ec      	add	ip, sp
			n /= base;
    5942:	4629      	mov	r1, r5
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5944:	f80c 4c24 	strb.w	r4, [ip, #-36]
			if (n == 0) break;
    5948:	d2e3      	bcs.n	5912 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x12>
	if (sign) {
    594a:	b14b      	cbz	r3, 5960 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x60>
		i--;
    594c:	f10e 3eff 	add.w	lr, lr, #4294967295
		buf[i] = '-';
    5950:	222d      	movs	r2, #45	; 0x2d
		i--;
    5952:	fa5f fe8e 	uxtb.w	lr, lr
		buf[i] = '-';
    5956:	f10e 0328 	add.w	r3, lr, #40	; 0x28
    595a:	446b      	add	r3, sp
    595c:	f803 2c24 	strb.w	r2, [r3, #-36]
	return write(buf + i, sizeof(buf) - i);
    5960:	6803      	ldr	r3, [r0, #0]
    5962:	a901      	add	r1, sp, #4
    5964:	f1ce 0222 	rsb	r2, lr, #34	; 0x22
    5968:	685b      	ldr	r3, [r3, #4]
    596a:	4471      	add	r1, lr
    596c:	4798      	blx	r3
}
    596e:	b00a      	add	sp, #40	; 0x28
    5970:	bd70      	pop	{r4, r5, r6, pc}
		buf[sizeof(buf) - 1] = '0';
    5972:	2230      	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    5974:	f04f 0e21 	mov.w	lr, #33	; 0x21
		buf[sizeof(buf) - 1] = '0';
    5978:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    597c:	e7e5      	b.n	594a <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]+0x4a>
    597e:	bf00      	nop

00005980 <Print::write(unsigned char const*, unsigned int)>:
{
    5980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buffer == nullptr) return 0;
    5984:	460c      	mov	r4, r1
    5986:	b1d1      	cbz	r1, 59be <Print::write(unsigned char const*, unsigned int)+0x3e>
	while (size--) count += write(*buffer++);
    5988:	b1ea      	cbz	r2, 59c6 <Print::write(unsigned char const*, unsigned int)+0x46>
    598a:	4680      	mov	r8, r0
    598c:	188e      	adds	r6, r1, r2
	size_t count = 0;
    598e:	2500      	movs	r5, #0
    5990:	4f0e      	ldr	r7, [pc, #56]	; (59cc <Print::write(unsigned char const*, unsigned int)+0x4c>)
    5992:	e004      	b.n	599e <Print::write(unsigned char const*, unsigned int)+0x1e>
    5994:	f002 f8a0 	bl	7ad8 <usb_serial_putchar>
	while (size--) count += write(*buffer++);
    5998:	42b4      	cmp	r4, r6
    599a:	4405      	add	r5, r0
    599c:	d00c      	beq.n	59b8 <Print::write(unsigned char const*, unsigned int)+0x38>
    599e:	f8d8 3000 	ldr.w	r3, [r8]
    59a2:	f814 0b01 	ldrb.w	r0, [r4], #1
    59a6:	681b      	ldr	r3, [r3, #0]
    59a8:	42bb      	cmp	r3, r7
    59aa:	d0f3      	beq.n	5994 <Print::write(unsigned char const*, unsigned int)+0x14>
    59ac:	4601      	mov	r1, r0
    59ae:	4640      	mov	r0, r8
    59b0:	4798      	blx	r3
    59b2:	42b4      	cmp	r4, r6
    59b4:	4405      	add	r5, r0
    59b6:	d1f2      	bne.n	599e <Print::write(unsigned char const*, unsigned int)+0x1e>
}
    59b8:	4628      	mov	r0, r5
    59ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    59be:	460d      	mov	r5, r1
}
    59c0:	4628      	mov	r0, r5
    59c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buffer == nullptr) return 0;
    59c6:	4615      	mov	r5, r2
    59c8:	e7f6      	b.n	59b8 <Print::write(unsigned char const*, unsigned int)+0x38>
    59ca:	bf00      	nop
    59cc:	000058f9 	.word	0x000058f9

000059d0 <Print::print(long)>:
	if (n < 0) {
    59d0:	2900      	cmp	r1, #0
    59d2:	db03      	blt.n	59dc <Print::print(long)+0xc>
	uint8_t sign=0;
    59d4:	2300      	movs	r3, #0
	if (base == 0) {
    59d6:	220a      	movs	r2, #10
    59d8:	f7ff bf92 	b.w	5900 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
		n = -n;
    59dc:	4249      	negs	r1, r1
		sign = '-';
    59de:	232d      	movs	r3, #45	; 0x2d
	if (base == 0) {
    59e0:	220a      	movs	r2, #10
    59e2:	f7ff bf8d 	b.w	5900 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    59e6:	bf00      	nop

000059e8 <Print::println()>:
{
    59e8:	b500      	push	{lr}
	return write(buf, 2);
    59ea:	6803      	ldr	r3, [r0, #0]
{
    59ec:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    59ee:	f640 2c0d 	movw	ip, #2573	; 0xa0d
	return write(buf, 2);
    59f2:	2202      	movs	r2, #2
    59f4:	a901      	add	r1, sp, #4
    59f6:	685b      	ldr	r3, [r3, #4]
	uint8_t buf[2]={'\r', '\n'};
    59f8:	f8ad c004 	strh.w	ip, [sp, #4]
	return write(buf, 2);
    59fc:	4798      	blx	r3
}
    59fe:	b003      	add	sp, #12
    5a00:	f85d fb04 	ldr.w	pc, [sp], #4

00005a04 <_write>:
	return ((class Print *)file)->write((uint8_t *)ptr, len);
    5a04:	4b05      	ldr	r3, [pc, #20]	; (5a1c <_write+0x18>)
    5a06:	2802      	cmp	r0, #2
    5a08:	bf88      	it	hi
    5a0a:	4603      	movhi	r3, r0
{
    5a0c:	b410      	push	{r4}
	return ((class Print *)file)->write((uint8_t *)ptr, len);
    5a0e:	681c      	ldr	r4, [r3, #0]
    5a10:	4618      	mov	r0, r3
    5a12:	6863      	ldr	r3, [r4, #4]
}
    5a14:	f85d 4b04 	ldr.w	r4, [sp], #4
	return ((class Print *)file)->write((uint8_t *)ptr, len);
    5a18:	4718      	bx	r3
    5a1a:	bf00      	nop
    5a1c:	20001110 	.word	0x20001110

00005a20 <Print::printf(char const*, ...)>:
{
    5a20:	b40e      	push	{r1, r2, r3}
    5a22:	b500      	push	{lr}
    5a24:	b082      	sub	sp, #8
    5a26:	aa03      	add	r2, sp, #12
    5a28:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(ap, format);
    5a2c:	9201      	str	r2, [sp, #4]
	int retval = vdprintf((int)this, format, ap);
    5a2e:	f002 ff5d 	bl	88ec <vdprintf>
}
    5a32:	b002      	add	sp, #8
    5a34:	f85d eb04 	ldr.w	lr, [sp], #4
    5a38:	b003      	add	sp, #12
    5a3a:	4770      	bx	lr

00005a3c <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	if (base == 0) {
    5a3c:	b95a      	cbnz	r2, 5a56 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1a>
		return write((uint8_t)n);
    5a3e:	6803      	ldr	r3, [r0, #0]
    5a40:	b2c9      	uxtb	r1, r1
    5a42:	4a07      	ldr	r2, [pc, #28]	; (5a60 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x24>)
    5a44:	681b      	ldr	r3, [r3, #0]
    5a46:	4293      	cmp	r3, r2
{
    5a48:	b500      	push	{lr}
    5a4a:	d106      	bne.n	5a5a <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    5a4c:	4608      	mov	r0, r1
}
    5a4e:	f85d eb04 	ldr.w	lr, [sp], #4
    5a52:	f002 b841 	b.w	7ad8 <usb_serial_putchar>
    5a56:	f7ff bf53 	b.w	5900 <Print::printNumber(unsigned long, unsigned char, unsigned char) [clone .part.0]>
    5a5a:	f85d eb04 	ldr.w	lr, [sp], #4
		return write((uint8_t)n);
    5a5e:	4718      	bx	r3
    5a60:	000058f9 	.word	0x000058f9

00005a64 <usb_serial_class::read()>:
        virtual int read() { return usb_serial_getchar(); }
    5a64:	f002 b828 	b.w	7ab8 <usb_serial_getchar>

00005a68 <usb_serial_class::peek()>:
        virtual int peek() { return usb_serial_peekchar(); }
    5a68:	f001 bfc0 	b.w	79ec <usb_serial_peekchar>

00005a6c <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    5a6c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
    5a70:	b392      	cbz	r2, 5ad8 <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
    5a72:	4617      	mov	r7, r2
    5a74:	fab3 f283 	clz	r2, r3
    5a78:	0952      	lsrs	r2, r2, #5
    5a7a:	b36b      	cbz	r3, 5ad8 <Stream::readBytesUntil(char, char*, unsigned int)+0x6c>
	length--;
	size_t index = 0;
	while (index < length) {
    5a7c:	f1b3 0801 	subs.w	r8, r3, #1
    5a80:	d025      	beq.n	5ace <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    5a82:	eb07 0a08 	add.w	sl, r7, r8
    5a86:	4683      	mov	fp, r0
    5a88:	4689      	mov	r9, r1
	size_t index = 0;
    5a8a:	4690      	mov	r8, r2
    5a8c:	4c17      	ldr	r4, [pc, #92]	; (5aec <Stream::readBytesUntil(char, char*, unsigned int)+0x80>)
    5a8e:	4e18      	ldr	r6, [pc, #96]	; (5af0 <Stream::readBytesUntil(char, char*, unsigned int)+0x84>)
    5a90:	6825      	ldr	r5, [r4, #0]
    5a92:	e00b      	b.n	5aac <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
        virtual int read() { return usb_serial_getchar(); }
    5a94:	f002 f810 	bl	7ab8 <usb_serial_getchar>
    if (c >= 0) return c;
    5a98:	2800      	cmp	r0, #0
    5a9a:	da10      	bge.n	5abe <Stream::readBytesUntil(char, char*, unsigned int)+0x52>
    yield();
    5a9c:	f002 f8b0 	bl	7c00 <yield>
    5aa0:	6823      	ldr	r3, [r4, #0]
  } while(millis() - startMillis < _timeout);
    5aa2:	f8db 2008 	ldr.w	r2, [fp, #8]
    5aa6:	1b5b      	subs	r3, r3, r5
    5aa8:	4293      	cmp	r3, r2
    5aaa:	d21a      	bcs.n	5ae2 <Stream::readBytesUntil(char, char*, unsigned int)+0x76>
    c = read();
    5aac:	f8db 3000 	ldr.w	r3, [fp]
    5ab0:	695b      	ldr	r3, [r3, #20]
    5ab2:	42b3      	cmp	r3, r6
    5ab4:	d0ee      	beq.n	5a94 <Stream::readBytesUntil(char, char*, unsigned int)+0x28>
    5ab6:	4658      	mov	r0, fp
    5ab8:	4798      	blx	r3
    if (c >= 0) return c;
    5aba:	2800      	cmp	r0, #0
    5abc:	dbee      	blt.n	5a9c <Stream::readBytesUntil(char, char*, unsigned int)+0x30>
		int c = timedRead();
		if (c == terminator) break;
    5abe:	4548      	cmp	r0, r9
    5ac0:	d005      	beq.n	5ace <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
		if (c < 0) {
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    5ac2:	f807 0b01 	strb.w	r0, [r7], #1
	while (index < length) {
    5ac6:	45ba      	cmp	sl, r7
		index++;
    5ac8:	f108 0801 	add.w	r8, r8, #1
	while (index < length) {
    5acc:	d1e0      	bne.n	5a90 <Stream::readBytesUntil(char, char*, unsigned int)+0x24>
	}
	*buffer = 0;
    5ace:	2300      	movs	r3, #0
	return index; // return number of characters, not including null terminator
}
    5ad0:	4640      	mov	r0, r8
	*buffer = 0;
    5ad2:	703b      	strb	r3, [r7, #0]
}
    5ad4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (length < 1) return 0;
    5ad8:	f04f 0800 	mov.w	r8, #0
}
    5adc:	4640      	mov	r0, r8
    5ade:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	String readString(size_t max = 0 /* 0 means unlimited length */);
	String readStringUntil(char terminator, size_t max = 0 /* 0 means unlimited length */);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    5ae2:	2301      	movs	r3, #1
    5ae4:	f88b 300c 	strb.w	r3, [fp, #12]
    5ae8:	e7f1      	b.n	5ace <Stream::readBytesUntil(char, char*, unsigned int)+0x62>
    5aea:	bf00      	nop
    5aec:	2000a5a8 	.word	0x2000a5a8
    5af0:	00005a65 	.word	0x00005a65

00005af4 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    5af4:	49a2      	ldr	r1, [pc, #648]	; (5d80 <set_arm_clock+0x28c>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    5af6:	4ba3      	ldr	r3, [pc, #652]	; (5d84 <set_arm_clock+0x290>)
	if (frequency > 528000000) {
    5af8:	4288      	cmp	r0, r1
{
    5afa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t dcdc = DCDC_REG3;
    5afe:	4ca2      	ldr	r4, [pc, #648]	; (5d88 <set_arm_clock+0x294>)
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    5b00:	695e      	ldr	r6, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    5b02:	699a      	ldr	r2, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    5b04:	f8d4 800c 	ldr.w	r8, [r4, #12]
	if (frequency > 528000000) {
    5b08:	d91b      	bls.n	5b42 <set_arm_clock+0x4e>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    5b0a:	4ba0      	ldr	r3, [pc, #640]	; (5d8c <set_arm_clock+0x298>)
    5b0c:	4298      	cmp	r0, r3
    5b0e:	f240 8102 	bls.w	5d16 <set_arm_clock+0x222>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    5b12:	1ac3      	subs	r3, r0, r3
    5b14:	499e      	ldr	r1, [pc, #632]	; (5d90 <set_arm_clock+0x29c>)
    5b16:	0a1b      	lsrs	r3, r3, #8
    5b18:	fba1 1303 	umull	r1, r3, r1, r3
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b1c:	f240 6127 	movw	r1, #1575	; 0x627
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    5b20:	09db      	lsrs	r3, r3, #7
    5b22:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    5b26:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    5b2a:	f203 43e2 	addw	r3, r3, #1250	; 0x4e2
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b2e:	428b      	cmp	r3, r1
    5b30:	bf28      	it	cs
    5b32:	460b      	movcs	r3, r1
    5b34:	f5a3 7748 	sub.w	r7, r3, #800	; 0x320
    5b38:	4b96      	ldr	r3, [pc, #600]	; (5d94 <set_arm_clock+0x2a0>)
    5b3a:	fba3 3707 	umull	r3, r7, r3, r7
    5b3e:	08ff      	lsrs	r7, r7, #3
    5b40:	e004      	b.n	5b4c <set_arm_clock+0x58>
	} else if (frequency <= 24000000) {
    5b42:	4f95      	ldr	r7, [pc, #596]	; (5d98 <set_arm_clock+0x2a4>)
    5b44:	42b8      	cmp	r0, r7
    5b46:	bf8c      	ite	hi
    5b48:	270e      	movhi	r7, #14
    5b4a:	2706      	movls	r7, #6
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    5b4c:	498d      	ldr	r1, [pc, #564]	; (5d84 <set_arm_clock+0x290>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b4e:	f008 091f 	and.w	r9, r8, #31
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    5b52:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b56:	45b9      	cmp	r9, r7
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    5b58:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    5b5c:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b60:	d20c      	bcs.n	5b7c <set_arm_clock+0x88>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    5b62:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    5b66:	f5a1 21f8 	sub.w	r1, r1, #507904	; 0x7c000
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    5b6a:	ea48 0807 	orr.w	r8, r8, r7
		DCDC_REG3 = dcdc;
    5b6e:	f8c1 800c 	str.w	r8, [r1, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    5b72:	680b      	ldr	r3, [r1, #0]
    5b74:	2b00      	cmp	r3, #0
    5b76:	dafc      	bge.n	5b72 <set_arm_clock+0x7e>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    5b78:	f008 091f 	and.w	r9, r8, #31
	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    5b7c:	f016 7300 	ands.w	r3, r6, #33554432	; 0x2000000
    5b80:	d124      	bne.n	5bcc <set_arm_clock+0xd8>
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    5b82:	4986      	ldr	r1, [pc, #536]	; (5d9c <set_arm_clock+0x2a8>)
    5b84:	690c      	ldr	r4, [r1, #16]
    5b86:	4986      	ldr	r1, [pc, #536]	; (5da0 <set_arm_clock+0x2ac>)
    5b88:	43a1      	bics	r1, r4
    5b8a:	f000 80ea 	beq.w	5d62 <set_arm_clock+0x26e>
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    5b8e:	f482 5180 	eor.w	r1, r2, #4096	; 0x1000
    5b92:	4634      	mov	r4, r6
    5b94:	f44f 5580 	mov.w	r5, #4096	; 0x1000
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    5b98:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    5b9c:	d004      	beq.n	5ba8 <set_arm_clock+0xb4>
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    5b9e:	f026 5660 	bic.w	r6, r6, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    5ba2:	431e      	orrs	r6, r3
			CCM_CBCDR = cbcdr;
    5ba4:	4b77      	ldr	r3, [pc, #476]	; (5d84 <set_arm_clock+0x290>)
    5ba6:	615e      	str	r6, [r3, #20]
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    5ba8:	f411 5f40 	tst.w	r1, #12288	; 0x3000
    5bac:	d007      	beq.n	5bbe <set_arm_clock+0xca>
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    5bae:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
			CCM_CBCMR = cbcmr;
    5bb2:	4974      	ldr	r1, [pc, #464]	; (5d84 <set_arm_clock+0x290>)
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    5bb4:	432a      	orrs	r2, r5
			CCM_CBCMR = cbcmr;
    5bb6:	618a      	str	r2, [r1, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    5bb8:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    5bba:	071a      	lsls	r2, r3, #28
    5bbc:	d4fc      	bmi.n	5bb8 <set_arm_clock+0xc4>
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    5bbe:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    5bc2:	4a70      	ldr	r2, [pc, #448]	; (5d84 <set_arm_clock+0x290>)
    5bc4:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    5bc6:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5bc8:	069b      	lsls	r3, r3, #26
    5bca:	d4fc      	bmi.n	5bc6 <set_arm_clock+0xd2>
	while (frequency * div_arm * div_ahb < 648000000) {
    5bcc:	4c75      	ldr	r4, [pc, #468]	; (5da4 <set_arm_clock+0x2b0>)
    5bce:	42a0      	cmp	r0, r4
    5bd0:	f200 80ce 	bhi.w	5d70 <set_arm_clock+0x27c>
	uint32_t div_ahb = 1;
    5bd4:	f04f 0c01 	mov.w	ip, #1
    5bd8:	4601      	mov	r1, r0
	uint32_t div_arm = 1;
    5bda:	4663      	mov	r3, ip
	while (frequency * div_arm * div_ahb < 648000000) {
    5bdc:	fb03 1201 	mla	r2, r3, r1, r1
			div_arm = div_arm + 1;
    5be0:	f103 0e01 	add.w	lr, r3, #1
				div_ahb = div_ahb + 1;
    5be4:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5be8:	42a2      	cmp	r2, r4
    5bea:	d818      	bhi.n	5c1e <set_arm_clock+0x12a>
		if (div_arm < 8) {
    5bec:	f1be 0f08 	cmp.w	lr, #8
				div_arm = 1;
    5bf0:	f04f 0301 	mov.w	r3, #1
		if (div_arm < 8) {
    5bf4:	f040 808d 	bne.w	5d12 <set_arm_clock+0x21e>
			if (div_ahb < 5) {
    5bf8:	f1bc 0f04 	cmp.w	ip, #4
    5bfc:	f200 8091 	bhi.w	5d22 <set_arm_clock+0x22e>
	while (frequency * div_arm * div_ahb < 648000000) {
    5c00:	180a      	adds	r2, r1, r0
    5c02:	42a2      	cmp	r2, r4
    5c04:	f200 80a4 	bhi.w	5d50 <set_arm_clock+0x25c>
    5c08:	fb05 f100 	mul.w	r1, r5, r0
				div_ahb = div_ahb + 1;
    5c0c:	46ac      	mov	ip, r5
			div_arm = div_arm + 1;
    5c0e:	f103 0e01 	add.w	lr, r3, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5c12:	fb03 1201 	mla	r2, r3, r1, r1
				div_ahb = div_ahb + 1;
    5c16:	f10c 0501 	add.w	r5, ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5c1a:	42a2      	cmp	r2, r4
    5c1c:	d9e6      	bls.n	5bec <set_arm_clock+0xf8>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5c1e:	f10c 31ff 	add.w	r1, ip, #4294967295
    5c22:	028c      	lsls	r4, r1, #10
    5c24:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5c28:	485f      	ldr	r0, [pc, #380]	; (5da8 <set_arm_clock+0x2b4>)
    5c2a:	4410      	add	r0, r2
	if (mult > 108) mult = 108;
    5c2c:	4a5f      	ldr	r2, [pc, #380]	; (5dac <set_arm_clock+0x2b8>)
    5c2e:	4290      	cmp	r0, r2
    5c30:	d97f      	bls.n	5d32 <set_arm_clock+0x23e>
    5c32:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 5dd8 <set_arm_clock+0x2e4>
    5c36:	226c      	movs	r2, #108	; 0x6c
    5c38:	485d      	ldr	r0, [pc, #372]	; (5db0 <set_arm_clock+0x2bc>)
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    5c3a:	4d58      	ldr	r5, [pc, #352]	; (5d9c <set_arm_clock+0x2a8>)
	frequency = mult * 12000000 / div_arm / div_ahb;
    5c3c:	fbb0 f0fe 	udiv	r0, r0, lr
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    5c40:	f8d5 e000 	ldr.w	lr, [r5]
	frequency = mult * 12000000 / div_arm / div_ahb;
    5c44:	fbb0 f0fc 	udiv	r0, r0, ip
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    5c48:	f8df c190 	ldr.w	ip, [pc, #400]	; 5ddc <set_arm_clock+0x2e8>
    5c4c:	ea0e 0c0c 	and.w	ip, lr, ip
    5c50:	45d4      	cmp	ip, sl
    5c52:	d009      	beq.n	5c68 <set_arm_clock+0x174>
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    5c54:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    5c58:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    5c5c:	f8c5 c000 	str.w	ip, [r5]
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    5c60:	602a      	str	r2, [r5, #0]
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    5c62:	682a      	ldr	r2, [r5, #0]
    5c64:	2a00      	cmp	r2, #0
    5c66:	dafc      	bge.n	5c62 <set_arm_clock+0x16e>
	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    5c68:	4a46      	ldr	r2, [pc, #280]	; (5d84 <set_arm_clock+0x290>)
    5c6a:	6915      	ldr	r5, [r2, #16]
    5c6c:	f005 0507 	and.w	r5, r5, #7
    5c70:	429d      	cmp	r5, r3
    5c72:	d003      	beq.n	5c7c <set_arm_clock+0x188>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    5c74:	6113      	str	r3, [r2, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    5c76:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5c78:	03dd      	lsls	r5, r3, #15
    5c7a:	d4fc      	bmi.n	5c76 <set_arm_clock+0x182>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5c7c:	f411 5fe0 	tst.w	r1, #7168	; 0x1c00
    5c80:	d009      	beq.n	5c96 <set_arm_clock+0x1a2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    5c82:	f426 56e0 	bic.w	r6, r6, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    5c86:	f404 54e0 	and.w	r4, r4, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
    5c8a:	4a3e      	ldr	r2, [pc, #248]	; (5d84 <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    5c8c:	4326      	orrs	r6, r4
		CCM_CBCDR = cbcdr;
    5c8e:	6156      	str	r6, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    5c90:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5c92:	0799      	lsls	r1, r3, #30
    5c94:	d4fc      	bmi.n	5c90 <set_arm_clock+0x19c>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    5c96:	4947      	ldr	r1, [pc, #284]	; (5db4 <set_arm_clock+0x2c0>)
	if (div_ipg > 4) div_ipg = 4;
    5c98:	4a47      	ldr	r2, [pc, #284]	; (5db8 <set_arm_clock+0x2c4>)
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    5c9a:	4401      	add	r1, r0
	if (div_ipg > 4) div_ipg = 4;
    5c9c:	4291      	cmp	r1, r2
    5c9e:	d83c      	bhi.n	5d1a <set_arm_clock+0x226>
	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    5ca0:	4b46      	ldr	r3, [pc, #280]	; (5dbc <set_arm_clock+0x2c8>)
    5ca2:	09c9      	lsrs	r1, r1, #7
    5ca4:	fba3 3101 	umull	r3, r1, r3, r1
    5ca8:	0b09      	lsrs	r1, r1, #12
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    5caa:	1e4b      	subs	r3, r1, #1
    5cac:	021b      	lsls	r3, r3, #8
    5cae:	ea86 0203 	eor.w	r2, r6, r3
    5cb2:	f412 7f40 	tst.w	r2, #768	; 0x300
    5cb6:	d006      	beq.n	5cc6 <set_arm_clock+0x1d2>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    5cb8:	f426 7640 	bic.w	r6, r6, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    5cbc:	f403 7340 	and.w	r3, r3, #768	; 0x300
		CCM_CBCDR = cbcdr;
    5cc0:	4a30      	ldr	r2, [pc, #192]	; (5d84 <set_arm_clock+0x290>)
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    5cc2:	4333      	orrs	r3, r6
		CCM_CBCDR = cbcdr;
    5cc4:	6153      	str	r3, [r2, #20]
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    5cc6:	4a2f      	ldr	r2, [pc, #188]	; (5d84 <set_arm_clock+0x290>)
    5cc8:	6953      	ldr	r3, [r2, #20]
    5cca:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
    5cce:	6153      	str	r3, [r2, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    5cd0:	6c93      	ldr	r3, [r2, #72]	; 0x48
    5cd2:	069b      	lsls	r3, r3, #26
    5cd4:	d4fc      	bmi.n	5cd0 <set_arm_clock+0x1dc>
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5cd6:	4b3a      	ldr	r3, [pc, #232]	; (5dc0 <set_arm_clock+0x2cc>)
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    5cd8:	454f      	cmp	r7, r9
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5cda:	fba3 2300 	umull	r2, r3, r3, r0
    5cde:	f04f 32ff 	mov.w	r2, #4294967295
    5ce2:	ea4f 4393 	mov.w	r3, r3, lsr #18
	F_BUS_ACTUAL = frequency / div_ipg;
    5ce6:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5cea:	fbb2 f3f3 	udiv	r3, r2, r3
	F_CPU_ACTUAL = frequency;
    5cee:	4a35      	ldr	r2, [pc, #212]	; (5dc4 <set_arm_clock+0x2d0>)
    5cf0:	6010      	str	r0, [r2, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
    5cf2:	4a35      	ldr	r2, [pc, #212]	; (5dc8 <set_arm_clock+0x2d4>)
    5cf4:	6011      	str	r1, [r2, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    5cf6:	4a35      	ldr	r2, [pc, #212]	; (5dcc <set_arm_clock+0x2d8>)
    5cf8:	6013      	str	r3, [r2, #0]
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    5cfa:	d208      	bcs.n	5d0e <set_arm_clock+0x21a>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    5cfc:	f028 081f 	bic.w	r8, r8, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    5d00:	4a21      	ldr	r2, [pc, #132]	; (5d88 <set_arm_clock+0x294>)
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    5d02:	ea48 0707 	orr.w	r7, r8, r7
		DCDC_REG3 = dcdc;
    5d06:	60d7      	str	r7, [r2, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    5d08:	6813      	ldr	r3, [r2, #0]
    5d0a:	2b00      	cmp	r3, #0
    5d0c:	dafc      	bge.n	5d08 <set_arm_clock+0x214>
	}

	return frequency;
}
    5d0e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5d12:	4673      	mov	r3, lr
    5d14:	e762      	b.n	5bdc <set_arm_clock+0xe8>
    5d16:	2712      	movs	r7, #18
    5d18:	e718      	b.n	5b4c <set_arm_clock+0x58>
    5d1a:	f44f 7340 	mov.w	r3, #768	; 0x300
	if (div_ipg > 4) div_ipg = 4;
    5d1e:	2104      	movs	r1, #4
    5d20:	e7c5      	b.n	5cae <set_arm_clock+0x1ba>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5d22:	f10c 31ff 	add.w	r1, ip, #4294967295
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5d26:	4820      	ldr	r0, [pc, #128]	; (5da8 <set_arm_clock+0x2b4>)
    5d28:	2307      	movs	r3, #7
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5d2a:	028c      	lsls	r4, r1, #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5d2c:	4410      	add	r0, r2
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5d2e:	ea86 2181 	eor.w	r1, r6, r1, lsl #10
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5d32:	4a27      	ldr	r2, [pc, #156]	; (5dd0 <set_arm_clock+0x2dc>)
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    5d34:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 5de0 <set_arm_clock+0x2ec>
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    5d38:	fba2 2000 	umull	r2, r0, r2, r0
    5d3c:	0d02      	lsrs	r2, r0, #20
	frequency = mult * 12000000 / div_arm / div_ahb;
    5d3e:	4825      	ldr	r0, [pc, #148]	; (5dd4 <set_arm_clock+0x2e0>)
    5d40:	2a36      	cmp	r2, #54	; 0x36
    5d42:	bf38      	it	cc
    5d44:	2236      	movcc	r2, #54	; 0x36
    5d46:	fb02 f000 	mul.w	r0, r2, r0
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    5d4a:	ea42 0a0a 	orr.w	sl, r2, sl
    5d4e:	e774      	b.n	5c3a <set_arm_clock+0x146>
	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    5d50:	ea4f 248c 	mov.w	r4, ip, lsl #10
    5d54:	2300      	movs	r3, #0
    5d56:	ea86 218c 	eor.w	r1, r6, ip, lsl #10
				div_arm = 1;
    5d5a:	f04f 0e01 	mov.w	lr, #1
				div_ahb = div_ahb + 1;
    5d5e:	46ac      	mov	ip, r5
    5d60:	e762      	b.n	5c28 <set_arm_clock+0x134>
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    5d62:	461d      	mov	r5, r3
    5d64:	f086 54c0 	eor.w	r4, r6, #402653184	; 0x18000000
    5d68:	4611      	mov	r1, r2
    5d6a:	f04f 53c0 	mov.w	r3, #402653184	; 0x18000000
    5d6e:	e713      	b.n	5b98 <set_arm_clock+0xa4>
	while (frequency * div_arm * div_ahb < 648000000) {
    5d70:	2400      	movs	r4, #0
	uint32_t div_ahb = 1;
    5d72:	f04f 0c01 	mov.w	ip, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    5d76:	4602      	mov	r2, r0
    5d78:	4631      	mov	r1, r6
    5d7a:	4623      	mov	r3, r4
	uint32_t div_arm = 1;
    5d7c:	46e6      	mov	lr, ip
    5d7e:	e753      	b.n	5c28 <set_arm_clock+0x134>
    5d80:	1f78a400 	.word	0x1f78a400
    5d84:	400fc000 	.word	0x400fc000
    5d88:	40080000 	.word	0x40080000
    5d8c:	23c34600 	.word	0x23c34600
    5d90:	004cb223 	.word	0x004cb223
    5d94:	51eb851f 	.word	0x51eb851f
    5d98:	016e3600 	.word	0x016e3600
    5d9c:	400d8000 	.word	0x400d8000
    5da0:	80003040 	.word	0x80003040
    5da4:	269fb1ff 	.word	0x269fb1ff
    5da8:	005b8d80 	.word	0x005b8d80
    5dac:	4df67eff 	.word	0x4df67eff
    5db0:	4d3f6400 	.word	0x4d3f6400
    5db4:	08f0d17f 	.word	0x08f0d17f
    5db8:	2cb4177f 	.word	0x2cb4177f
    5dbc:	00e5109f 	.word	0x00e5109f
    5dc0:	431bde83 	.word	0x431bde83
    5dc4:	2000110c 	.word	0x2000110c
    5dc8:	20001108 	.word	0x20001108
    5dcc:	2000a55c 	.word	0x2000a55c
    5dd0:	165e9f81 	.word	0x165e9f81
    5dd4:	00b71b00 	.word	0x00b71b00
    5dd8:	8000206c 	.word	0x8000206c
    5ddc:	8001307f 	.word	0x8001307f
    5de0:	80002000 	.word	0x80002000

00005de4 <delay>:
	if (msec == 0) return;
    5de4:	b900      	cbnz	r0, 5de8 <delay+0x4>
    5de6:	4770      	bx	lr
{
    5de8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5dec:	2101      	movs	r1, #1
    5dee:	4681      	mov	r9, r0
    5df0:	4c21      	ldr	r4, [pc, #132]	; (5e78 <delay+0x94>)
    5df2:	4d22      	ldr	r5, [pc, #136]	; (5e7c <delay+0x98>)
    5df4:	4e22      	ldr	r6, [pc, #136]	; (5e80 <delay+0x9c>)
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    5df6:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    5dfa:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5dfc:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5dfe:	e844 1300 	strex	r3, r1, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    5e02:	2b00      	cmp	r3, #0
    5e04:	d1f7      	bne.n	5df6 <delay+0x12>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    5e06:	491f      	ldr	r1, [pc, #124]	; (5e84 <delay+0xa0>)
    5e08:	684b      	ldr	r3, [r1, #4]
	uint32_t usec = 1000*smc + frac;
    5e0a:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5e0e:	f8df a078 	ldr.w	sl, [pc, #120]	; 5e88 <delay+0xa4>
	uint32_t ccdelta = cyccnt - scc;
    5e12:	1a1b      	subs	r3, r3, r0
    5e14:	2701      	movs	r7, #1
	uint32_t usec = 1000*smc + frac;
    5e16:	fb0b f802 	mul.w	r8, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5e1a:	f8da 2000 	ldr.w	r2, [sl]
    5e1e:	fba3 3202 	umull	r3, r2, r3, r2
	uint32_t usec = 1000*smc + frac;
    5e22:	455a      	cmp	r2, fp
    5e24:	bf94      	ite	ls
    5e26:	4490      	addls	r8, r2
    5e28:	44d8      	addhi	r8, fp
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    5e2a:	e854 3f00 	ldrex	r3, [r4]
		smc = systick_millis_count;
    5e2e:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    5e30:	6830      	ldr	r0, [r6, #0]
   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    5e32:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    5e36:	2b00      	cmp	r3, #0
    5e38:	d1f7      	bne.n	5e2a <delay+0x46>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    5e3a:	684b      	ldr	r3, [r1, #4]
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5e3c:	f8da c000 	ldr.w	ip, [sl]
	uint32_t ccdelta = cyccnt - scc;
    5e40:	1a1b      	subs	r3, r3, r0
	uint32_t usec = 1000*smc + frac;
    5e42:	fb0b f202 	mul.w	r2, fp, r2
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    5e46:	fba3 3c0c 	umull	r3, ip, r3, ip
	uint32_t usec = 1000*smc + frac;
    5e4a:	f5bc 7f7a 	cmp.w	ip, #1000	; 0x3e8
    5e4e:	bf94      	ite	ls
    5e50:	4462      	addls	r2, ip
    5e52:	f502 727a 	addhi.w	r2, r2, #1000	; 0x3e8
		while ((micros() - start) >= 1000) {
    5e56:	eba2 0208 	sub.w	r2, r2, r8
    5e5a:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
    5e5e:	d306      	bcc.n	5e6e <delay+0x8a>
			if (--msec == 0) return;
    5e60:	f1b9 0901 	subs.w	r9, r9, #1
			start += 1000;
    5e64:	f508 787a 	add.w	r8, r8, #1000	; 0x3e8
			if (--msec == 0) return;
    5e68:	d1df      	bne.n	5e2a <delay+0x46>
}
    5e6a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		yield();
    5e6e:	f001 fec7 	bl	7c00 <yield>
		while ((micros() - start) >= 1000) {
    5e72:	4904      	ldr	r1, [pc, #16]	; (5e84 <delay+0xa0>)
    5e74:	e7d9      	b.n	5e2a <delay+0x46>
    5e76:	bf00      	nop
    5e78:	2000a5ac 	.word	0x2000a5ac
    5e7c:	2000a5a8 	.word	0x2000a5a8
    5e80:	2000a5a4 	.word	0x2000a5a4
    5e84:	e0001000 	.word	0xe0001000
    5e88:	2000a55c 	.word	0x2000a55c

00005e8c <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    5e8c:	2827      	cmp	r0, #39	; 0x27
    5e8e:	d816      	bhi.n	5ebe <digitalWrite+0x32>
	p = digital_pin_to_info_PGM + pin;
    5e90:	0102      	lsls	r2, r0, #4
    5e92:	4b10      	ldr	r3, [pc, #64]	; (5ed4 <digitalWrite+0x48>)
    5e94:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	pinmode = *(p->reg + 1);
    5e98:	589b      	ldr	r3, [r3, r2]
{
    5e9a:	b410      	push	{r4}
	mask = p->mask;
    5e9c:	68c2      	ldr	r2, [r0, #12]
	pinmode = *(p->reg + 1);
    5e9e:	685c      	ldr	r4, [r3, #4]
	if (pinmode & mask) {
    5ea0:	4214      	tst	r4, r2
    5ea2:	d005      	beq.n	5eb0 <digitalWrite+0x24>
		// pin is configured for output mode
		if (val) {
    5ea4:	b961      	cbnz	r1, 5ec0 <digitalWrite+0x34>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    5ea6:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x22) = mask; // clear register
    5eaa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
    5eae:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5eb0:	6883      	ldr	r3, [r0, #8]
		if (val) {
    5eb2:	b151      	cbz	r1, 5eca <digitalWrite+0x3e>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5eb4:	4a08      	ldr	r2, [pc, #32]	; (5ed8 <digitalWrite+0x4c>)
}
    5eb6:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5eba:	601a      	str	r2, [r3, #0]
}
    5ebc:	4770      	bx	lr
    5ebe:	4770      	bx	lr
    5ec0:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->reg + 0x21) = mask; // set register
    5ec4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    5ec8:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5eca:	4a04      	ldr	r2, [pc, #16]	; (5edc <digitalWrite+0x50>)
}
    5ecc:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5ed0:	601a      	str	r2, [r3, #0]
}
    5ed2:	4770      	bx	lr
    5ed4:	20000b7c 	.word	0x20000b7c
    5ed8:	0001f038 	.word	0x0001f038
    5edc:	00013038 	.word	0x00013038

00005ee0 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    5ee0:	2827      	cmp	r0, #39	; 0x27
    5ee2:	d80b      	bhi.n	5efc <digitalRead+0x1c>
	p = digital_pin_to_info_PGM + pin;
    5ee4:	4b06      	ldr	r3, [pc, #24]	; (5f00 <digitalRead+0x20>)
    5ee6:	0102      	lsls	r2, r0, #4
    5ee8:	eb03 1000 	add.w	r0, r3, r0, lsl #4
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    5eec:	589a      	ldr	r2, [r3, r2]
    5eee:	68c3      	ldr	r3, [r0, #12]
    5ef0:	6892      	ldr	r2, [r2, #8]
    5ef2:	421a      	tst	r2, r3
    5ef4:	bf14      	ite	ne
    5ef6:	2001      	movne	r0, #1
    5ef8:	2000      	moveq	r0, #0
    5efa:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return 0;
    5efc:	2000      	movs	r0, #0
}
    5efe:	4770      	bx	lr
    5f00:	20000b7c 	.word	0x20000b7c

00005f04 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    5f04:	2827      	cmp	r0, #39	; 0x27
    5f06:	d829      	bhi.n	5f5c <pinMode+0x58>
	p = digital_pin_to_info_PGM + pin;
    5f08:	4b16      	ldr	r3, [pc, #88]	; (5f64 <pinMode+0x60>)
    5f0a:	0102      	lsls	r2, r0, #4
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5f0c:	2901      	cmp	r1, #1
	p = digital_pin_to_info_PGM + pin;
    5f0e:	eb03 1000 	add.w	r0, r3, r0, lsl #4
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5f12:	589a      	ldr	r2, [r3, r2]
{
    5f14:	b410      	push	{r4}
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5f16:	6853      	ldr	r3, [r2, #4]
    5f18:	68c4      	ldr	r4, [r0, #12]
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    5f1a:	d00e      	beq.n	5f3a <pinMode+0x36>
    5f1c:	2904      	cmp	r1, #4
    5f1e:	d00c      	beq.n	5f3a <pinMode+0x36>
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    5f20:	ea23 0304 	bic.w	r3, r3, r4
    5f24:	6053      	str	r3, [r2, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5f26:	6883      	ldr	r3, [r0, #8]
		if (mode == INPUT) {
    5f28:	b1a9      	cbz	r1, 5f56 <pinMode+0x52>
		} else if (mode == INPUT_PULLUP) {
    5f2a:	2902      	cmp	r1, #2
    5f2c:	d017      	beq.n	5f5e <pinMode+0x5a>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    5f2e:	2903      	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    5f30:	bf0c      	ite	eq
    5f32:	4a0d      	ldreq	r2, [pc, #52]	; (5f68 <pinMode+0x64>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    5f34:	4a0d      	ldrne	r2, [pc, #52]	; (5f6c <pinMode+0x68>)
    5f36:	601a      	str	r2, [r3, #0]
    5f38:	e007      	b.n	5f4a <pinMode+0x46>
		*(p->reg + 1) |= p->mask; // TODO: atomic
    5f3a:	4323      	orrs	r3, r4
		if (mode == OUTPUT) {
    5f3c:	2901      	cmp	r1, #1
		*(p->reg + 1) |= p->mask; // TODO: atomic
    5f3e:	6053      	str	r3, [r2, #4]
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5f40:	6883      	ldr	r3, [r0, #8]
		if (mode == OUTPUT) {
    5f42:	d008      	beq.n	5f56 <pinMode+0x52>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    5f44:	f640 0238 	movw	r2, #2104	; 0x838
    5f48:	601a      	str	r2, [r3, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    5f4a:	6843      	ldr	r3, [r0, #4]
    5f4c:	2215      	movs	r2, #21
}
    5f4e:	f85d 4b04 	ldr.w	r4, [sp], #4
	*(p->mux) = 5 | 0x10;
    5f52:	601a      	str	r2, [r3, #0]
}
    5f54:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7);
    5f56:	2238      	movs	r2, #56	; 0x38
    5f58:	601a      	str	r2, [r3, #0]
    5f5a:	e7f6      	b.n	5f4a <pinMode+0x46>
    5f5c:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    5f5e:	4a04      	ldr	r2, [pc, #16]	; (5f70 <pinMode+0x6c>)
    5f60:	601a      	str	r2, [r3, #0]
    5f62:	e7f2      	b.n	5f4a <pinMode+0x46>
    5f64:	20000b7c 	.word	0x20000b7c
    5f68:	00013038 	.word	0x00013038
    5f6c:	00010038 	.word	0x00010038
    5f70:	0001f038 	.word	0x0001f038

00005f74 <flash_wait>:
{
    5f74:	b430      	push	{r4, r5}
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5f76:	4a12      	ldr	r2, [pc, #72]	; (5fc0 <flash_wait+0x4c>)
	FLEXSPI_LUT61 = 0;
    5f78:	2000      	movs	r0, #0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5f7a:	4b12      	ldr	r3, [pc, #72]	; (5fc4 <flash_wait+0x50>)
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5f7c:	2101      	movs	r1, #1
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    5f7e:	4d12      	ldr	r5, [pc, #72]	; (5fc8 <flash_wait+0x54>)
		status = *(uint8_t *)&FLEXSPI_RFDR0;
    5f80:	4c12      	ldr	r4, [pc, #72]	; (5fcc <flash_wait+0x58>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x05) | LUT1(READ_SDR, PINS1, 1); // 05 = read status
    5f82:	f8c2 32f0 	str.w	r3, [r2, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    5f86:	f8c2 02f4 	str.w	r0, [r2, #756]	; 0x2f4
		FLEXSPI_IPRXFCR = FLEXSPI_IPRXFCR_CLRIPRXF; // clear rx fifo
    5f8a:	f8c2 10b8 	str.w	r1, [r2, #184]	; 0xb8
		FLEXSPI_IPCR0 = 0;
    5f8e:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
		FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(1);
    5f92:	f8c2 50a4 	str.w	r5, [r2, #164]	; 0xa4
		FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    5f96:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
		while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) {;}
    5f9a:	6953      	ldr	r3, [r2, #20]
    5f9c:	07db      	lsls	r3, r3, #31
    5f9e:	d5fc      	bpl.n	5f9a <flash_wait+0x26>
		FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    5fa0:	6151      	str	r1, [r2, #20]
	} while (status & 1);
    5fa2:	7823      	ldrb	r3, [r4, #0]
    5fa4:	07db      	lsls	r3, r3, #31
    5fa6:	d4f0      	bmi.n	5f8a <flash_wait+0x16>
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    5fa8:	6813      	ldr	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    5faa:	4905      	ldr	r1, [pc, #20]	; (5fc0 <flash_wait+0x4c>)
	FLEXSPI_MCR0 |= FLEXSPI_MCR0_SWRESET; // purge stale data from FlexSPI's AHB FIFO
    5fac:	f043 0301 	orr.w	r3, r3, #1
    5fb0:	6013      	str	r3, [r2, #0]
	while (FLEXSPI_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
    5fb2:	680b      	ldr	r3, [r1, #0]
    5fb4:	07db      	lsls	r3, r3, #31
    5fb6:	d4fc      	bmi.n	5fb2 <flash_wait+0x3e>
	__enable_irq();
    5fb8:	b662      	cpsie	i
}
    5fba:	bc30      	pop	{r4, r5}
    5fbc:	4770      	bx	lr
    5fbe:	bf00      	nop
    5fc0:	402a8000 	.word	0x402a8000
    5fc4:	24010405 	.word	0x24010405
    5fc8:	000f0001 	.word	0x000f0001
    5fcc:	402a8100 	.word	0x402a8100

00005fd0 <eeprom_initialize>:
{
    5fd0:	b570      	push	{r4, r5, r6, lr}
    5fd2:	4c0e      	ldr	r4, [pc, #56]	; (600c <eeprom_initialize+0x3c>)
			if (*p++ == 0xFFFF) break;
    5fd4:	f64f 7eff 	movw	lr, #65535	; 0xffff
{
    5fd8:	4e0d      	ldr	r6, [pc, #52]	; (6010 <eeprom_initialize+0x40>)
    5fda:	f104 051e 	add.w	r5, r4, #30
		const uint16_t *p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    5fde:	f5a6 5380 	sub.w	r3, r6, #4096	; 0x1000
		uint16_t index = 0;
    5fe2:	2100      	movs	r1, #0
    5fe4:	e002      	b.n	5fec <eeprom_initialize+0x1c>
		} while (p < end);
    5fe6:	42b3      	cmp	r3, r6
			index++;
    5fe8:	b281      	uxth	r1, r0
		} while (p < end);
    5fea:	d204      	bcs.n	5ff6 <eeprom_initialize+0x26>
			if (*p++ == 0xFFFF) break;
    5fec:	881a      	ldrh	r2, [r3, #0]
			index++;
    5fee:	1c48      	adds	r0, r1, #1
			if (*p++ == 0xFFFF) break;
    5ff0:	3302      	adds	r3, #2
    5ff2:	4572      	cmp	r2, lr
    5ff4:	d1f7      	bne.n	5fe6 <eeprom_initialize+0x16>
		sector_index[sector] = index;
    5ff6:	f824 1f02 	strh.w	r1, [r4, #2]!
	for (sector=0; sector < FLASH_SECTORS; sector++) {
    5ffa:	42ac      	cmp	r4, r5
    5ffc:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
    6000:	d1ed      	bne.n	5fde <eeprom_initialize+0xe>
	initialized = 1;
    6002:	4b04      	ldr	r3, [pc, #16]	; (6014 <eeprom_initialize+0x44>)
    6004:	2201      	movs	r2, #1
    6006:	701a      	strb	r2, [r3, #0]
}
    6008:	bd70      	pop	{r4, r5, r6, pc}
    600a:	bf00      	nop
    600c:	2000a55e 	.word	0x2000a55e
    6010:	601f1000 	.word	0x601f1000
    6014:	2000a712 	.word	0x2000a712

00006018 <eeprom_read_byte>:
	if (addr > E2END) return 0xFF;
    6018:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    601c:	d22c      	bcs.n	6078 <eeprom_read_byte+0x60>
	if (!initialized) eeprom_initialize();
    601e:	4b17      	ldr	r3, [pc, #92]	; (607c <eeprom_read_byte+0x64>)
{
    6020:	b510      	push	{r4, lr}
	if (!initialized) eeprom_initialize();
    6022:	781b      	ldrb	r3, [r3, #0]
    6024:	4604      	mov	r4, r0
    6026:	b323      	cbz	r3, 6072 <eeprom_read_byte+0x5a>
	sector = (addr >> 2) % FLASH_SECTORS;
    6028:	08a0      	lsrs	r0, r4, #2
    602a:	4b15      	ldr	r3, [pc, #84]	; (6080 <eeprom_read_byte+0x68>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    602c:	f004 0103 	and.w	r1, r4, #3
	end = p + sector_index[sector];
    6030:	4c14      	ldr	r4, [pc, #80]	; (6084 <eeprom_read_byte+0x6c>)
	sector = (addr >> 2) % FLASH_SECTORS;
    6032:	fba3 2300 	umull	r2, r3, r3, r0
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    6036:	4a14      	ldr	r2, [pc, #80]	; (6088 <eeprom_read_byte+0x70>)
	sector = (addr >> 2) % FLASH_SECTORS;
    6038:	08db      	lsrs	r3, r3, #3
    603a:	ebc3 1e03 	rsb	lr, r3, r3, lsl #4
    603e:	469c      	mov	ip, r3
    6040:	eba0 030e 	sub.w	r3, r0, lr
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    6044:	ea41 018c 	orr.w	r1, r1, ip, lsl #2
	uint8_t data=0xFF;
    6048:	20ff      	movs	r0, #255	; 0xff
	end = p + sector_index[sector];
    604a:	f834 c013 	ldrh.w	ip, [r4, r3, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    604e:	441a      	add	r2, r3
	end = p + sector_index[sector];
    6050:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    6054:	0313      	lsls	r3, r2, #12
	end = p + sector_index[sector];
    6056:	eb0c 3c02 	add.w	ip, ip, r2, lsl #12
	while (p < end) {
    605a:	ebbc 3f02 	cmp.w	ip, r2, lsl #12
    605e:	d907      	bls.n	6070 <eeprom_read_byte+0x58>
		uint32_t val = *p++;
    6060:	881a      	ldrh	r2, [r3, #0]
    6062:	3302      	adds	r3, #2
		if ((val & 255) == offset) data = val >> 8;
    6064:	b2d4      	uxtb	r4, r2
    6066:	428c      	cmp	r4, r1
    6068:	bf08      	it	eq
    606a:	0a10      	lsreq	r0, r2, #8
	while (p < end) {
    606c:	459c      	cmp	ip, r3
    606e:	d8f7      	bhi.n	6060 <eeprom_read_byte+0x48>
}
    6070:	bd10      	pop	{r4, pc}
	if (!initialized) eeprom_initialize();
    6072:	f7ff ffad 	bl	5fd0 <eeprom_initialize>
    6076:	e7d7      	b.n	6028 <eeprom_read_byte+0x10>
	if (addr > E2END) return 0xFF;
    6078:	20ff      	movs	r0, #255	; 0xff
}
    607a:	4770      	bx	lr
    607c:	2000a712 	.word	0x2000a712
    6080:	88888889 	.word	0x88888889
    6084:	2000a560 	.word	0x2000a560
    6088:	000601f0 	.word	0x000601f0

0000608c <eepromemu_flash_write>:
{
    608c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    608e:	460f      	mov	r7, r1
    6090:	4616      	mov	r6, r2
	__disable_irq();
    6092:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    6094:	4b34      	ldr	r3, [pc, #208]	; (6168 <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    6096:	f240 4106 	movw	r1, #1030	; 0x406
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    609a:	4a34      	ldr	r2, [pc, #208]	; (616c <eepromemu_flash_write+0xe0>)
    609c:	619a      	str	r2, [r3, #24]
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    609e:	2202      	movs	r2, #2
    60a0:	61da      	str	r2, [r3, #28]
	FLEXSPI_IPCR0 = 0;
    60a2:	2200      	movs	r2, #0
    60a4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    60a8:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_LUT61 = 0;
    60ac:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    60b0:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    60b4:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    60b8:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    60bc:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    60c0:	2201      	movs	r2, #1
    60c2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    60c6:	f020 031f 	bic.w	r3, r0, #31
	uint32_t end_addr = (uint32_t)addr + size;
    60ca:	1982      	adds	r2, r0, r6
	asm volatile("": : :"memory");
	asm("dsb");
    60cc:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    60d0:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
    60d4:	f8c4 3f5c 	str.w	r3, [r4, #3932]	; 0xf5c
		location += 32;
    60d8:	3320      	adds	r3, #32
	} while (location < end_addr);
    60da:	429a      	cmp	r2, r3
    60dc:	d8fa      	bhi.n	60d4 <eepromemu_flash_write+0x48>
	asm("dsb");
    60de:	f3bf 8f4f 	dsb	sy
	asm("isb");
    60e2:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    60e6:	4d20      	ldr	r5, [pc, #128]	; (6168 <eepromemu_flash_write+0xdc>)
    60e8:	696b      	ldr	r3, [r5, #20]
    60ea:	07da      	lsls	r2, r3, #31
    60ec:	d5fc      	bpl.n	60e8 <eepromemu_flash_write+0x5c>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    60ee:	2301      	movs	r3, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    60f0:	491f      	ldr	r1, [pc, #124]	; (6170 <eepromemu_flash_write+0xe4>)
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    60f2:	b2b2      	uxth	r2, r6
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    60f4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    60f8:	616b      	str	r3, [r5, #20]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    60fa:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x32) | LUT1(ADDR_SDR, PINS1, 24); // 32 = quad write
    60fe:	f8c5 12f0 	str.w	r1, [r5, #752]	; 0x2f0
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    6102:	f242 2101 	movw	r1, #8705	; 0x2201
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    6106:	4c18      	ldr	r4, [pc, #96]	; (6168 <eepromemu_flash_write+0xdc>)
	FLEXSPI_LUT61 = LUT0(WRITE_SDR, PINS4, 1);
    6108:	f8c5 12f4 	str.w	r1, [r5, #756]	; 0x2f4
	FLEXSPI_IPTXFCR = FLEXSPI_IPTXFCR_CLRIPTXF; // clear tx fifo
    610c:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFFFFF;
    6110:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15) | FLEXSPI_IPCR1_IDATSZ(len);
    6114:	f8c5 20a4 	str.w	r2, [r5, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    6118:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    611c:	4d15      	ldr	r5, [pc, #84]	; (6174 <eepromemu_flash_write+0xe8>)
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    611e:	e001      	b.n	6124 <eepromemu_flash_write+0x98>
		if (n & FLEXSPI_INTR_IPTXWE) {
    6120:	065b      	lsls	r3, r3, #25
    6122:	d409      	bmi.n	6138 <eepromemu_flash_write+0xac>
	while (!((n = FLEXSPI_INTR) & FLEXSPI_INTR_IPCMDDONE)) {
    6124:	6963      	ldr	r3, [r4, #20]
    6126:	f013 0001 	ands.w	r0, r3, #1
    612a:	d0f9      	beq.n	6120 <eepromemu_flash_write+0x94>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPTXWE;
    612c:	2341      	movs	r3, #65	; 0x41
    612e:	6163      	str	r3, [r4, #20]
}
    6130:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	flash_wait();
    6134:	f7ff bf1e 	b.w	5f74 <flash_wait>
			if (wrlen > 8) wrlen = 8;
    6138:	2e08      	cmp	r6, #8
    613a:	d80a      	bhi.n	6152 <eepromemu_flash_write+0xc6>
			if (wrlen > 0) {
    613c:	b136      	cbz	r6, 614c <eepromemu_flash_write+0xc0>
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    613e:	4632      	mov	r2, r6
    6140:	4639      	mov	r1, r7
				src += wrlen;
    6142:	4437      	add	r7, r6
				len -= wrlen;
    6144:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    6146:	4628      	mov	r0, r5
    6148:	f000 f994 	bl	6474 <memcpy>
			FLEXSPI_INTR = FLEXSPI_INTR_IPTXWE;
    614c:	2340      	movs	r3, #64	; 0x40
    614e:	6163      	str	r3, [r4, #20]
    6150:	e7e8      	b.n	6124 <eepromemu_flash_write+0x98>
    6152:	f1a6 0008 	sub.w	r0, r6, #8
			if (wrlen > 8) wrlen = 8;
    6156:	2608      	movs	r6, #8
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    6158:	4639      	mov	r1, r7
    615a:	4632      	mov	r2, r6
				src += wrlen;
    615c:	4437      	add	r7, r6
				len -= wrlen;
    615e:	4606      	mov	r6, r0
				memcpy((void *)&FLEXSPI_TFDR0, src, wrlen);
    6160:	4628      	mov	r0, r5
    6162:	f000 f987 	bl	6474 <memcpy>
				len -= wrlen;
    6166:	e7f1      	b.n	614c <eepromemu_flash_write+0xc0>
    6168:	402a8000 	.word	0x402a8000
    616c:	5af05af0 	.word	0x5af05af0
    6170:	08180432 	.word	0x08180432
    6174:	402a8180 	.word	0x402a8180

00006178 <eepromemu_flash_erase_sector>:
{
    6178:	b410      	push	{r4}
	__disable_irq();
    617a:	b672      	cpsid	i
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    617c:	4b28      	ldr	r3, [pc, #160]	; (6220 <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    617e:	2102      	movs	r1, #2
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    6180:	4c28      	ldr	r4, [pc, #160]	; (6224 <eepromemu_flash_erase_sector+0xac>)
	FLEXSPI_LUT61 = 0;
    6182:	2200      	movs	r2, #0
	FLEXSPI_LUTKEY = FLEXSPI_LUTKEY_VALUE;
    6184:	619c      	str	r4, [r3, #24]
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    6186:	f44f 2470 	mov.w	r4, #983040	; 0xf0000
	FLEXSPI_LUTCR = FLEXSPI_LUTCR_UNLOCK;
    618a:	61d9      	str	r1, [r3, #28]
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x06); // 06 = write enable
    618c:	f240 4106 	movw	r1, #1030	; 0x406
    6190:	f8c3 12f0 	str.w	r1, [r3, #752]	; 0x2f0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    6194:	2101      	movs	r1, #1
	FLEXSPI_LUT61 = 0;
    6196:	f8c3 22f4 	str.w	r2, [r3, #756]	; 0x2f4
	FLEXSPI_LUT62 = 0;
    619a:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
	FLEXSPI_LUT63 = 0;
    619e:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	FLEXSPI_IPCR0 = 0;
    61a2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    61a6:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    61aa:	f8c3 40a4 	str.w	r4, [r3, #164]	; 0xa4
	arm_dcache_delete((void *)((uint32_t)addr & 0xFFFFF000), 4096); // purge data from cache
    61ae:	4002      	ands	r2, r0
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    61b0:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
	asm("dsb");
    61b4:	f3bf 8f4f 	dsb	sy
	uint32_t end_addr = (uint32_t)addr + size;
    61b8:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
    61bc:	f102 0320 	add.w	r3, r2, #32
		SCB_CACHE_DCIMVAC = location;
    61c0:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
    61c4:	4299      	cmp	r1, r3
    61c6:	bf34      	ite	cc
    61c8:	2101      	movcc	r1, #1
    61ca:	2180      	movcs	r1, #128	; 0x80
    61cc:	eb02 1141 	add.w	r1, r2, r1, lsl #5
	} while (location < end_addr);
    61d0:	428b      	cmp	r3, r1
		SCB_CACHE_DCIMVAC = location;
    61d2:	f8cc 2f5c 	str.w	r2, [ip, #3932]	; 0xf5c
		location += 32;
    61d6:	461a      	mov	r2, r3
	} while (location < end_addr);
    61d8:	f103 0320 	add.w	r3, r3, #32
    61dc:	d1f8      	bne.n	61d0 <eepromemu_flash_erase_sector+0x58>
	asm("dsb");
    61de:	f3bf 8f4f 	dsb	sy
	asm("isb");
    61e2:	f3bf 8f6f 	isb	sy
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    61e6:	4a0e      	ldr	r2, [pc, #56]	; (6220 <eepromemu_flash_erase_sector+0xa8>)
    61e8:	6953      	ldr	r3, [r2, #20]
    61ea:	07d9      	lsls	r1, r3, #31
    61ec:	d5fc      	bpl.n	61e8 <eepromemu_flash_erase_sector+0x70>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    61ee:	2401      	movs	r4, #1
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    61f0:	490d      	ldr	r1, [pc, #52]	; (6228 <eepromemu_flash_erase_sector+0xb0>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    61f2:	4b0e      	ldr	r3, [pc, #56]	; (622c <eepromemu_flash_erase_sector+0xb4>)
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    61f4:	6154      	str	r4, [r2, #20]
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    61f6:	4003      	ands	r3, r0
	FLEXSPI_LUT60 = LUT0(CMD_SDR, PINS1, 0x20) | LUT1(ADDR_SDR, PINS1, 24); // 20 = sector erase
    61f8:	f8c2 12f0 	str.w	r1, [r2, #752]	; 0x2f0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    61fc:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    6200:	4907      	ldr	r1, [pc, #28]	; (6220 <eepromemu_flash_erase_sector+0xa8>)
	FLEXSPI_IPCR0 = (uint32_t)addr & 0x00FFF000;
    6202:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI_IPCR1 = FLEXSPI_IPCR1_ISEQID(15);
    6206:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI_IPCMD = FLEXSPI_IPCMD_TRG;
    620a:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
	while (!(FLEXSPI_INTR & FLEXSPI_INTR_IPCMDDONE)) ; // wait
    620e:	694b      	ldr	r3, [r1, #20]
    6210:	07db      	lsls	r3, r3, #31
    6212:	d5fc      	bpl.n	620e <eepromemu_flash_erase_sector+0x96>
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    6214:	2301      	movs	r3, #1
}
    6216:	f85d 4b04 	ldr.w	r4, [sp], #4
	FLEXSPI_INTR = FLEXSPI_INTR_IPCMDDONE;
    621a:	614b      	str	r3, [r1, #20]
	flash_wait();
    621c:	f7ff beaa 	b.w	5f74 <flash_wait>
    6220:	402a8000 	.word	0x402a8000
    6224:	5af05af0 	.word	0x5af05af0
    6228:	08180420 	.word	0x08180420
    622c:	00fff000 	.word	0x00fff000

00006230 <eeprom_write_byte>:
	if (addr > E2END) return;
    6230:	f5b0 6f87 	cmp.w	r0, #1080	; 0x438
    6234:	f080 8086 	bcs.w	6344 <eeprom_write_byte+0x114>
	if (!initialized) eeprom_initialize();
    6238:	4b44      	ldr	r3, [pc, #272]	; (634c <eeprom_write_byte+0x11c>)
{
    623a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!initialized) eeprom_initialize();
    623e:	781b      	ldrb	r3, [r3, #0]
{
    6240:	b0c2      	sub	sp, #264	; 0x108
    6242:	4605      	mov	r5, r0
    6244:	4689      	mov	r9, r1
	if (!initialized) eeprom_initialize();
    6246:	2b00      	cmp	r3, #0
    6248:	d079      	beq.n	633e <eeprom_write_byte+0x10e>
	sector = (addr >> 2) % FLASH_SECTORS; 
    624a:	08ab      	lsrs	r3, r5, #2
    624c:	4e40      	ldr	r6, [pc, #256]	; (6350 <eeprom_write_byte+0x120>)
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    624e:	f005 0503 	and.w	r5, r5, #3
	end = p + sector_index[sector];
    6252:	4f40      	ldr	r7, [pc, #256]	; (6354 <eeprom_write_byte+0x124>)
	sector = (addr >> 2) % FLASH_SECTORS; 
    6254:	fba6 2603 	umull	r2, r6, r6, r3
    6258:	08f6      	lsrs	r6, r6, #3
	offset = (addr & 3) | (((addr >> 2) / FLASH_SECTORS) << 2);
    625a:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
	sector = (addr >> 2) % FLASH_SECTORS; 
    625e:	ebc6 1606 	rsb	r6, r6, r6, lsl #4
    6262:	1b9e      	subs	r6, r3, r6
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    6264:	4b3c      	ldr	r3, [pc, #240]	; (6358 <eeprom_write_byte+0x128>)
	end = p + sector_index[sector];
    6266:	f837 4016 	ldrh.w	r4, [r7, r6, lsl #1]
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    626a:	4433      	add	r3, r6
	end = p + sector_index[sector];
    626c:	0060      	lsls	r0, r4, #1
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    626e:	ea4f 3803 	mov.w	r8, r3, lsl #12
	end = p + sector_index[sector];
    6272:	eb00 3003 	add.w	r0, r0, r3, lsl #12
	while (p < end) {
    6276:	ebb0 3f03 	cmp.w	r0, r3, lsl #12
    627a:	d964      	bls.n	6346 <eeprom_write_byte+0x116>
    627c:	4643      	mov	r3, r8
	uint8_t olddata=0xFF;
    627e:	f04f 0cff 	mov.w	ip, #255	; 0xff
		uint16_t val = *p++;
    6282:	881a      	ldrh	r2, [r3, #0]
    6284:	3302      	adds	r3, #2
		if ((val & 255) == offset) olddata = val >> 8;
    6286:	b2d1      	uxtb	r1, r2
    6288:	42a9      	cmp	r1, r5
    628a:	bf08      	it	eq
    628c:	ea4f 2c12 	moveq.w	ip, r2, lsr #8
	while (p < end) {
    6290:	4298      	cmp	r0, r3
    6292:	d8f6      	bhi.n	6282 <eeprom_write_byte+0x52>
	if (data == olddata) return;
    6294:	45e1      	cmp	r9, ip
    6296:	d041      	beq.n	631c <eeprom_write_byte+0xec>
	if (sector_index[sector] < 2048) {
    6298:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
    629c:	d341      	bcc.n	6322 <eeprom_write_byte+0xf2>
		memset(buf, 0xFF, sizeof(buf));
    629e:	ac02      	add	r4, sp, #8
    62a0:	f44f 7280 	mov.w	r2, #256	; 0x100
    62a4:	21ff      	movs	r1, #255	; 0xff
    62a6:	4620      	mov	r0, r4
    62a8:	f002 fbdc 	bl	8a64 <memset>
		while (p < end) {
    62ac:	f508 5080 	add.w	r0, r8, #4096	; 0x1000
    62b0:	f108 0302 	add.w	r3, r8, #2
	p = (uint16_t *)(FLASH_BASEADDR + sector * 4096);
    62b4:	4642      	mov	r2, r8
    62b6:	4298      	cmp	r0, r3
    62b8:	bf34      	ite	cc
    62ba:	2001      	movcc	r0, #1
    62bc:	f44f 6000 	movcs.w	r0, #2048	; 0x800
    62c0:	eb08 0040 	add.w	r0, r8, r0, lsl #1
			uint16_t val = *p++;
    62c4:	4613      	mov	r3, r2
    62c6:	3202      	adds	r2, #2
    62c8:	881b      	ldrh	r3, [r3, #0]
		while (p < end) {
    62ca:	4282      	cmp	r2, r0
			buf[val & 255] = val >> 8;
    62cc:	b2d9      	uxtb	r1, r3
    62ce:	ea4f 2313 	mov.w	r3, r3, lsr #8
    62d2:	5463      	strb	r3, [r4, r1]
		while (p < end) {
    62d4:	d1f6      	bne.n	62c4 <eeprom_write_byte+0x94>
		buf[offset] = data;
    62d6:	f804 9005 	strb.w	r9, [r4, r5]
		eepromemu_flash_erase_sector(p);
    62da:	f10d 0907 	add.w	r9, sp, #7
    62de:	f20d 1a07 	addw	sl, sp, #263	; 0x107
		index = 0;
    62e2:	2500      	movs	r5, #0
		eepromemu_flash_erase_sector(p);
    62e4:	464c      	mov	r4, r9
    62e6:	4640      	mov	r0, r8
    62e8:	f7ff ff46 	bl	6178 <eepromemu_flash_erase_sector>
			if (buf[i] != 0xFF) {
    62ec:	f814 cf01 	ldrb.w	ip, [r4, #1]!
				eepromemu_flash_write(p + index, &newval, 2);
    62f0:	eb08 0045 	add.w	r0, r8, r5, lsl #1
    62f4:	2202      	movs	r2, #2
    62f6:	f10d 0106 	add.w	r1, sp, #6
				uint16_t newval = i | (buf[i] << 8);
    62fa:	1e63      	subs	r3, r4, #1
			if (buf[i] != 0xFF) {
    62fc:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
				uint16_t newval = i | (buf[i] << 8);
    6300:	eba3 0309 	sub.w	r3, r3, r9
			if (buf[i] != 0xFF) {
    6304:	d006      	beq.n	6314 <eeprom_write_byte+0xe4>
				uint16_t newval = i | (buf[i] << 8);
    6306:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
				index = index + 1;
    630a:	3501      	adds	r5, #1
				uint16_t newval = i | (buf[i] << 8);
    630c:	f8ad 3006 	strh.w	r3, [sp, #6]
				eepromemu_flash_write(p + index, &newval, 2);
    6310:	f7ff febc 	bl	608c <eepromemu_flash_write>
		for (i=0; i < 256; i++) {
    6314:	45a2      	cmp	sl, r4
    6316:	d1e9      	bne.n	62ec <eeprom_write_byte+0xbc>
		sector_index[sector] = index;
    6318:	f827 5016 	strh.w	r5, [r7, r6, lsl #1]
}
    631c:	b042      	add	sp, #264	; 0x108
    631e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint16_t newdata = offset | (data << 8);
    6322:	ea45 2509 	orr.w	r5, r5, r9, lsl #8
		eepromemu_flash_write(end, &newdata, 2);
    6326:	a902      	add	r1, sp, #8
    6328:	2202      	movs	r2, #2
		sector_index[sector] = sector_index[sector] + 1;
    632a:	3401      	adds	r4, #1
		uint16_t newdata = offset | (data << 8);
    632c:	f8ad 5008 	strh.w	r5, [sp, #8]
		eepromemu_flash_write(end, &newdata, 2);
    6330:	f7ff feac 	bl	608c <eepromemu_flash_write>
		sector_index[sector] = sector_index[sector] + 1;
    6334:	f827 4016 	strh.w	r4, [r7, r6, lsl #1]
}
    6338:	b042      	add	sp, #264	; 0x108
    633a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!initialized) eeprom_initialize();
    633e:	f7ff fe47 	bl	5fd0 <eeprom_initialize>
    6342:	e782      	b.n	624a <eeprom_write_byte+0x1a>
    6344:	4770      	bx	lr
	uint8_t olddata=0xFF;
    6346:	f04f 0cff 	mov.w	ip, #255	; 0xff
    634a:	e7a3      	b.n	6294 <eeprom_write_byte+0x64>
    634c:	2000a712 	.word	0x2000a712
    6350:	88888889 	.word	0x88888889
    6354:	2000a560 	.word	0x2000a560
    6358:	000601f0 	.word	0x000601f0

0000635c <dummy_isr>:
static void dummy_isr() {};
    635c:	4770      	bx	lr
    635e:	bf00      	nop

00006360 <attachInterrupt>:

#endif

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    6360:	2827      	cmp	r0, #39	; 0x27
    6362:	d858      	bhi.n	6416 <attachInterrupt+0xb6>
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
    6364:	0100      	lsls	r0, r0, #4
{
    6366:	b4f0      	push	{r4, r5, r6, r7}
	volatile uint32_t *gpio = portOutputRegister(pin);
    6368:	4c34      	ldr	r4, [pc, #208]	; (643c <attachInterrupt+0xdc>)

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
    636a:	4d35      	ldr	r5, [pc, #212]	; (6440 <attachInterrupt+0xe0>)
	volatile uint32_t *gpio = portOutputRegister(pin);
    636c:	5823      	ldr	r3, [r4, r0]
	switch((uint32_t)gpio) {
    636e:	42ab      	cmp	r3, r5
    6370:	d056      	beq.n	6420 <attachInterrupt+0xc0>
    6372:	d849      	bhi.n	6408 <attachInterrupt+0xa8>
    6374:	f1b3 4f84 	cmp.w	r3, #1107296256	; 0x42000000
    6378:	d04b      	beq.n	6412 <attachInterrupt+0xb2>
    637a:	f5a5 4580 	sub.w	r5, r5, #16384	; 0x4000
    637e:	42ab      	cmp	r3, r5
    6380:	d140      	bne.n	6404 <attachInterrupt+0xa4>
    6382:	4d30      	ldr	r5, [pc, #192]	; (6444 <attachInterrupt+0xe4>)
	volatile uint32_t *mux = portConfigRegister(pin);
    6384:	4420      	add	r0, r4
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    6386:	4e30      	ldr	r6, [pc, #192]	; (6448 <attachInterrupt+0xe8>)
    6388:	4c30      	ldr	r4, [pc, #192]	; (644c <attachInterrupt+0xec>)
    638a:	f8c4 62b4 	str.w	r6, [r4, #692]	; 0x2b4
	volatile uint32_t *pad = portControlRegister(pin);
    638e:	e9d0 c401 	ldrd	ip, r4, [r0, #4]
	uint32_t mask = digitalPinToBitMask(pin);
    6392:	68c0      	ldr	r0, [r0, #12]
		default:
			return;
	}

	attachInterruptVector(IRQ_GPIO6789, &irq_gpio6789);
	NVIC_ENABLE_IRQ(IRQ_GPIO6789);
    6394:	f04f 26e0 	mov.w	r6, #3758153728	; 0xe000e000
    6398:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
    639c:	2a04      	cmp	r2, #4
    639e:	f8c6 7110 	str.w	r7, [r6, #272]	; 0x110

#endif

	uint32_t icr;
	switch (mode) {
    63a2:	d82f      	bhi.n	6404 <attachInterrupt+0xa4>
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    63a4:	695e      	ldr	r6, [r3, #20]
    63a6:	ea26 0600 	bic.w	r6, r6, r0
    63aa:	615e      	str	r6, [r3, #20]
	*mux = 5;			// pin is GPIO
    63ac:	f04f 0605 	mov.w	r6, #5
    63b0:	f8cc 6000 	str.w	r6, [ip]
	*pad |= IOMUXC_PAD_HYS;		// use hystersis avoid false trigger by slow signals
    63b4:	6826      	ldr	r6, [r4, #0]
    63b6:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
    63ba:	6026      	str	r6, [r4, #0]
	gpio[GDIR_INDEX] &= ~mask;	// pin to input mode
    63bc:	685c      	ldr	r4, [r3, #4]
    63be:	ea24 0400 	bic.w	r4, r4, r0
    63c2:	605c      	str	r4, [r3, #4]
    63c4:	4c22      	ldr	r4, [pc, #136]	; (6450 <attachInterrupt+0xf0>)
    63c6:	f854 4022 	ldr.w	r4, [r4, r2, lsl #2]
	uint32_t index = __builtin_ctz(mask);
    63ca:	fa90 f2a0 	rbit	r2, r0
    63ce:	fab2 f282 	clz	r2, r2
	table[index] = function;
    63d2:	f845 1022 	str.w	r1, [r5, r2, lsl #2]
	gpio[IMR_INDEX] &= ~mask;	// disable interrupt
    63d6:	ea6f 0100 	mvn.w	r1, r0
	if (mode == CHANGE) {
    63da:	d01d      	beq.n	6418 <attachInterrupt+0xb8>
		gpio[EDGE_INDEX] |= mask;
	} else {
		gpio[EDGE_INDEX] &= ~mask;
    63dc:	69dd      	ldr	r5, [r3, #28]
		if (index < 16) {
    63de:	2a0f      	cmp	r2, #15
		gpio[EDGE_INDEX] &= ~mask;
    63e0:	ea01 0105 	and.w	r1, r1, r5
    63e4:	61d9      	str	r1, [r3, #28]
		if (index < 16) {
    63e6:	dc1d      	bgt.n	6424 <attachInterrupt+0xc4>
			uint32_t shift = index * 2;
    63e8:	0052      	lsls	r2, r2, #1
			gpio[ICR1_INDEX] = (gpio[ICR1_INDEX] & ~(3 << shift)) | (icr << shift);
    63ea:	2503      	movs	r5, #3
    63ec:	68d9      	ldr	r1, [r3, #12]
    63ee:	4094      	lsls	r4, r2
    63f0:	fa05 f202 	lsl.w	r2, r5, r2
    63f4:	ea21 0202 	bic.w	r2, r1, r2
    63f8:	4322      	orrs	r2, r4
    63fa:	60da      	str	r2, [r3, #12]
		} else {
			uint32_t shift = (index - 16) * 2;
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
		}
	}
	gpio[ISR_INDEX] = mask;  // clear any prior pending interrupt
    63fc:	6198      	str	r0, [r3, #24]
	gpio[IMR_INDEX] |= mask; // enable interrupt
    63fe:	695a      	ldr	r2, [r3, #20]
    6400:	4302      	orrs	r2, r0
    6402:	615a      	str	r2, [r3, #20]
}
    6404:	bcf0      	pop	{r4, r5, r6, r7}
    6406:	4770      	bx	lr
	switch((uint32_t)gpio) {
    6408:	4d12      	ldr	r5, [pc, #72]	; (6454 <attachInterrupt+0xf4>)
    640a:	42ab      	cmp	r3, r5
    640c:	d1fa      	bne.n	6404 <attachInterrupt+0xa4>
			table = isr_table_gpio4;
    640e:	4d12      	ldr	r5, [pc, #72]	; (6458 <attachInterrupt+0xf8>)
    6410:	e7b8      	b.n	6384 <attachInterrupt+0x24>
			table = isr_table_gpio1;
    6412:	4d12      	ldr	r5, [pc, #72]	; (645c <attachInterrupt+0xfc>)
    6414:	e7b6      	b.n	6384 <attachInterrupt+0x24>
    6416:	4770      	bx	lr
		gpio[EDGE_INDEX] |= mask;
    6418:	69da      	ldr	r2, [r3, #28]
    641a:	4302      	orrs	r2, r0
    641c:	61da      	str	r2, [r3, #28]
    641e:	e7ed      	b.n	63fc <attachInterrupt+0x9c>
			table = isr_table_gpio3;
    6420:	4d0f      	ldr	r5, [pc, #60]	; (6460 <attachInterrupt+0x100>)
    6422:	e7af      	b.n	6384 <attachInterrupt+0x24>
			uint32_t shift = (index - 16) * 2;
    6424:	3a10      	subs	r2, #16
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    6426:	2503      	movs	r5, #3
    6428:	6919      	ldr	r1, [r3, #16]
			uint32_t shift = (index - 16) * 2;
    642a:	0052      	lsls	r2, r2, #1
			gpio[ICR2_INDEX] = (gpio[ICR2_INDEX] & ~(3 << shift)) | (icr << shift);
    642c:	4094      	lsls	r4, r2
    642e:	fa05 f202 	lsl.w	r2, r5, r2
    6432:	ea21 0202 	bic.w	r2, r1, r2
    6436:	4322      	orrs	r2, r4
    6438:	611a      	str	r2, [r3, #16]
    643a:	e7df      	b.n	63fc <attachInterrupt+0x9c>
    643c:	20000b7c 	.word	0x20000b7c
    6440:	42008000 	.word	0x42008000
    6444:	20001804 	.word	0x20001804
    6448:	00000021 	.word	0x00000021
    644c:	20001c00 	.word	0x20001c00
    6450:	200003c8 	.word	0x200003c8
    6454:	4200c000 	.word	0x4200c000
    6458:	20001904 	.word	0x20001904
    645c:	20001784 	.word	0x20001784
    6460:	20001884 	.word	0x20001884

00006464 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    6464:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    6466:	f7f9 fe7b 	bl	160 <setup>
	while (1) {
		loop();
    646a:	f7f9 ff5f 	bl	32c <loop>
		yield();
    646e:	f001 fbc7 	bl	7c00 <yield>
	while (1) {
    6472:	e7fa      	b.n	646a <main+0x6>

00006474 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    6474:	4684      	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    6476:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    647a:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    647e:	d16d      	bne.n	655c <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    6480:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    6482:	d341      	bcc.n	6508 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    6484:	f851 3b04 	ldr.w	r3, [r1], #4
    6488:	f840 3b04 	str.w	r3, [r0], #4
    648c:	f851 3b04 	ldr.w	r3, [r1], #4
    6490:	f840 3b04 	str.w	r3, [r0], #4
    6494:	f851 3b04 	ldr.w	r3, [r1], #4
    6498:	f840 3b04 	str.w	r3, [r0], #4
    649c:	f851 3b04 	ldr.w	r3, [r1], #4
    64a0:	f840 3b04 	str.w	r3, [r0], #4
    64a4:	f851 3b04 	ldr.w	r3, [r1], #4
    64a8:	f840 3b04 	str.w	r3, [r0], #4
    64ac:	f851 3b04 	ldr.w	r3, [r1], #4
    64b0:	f840 3b04 	str.w	r3, [r0], #4
    64b4:	f851 3b04 	ldr.w	r3, [r1], #4
    64b8:	f840 3b04 	str.w	r3, [r0], #4
    64bc:	f851 3b04 	ldr.w	r3, [r1], #4
    64c0:	f840 3b04 	str.w	r3, [r0], #4
    64c4:	f851 3b04 	ldr.w	r3, [r1], #4
    64c8:	f840 3b04 	str.w	r3, [r0], #4
    64cc:	f851 3b04 	ldr.w	r3, [r1], #4
    64d0:	f840 3b04 	str.w	r3, [r0], #4
    64d4:	f851 3b04 	ldr.w	r3, [r1], #4
    64d8:	f840 3b04 	str.w	r3, [r0], #4
    64dc:	f851 3b04 	ldr.w	r3, [r1], #4
    64e0:	f840 3b04 	str.w	r3, [r0], #4
    64e4:	f851 3b04 	ldr.w	r3, [r1], #4
    64e8:	f840 3b04 	str.w	r3, [r0], #4
    64ec:	f851 3b04 	ldr.w	r3, [r1], #4
    64f0:	f840 3b04 	str.w	r3, [r0], #4
    64f4:	f851 3b04 	ldr.w	r3, [r1], #4
    64f8:	f840 3b04 	str.w	r3, [r0], #4
    64fc:	f851 3b04 	ldr.w	r3, [r1], #4
    6500:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    6504:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    6506:	d2bd      	bcs.n	6484 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    6508:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    650a:	d311      	bcc.n	6530 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    650c:	f851 3b04 	ldr.w	r3, [r1], #4
    6510:	f840 3b04 	str.w	r3, [r0], #4
    6514:	f851 3b04 	ldr.w	r3, [r1], #4
    6518:	f840 3b04 	str.w	r3, [r0], #4
    651c:	f851 3b04 	ldr.w	r3, [r1], #4
    6520:	f840 3b04 	str.w	r3, [r0], #4
    6524:	f851 3b04 	ldr.w	r3, [r1], #4
    6528:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    652c:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    652e:	d2ed      	bcs.n	650c <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    6530:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    6532:	d305      	bcc.n	6540 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    6534:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    6538:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    653c:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    653e:	d2f9      	bcs.n	6534 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    6540:	3204      	adds	r2, #4
	beq	.Ldone
    6542:	d008      	beq.n	6556 <memcpy+0xe2>

	lsls	r2, r2, #31
    6544:	07d2      	lsls	r2, r2, #31
	itt ne
    6546:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    6548:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    654c:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    6550:	d301      	bcc.n	6556 <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    6552:	880b      	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    6554:	8003      	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    6556:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    6558:	4770      	bx	lr
    655a:	bf00      	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    655c:	2a08      	cmp	r2, #8
	blo	.Lbyte_copy
    655e:	d313      	bcc.n	6588 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    6560:	078b      	lsls	r3, r1, #30
	beq	.Ldst_aligned
    6562:	d08d      	beq.n	6480 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    6564:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    6568:	d08a      	beq.n	6480 <memcpy+0xc>

	rsb	r3, #4
    656a:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    656e:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    6570:	07db      	lsls	r3, r3, #31
	itt ne
    6572:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    6574:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    6578:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    657c:	d380      	bcc.n	6480 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    657e:	f831 3b02 	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    6582:	f820 3b02 	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    6586:	e77b      	b.n	6480 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    6588:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    658a:	d3d9      	bcc.n	6540 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    658c:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    658e:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    6592:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    6596:	d2f9      	bcs.n	658c <memcpy+0x118>

	ldrb	r3, [r1]
    6598:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    659a:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    659c:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    659e:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    65a0:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    65a2:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    65a4:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    65a6:	4770      	bx	lr

000065a8 <ultoa>:


char * ultoa(unsigned long val, char *buf, int radix)
{
	unsigned digit;
	int i=0, j;
    65a8:	f101 3cff 	add.w	ip, r1, #4294967295
{
    65ac:	b570      	push	{r4, r5, r6, lr}
	char t;

	while (1) {
		digit = val % radix;
    65ae:	4666      	mov	r6, ip
	int i=0, j;
    65b0:	2400      	movs	r4, #0
    65b2:	e000      	b.n	65b6 <ultoa+0xe>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    65b4:	3401      	adds	r4, #1
		digit = val % radix;
    65b6:	fbb0 f5f2 	udiv	r5, r0, r2
    65ba:	fb02 0315 	mls	r3, r2, r5, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    65be:	2b09      	cmp	r3, #9
    65c0:	f103 0e37 	add.w	lr, r3, #55	; 0x37
    65c4:	f103 0330 	add.w	r3, r3, #48	; 0x30
    65c8:	fa5f fe8e 	uxtb.w	lr, lr
    65cc:	bf98      	it	ls
    65ce:	fa5f fe83 	uxtbls.w	lr, r3
		if (val == 0) break;
    65d2:	4290      	cmp	r0, r2
		val /= radix;
    65d4:	4628      	mov	r0, r5
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    65d6:	f806 ef01 	strb.w	lr, [r6, #1]!
		if (val == 0) break;
    65da:	d2eb      	bcs.n	65b4 <ultoa+0xc>
	}
	buf[i + 1] = 0;
    65dc:	1c63      	adds	r3, r4, #1
    65de:	2200      	movs	r2, #0
    65e0:	18c8      	adds	r0, r1, r3
    65e2:	54ca      	strb	r2, [r1, r3]
	for (j=0; j < i; j++, i--) {
    65e4:	b17c      	cbz	r4, 6606 <ultoa+0x5e>
		t = buf[j];
    65e6:	4662      	mov	r2, ip
    65e8:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
		buf[j] = buf[i];
    65ec:	f810 6d01 	ldrb.w	r6, [r0, #-1]!
	for (j=0; j < i; j++, i--) {
    65f0:	eba1 030c 	sub.w	r3, r1, ip
    65f4:	3202      	adds	r2, #2
		buf[j] = buf[i];
    65f6:	f88c 6000 	strb.w	r6, [ip]
	for (j=0; j < i; j++, i--) {
    65fa:	3b01      	subs	r3, #1
    65fc:	1a52      	subs	r2, r2, r1
		buf[i] = t;
    65fe:	7005      	strb	r5, [r0, #0]
	for (j=0; j < i; j++, i--) {
    6600:	4423      	add	r3, r4
    6602:	429a      	cmp	r2, r3
    6604:	dbef      	blt.n	65e6 <ultoa+0x3e>
	}
	return buf;
}
    6606:	4608      	mov	r0, r1
    6608:	bd70      	pop	{r4, r5, r6, pc}
    660a:	bf00      	nop

0000660c <flexpwmWrite>:

#endif // __IMXRT1062__

void flexpwmWrite(IMXRT_FLEXPWM_t *p, unsigned int submodule, uint8_t channel, uint16_t val)
{
	uint16_t mask = 1 << submodule;
    660c:	f04f 0c01 	mov.w	ip, #1
    6610:	fa0c fc01 	lsl.w	ip, ip, r1
	uint32_t modulo = p->SM[submodule].VAL1;
    6614:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6618:	eb00 1141 	add.w	r1, r0, r1, lsl #5
{
    661c:	b570      	push	{r4, r5, r6, lr}
	uint32_t modulo = p->SM[submodule].VAL1;
    661e:	f8b1 e00e 	ldrh.w	lr, [r1, #14]
	uint16_t mask = 1 << submodule;
    6622:	fa1f f58c 	uxth.w	r5, ip
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6626:	4c25      	ldr	r4, [pc, #148]	; (66bc <flexpwmWrite+0xb0>)
	uint32_t modulo = p->SM[submodule].VAL1;
    6628:	fa1f fe8e 	uxth.w	lr, lr
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    662c:	7824      	ldrb	r4, [r4, #0]
	if (cval > modulo) cval = modulo; // TODO: is this check correct?

	//printf("flexpwmWrite, p=%08lX, sm=%d, ch=%c, cval=%ld\n",
		//(uint32_t)p, submodule, channel == 0 ? 'X' : (channel == 1 ? 'A' : 'B'), cval);
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    662e:	012e      	lsls	r6, r5, #4
	uint32_t cval = ((uint32_t)val * (modulo + 1)) >> analog_write_res;
    6630:	fb0e 3303 	mla	r3, lr, r3, r3
    6634:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    6638:	40e3      	lsrs	r3, r4
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    663a:	f8b0 4188 	ldrh.w	r4, [r0, #392]	; 0x188
    663e:	4573      	cmp	r3, lr
    6640:	b2a4      	uxth	r4, r4
    6642:	bf28      	it	cs
    6644:	4673      	movcs	r3, lr
    6646:	4334      	orrs	r4, r6
	switch (channel) {
    6648:	2a01      	cmp	r2, #1
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(mask);
    664a:	f8a0 4188 	strh.w	r4, [r0, #392]	; 0x188
	switch (channel) {
    664e:	d00d      	beq.n	666c <flexpwmWrite+0x60>
    6650:	2a02      	cmp	r2, #2
    6652:	d028      	beq.n	66a6 <flexpwmWrite+0x9a>
    6654:	b1c2      	cbz	r2, 6688 <flexpwmWrite+0x7c>
    6656:	f00c 020f 	and.w	r2, ip, #15
	  case 2: // B
		p->SM[submodule].VAL5 = cval;
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
		//printf(" write channel B\n");
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(mask);
    665a:	f8b0 c188 	ldrh.w	ip, [r0, #392]	; 0x188
    665e:	fa1f fc8c 	uxth.w	ip, ip
    6662:	ea4c 0c02 	orr.w	ip, ip, r2
    6666:	f8a0 c188 	strh.w	ip, [r0, #392]	; 0x188
}
    666a:	bd70      	pop	{r4, r5, r6, pc}
		p->SM[submodule].VAL3 = cval;
    666c:	b29b      	uxth	r3, r3
    666e:	f00c 020f 	and.w	r2, ip, #15
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    6672:	022d      	lsls	r5, r5, #8
		p->SM[submodule].VAL3 = cval;
    6674:	82cb      	strh	r3, [r1, #22]
		p->OUTEN |= FLEXPWM_OUTEN_PWMA_EN(mask);
    6676:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    667a:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
    667e:	b29b      	uxth	r3, r3
    6680:	432b      	orrs	r3, r5
    6682:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    6686:	e7e8      	b.n	665a <flexpwmWrite+0x4e>
		p->SM[submodule].VAL0 = modulo - cval;
    6688:	ebae 0e03 	sub.w	lr, lr, r3
    668c:	f00c 020f 	and.w	r2, ip, #15
    6690:	fa1f fe8e 	uxth.w	lr, lr
    6694:	f8a1 e00a 	strh.w	lr, [r1, #10]
		p->OUTEN |= FLEXPWM_OUTEN_PWMX_EN(mask);
    6698:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    669c:	b29b      	uxth	r3, r3
    669e:	4313      	orrs	r3, r2
    66a0:	f8a0 3180 	strh.w	r3, [r0, #384]	; 0x180
		break;
    66a4:	e7d9      	b.n	665a <flexpwmWrite+0x4e>
		p->SM[submodule].VAL5 = cval;
    66a6:	b29b      	uxth	r3, r3
    66a8:	f00c 020f 	and.w	r2, ip, #15
    66ac:	83cb      	strh	r3, [r1, #30]
		p->OUTEN |= FLEXPWM_OUTEN_PWMB_EN(mask);
    66ae:	f8b0 3180 	ldrh.w	r3, [r0, #384]	; 0x180
    66b2:	b29b      	uxth	r3, r3
    66b4:	431e      	orrs	r6, r3
    66b6:	f8a0 6180 	strh.w	r6, [r0, #384]	; 0x180
    66ba:	e7ce      	b.n	665a <flexpwmWrite+0x4e>
    66bc:	200019da 	.word	0x200019da

000066c0 <analogWrite>:

void analogWrite(uint8_t pin, int val)
{
	const struct pwm_pin_info_struct *info;

	if (pin >= CORE_NUM_DIGITAL) return;
    66c0:	2827      	cmp	r0, #39	; 0x27
    66c2:	d84b      	bhi.n	675c <analogWrite+0x9c>
{
    66c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//printf("analogWrite, pin %d, val %d\n", pin, val);
	info = pwm_pin_info + pin;
    66c6:	4d2a      	ldr	r5, [pc, #168]	; (6770 <analogWrite+0xb0>)
    66c8:	4604      	mov	r4, r0
	if (info->type == 1) {
    66ca:	f815 2020 	ldrb.w	r2, [r5, r0, lsl #2]
	info = pwm_pin_info + pin;
    66ce:	eb05 0580 	add.w	r5, r5, r0, lsl #2
	if (info->type == 1) {
    66d2:	2a01      	cmp	r2, #1
    66d4:	d02d      	beq.n	6732 <analogWrite+0x72>
		  case 1: flexpwm = &IMXRT_FLEXPWM2; break;
		  case 2: flexpwm = &IMXRT_FLEXPWM3; break;
		  default: flexpwm = &IMXRT_FLEXPWM4;
		}
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
	} else if (info->type == 2) {
    66d6:	2a02      	cmp	r2, #2
    66d8:	d13f      	bne.n	675a <analogWrite+0x9a>
		// QuadTimer pin
		IMXRT_TMR_t *qtimer;
		switch ((info->module >> 4) & 3) {
    66da:	786b      	ldrb	r3, [r5, #1]
    66dc:	f3c3 1001 	ubfx	r0, r3, #4, #2
    66e0:	2803      	cmp	r0, #3
    66e2:	d03e      	beq.n	6762 <analogWrite+0xa2>
    66e4:	4a23      	ldr	r2, [pc, #140]	; (6774 <analogWrite+0xb4>)
    66e6:	eb02 3280 	add.w	r2, r2, r0, lsl #14
		  case 0: qtimer = &IMXRT_TMR1; break;
		  case 1: qtimer = &IMXRT_TMR2; break;
		  case 2: qtimer = &IMXRT_TMR3; break;
		  default: qtimer = &IMXRT_TMR4;
		}
		quadtimerWrite(qtimer, info->module & 0x03, val);
    66ea:	f003 0c03 	and.w	ip, r3, #3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    66ee:	4822      	ldr	r0, [pc, #136]	; (6778 <analogWrite+0xb8>)
    66f0:	b289      	uxth	r1, r1
    66f2:	4663      	mov	r3, ip
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    66f4:	eb02 1c4c 	add.w	ip, r2, ip, lsl #5
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    66f8:	7806      	ldrb	r6, [r0, #0]
	uint32_t modulo = 65537 - p->CH[submodule].LOAD + p->CH[submodule].CMPLD1;
    66fa:	f8bc e006 	ldrh.w	lr, [ip, #6]
    66fe:	0158      	lsls	r0, r3, #5
    6700:	f8bc 3010 	ldrh.w	r3, [ip, #16]
    6704:	fa1f fe8e 	uxth.w	lr, lr
    6708:	f1ce 1e01 	rsb	lr, lr, #65537	; 0x10001
    670c:	fa1e f383 	uxtah	r3, lr, r3
	uint32_t high = ((uint32_t)val * (modulo - 1)) >> analog_write_res;
    6710:	f103 3eff 	add.w	lr, r3, #4294967295
    6714:	fb0e f101 	mul.w	r1, lr, r1
    6718:	40f1      	lsrs	r1, r6
	if (high >= modulo - 1) high = modulo - 2;
    671a:	458e      	cmp	lr, r1
    671c:	d923      	bls.n	6766 <analogWrite+0xa6>
	uint32_t low = modulo - high; // low must 2 or higher
    671e:	1a5b      	subs	r3, r3, r1
	p->CH[submodule].LOAD = 65537 - low;
    6720:	f1c3 0301 	rsb	r3, r3, #1
    6724:	b29b      	uxth	r3, r3
	p->CH[submodule].CMPLD1 = high;
    6726:	b289      	uxth	r1, r1
    6728:	4402      	add	r2, r0
	p->CH[submodule].LOAD = 65537 - low;
    672a:	f8ac 3006 	strh.w	r3, [ip, #6]
	p->CH[submodule].CMPLD1 = high;
    672e:	8211      	strh	r1, [r2, #16]
}
    6730:	e00d      	b.n	674e <analogWrite+0x8e>
		switch ((info->module >> 4) & 3) {
    6732:	786a      	ldrb	r2, [r5, #1]
    6734:	f3c2 1301 	ubfx	r3, r2, #4, #2
    6738:	2b03      	cmp	r3, #3
    673a:	d010      	beq.n	675e <analogWrite+0x9e>
    673c:	480f      	ldr	r0, [pc, #60]	; (677c <analogWrite+0xbc>)
    673e:	eb00 3083 	add.w	r0, r0, r3, lsl #14
		flexpwmWrite(flexpwm, info->module & 0x03, info->channel, val);
    6742:	b28b      	uxth	r3, r1
    6744:	f002 0103 	and.w	r1, r2, #3
    6748:	78aa      	ldrb	r2, [r5, #2]
    674a:	f7ff ff5f 	bl	660c <flexpwmWrite>
	} else {
		return;
	}
	*(portConfigRegister(pin)) = info->muxval;
    674e:	4b0c      	ldr	r3, [pc, #48]	; (6780 <analogWrite+0xc0>)
    6750:	78ea      	ldrb	r2, [r5, #3]
    6752:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    6756:	685b      	ldr	r3, [r3, #4]
    6758:	601a      	str	r2, [r3, #0]
	// TODO: pad config register
}
    675a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    675c:	4770      	bx	lr
		switch ((info->module >> 4) & 3) {
    675e:	4809      	ldr	r0, [pc, #36]	; (6784 <analogWrite+0xc4>)
    6760:	e7ef      	b.n	6742 <analogWrite+0x82>
		switch ((info->module >> 4) & 3) {
    6762:	4a09      	ldr	r2, [pc, #36]	; (6788 <analogWrite+0xc8>)
    6764:	e7c1      	b.n	66ea <analogWrite+0x2a>
	if (high >= modulo - 1) high = modulo - 2;
    6766:	1e99      	subs	r1, r3, #2
    6768:	f64f 73ff 	movw	r3, #65535	; 0xffff
    676c:	e7db      	b.n	6726 <analogWrite+0x66>
    676e:	bf00      	nop
    6770:	20000e08 	.word	0x20000e08
    6774:	401dc000 	.word	0x401dc000
    6778:	200019da 	.word	0x200019da
    677c:	403dc000 	.word	0x403dc000
    6780:	20000b7c 	.word	0x20000b7c
    6784:	403e8000 	.word	0x403e8000
    6788:	401e8000 	.word	0x401e8000

0000678c <flexpwm_init>:
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    678c:	2300      	movs	r3, #0
	p->FSTS0 = 0x000F; // clear fault status
    678e:	220f      	movs	r2, #15
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    6790:	f248 2cb8 	movw	ip, #33464	; 0x82b8
	for (i=0; i < 4; i++) {
    6794:	4619      	mov	r1, r3
{
    6796:	b510      	push	{r4, lr}
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    6798:	f44f 4470 	mov.w	r4, #61440	; 0xf000
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    679c:	f44f 6e80 	mov.w	lr, #1024	; 0x400
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    67a0:	f8a0 418c 	strh.w	r4, [r0, #396]	; 0x18c
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    67a4:	f44f 4460 	mov.w	r4, #57344	; 0xe000
	p->FSTS0 = 0x000F; // clear fault status
    67a8:	f8a0 218e 	strh.w	r2, [r0, #398]	; 0x18e
		p->SM[i].OCTRL = 0;
    67ac:	460a      	mov	r2, r1
	p->FFILT0 = 0;
    67ae:	f8a0 3190 	strh.w	r3, [r0, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    67b2:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    67b6:	b29b      	uxth	r3, r3
    67b8:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    67bc:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    67c0:	eb01 0341 	add.w	r3, r1, r1, lsl #1
	for (i=0; i < 4; i++) {
    67c4:	3101      	adds	r1, #1
    67c6:	eb00 1343 	add.w	r3, r0, r3, lsl #5
    67ca:	2904      	cmp	r1, #4
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    67cc:	809c      	strh	r4, [r3, #4]
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    67ce:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    67d2:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    67d4:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    67d6:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    67d8:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    67da:	f8a3 c00e 	strh.w	ip, [r3, #14]
		p->SM[i].VAL2 = 0;
    67de:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    67e0:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    67e2:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    67e4:	83da      	strh	r2, [r3, #30]
	for (i=0; i < 4; i++) {
    67e6:	d1eb      	bne.n	67c0 <flexpwm_init+0x34>
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    67e8:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    67ec:	b29b      	uxth	r3, r3
    67ee:	f043 030f 	orr.w	r3, r3, #15
    67f2:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    67f6:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    67fa:	b29b      	uxth	r3, r3
    67fc:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    6800:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
}
    6804:	bd10      	pop	{r4, pc}
    6806:	bf00      	nop

00006808 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6808:	4b37      	ldr	r3, [pc, #220]	; (68e8 <pwm_init+0xe0>)
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    680a:	4a38      	ldr	r2, [pc, #224]	; (68ec <pwm_init+0xe4>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    680c:	6f99      	ldr	r1, [r3, #120]	; 0x78
		CCM_CCGR6_QTIMER3(CCM_CCGR_ON) | CCM_CCGR6_QTIMER4(CCM_CCGR_ON);
	flexpwm_init(&IMXRT_FLEXPWM1);
    680e:	4838      	ldr	r0, [pc, #224]	; (68f0 <pwm_init+0xe8>)
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6810:	f441 017f 	orr.w	r1, r1, #16711680	; 0xff0000
{
    6814:	b570      	push	{r4, r5, r6, lr}
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    6816:	6799      	str	r1, [r3, #120]	; 0x78
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6818:	f241 0601 	movw	r6, #4097	; 0x1001
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    681c:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6820:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6824:	f243 0426 	movw	r4, #12326	; 0x3026
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    6828:	430a      	orrs	r2, r1
    682a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	flexpwm_init(&IMXRT_FLEXPWM1);
    682e:	f7ff ffad 	bl	678c <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM2);
    6832:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    6836:	f7ff ffa9 	bl	678c <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM3);
    683a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    683e:	f7ff ffa5 	bl	678c <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM4);
    6842:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    6846:	f7ff ffa1 	bl	678c <flexpwm_init>
	for (i=0; i < 4; i++) {
    684a:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    684c:	f5a0 1003 	sub.w	r0, r0, #2146304	; 0x20c000
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6850:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CTRL = 0; // stop timer
    6854:	4611      	mov	r1, r2
    6856:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    685a:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    685e:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6860:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    6862:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    6864:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    6866:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    686a:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    686c:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    686e:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    6872:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    6874:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    6876:	d1ee      	bne.n	6856 <pwm_init+0x4e>
    6878:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    687a:	481e      	ldr	r0, [pc, #120]	; (68f4 <pwm_init+0xec>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    687c:	f04f 0e0f 	mov.w	lr, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    6880:	f241 0601 	movw	r6, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    6884:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    6886:	f645 55c0 	movw	r5, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    688a:	f243 0426 	movw	r4, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    688e:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    6892:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    6896:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    6898:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    689a:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    689c:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    689e:	f8a3 e00e 	strh.w	lr, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    68a2:	829e      	strh	r6, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    68a4:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    68a6:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    68aa:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    68ac:	819c      	strh	r4, [r3, #12]
	for (i=0; i < 4; i++) {
    68ae:	d1ee      	bne.n	688e <pwm_init+0x86>
    68b0:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
    68b2:	4811      	ldr	r0, [pc, #68]	; (68f8 <pwm_init+0xf0>)
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    68b4:	260f      	movs	r6, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    68b6:	f241 0501 	movw	r5, #4097	; 0x1001
		p->CH[i].CTRL = 0; // stop timer
    68ba:	4611      	mov	r1, r2
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    68bc:	f645 54c0 	movw	r4, #24000	; 0x5dc0
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    68c0:	f243 0e26 	movw	lr, #12326	; 0x3026
		p->CH[i].CTRL = 0; // stop timer
    68c4:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    68c8:	ea4f 1c42 	mov.w	ip, r2, lsl #5
	for (i=0; i < 4; i++) {
    68cc:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    68ce:	8199      	strh	r1, [r3, #12]
	for (i=0; i < 4; i++) {
    68d0:	2a04      	cmp	r2, #4
		p->CH[i].CNTR = 0;
    68d2:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    68d4:	81de      	strh	r6, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    68d6:	829d      	strh	r5, [r3, #20]
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    68d8:	80dc      	strh	r4, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    68da:	f820 100c 	strh.w	r1, [r0, ip]
		p->CH[i].CMPLD1 = 0;
    68de:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    68e0:	f8a3 e00c 	strh.w	lr, [r3, #12]
	for (i=0; i < 4; i++) {
    68e4:	d1ee      	bne.n	68c4 <pwm_init+0xbc>
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    68e6:	bd70      	pop	{r4, r5, r6, pc}
    68e8:	400fc000 	.word	0x400fc000
    68ec:	fc030000 	.word	0xfc030000
    68f0:	403dc000 	.word	0x403dc000
    68f4:	401e0000 	.word	0x401e0000
    68f8:	401e4000 	.word	0x401e4000

000068fc <unused_interrupt_vector>:
	__disable_irq();
    68fc:	b672      	cpsid	i
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    68fe:	f3ef 8305 	mrs	r3, IPSR
	info->ipsr = ipsr;
    6902:	4c52      	ldr	r4, [pc, #328]	; (6a4c <unused_interrupt_vector+0x150>)
    6904:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	asm volatile("tst lr, #4\nite eq\nmrseq %0, msp\nmrsne %0, psp\n" : "=r" (stack) :: "memory");
    6908:	f01e 0f04 	tst.w	lr, #4
    690c:	bf0c      	ite	eq
    690e:	f3ef 8208 	mrseq	r2, MSP
    6912:	f3ef 8209 	mrsne	r2, PSP
	info->cfsr = SCB_CFSR;
    6916:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	p = (uint32_t *)info;
    691a:	4e4d      	ldr	r6, [pc, #308]	; (6a50 <unused_interrupt_vector+0x154>)
	while (p < end) {
    691c:	4d4d      	ldr	r5, [pc, #308]	; (6a54 <unused_interrupt_vector+0x158>)
	info->cfsr = SCB_CFSR;
    691e:	f8d3 0d28 	ldr.w	r0, [r3, #3368]	; 0xd28
	info->hfsr = SCB_HFSR;
    6922:	f8d3 1d2c 	ldr.w	r1, [r3, #3372]	; 0xd2c
    6926:	e9c4 0122 	strd	r0, r1, [r4, #136]	; 0x88
	info->mmfar = SCB_MMFAR;
    692a:	f8d3 1d34 	ldr.w	r1, [r3, #3380]	; 0xd34
	info->bfar = SCB_BFAR;
    692e:	f8d3 3d38 	ldr.w	r3, [r3, #3384]	; 0xd38
    6932:	e9c4 1324 	strd	r1, r3, [r4, #144]	; 0x90
	info->ret = stack[6];
    6936:	6993      	ldr	r3, [r2, #24]
    6938:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	info->xpsr = stack[7];
    693c:	69d3      	ldr	r3, [r2, #28]
    693e:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	info->temp = tempmonGetTemp();
    6942:	f000 f8d1 	bl	6ae8 <tempmonGetTemp>
    6946:	ed84 0a28 	vstr	s0, [r4, #160]	; 0xa0
	info->time = rtc_get();
    694a:	f001 f9c5 	bl	7cd8 <rtc_get>
	info->len = sizeof(*info) / 4;
    694e:	210b      	movs	r1, #11
	crc = 0xFFFFFFFF;
    6950:	f04f 32ff 	mov.w	r2, #4294967295
	info->time = rtc_get();
    6954:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
	info->len = sizeof(*info) / 4;
    6958:	460b      	mov	r3, r1
    695a:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    695e:	493e      	ldr	r1, [pc, #248]	; (6a58 <unused_interrupt_vector+0x15c>)
		crc ^= *p++;
    6960:	1d30      	adds	r0, r6, #4
    6962:	405a      	eors	r2, r3
    6964:	2420      	movs	r4, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    6966:	f002 0301 	and.w	r3, r2, #1
    696a:	3c01      	subs	r4, #1
    696c:	fb01 f303 	mul.w	r3, r1, r3
    6970:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    6974:	d1f7      	bne.n	6966 <unused_interrupt_vector+0x6a>
	while (p < end) {
    6976:	42a8      	cmp	r0, r5
    6978:	d002      	beq.n	6980 <unused_interrupt_vector+0x84>
		crc ^= *p++;
    697a:	6873      	ldr	r3, [r6, #4]
    697c:	4606      	mov	r6, r0
    697e:	e7ef      	b.n	6960 <unused_interrupt_vector+0x64>
	info->crc = crc;
    6980:	4b32      	ldr	r3, [pc, #200]	; (6a4c <unused_interrupt_vector+0x150>)
    6982:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    6986:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    698a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    698e:	4930      	ldr	r1, [pc, #192]	; (6a50 <unused_interrupt_vector+0x154>)
    6990:	4a32      	ldr	r2, [pc, #200]	; (6a5c <unused_interrupt_vector+0x160>)
    6992:	f8c3 1f70 	str.w	r1, [r3, #3952]	; 0xf70
    6996:	f8c3 2f70 	str.w	r2, [r3, #3952]	; 0xf70
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    699a:	f3bf 8f4f 	dsb	sy
	asm("isb");
    699e:	f3bf 8f6f 	isb	sy
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    69a2:	4a2f      	ldr	r2, [pc, #188]	; (6a60 <unused_interrupt_vector+0x164>)
	PIT_MCR = PIT_MCR_MDIS;
    69a4:	2502      	movs	r5, #2
    69a6:	482f      	ldr	r0, [pc, #188]	; (6a64 <unused_interrupt_vector+0x168>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    69a8:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    69aa:	492f      	ldr	r1, [pc, #188]	; (6a68 <unused_interrupt_vector+0x16c>)
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    69ac:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
    69b0:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    69b2:	6005      	str	r5, [r0, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    69b4:	69d3      	ldr	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    69b6:	482d      	ldr	r0, [pc, #180]	; (6a6c <unused_interrupt_vector+0x170>)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    69b8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    69bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    69c0:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    69c2:	680b      	ldr	r3, [r1, #0]
    69c4:	4283      	cmp	r3, r0
    69c6:	d83d      	bhi.n	6a44 <unused_interrupt_vector+0x148>
	PIT_MCR = 0;
    69c8:	4d26      	ldr	r5, [pc, #152]	; (6a64 <unused_interrupt_vector+0x168>)
    69ca:	2100      	movs	r1, #0
	NVIC_ICER0 = 0xFFFFFFFF;
    69cc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    69d0:	f04f 32ff 	mov.w	r2, #4294967295
	PIT_MCR = 0;
    69d4:	6029      	str	r1, [r5, #0]
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    69d6:	2601      	movs	r6, #1
	PIT_TCTRL0 = 0;
    69d8:	f8c5 1108 	str.w	r1, [r5, #264]	; 0x108
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    69dc:	4924      	ldr	r1, [pc, #144]	; (6a70 <unused_interrupt_vector+0x174>)
    69de:	f8c5 1100 	str.w	r1, [r5, #256]	; 0x100
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    69e2:	f8c5 6108 	str.w	r6, [r5, #264]	; 0x108
	NVIC_ICER0 = 0xFFFFFFFF;
    69e6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	NVIC_ICER1 = 0xFFFFFFFF;
    69ea:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
	NVIC_ICER2 = 0xFFFFFFFF;
    69ee:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
	NVIC_ICER3 = 0xFFFFFFFF;
    69f2:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	NVIC_ICER4 = 0xFFFFFFFF;
    69f6:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
	count = 0;
    69fa:	e001      	b.n	6a00 <unused_interrupt_vector+0x104>
		usb_isr();
    69fc:	f000 f966 	bl	6ccc <usb_isr>
		if (PIT_TFLG0) {
    6a00:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    6a04:	2b00      	cmp	r3, #0
    6a06:	d0f9      	beq.n	69fc <unused_interrupt_vector+0x100>
			if (++count >= 80) break;  // reboot after 8 seconds
    6a08:	3401      	adds	r4, #1
			PIT_TFLG0 = 1;
    6a0a:	f8c5 610c 	str.w	r6, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    6a0e:	2c4f      	cmp	r4, #79	; 0x4f
    6a10:	d9f4      	bls.n	69fc <unused_interrupt_vector+0x100>
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6a12:	4b18      	ldr	r3, [pc, #96]	; (6a74 <unused_interrupt_vector+0x178>)
	USB1_USBCMD = USB_USBCMD_RST;
    6a14:	2002      	movs	r0, #2
    6a16:	4918      	ldr	r1, [pc, #96]	; (6a78 <unused_interrupt_vector+0x17c>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6a18:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	USB1_USBCMD = USB_USBCMD_RST;
    6a1c:	f8c1 0140 	str.w	r0, [r1, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    6a20:	635a      	str	r2, [r3, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6a22:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    6a26:	b93b      	cbnz	r3, 6a38 <unused_interrupt_vector+0x13c>
	SRC_GPR5 = 0x0BAD00F1;
    6a28:	4814      	ldr	r0, [pc, #80]	; (6a7c <unused_interrupt_vector+0x180>)
    6a2a:	4915      	ldr	r1, [pc, #84]	; (6a80 <unused_interrupt_vector+0x184>)
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6a2c:	4a0d      	ldr	r2, [pc, #52]	; (6a64 <unused_interrupt_vector+0x168>)
	SRC_GPR5 = 0x0BAD00F1;
    6a2e:	6301      	str	r1, [r0, #48]	; 0x30
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    6a30:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    6a34:	2b00      	cmp	r3, #0
    6a36:	d0fa      	beq.n	6a2e <unused_interrupt_vector+0x132>
	SCB_AIRCR = 0x05FA0004;
    6a38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6a3c:	4a11      	ldr	r2, [pc, #68]	; (6a84 <unused_interrupt_vector+0x188>)
    6a3e:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c
	while (1) ;
    6a42:	e7fe      	b.n	6a42 <unused_interrupt_vector+0x146>
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    6a44:	f7ff f856 	bl	5af4 <set_arm_clock>
    6a48:	e7be      	b.n	69c8 <unused_interrupt_vector+0xcc>
    6a4a:	bf00      	nop
    6a4c:	2027ff00 	.word	0x2027ff00
    6a50:	2027ff80 	.word	0x2027ff80
    6a54:	2027ffa8 	.word	0x2027ffa8
    6a58:	edb88320 	.word	0xedb88320
    6a5c:	2027ffa0 	.word	0x2027ffa0
    6a60:	400fc000 	.word	0x400fc000
    6a64:	40084000 	.word	0x40084000
    6a68:	2000110c 	.word	0x2000110c
    6a6c:	0bcd3d80 	.word	0x0bcd3d80
    6a70:	00249f00 	.word	0x00249f00
    6a74:	400d9000 	.word	0x400d9000
    6a78:	402e0000 	.word	0x402e0000
    6a7c:	400f8000 	.word	0x400f8000
    6a80:	0bad00f1 	.word	0x0bad00f1
    6a84:	05fa0004 	.word	0x05fa0004

00006a88 <_sbrk>:
char *__brkval = (char *)&_heap_start;

__attribute__((weak))
void * _sbrk(int incr)
{
        char *prev = __brkval;
    6a88:	490a      	ldr	r1, [pc, #40]	; (6ab4 <_sbrk+0x2c>)
    6a8a:	680a      	ldr	r2, [r1, #0]
        if (incr != 0) {
    6a8c:	b138      	cbz	r0, 6a9e <_sbrk+0x16>
{
    6a8e:	b508      	push	{r3, lr}
                if (prev + incr > (char *)&_heap_end) {
    6a90:	1813      	adds	r3, r2, r0
    6a92:	4809      	ldr	r0, [pc, #36]	; (6ab8 <_sbrk+0x30>)
    6a94:	4283      	cmp	r3, r0
    6a96:	d804      	bhi.n	6aa2 <_sbrk+0x1a>
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    6a98:	4610      	mov	r0, r2
                __brkval = prev + incr;
    6a9a:	600b      	str	r3, [r1, #0]
}
    6a9c:	bd08      	pop	{r3, pc}
    6a9e:	4610      	mov	r0, r2
    6aa0:	4770      	bx	lr
                        errno = ENOMEM;
    6aa2:	f002 f8cf 	bl	8c44 <__errno>
    6aa6:	230c      	movs	r3, #12
                        return (void *)-1;
    6aa8:	f04f 32ff 	mov.w	r2, #4294967295
                        errno = ENOMEM;
    6aac:	6003      	str	r3, [r0, #0]
}
    6aae:	4610      	mov	r0, r2
    6ab0:	bd08      	pop	{r3, pc}
    6ab2:	bf00      	nop
    6ab4:	200011e0 	.word	0x200011e0
    6ab8:	20280000 	.word	0x20280000

00006abc <_read>:

__attribute__((weak))
int _read(int file __attribute__((unused)), char *ptr __attribute__((unused)), int len __attribute__((unused)))
{
	return 0;
}
    6abc:	2000      	movs	r0, #0
    6abe:	4770      	bx	lr

00006ac0 <_close>:

__attribute__((weak))
int _close(int fd __attribute__((unused)))
{
	return -1;
}
    6ac0:	f04f 30ff 	mov.w	r0, #4294967295
    6ac4:	4770      	bx	lr
    6ac6:	bf00      	nop

00006ac8 <_fstat>:
#include <sys/stat.h>

__attribute__((weak))
int _fstat(int fd __attribute__((unused)), struct stat *st)
{
	st->st_mode = S_IFCHR;
    6ac8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
    6acc:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
    6ace:	604b      	str	r3, [r1, #4]
}
    6ad0:	4770      	bx	lr
    6ad2:	bf00      	nop

00006ad4 <_isatty>:

__attribute__((weak))
int _isatty(int fd __attribute__((unused)))
{
	return 1;
}
    6ad4:	2001      	movs	r0, #1
    6ad6:	4770      	bx	lr

00006ad8 <_lseek>:

__attribute__((weak))
int _lseek(int fd __attribute__((unused)), long long offset __attribute__((unused)), int whence __attribute__((unused)))
{
	return -1;
}
    6ad8:	f04f 30ff 	mov.w	r0, #4294967295
    6adc:	4770      	bx	lr
    6ade:	bf00      	nop

00006ae0 <abort>:
}

__attribute__((weak))
void abort(void)
{
	while (1) asm ("WFI");
    6ae0:	bf30      	wfi
    6ae2:	e7fd      	b.n	6ae0 <abort>

00006ae4 <Panic_Temp_isr>:
  unused_interrupt_vector();
    6ae4:	f7ff bf0a 	b.w	68fc <unused_interrupt_vector>

00006ae8 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    6ae8:	4a12      	ldr	r2, [pc, #72]	; (6b34 <tempmonGetTemp+0x4c>)
    6aea:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    6aee:	075b      	lsls	r3, r3, #29
    6af0:	d5fb      	bpl.n	6aea <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6af2:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6af6:	4810      	ldr	r0, [pc, #64]	; (6b38 <tempmonGetTemp+0x50>)
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6af8:	f3c3 230b 	ubfx	r3, r3, #8, #12
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6afc:	490f      	ldr	r1, [pc, #60]	; (6b3c <tempmonGetTemp+0x54>)
    6afe:	ed90 7a00 	vldr	s14, [r0]
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    6b02:	ee07 3a90 	vmov	s15, r3
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    6b06:	ed91 6a00 	vldr	s12, [r1]
    6b0a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    6b0e:	4a0c      	ldr	r2, [pc, #48]	; (6b40 <tempmonGetTemp+0x58>)
    6b10:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    6b14:	4b0b      	ldr	r3, [pc, #44]	; (6b44 <tempmonGetTemp+0x5c>)
    6b16:	edd2 6a00 	vldr	s13, [r2]
    6b1a:	ee77 7ac7 	vsub.f32	s15, s15, s14
    6b1e:	ed93 7a00 	vldr	s14, [r3]
    6b22:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    6b26:	ee67 7a86 	vmul.f32	s15, s15, s12
    6b2a:	ee87 0aa6 	vdiv.f32	s0, s15, s13

    return tmeas;
}
    6b2e:	ee37 0a40 	vsub.f32	s0, s14, s0
    6b32:	4770      	bx	lr
    6b34:	400d8100 	.word	0x400d8100
    6b38:	2000a54c 	.word	0x2000a54c
    6b3c:	2000a554 	.word	0x2000a554
    6b40:	2000a558 	.word	0x2000a558
    6b44:	2000a550 	.word	0x2000a550

00006b48 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    6b48:	6b83      	ldr	r3, [r0, #56]	; 0x38
{
    6b4a:	b4f0      	push	{r4, r5, r6, r7}
	if (endpoint->callback_function) {
    6b4c:	b11b      	cbz	r3, 6b56 <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    6b4e:	6853      	ldr	r3, [r2, #4]
    6b50:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    6b54:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    6b56:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    6b58:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    6b5a:	b33c      	cbz	r4, 6bac <schedule_transfer+0x64>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    6b5c:	4b1a      	ldr	r3, [pc, #104]	; (6bc8 <schedule_transfer+0x80>)
		last->next = (uint32_t)transfer;
    6b5e:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    6b60:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    6b64:	420c      	tst	r4, r1
    6b66:	d11d      	bne.n	6ba4 <schedule_transfer+0x5c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    6b68:	4e18      	ldr	r6, [pc, #96]	; (6bcc <schedule_transfer+0x84>)
    6b6a:	6877      	ldr	r7, [r6, #4]
    6b6c:	e004      	b.n	6b78 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    6b6e:	6874      	ldr	r4, [r6, #4]
    6b70:	1be4      	subs	r4, r4, r7
    6b72:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    6b76:	d20b      	bcs.n	6b90 <schedule_transfer+0x48>
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    6b78:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    6b7c:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    6b80:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    6b84:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    6b88:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    6b8c:	0464      	lsls	r4, r4, #17
    6b8e:	d5ee      	bpl.n	6b6e <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    6b90:	400d      	ands	r5, r1
    6b92:	d107      	bne.n	6ba4 <schedule_transfer+0x5c>
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    6b94:	4c0c      	ldr	r4, [pc, #48]	; (6bc8 <schedule_transfer+0x80>)
		endpoint->status = 0;
    6b96:	e9c0 2502 	strd	r2, r5, [r0, #8]
		USB1_ENDPTPRIME |= epmask;
    6b9a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6b9e:	430b      	orrs	r3, r1
    6ba0:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    6ba4:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    6ba6:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    6ba8:	bcf0      	pop	{r4, r5, r6, r7}
    6baa:	4770      	bx	lr
	USB1_ENDPTPRIME |= epmask;
    6bac:	4d06      	ldr	r5, [pc, #24]	; (6bc8 <schedule_transfer+0x80>)
	endpoint->status = 0;
    6bae:	e9c0 2402 	strd	r2, r4, [r0, #8]
	USB1_ENDPTPRIME |= epmask;
    6bb2:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    6bb6:	430b      	orrs	r3, r1
    6bb8:	f8c5 31b0 	str.w	r3, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    6bbc:	6302      	str	r2, [r0, #48]	; 0x30
	endpoint->last_transfer = transfer;
    6bbe:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    6bc0:	b662      	cpsie	i
}
    6bc2:	bcf0      	pop	{r4, r5, r6, r7}
    6bc4:	4770      	bx	lr
    6bc6:	bf00      	nop
    6bc8:	402e0000 	.word	0x402e0000
    6bcc:	e0001000 	.word	0xe0001000

00006bd0 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    6bd0:	b570      	push	{r4, r5, r6, lr}
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    6bd2:	6b05      	ldr	r5, [r0, #48]	; 0x30
	if (first == NULL) return;
    6bd4:	b19d      	cbz	r5, 6bfe <run_callbacks+0x2e>
    6bd6:	4606      	mov	r6, r0
    6bd8:	462a      	mov	r2, r5

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
    6bda:	2400      	movs	r4, #0
    6bdc:	e003      	b.n	6be6 <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    6bde:	6812      	ldr	r2, [r2, #0]
		count++;
    6be0:	3401      	adds	r4, #1
		if ((uint32_t)t == 1) {
    6be2:	2a01      	cmp	r2, #1
    6be4:	d00c      	beq.n	6c00 <run_callbacks+0x30>
		if (t->status & (1<<7)) {
    6be6:	6853      	ldr	r3, [r2, #4]
    6be8:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    6bec:	d0f7      	beq.n	6bde <run_callbacks+0xe>
			ep->first_transfer = t;
    6bee:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    6bf0:	b12c      	cbz	r4, 6bfe <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
    6bf2:	4628      	mov	r0, r5
		ep->callback_function(first);
    6bf4:	6bb3      	ldr	r3, [r6, #56]	; 0x38
		transfer_t *next = (transfer_t *)first->next;
    6bf6:	682d      	ldr	r5, [r5, #0]
		ep->callback_function(first);
    6bf8:	4798      	blx	r3
	while (count) {
    6bfa:	3c01      	subs	r4, #1
    6bfc:	d1f9      	bne.n	6bf2 <run_callbacks+0x22>
		first = next;
		count--;
	}
}
    6bfe:	bd70      	pop	{r4, r5, r6, pc}
			ep->last_transfer = NULL;
    6c00:	e9c6 330c 	strd	r3, r3, [r6, #48]	; 0x30
			break;
    6c04:	e7f4      	b.n	6bf0 <run_callbacks+0x20>
    6c06:	bf00      	nop

00006c08 <endpoint0_transmit.constprop.0>:
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    6c08:	b430      	push	{r4, r5}
	if (len > 0) {
    6c0a:	b9d9      	cbnz	r1, 6c44 <endpoint0_transmit.constprop.0+0x3c>
    6c0c:	4c1f      	ldr	r4, [pc, #124]	; (6c8c <endpoint0_transmit.constprop.0+0x84>)
	endpoint0_transfer_ack.next = 1;
    6c0e:	4b20      	ldr	r3, [pc, #128]	; (6c90 <endpoint0_transmit.constprop.0+0x88>)
	endpoint0_transfer_ack.pointer0 = 0;
    6c10:	2100      	movs	r1, #0
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6c12:	4a20      	ldr	r2, [pc, #128]	; (6c94 <endpoint0_transmit.constprop.0+0x8c>)
	endpoint0_transfer_ack.next = 1;
    6c14:	2501      	movs	r5, #1
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6c16:	f04f 1001 	mov.w	r0, #65537	; 0x10001
	endpoint0_transfer_ack.pointer0 = 0;
    6c1a:	6099      	str	r1, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    6c1c:	601d      	str	r5, [r3, #0]
	endpoint_queue_head[0].status = 0;
    6c1e:	e9c4 3102 	strd	r3, r1, [r4, #8]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6c22:	2480      	movs	r4, #128	; 0x80
    6c24:	605c      	str	r4, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6c26:	f8c2 01bc 	str.w	r0, [r2, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    6c2a:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    6c2e:	481a      	ldr	r0, [pc, #104]	; (6c98 <endpoint0_transmit.constprop.0+0x90>)
	USB1_ENDPTPRIME |= (1<<0);
    6c30:	432b      	orrs	r3, r5
    6c32:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    6c36:	6001      	str	r1, [r0, #0]
	while (USB1_ENDPTPRIME) ;
    6c38:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6c3c:	2b00      	cmp	r3, #0
    6c3e:	d1fb      	bne.n	6c38 <endpoint0_transmit.constprop.0+0x30>
}
    6c40:	bc30      	pop	{r4, r5}
    6c42:	4770      	bx	lr
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6c44:	0409      	lsls	r1, r1, #16
		endpoint0_transfer_data.next = 1;
    6c46:	4b15      	ldr	r3, [pc, #84]	; (6c9c <endpoint0_transmit.constprop.0+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    6c48:	4c10      	ldr	r4, [pc, #64]	; (6c8c <endpoint0_transmit.constprop.0+0x84>)
		endpoint0_transfer_data.next = 1;
    6c4a:	2501      	movs	r5, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6c4c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    6c50:	6098      	str	r0, [r3, #8]
		USB1_ENDPTPRIME |= (1<<16);
    6c52:	4a10      	ldr	r2, [pc, #64]	; (6c94 <endpoint0_transmit.constprop.0+0x8c>)
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6c54:	6059      	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6c56:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
		endpoint0_transfer_data.next = 1;
    6c5a:	601d      	str	r5, [r3, #0]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6c5c:	60d9      	str	r1, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6c5e:	f500 5100 	add.w	r1, r0, #8192	; 0x2000
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    6c62:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6c64:	6119      	str	r1, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6c66:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6c6a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6c6e:	6159      	str	r1, [r3, #20]
		endpoint_queue_head[1].status = 0;
    6c70:	2100      	movs	r1, #0
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6c72:	6198      	str	r0, [r3, #24]
		endpoint_queue_head[1].status = 0;
    6c74:	64e1      	str	r1, [r4, #76]	; 0x4c
		USB1_ENDPTPRIME |= (1<<16);
    6c76:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6c7a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6c7e:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    6c82:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    6c86:	2b00      	cmp	r3, #0
    6c88:	d1fb      	bne.n	6c82 <endpoint0_transmit.constprop.0+0x7a>
    6c8a:	e7c0      	b.n	6c0e <endpoint0_transmit.constprop.0+0x6>
    6c8c:	20000000 	.word	0x20000000
    6c90:	20001ec0 	.word	0x20001ec0
    6c94:	402e0000 	.word	0x402e0000
    6c98:	2000a4e0 	.word	0x2000a4e0
    6c9c:	20001ee0 	.word	0x20001ee0

00006ca0 <usb_stop_sof_interrupts>:
	sof_usage &= ~(1 << interface);
    6ca0:	4908      	ldr	r1, [pc, #32]	; (6cc4 <usb_stop_sof_interrupts+0x24>)
    6ca2:	2201      	movs	r2, #1
    6ca4:	780b      	ldrb	r3, [r1, #0]
    6ca6:	fa02 f000 	lsl.w	r0, r2, r0
    6caa:	ea23 0000 	bic.w	r0, r3, r0
    6cae:	7008      	strb	r0, [r1, #0]
	if (sof_usage == 0) {
    6cb0:	b930      	cbnz	r0, 6cc0 <usb_stop_sof_interrupts+0x20>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    6cb2:	4a05      	ldr	r2, [pc, #20]	; (6cc8 <usb_stop_sof_interrupts+0x28>)
    6cb4:	f8d2 3148 	ldr.w	r3, [r2, #328]	; 0x148
    6cb8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    6cbc:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
}
    6cc0:	4770      	bx	lr
    6cc2:	bf00      	nop
    6cc4:	2000a718 	.word	0x2000a718
    6cc8:	402e0000 	.word	0x402e0000

00006ccc <usb_isr>:
{
    6ccc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t status = USB1_USBSTS;
    6cd0:	4c97      	ldr	r4, [pc, #604]	; (6f30 <usb_isr+0x264>)
{
    6cd2:	b083      	sub	sp, #12
	uint32_t status = USB1_USBSTS;
    6cd4:	f8d4 7144 	ldr.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    6cd8:	07fb      	lsls	r3, r7, #31
	USB1_USBSTS = status;
    6cda:	f8c4 7144 	str.w	r7, [r4, #324]	; 0x144
	if (status & USB_USBSTS_UI) {
    6cde:	d553      	bpl.n	6d88 <usb_isr+0xbc>
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    6ce0:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6ce4:	2a00      	cmp	r2, #0
    6ce6:	d04a      	beq.n	6d7e <usb_isr+0xb2>
    6ce8:	4e92      	ldr	r6, [pc, #584]	; (6f34 <usb_isr+0x268>)
    6cea:	f8df a260 	ldr.w	sl, [pc, #608]	; 6f4c <usb_isr+0x280>
		uint32_t addr = (uint32_t)data;
    6cee:	f8df 9274 	ldr.w	r9, [pc, #628]	; 6f64 <usb_isr+0x298>
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    6cf2:	f8df b274 	ldr.w	fp, [pc, #628]	; 6f68 <usb_isr+0x29c>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    6cf6:	f8df 8274 	ldr.w	r8, [pc, #628]	; 6f6c <usb_isr+0x2a0>
			USB1_ENDPTSETUPSTAT = setupstatus;
    6cfa:	f8c4 21ac 	str.w	r2, [r4, #428]	; 0x1ac
				s.word2 = endpoint_queue_head[0].setup1;
    6cfe:	e9d6 200a 	ldrd	r2, r0, [r6, #40]	; 0x28
				USB1_USBCMD |= USB_USBCMD_SUTW;
    6d02:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6d06:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    6d0a:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    6d0e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6d12:	049d      	lsls	r5, r3, #18
    6d14:	d5f5      	bpl.n	6d02 <usb_isr+0x36>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    6d16:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    6d1a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    6d1e:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    6d22:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6d26:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    6d2a:	f8d4 51b4 	ldr.w	r5, [r4, #436]	; 0x1b4
    6d2e:	f015 1501 	ands.w	r5, r5, #65537	; 0x10001
    6d32:	d1fa      	bne.n	6d2a <usb_isr+0x5e>
			endpoint0_notify_mask = 0;
    6d34:	b293      	uxth	r3, r2
	setup.bothwords = setupdata;
    6d36:	4684      	mov	ip, r0
			endpoint0_notify_mask = 0;
    6d38:	f8ca 5000 	str.w	r5, [sl]
	switch (setup.wRequestAndType) {
    6d3c:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    6d40:	f000 81cf 	beq.w	70e2 <usb_isr+0x416>
    6d44:	f200 80db 	bhi.w	6efe <usb_isr+0x232>
    6d48:	f240 3102 	movw	r1, #770	; 0x302
    6d4c:	428b      	cmp	r3, r1
    6d4e:	f000 81e7 	beq.w	7120 <usb_isr+0x454>
    6d52:	f200 809a 	bhi.w	6e8a <usb_isr+0x1be>
    6d56:	2b82      	cmp	r3, #130	; 0x82
    6d58:	f000 81cb 	beq.w	70f2 <usb_isr+0x426>
    6d5c:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    6d60:	f040 808a 	bne.w	6e78 <usb_isr+0x1ac>
		if (endpoint > 7) break;
    6d64:	f010 0f78 	tst.w	r0, #120	; 0x78
    6d68:	b283      	uxth	r3, r0
    6d6a:	f000 8203 	beq.w	7174 <usb_isr+0x4a8>
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    6d6e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6d72:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    6d76:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
		while (setupstatus) {
    6d7a:	2a00      	cmp	r2, #0
    6d7c:	d1bd      	bne.n	6cfa <usb_isr+0x2e>
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    6d7e:	4a6c      	ldr	r2, [pc, #432]	; (6f30 <usb_isr+0x264>)
    6d80:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    6d84:	2b00      	cmp	r3, #0
    6d86:	d142      	bne.n	6e0e <usb_isr+0x142>
	if (status & USB_USBSTS_URI) { // page 3164
    6d88:	067e      	lsls	r6, r7, #25
    6d8a:	d516      	bpl.n	6dba <usb_isr+0xee>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    6d8c:	4b68      	ldr	r3, [pc, #416]	; (6f30 <usb_isr+0x264>)
    6d8e:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
    6d92:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    6d96:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    6d9a:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    6d9e:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    6da2:	2c00      	cmp	r4, #0
    6da4:	d1fb      	bne.n	6d9e <usb_isr+0xd2>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    6da6:	f04f 32ff 	mov.w	r2, #4294967295
    6daa:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    6dae:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
		usb_serial_reset();
    6db2:	f000 fd29 	bl	7808 <usb_serial_reset>
		endpointN_notify_mask = 0;
    6db6:	4b60      	ldr	r3, [pc, #384]	; (6f38 <usb_isr+0x26c>)
    6db8:	601c      	str	r4, [r3, #0]
	if (status & USB_USBSTS_TI0) {
    6dba:	01fc      	lsls	r4, r7, #7
    6dbc:	d503      	bpl.n	6dc6 <usb_isr+0xfa>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    6dbe:	4b5f      	ldr	r3, [pc, #380]	; (6f3c <usb_isr+0x270>)
    6dc0:	681b      	ldr	r3, [r3, #0]
    6dc2:	b103      	cbz	r3, 6dc6 <usb_isr+0xfa>
    6dc4:	4798      	blx	r3
	if (status & USB_USBSTS_TI1) {
    6dc6:	01b8      	lsls	r0, r7, #6
    6dc8:	d503      	bpl.n	6dd2 <usb_isr+0x106>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    6dca:	4b5d      	ldr	r3, [pc, #372]	; (6f40 <usb_isr+0x274>)
    6dcc:	681b      	ldr	r3, [r3, #0]
    6dce:	b103      	cbz	r3, 6dd2 <usb_isr+0x106>
    6dd0:	4798      	blx	r3
	if (status & USB_USBSTS_PCI) {
    6dd2:	0779      	lsls	r1, r7, #29
    6dd4:	d508      	bpl.n	6de8 <usb_isr+0x11c>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    6dd6:	4b56      	ldr	r3, [pc, #344]	; (6f30 <usb_isr+0x264>)
    6dd8:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    6ddc:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    6de0:	d047      	beq.n	6e72 <usb_isr+0x1a6>
			usb_high_speed = 1;
    6de2:	4b58      	ldr	r3, [pc, #352]	; (6f44 <usb_isr+0x278>)
    6de4:	2201      	movs	r2, #1
    6de6:	701a      	strb	r2, [r3, #0]
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    6de8:	4b51      	ldr	r3, [pc, #324]	; (6f30 <usb_isr+0x264>)
    6dea:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
    6dee:	061a      	lsls	r2, r3, #24
    6df0:	d50a      	bpl.n	6e08 <usb_isr+0x13c>
    6df2:	063b      	lsls	r3, r7, #24
    6df4:	d508      	bpl.n	6e08 <usb_isr+0x13c>
		if (usb_reboot_timer) {
    6df6:	4a54      	ldr	r2, [pc, #336]	; (6f48 <usb_isr+0x27c>)
    6df8:	7813      	ldrb	r3, [r2, #0]
    6dfa:	b12b      	cbz	r3, 6e08 <usb_isr+0x13c>
			if (--usb_reboot_timer == 0) {
    6dfc:	3b01      	subs	r3, #1
    6dfe:	b2db      	uxtb	r3, r3
    6e00:	7013      	strb	r3, [r2, #0]
    6e02:	2b00      	cmp	r3, #0
    6e04:	f000 8272 	beq.w	72ec <usb_isr+0x620>
}
    6e08:	b003      	add	sp, #12
    6e0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (completestatus & endpoint0_notify_mask) {
    6e0e:	494f      	ldr	r1, [pc, #316]	; (6f4c <usb_isr+0x280>)
			USB1_ENDPTCOMPLETE = completestatus;
    6e10:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			if (completestatus & endpoint0_notify_mask) {
    6e14:	6808      	ldr	r0, [r1, #0]
    6e16:	4203      	tst	r3, r0
    6e18:	f040 81d1 	bne.w	71be <usb_isr+0x4f2>
			completestatus &= endpointN_notify_mask;
    6e1c:	4a46      	ldr	r2, [pc, #280]	; (6f38 <usb_isr+0x26c>)
    6e1e:	6814      	ldr	r4, [r2, #0]
			if (completestatus) {
    6e20:	401c      	ands	r4, r3
    6e22:	d0b1      	beq.n	6d88 <usb_isr+0xbc>
				while (tx) {
    6e24:	ea5f 4814 	movs.w	r8, r4, lsr #16
    6e28:	d010      	beq.n	6e4c <usb_isr+0x180>
    6e2a:	4e42      	ldr	r6, [pc, #264]	; (6f34 <usb_isr+0x268>)
					tx &= ~(1<<p);
    6e2c:	f04f 0901 	mov.w	r9, #1
					int p=__builtin_ctz(tx);
    6e30:	fa98 f5a8 	rbit	r5, r8
    6e34:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    6e38:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					tx &= ~(1<<p);
    6e3c:	fa09 f505 	lsl.w	r5, r9, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    6e40:	3040      	adds	r0, #64	; 0x40
    6e42:	f7ff fec5 	bl	6bd0 <run_callbacks>
				while (tx) {
    6e46:	ea38 0805 	bics.w	r8, r8, r5
    6e4a:	d1f1      	bne.n	6e30 <usb_isr+0x164>
				uint32_t rx = completestatus & 0xffff;
    6e4c:	b2a4      	uxth	r4, r4
				while(rx) {
    6e4e:	2c00      	cmp	r4, #0
    6e50:	d09a      	beq.n	6d88 <usb_isr+0xbc>
    6e52:	4e38      	ldr	r6, [pc, #224]	; (6f34 <usb_isr+0x268>)
					rx &= ~(1<<p);
    6e54:	f04f 0801 	mov.w	r8, #1
					int p=__builtin_ctz(rx);
    6e58:	fa94 f5a4 	rbit	r5, r4
    6e5c:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2);
    6e60:	eb06 10c5 	add.w	r0, r6, r5, lsl #7
					rx &= ~(1<<p);
    6e64:	fa08 f505 	lsl.w	r5, r8, r5
					run_callbacks(endpoint_queue_head + p * 2);
    6e68:	f7ff feb2 	bl	6bd0 <run_callbacks>
				while(rx) {
    6e6c:	43ac      	bics	r4, r5
    6e6e:	d1f3      	bne.n	6e58 <usb_isr+0x18c>
    6e70:	e78a      	b.n	6d88 <usb_isr+0xbc>
			usb_high_speed = 0;
    6e72:	4a34      	ldr	r2, [pc, #208]	; (6f44 <usb_isr+0x278>)
    6e74:	7013      	strb	r3, [r2, #0]
    6e76:	e7b7      	b.n	6de8 <usb_isr+0x11c>
	switch (setup.wRequestAndType) {
    6e78:	2b80      	cmp	r3, #128	; 0x80
    6e7a:	f47f af78 	bne.w	6d6e <usb_isr+0xa2>
		reply_buffer[0] = 0;
    6e7e:	4834      	ldr	r0, [pc, #208]	; (6f50 <usb_isr+0x284>)
		endpoint0_transmit(reply_buffer, 2, 0);
    6e80:	2102      	movs	r1, #2
		reply_buffer[0] = 0;
    6e82:	8005      	strh	r5, [r0, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    6e84:	f7ff fec0 	bl	6c08 <endpoint0_transmit.constprop.0>
		return;
    6e88:	e775      	b.n	6d76 <usb_isr+0xaa>
	switch (setup.wRequestAndType) {
    6e8a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    6e8e:	f000 810b 	beq.w	70a8 <usb_isr+0x3dc>
    6e92:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    6e96:	2b01      	cmp	r3, #1
    6e98:	f63f af69 	bhi.w	6d6e <usb_isr+0xa2>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6e9c:	4b2d      	ldr	r3, [pc, #180]	; (6f54 <usb_isr+0x288>)
    6e9e:	685d      	ldr	r5, [r3, #4]
    6ea0:	2d00      	cmp	r5, #0
    6ea2:	f43f af64 	beq.w	6d6e <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6ea6:	fa1f fc8c 	uxth.w	ip, ip
    6eaa:	ea4f 4e12 	mov.w	lr, r2, lsr #16
    6eae:	e004      	b.n	6eba <usb_isr+0x1ee>
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    6eb0:	691d      	ldr	r5, [r3, #16]
    6eb2:	330c      	adds	r3, #12
    6eb4:	2d00      	cmp	r5, #0
    6eb6:	f43f af5a 	beq.w	6d6e <usb_isr+0xa2>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    6eba:	881a      	ldrh	r2, [r3, #0]
    6ebc:	4572      	cmp	r2, lr
    6ebe:	d1f7      	bne.n	6eb0 <usb_isr+0x1e4>
    6ec0:	885a      	ldrh	r2, [r3, #2]
    6ec2:	4562      	cmp	r2, ip
    6ec4:	d1f4      	bne.n	6eb0 <usb_isr+0x1e4>
				if ((setup.wValue >> 8) == 3) {
    6ec6:	ea4f 221e 	mov.w	r2, lr, lsr #8
    6eca:	2a03      	cmp	r2, #3
    6ecc:	f000 81a5 	beq.w	721a <usb_isr+0x54e>
					datalen = list->length;
    6ed0:	891a      	ldrh	r2, [r3, #8]
				if (datalen > setup.wLength) datalen = setup.wLength;
    6ed2:	0c00      	lsrs	r0, r0, #16
    6ed4:	4282      	cmp	r2, r0
    6ed6:	bf28      	it	cs
    6ed8:	4602      	movcs	r2, r0
				if (setup.wValue == 0x200) {
    6eda:	f5be 7f00 	cmp.w	lr, #512	; 0x200
    6ede:	f040 81a1 	bne.w	7224 <usb_isr+0x558>
					if (usb_high_speed) src = usb_config_descriptor_480;
    6ee2:	4b18      	ldr	r3, [pc, #96]	; (6f44 <usb_isr+0x278>)
    6ee4:	491c      	ldr	r1, [pc, #112]	; (6f58 <usb_isr+0x28c>)
    6ee6:	7818      	ldrb	r0, [r3, #0]
    6ee8:	4b1c      	ldr	r3, [pc, #112]	; (6f5c <usb_isr+0x290>)
					memcpy(usb_descriptor_buffer, src, datalen);
    6eea:	9201      	str	r2, [sp, #4]
    6eec:	2800      	cmp	r0, #0
    6eee:	bf18      	it	ne
    6ef0:	4619      	movne	r1, r3
    6ef2:	481b      	ldr	r0, [pc, #108]	; (6f60 <usb_isr+0x294>)
    6ef4:	f7ff fabe 	bl	6474 <memcpy>
    6ef8:	4d19      	ldr	r5, [pc, #100]	; (6f60 <usb_isr+0x294>)
    6efa:	9a01      	ldr	r2, [sp, #4]
    6efc:	e1e1      	b.n	72c2 <usb_isr+0x5f6>
	switch (setup.wRequestAndType) {
    6efe:	f242 2121 	movw	r1, #8737	; 0x2221
    6f02:	428b      	cmp	r3, r1
    6f04:	d07c      	beq.n	7000 <usb_isr+0x334>
    6f06:	d933      	bls.n	6f70 <usb_isr+0x2a4>
    6f08:	f242 3121 	movw	r1, #8993	; 0x2321
    6f0c:	428b      	cmp	r3, r1
    6f0e:	f000 8081 	beq.w	7014 <usb_isr+0x348>
    6f12:	f64f 01c0 	movw	r1, #63680	; 0xf8c0
    6f16:	428b      	cmp	r3, r1
    6f18:	f47f af29 	bne.w	6d6e <usb_isr+0xa2>
		if ((setup.wIndex & 0xFF00) != 0) break; // 1=Genre, 4=Compat ID, 5=Properties
    6f1c:	f410 4f7f 	tst.w	r0, #65280	; 0xff00
    6f20:	b283      	uxth	r3, r0
    6f22:	f47f af24 	bne.w	6d6e <usb_isr+0xa2>
		setup.wIndex |= 0xEE00; // alter wIndex and treat as normal USB descriptor
    6f26:	f443 436e 	orr.w	r3, r3, #60928	; 0xee00
    6f2a:	f363 0c0f 	bfi	ip, r3, #0, #16
    6f2e:	e7b5      	b.n	6e9c <usb_isr+0x1d0>
    6f30:	402e0000 	.word	0x402e0000
    6f34:	20000000 	.word	0x20000000
    6f38:	2000a4e4 	.word	0x2000a4e4
    6f3c:	2000a6fc 	.word	0x2000a6fc
    6f40:	2000a700 	.word	0x2000a700
    6f44:	2000a71e 	.word	0x2000a71e
    6f48:	2000a71f 	.word	0x2000a71f
    6f4c:	2000a4e0 	.word	0x2000a4e0
    6f50:	2000a514 	.word	0x2000a514
    6f54:	20000f44 	.word	0x20000f44
    6f58:	60001b40 	.word	0x60001b40
    6f5c:	60001ba4 	.word	0x60001ba4
    6f60:	20200000 	.word	0x20200000
    6f64:	2000a4d8 	.word	0x2000a4d8
    6f68:	b8c6cf5d 	.word	0xb8c6cf5d
    6f6c:	402e01c0 	.word	0x402e01c0
	switch (setup.wRequestAndType) {
    6f70:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    6f74:	d066      	beq.n	7044 <usb_isr+0x378>
    6f76:	f242 0121 	movw	r1, #8225	; 0x2021
    6f7a:	428b      	cmp	r3, r1
    6f7c:	f47f aef7 	bne.w	6d6e <usb_isr+0xa2>
		if (setup.wLength != 7) break;
    6f80:	0c03      	lsrs	r3, r0, #16
    6f82:	2b07      	cmp	r3, #7
    6f84:	f47f aef3 	bne.w	6d6e <usb_isr+0xa2>
		endpoint0_transfer_data.next = 1;
    6f88:	4bb2      	ldr	r3, [pc, #712]	; (7254 <usb_isr+0x588>)
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6f8a:	49b3      	ldr	r1, [pc, #716]	; (7258 <usb_isr+0x58c>)
		endpoint_queue_head[0].status = 0;
    6f8c:	60f5      	str	r5, [r6, #12]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    6f8e:	60d9      	str	r1, [r3, #12]
		endpoint0_setupdata.bothwords = setupdata;
    6f90:	49b2      	ldr	r1, [pc, #712]	; (725c <usb_isr+0x590>)
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    6f92:	60b3      	str	r3, [r6, #8]
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    6f94:	f8c3 9008 	str.w	r9, [r3, #8]
		endpoint0_setupdata.bothwords = setupdata;
    6f98:	e9c1 2000 	strd	r2, r0, [r1]
		endpoint0_transfer_data.next = 1;
    6f9c:	2201      	movs	r2, #1
    6f9e:	601a      	str	r2, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    6fa0:	4aaf      	ldr	r2, [pc, #700]	; (7260 <usb_isr+0x594>)
    6fa2:	605a      	str	r2, [r3, #4]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    6fa4:	4aaf      	ldr	r2, [pc, #700]	; (7264 <usb_isr+0x598>)
    6fa6:	611a      	str	r2, [r3, #16]
		USB1_ENDPTPRIME |= (1<<0);
    6fa8:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
    6fac:	f041 0101 	orr.w	r1, r1, #1
    6fb0:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6fb4:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6fb8:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    6fbc:	6159      	str	r1, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    6fbe:	619a      	str	r2, [r3, #24]
		while (USB1_ENDPTPRIME) ;
    6fc0:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6fc4:	2b00      	cmp	r3, #0
    6fc6:	d1fb      	bne.n	6fc0 <usb_isr+0x2f4>
	endpoint0_transfer_ack.next = 1;
    6fc8:	4aa7      	ldr	r2, [pc, #668]	; (7268 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    6fca:	64f3      	str	r3, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    6fcc:	6093      	str	r3, [r2, #8]
	endpoint0_transfer_ack.next = 1;
    6fce:	2301      	movs	r3, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    6fd0:	64b2      	str	r2, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    6fd2:	6013      	str	r3, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    6fd4:	f248 0380 	movw	r3, #32896	; 0x8080
    6fd8:	6053      	str	r3, [r2, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    6fda:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    6fde:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    6fe2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6fe6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    6fea:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    6fee:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    6ff2:	f8ca 3000 	str.w	r3, [sl]
	while (USB1_ENDPTPRIME) ;
    6ff6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    6ffa:	2b00      	cmp	r3, #0
    6ffc:	d1fb      	bne.n	6ff6 <usb_isr+0x32a>
    6ffe:	e6ba      	b.n	6d76 <usb_isr+0xaa>
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
    7000:	b280      	uxth	r0, r0
    7002:	b938      	cbnz	r0, 7014 <usb_isr+0x348>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    7004:	4b99      	ldr	r3, [pc, #612]	; (726c <usb_isr+0x5a0>)
			usb_cdc_line_rtsdtr = setup.wValue;
    7006:	f3c2 4207 	ubfx	r2, r2, #16, #8
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    700a:	6819      	ldr	r1, [r3, #0]
    700c:	4b98      	ldr	r3, [pc, #608]	; (7270 <usb_isr+0x5a4>)
    700e:	6019      	str	r1, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    7010:	4b98      	ldr	r3, [pc, #608]	; (7274 <usb_isr+0x5a8>)
    7012:	701a      	strb	r2, [r3, #0]
	endpoint0_transfer_ack.next = 1;
    7014:	4b94      	ldr	r3, [pc, #592]	; (7268 <usb_isr+0x59c>)
	endpoint0_transfer_ack.pointer0 = 0;
    7016:	2200      	movs	r2, #0
    7018:	609a      	str	r2, [r3, #8]
	endpoint_queue_head[1].status = 0;
    701a:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    701c:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    701e:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    7020:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    7022:	2280      	movs	r2, #128	; 0x80
    7024:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    7026:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    702a:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    702e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    7032:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    7036:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    703a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    703e:	2b00      	cmp	r3, #0
    7040:	d1fb      	bne.n	703a <usb_isr+0x36e>
    7042:	e698      	b.n	6d76 <usb_isr+0xaa>
		usb_configuration = setup.wValue;
    7044:	f3c2 4207 	ubfx	r2, r2, #16, #8
    7048:	4b8b      	ldr	r3, [pc, #556]	; (7278 <usb_isr+0x5ac>)
    704a:	701a      	strb	r2, [r3, #0]
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    704c:	4b8b      	ldr	r3, [pc, #556]	; (727c <usb_isr+0x5b0>)
    704e:	f8c4 31c8 	str.w	r3, [r4, #456]	; 0x1c8
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    7052:	4b8b      	ldr	r3, [pc, #556]	; (7280 <usb_isr+0x5b4>)
    7054:	f8c4 31cc 	str.w	r3, [r4, #460]	; 0x1cc
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    7058:	4b8a      	ldr	r3, [pc, #552]	; (7284 <usb_isr+0x5b8>)
    705a:	f8c4 31d0 	str.w	r3, [r4, #464]	; 0x1d0
		usb_serial_configure();
    705e:	f000 fbd5 	bl	780c <usb_serial_configure>
		memset(endpoint_queue_head + 2, 0, sizeof(endpoint_t) * 2);
    7062:	2280      	movs	r2, #128	; 0x80
    7064:	4629      	mov	r1, r5
    7066:	4888      	ldr	r0, [pc, #544]	; (7288 <usb_isr+0x5bc>)
    7068:	f001 fcfc 	bl	8a64 <memset>
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    706c:	4b87      	ldr	r3, [pc, #540]	; (728c <usb_isr+0x5c0>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    706e:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[2].pointer4 = 0xB8C6CF5D;
    7070:	f8c6 b0a0 	str.w	fp, [r6, #160]	; 0xa0
		endpoint_queue_head[3].pointer4 = 0x74D59319;
    7074:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
	endpoint0_transfer_ack.next = 1;
    7078:	4b7b      	ldr	r3, [pc, #492]	; (7268 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    707a:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    707c:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.next = 1;
    707e:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    7080:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.pointer0 = 0;
    7082:	609d      	str	r5, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    7084:	601a      	str	r2, [r3, #0]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    7086:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    708a:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    708e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    7092:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    7096:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    709a:	f8ca 5000 	str.w	r5, [sl]
	while (USB1_ENDPTPRIME) ;
    709e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    70a2:	2b00      	cmp	r3, #0
    70a4:	d1fb      	bne.n	709e <usb_isr+0x3d2>
    70a6:	e666      	b.n	6d76 <usb_isr+0xaa>
	endpoint0_transfer_ack.next = 1;
    70a8:	4b6f      	ldr	r3, [pc, #444]	; (7268 <usb_isr+0x59c>)
    70aa:	2101      	movs	r1, #1
	endpoint_queue_head[1].status = 0;
    70ac:	64f5      	str	r5, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.next = 1;
    70ae:	6019      	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    70b0:	2180      	movs	r1, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
    70b2:	609d      	str	r5, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    70b4:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    70b6:	6059      	str	r1, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    70b8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    70bc:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    70c0:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    70c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    70c8:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    70cc:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    70d0:	2b00      	cmp	r3, #0
    70d2:	d1fb      	bne.n	70cc <usb_isr+0x400>
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    70d4:	0c13      	lsrs	r3, r2, #16
    70d6:	065b      	lsls	r3, r3, #25
    70d8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    70dc:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
		return;
    70e0:	e649      	b.n	6d76 <usb_isr+0xaa>
		reply_buffer[0] = usb_configuration;
    70e2:	4b65      	ldr	r3, [pc, #404]	; (7278 <usb_isr+0x5ac>)
		endpoint0_transmit(reply_buffer, 1, 0);
    70e4:	2101      	movs	r1, #1
		reply_buffer[0] = usb_configuration;
    70e6:	486a      	ldr	r0, [pc, #424]	; (7290 <usb_isr+0x5c4>)
    70e8:	781b      	ldrb	r3, [r3, #0]
    70ea:	7003      	strb	r3, [r0, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    70ec:	f7ff fd8c 	bl	6c08 <endpoint0_transmit.constprop.0>
		return;
    70f0:	e641      	b.n	6d76 <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    70f2:	b283      	uxth	r3, r0
		if (endpoint > 7) break;
    70f4:	f010 0078 	ands.w	r0, r0, #120	; 0x78
    70f8:	f47f ae39 	bne.w	6d6e <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    70fc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    7100:	f858 1022 	ldr.w	r1, [r8, r2, lsl #2]
		reply_buffer[0] = 0;
    7104:	4a62      	ldr	r2, [pc, #392]	; (7290 <usb_isr+0x5c4>)
    7106:	8010      	strh	r0, [r2, #0]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    7108:	0618      	lsls	r0, r3, #24
    710a:	f100 809e 	bmi.w	724a <usb_isr+0x57e>
    710e:	07cb      	lsls	r3, r1, #31
    7110:	d501      	bpl.n	7116 <usb_isr+0x44a>
			reply_buffer[0] = 1;
    7112:	2301      	movs	r3, #1
    7114:	7013      	strb	r3, [r2, #0]
		endpoint0_transmit(reply_buffer, 2, 0);
    7116:	2102      	movs	r1, #2
    7118:	485d      	ldr	r0, [pc, #372]	; (7290 <usb_isr+0x5c4>)
    711a:	f7ff fd75 	bl	6c08 <endpoint0_transmit.constprop.0>
		return;
    711e:	e62a      	b.n	6d76 <usb_isr+0xaa>
		if (endpoint > 7) break;
    7120:	f010 0f78 	tst.w	r0, #120	; 0x78
    7124:	b283      	uxth	r3, r0
    7126:	f47f ae22 	bne.w	6d6e <usb_isr+0xa2>
		endpoint = setup.wIndex & 0x7F;
    712a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    712e:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    7132:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    7136:	bf14      	ite	ne
    7138:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    713c:	f043 0301 	orreq.w	r3, r3, #1
    7140:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    7144:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    7146:	4b48      	ldr	r3, [pc, #288]	; (7268 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    7148:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    714a:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    714c:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    714e:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    7150:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    7152:	2280      	movs	r2, #128	; 0x80
    7154:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    7156:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    715a:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    715e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    7162:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    7166:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    716a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    716e:	2b00      	cmp	r3, #0
    7170:	d1fb      	bne.n	716a <usb_isr+0x49e>
    7172:	e600      	b.n	6d76 <usb_isr+0xaa>
		endpoint = setup.wIndex & 0x7F;
    7174:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if (dir) {
    7178:	f013 0f80 	tst.w	r3, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    717c:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    7180:	bf14      	ite	ne
    7182:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    7186:	f023 0301 	biceq.w	r3, r3, #1
    718a:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
	endpoint0_transfer_ack.pointer0 = 0;
    718e:	2200      	movs	r2, #0
	endpoint0_transfer_ack.next = 1;
    7190:	4b35      	ldr	r3, [pc, #212]	; (7268 <usb_isr+0x59c>)
	endpoint_queue_head[1].status = 0;
    7192:	64f2      	str	r2, [r6, #76]	; 0x4c
	endpoint0_transfer_ack.pointer0 = 0;
    7194:	609a      	str	r2, [r3, #8]
	endpoint0_transfer_ack.next = 1;
    7196:	2201      	movs	r2, #1
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    7198:	64b3      	str	r3, [r6, #72]	; 0x48
	endpoint0_transfer_ack.next = 1;
    719a:	601a      	str	r2, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    719c:	2280      	movs	r2, #128	; 0x80
    719e:	605a      	str	r2, [r3, #4]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    71a0:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    71a4:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    71a8:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    71ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    71b0:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	while (USB1_ENDPTPRIME) ;
    71b4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    71b8:	2b00      	cmp	r3, #0
    71ba:	d1fb      	bne.n	71b4 <usb_isr+0x4e8>
    71bc:	e5db      	b.n	6d76 <usb_isr+0xaa>
				endpoint0_notify_mask = 0;
    71be:	2000      	movs	r0, #0
    71c0:	6008      	str	r0, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    71c2:	4926      	ldr	r1, [pc, #152]	; (725c <usb_isr+0x590>)
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    71c4:	880c      	ldrh	r4, [r1, #0]
	setup.bothwords = endpoint0_setupdata.bothwords;
    71c6:	6848      	ldr	r0, [r1, #4]
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    71c8:	f242 0121 	movw	r1, #8225	; 0x2021
    71cc:	428c      	cmp	r4, r1
    71ce:	f47f ae25 	bne.w	6e1c <usb_isr+0x150>
    71d2:	b280      	uxth	r0, r0
    71d4:	2800      	cmp	r0, #0
    71d6:	f47f ae21 	bne.w	6e1c <usb_isr+0x150>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    71da:	492e      	ldr	r1, [pc, #184]	; (7294 <usb_isr+0x5c8>)
    71dc:	4c2e      	ldr	r4, [pc, #184]	; (7298 <usb_isr+0x5cc>)
    71de:	c903      	ldmia	r1, {r0, r1}
    71e0:	80a1      	strh	r1, [r4, #4]
		if (usb_cdc_line_coding[0] == 134) {
    71e2:	2886      	cmp	r0, #134	; 0x86
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    71e4:	ea4f 4111 	mov.w	r1, r1, lsr #16
    71e8:	6020      	str	r0, [r4, #0]
    71ea:	71a1      	strb	r1, [r4, #6]
		if (usb_cdc_line_coding[0] == 134) {
    71ec:	f47f ae16 	bne.w	6e1c <usb_isr+0x150>
	__disable_irq();
    71f0:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    71f2:	482a      	ldr	r0, [pc, #168]	; (729c <usb_isr+0x5d0>)
    71f4:	7801      	ldrb	r1, [r0, #0]
    71f6:	f041 0108 	orr.w	r1, r1, #8
    71fa:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    71fc:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    7200:	060d      	lsls	r5, r1, #24
    7202:	d405      	bmi.n	7210 <usb_isr+0x544>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    7204:	2080      	movs	r0, #128	; 0x80
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    7206:	4301      	orrs	r1, r0
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    7208:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    720c:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	__enable_irq();
    7210:	b662      	cpsie	i
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    7212:	4a23      	ldr	r2, [pc, #140]	; (72a0 <usb_isr+0x5d4>)
    7214:	2150      	movs	r1, #80	; 0x50
    7216:	7011      	strb	r1, [r2, #0]
    7218:	e600      	b.n	6e1c <usb_isr+0x150>
				if (datalen > setup.wLength) datalen = setup.wLength;
    721a:	0c00      	lsrs	r0, r0, #16
					datalen = *(list->addr);
    721c:	782a      	ldrb	r2, [r5, #0]
    721e:	4282      	cmp	r2, r0
    7220:	bf28      	it	cs
    7222:	4602      	movcs	r2, r0
				} else if (setup.wValue == 0x700) {
    7224:	f5be 6fe0 	cmp.w	lr, #1792	; 0x700
    7228:	d144      	bne.n	72b4 <usb_isr+0x5e8>
					if (usb_high_speed) src = usb_config_descriptor_12;
    722a:	4b1e      	ldr	r3, [pc, #120]	; (72a4 <usb_isr+0x5d8>)
					memcpy(usb_descriptor_buffer, src, datalen);
    722c:	4d1e      	ldr	r5, [pc, #120]	; (72a8 <usb_isr+0x5dc>)
					if (usb_high_speed) src = usb_config_descriptor_12;
    722e:	7818      	ldrb	r0, [r3, #0]
    7230:	491e      	ldr	r1, [pc, #120]	; (72ac <usb_isr+0x5e0>)
    7232:	4b1f      	ldr	r3, [pc, #124]	; (72b0 <usb_isr+0x5e4>)
					memcpy(usb_descriptor_buffer, src, datalen);
    7234:	9201      	str	r2, [sp, #4]
    7236:	2800      	cmp	r0, #0
    7238:	bf18      	it	ne
    723a:	4619      	movne	r1, r3
    723c:	4628      	mov	r0, r5
    723e:	f7ff f919 	bl	6474 <memcpy>
					usb_descriptor_buffer[1] = 7;
    7242:	2307      	movs	r3, #7
    7244:	706b      	strb	r3, [r5, #1]
    7246:	9a01      	ldr	r2, [sp, #4]
    7248:	e03b      	b.n	72c2 <usb_isr+0x5f6>
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    724a:	03c9      	lsls	r1, r1, #15
    724c:	f53f af61 	bmi.w	7112 <usb_isr+0x446>
    7250:	e761      	b.n	7116 <usb_isr+0x44a>
    7252:	bf00      	nop
    7254:	20001ee0 	.word	0x20001ee0
    7258:	2000b4d8 	.word	0x2000b4d8
    725c:	20005080 	.word	0x20005080
    7260:	00070080 	.word	0x00070080
    7264:	2000c4d8 	.word	0x2000c4d8
    7268:	20001ec0 	.word	0x20001ec0
    726c:	2000a5a8 	.word	0x2000a5a8
    7270:	2000a6f8 	.word	0x2000a6f8
    7274:	2000a71c 	.word	0x2000a71c
    7278:	2000a71d 	.word	0x2000a71d
    727c:	00cc0002 	.word	0x00cc0002
    7280:	000200c8 	.word	0x000200c8
    7284:	00c80002 	.word	0x00c80002
    7288:	20000080 	.word	0x20000080
    728c:	74d59319 	.word	0x74d59319
    7290:	2000a514 	.word	0x2000a514
    7294:	2000a4d8 	.word	0x2000a4d8
    7298:	2000a6f0 	.word	0x2000a6f0
    729c:	2000a718 	.word	0x2000a718
    72a0:	2000a71f 	.word	0x2000a71f
    72a4:	2000a71e 	.word	0x2000a71e
    72a8:	20200000 	.word	0x20200000
    72ac:	60001ba4 	.word	0x60001ba4
    72b0:	60001b40 	.word	0x60001b40
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    72b4:	4629      	mov	r1, r5
    72b6:	4d10      	ldr	r5, [pc, #64]	; (72f8 <usb_isr+0x62c>)
    72b8:	9201      	str	r2, [sp, #4]
    72ba:	4628      	mov	r0, r5
    72bc:	f7ff f8da 	bl	6474 <memcpy>
    72c0:	9a01      	ldr	r2, [sp, #4]
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    72c2:	f025 031f 	bic.w	r3, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    72c6:	4415      	add	r5, r2
	asm("dsb");
    72c8:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    72cc:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    72d0:	f8c1 3f70 	str.w	r3, [r1, #3952]	; 0xf70
		location += 32;
    72d4:	3320      	adds	r3, #32
	} while (location < end_addr);
    72d6:	429d      	cmp	r5, r3
    72d8:	d8fa      	bhi.n	72d0 <usb_isr+0x604>
	asm("dsb");
    72da:	f3bf 8f4f 	dsb	sy
	asm("isb");
    72de:	f3bf 8f6f 	isb	sy
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    72e2:	4805      	ldr	r0, [pc, #20]	; (72f8 <usb_isr+0x62c>)
    72e4:	4611      	mov	r1, r2
    72e6:	f7ff fc8f 	bl	6c08 <endpoint0_transmit.constprop.0>
				return;
    72ea:	e544      	b.n	6d76 <usb_isr+0xaa>
				usb_stop_sof_interrupts(NUM_INTERFACE);
    72ec:	2003      	movs	r0, #3
    72ee:	f7ff fcd7 	bl	6ca0 <usb_stop_sof_interrupts>
				_reboot_Teensyduino_();
    72f2:	f006 fe3d 	bl	df70 <___reboot_Teensyduino__veneer>
    72f6:	bf00      	nop
    72f8:	20200000 	.word	0x20200000

000072fc <usb_config_rx>:
{
    72fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7300:	461f      	mov	r7, r3
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    7302:	1e83      	subs	r3, r0, #2
    7304:	2b02      	cmp	r3, #2
    7306:	d901      	bls.n	730c <usb_config_rx+0x10>
}
    7308:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    730c:	f8df 904c 	ldr.w	r9, [pc, #76]	; 735c <usb_config_rx+0x60>
    7310:	4615      	mov	r5, r2
    7312:	460c      	mov	r4, r1
	memset(qh, 0, sizeof(endpoint_t));
    7314:	223c      	movs	r2, #60	; 0x3c
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    7316:	eb09 18c0 	add.w	r8, r9, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    731a:	4606      	mov	r6, r0
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    731c:	ea4f 1ac0 	mov.w	sl, r0, lsl #7
	memset(qh, 0, sizeof(endpoint_t));
    7320:	2100      	movs	r1, #0
    7322:	f108 0004 	add.w	r0, r8, #4
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    7326:	0424      	lsls	r4, r4, #16
	memset(qh, 0, sizeof(endpoint_t));
    7328:	f001 fb9c 	bl	8a64 <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    732c:	fab5 f285 	clz	r2, r5
	qh->next = 1; // Terminate bit = 1
    7330:	2301      	movs	r3, #1
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    7332:	0952      	lsrs	r2, r2, #5
    7334:	ea44 7442 	orr.w	r4, r4, r2, lsl #29
	qh->config = config;
    7338:	f849 400a 	str.w	r4, [r9, sl]
	qh->callback_function = callback;
    733c:	f8c8 7038 	str.w	r7, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    7340:	f8c8 3008 	str.w	r3, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << ep);
    7344:	2f00      	cmp	r7, #0
    7346:	d0df      	beq.n	7308 <usb_config_rx+0xc>
    7348:	4a03      	ldr	r2, [pc, #12]	; (7358 <usb_config_rx+0x5c>)
    734a:	40b3      	lsls	r3, r6
    734c:	6811      	ldr	r1, [r2, #0]
    734e:	430b      	orrs	r3, r1
    7350:	6013      	str	r3, [r2, #0]
}
    7352:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7356:	bf00      	nop
    7358:	2000a4e4 	.word	0x2000a4e4
    735c:	20000000 	.word	0x20000000

00007360 <usb_config_tx>:
{
    7360:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7364:	460d      	mov	r5, r1
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    7366:	1e81      	subs	r1, r0, #2
    7368:	2902      	cmp	r1, #2
    736a:	d901      	bls.n	7370 <usb_config_tx+0x10>
}
    736c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    7370:	01c7      	lsls	r7, r0, #7
    7372:	f8df 904c 	ldr.w	r9, [pc, #76]	; 73c0 <usb_config_tx+0x60>
    7376:	4692      	mov	sl, r2
    7378:	4604      	mov	r4, r0
    737a:	3740      	adds	r7, #64	; 0x40
	memset(qh, 0, sizeof(endpoint_t));
    737c:	223c      	movs	r2, #60	; 0x3c
    737e:	2100      	movs	r1, #0
    7380:	461e      	mov	r6, r3
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    7382:	eb09 0807 	add.w	r8, r9, r7
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    7386:	042d      	lsls	r5, r5, #16
	memset(qh, 0, sizeof(endpoint_t));
    7388:	f108 0004 	add.w	r0, r8, #4
    738c:	f001 fb6a 	bl	8a64 <memset>
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    7390:	faba f28a 	clz	r2, sl
    7394:	0952      	lsrs	r2, r2, #5
    7396:	ea45 7242 	orr.w	r2, r5, r2, lsl #29
	qh->config = config;
    739a:	f849 2007 	str.w	r2, [r9, r7]
	qh->next = 1; // Terminate bit = 1
    739e:	2201      	movs	r2, #1
	qh->callback_function = callback;
    73a0:	f8c8 6038 	str.w	r6, [r8, #56]	; 0x38
	qh->next = 1; // Terminate bit = 1
    73a4:	f8c8 2008 	str.w	r2, [r8, #8]
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    73a8:	2e00      	cmp	r6, #0
    73aa:	d0df      	beq.n	736c <usb_config_tx+0xc>
    73ac:	4b03      	ldr	r3, [pc, #12]	; (73bc <usb_config_tx+0x5c>)
    73ae:	3410      	adds	r4, #16
    73b0:	6819      	ldr	r1, [r3, #0]
    73b2:	40a2      	lsls	r2, r4
    73b4:	430a      	orrs	r2, r1
    73b6:	601a      	str	r2, [r3, #0]
}
    73b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    73bc:	2000a4e4 	.word	0x2000a4e4
    73c0:	20000000 	.word	0x20000000

000073c4 <usb_prepare_transfer>:
	transfer->status = (len << 16) | (1<<7);
    73c4:	0412      	lsls	r2, r2, #16
	transfer->pointer0 = addr;
    73c6:	6081      	str	r1, [r0, #8]
	transfer->callback_param = param;
    73c8:	61c3      	str	r3, [r0, #28]
	transfer->pointer3 = addr + 12288;
    73ca:	f501 5340 	add.w	r3, r1, #12288	; 0x3000
	transfer->status = (len << 16) | (1<<7);
    73ce:	f042 0280 	orr.w	r2, r2, #128	; 0x80
{
    73d2:	b410      	push	{r4}
	transfer->next = 1;
    73d4:	2401      	movs	r4, #1
	transfer->status = (len << 16) | (1<<7);
    73d6:	6042      	str	r2, [r0, #4]
	transfer->pointer2 = addr + 8192;
    73d8:	f501 5200 	add.w	r2, r1, #8192	; 0x2000
	transfer->next = 1;
    73dc:	6004      	str	r4, [r0, #0]
	transfer->pointer1 = addr + 4096;
    73de:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
	transfer->pointer4 = addr + 16384;
    73e2:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
	transfer->pointer1 = addr + 4096;
    73e6:	60c4      	str	r4, [r0, #12]
	transfer->pointer4 = addr + 16384;
    73e8:	6181      	str	r1, [r0, #24]
}
    73ea:	f85d 4b04 	ldr.w	r4, [sp], #4
	transfer->pointer3 = addr + 12288;
    73ee:	e9c0 2304 	strd	r2, r3, [r0, #16]
}
    73f2:	4770      	bx	lr

000073f4 <usb_transmit>:

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    73f4:	1e83      	subs	r3, r0, #2
{
    73f6:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    73f8:	2b02      	cmp	r3, #2
    73fa:	d900      	bls.n	73fe <usb_transmit+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}
    73fc:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    73fe:	4b06      	ldr	r3, [pc, #24]	; (7418 <usb_transmit+0x24>)
	uint32_t mask = 1 << (endpoint_number + 16);
    7400:	f100 0110 	add.w	r1, r0, #16
    7404:	f04f 0c01 	mov.w	ip, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    7408:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
	schedule_transfer(endpoint, mask, transfer);
    740c:	fa0c f101 	lsl.w	r1, ip, r1
    7410:	3040      	adds	r0, #64	; 0x40
    7412:	f7ff bb99 	b.w	6b48 <schedule_transfer>
    7416:	bf00      	nop
    7418:	20000000 	.word	0x20000000

0000741c <usb_receive>:

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    741c:	1e83      	subs	r3, r0, #2
{
    741e:	460a      	mov	r2, r1
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    7420:	2b02      	cmp	r3, #2
    7422:	d900      	bls.n	7426 <usb_receive+0xa>
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
}
    7424:	4770      	bx	lr
	uint32_t mask = 1 << endpoint_number;
    7426:	2101      	movs	r1, #1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
    7428:	4b02      	ldr	r3, [pc, #8]	; (7434 <usb_receive+0x18>)
	schedule_transfer(endpoint, mask, transfer);
    742a:	4081      	lsls	r1, r0
    742c:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    7430:	f7ff bb8a 	b.w	6b48 <schedule_transfer>
    7434:	20000000 	.word	0x20000000

00007438 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    7438:	6840      	ldr	r0, [r0, #4]
#endif
}
    743a:	4770      	bx	lr

0000743c <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    743c:	4a12      	ldr	r2, [pc, #72]	; (7488 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    743e:	4b13      	ldr	r3, [pc, #76]	; (748c <usb_init_serialnumber+0x50>)
	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    7440:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    7444:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	if (num < 10000000) num = num * 10;
    7448:	4298      	cmp	r0, r3
{
    744a:	b510      	push	{r4, lr}
    744c:	b084      	sub	sp, #16
	if (num < 10000000) num = num * 10;
    744e:	d202      	bcs.n	7456 <usb_init_serialnumber+0x1a>
    7450:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    7454:	0040      	lsls	r0, r0, #1
	ultoa(num, buf, 10);
    7456:	4c0e      	ldr	r4, [pc, #56]	; (7490 <usb_init_serialnumber+0x54>)
    7458:	a901      	add	r1, sp, #4
    745a:	220a      	movs	r2, #10
    745c:	f7ff f8a4 	bl	65a8 <ultoa>
	for (i=0; i<10; i++) {
    7460:	a901      	add	r1, sp, #4
    7462:	2300      	movs	r3, #0
    7464:	4620      	mov	r0, r4
		char c = buf[i];
    7466:	f811 2b01 	ldrb.w	r2, [r1], #1
	for (i=0; i<10; i++) {
    746a:	3301      	adds	r3, #1
		if (!c) break;
    746c:	b13a      	cbz	r2, 747e <usb_init_serialnumber+0x42>
	for (i=0; i<10; i++) {
    746e:	2b0a      	cmp	r3, #10
		usb_string_serial_number_default.wString[i] = c;
    7470:	f820 2f02 	strh.w	r2, [r0, #2]!
	for (i=0; i<10; i++) {
    7474:	d1f7      	bne.n	7466 <usb_init_serialnumber+0x2a>
    7476:	2316      	movs	r3, #22
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    7478:	7023      	strb	r3, [r4, #0]
}
    747a:	b004      	add	sp, #16
    747c:	bd10      	pop	{r4, pc}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    747e:	005b      	lsls	r3, r3, #1
    7480:	b2db      	uxtb	r3, r3
    7482:	7023      	strb	r3, [r4, #0]
}
    7484:	b004      	add	sp, #16
    7486:	bd10      	pop	{r4, pc}
    7488:	401f4400 	.word	0x401f4400
    748c:	00989680 	.word	0x00989680
    7490:	200019c4 	.word	0x200019c4

00007494 <usb_serial_class::clear()>:
        virtual void clear(void) { usb_serial_flush_input(); }
    7494:	f000 bad8 	b.w	7a48 <usb_serial_flush_input>

00007498 <usb_serial_class::available()>:
        virtual int available() { return usb_serial_available(); }
    7498:	f000 baca 	b.w	7a30 <usb_serial_available>

0000749c <usb_serial_class::flush()>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    749c:	f000 bb66 	b.w	7b6c <usb_serial_flush_output>

000074a0 <usb_serial_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    74a0:	f000 bb3c 	b.w	7b1c <usb_serial_write_buffer_free>

000074a4 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    74a4:	4608      	mov	r0, r1
    74a6:	4611      	mov	r1, r2
    74a8:	f000 bb2c 	b.w	7b04 <usb_serial_write>

000074ac <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    74ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    74ae:	4c14      	ldr	r4, [pc, #80]	; (7500 <rx_queue_transfer+0x54>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    74b0:	f04f 25e0 	mov.w	r5, #3758153728	; 0xe000e000
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    74b4:	4e13      	ldr	r6, [pc, #76]	; (7504 <rx_queue_transfer+0x58>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
    74b6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    74ba:	eb04 2440 	add.w	r4, r4, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    74be:	4f12      	ldr	r7, [pc, #72]	; (7508 <rx_queue_transfer+0x5c>)
    74c0:	eb06 1640 	add.w	r6, r6, r0, lsl #5
{
    74c4:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
    74c6:	f8c5 218c 	str.w	r2, [r5, #396]	; 0x18c
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    74ca:	4621      	mov	r1, r4
    74cc:	883a      	ldrh	r2, [r7, #0]
    74ce:	4630      	mov	r0, r6
    74d0:	f7ff ff78 	bl	73c4 <usb_prepare_transfer>
	arm_dcache_delete(buffer, rx_packet_size);
    74d4:	883b      	ldrh	r3, [r7, #0]
	uint32_t end_addr = (uint32_t)addr + size;
    74d6:	4423      	add	r3, r4
	asm("dsb");
    74d8:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCIMVAC = location;
    74dc:	f8c5 4f5c 	str.w	r4, [r5, #3932]	; 0xf5c
		location += 32;
    74e0:	3420      	adds	r4, #32
	} while (location < end_addr);
    74e2:	42a3      	cmp	r3, r4
    74e4:	d8fa      	bhi.n	74dc <rx_queue_transfer+0x30>
	asm("dsb");
    74e6:	f3bf 8f4f 	dsb	sy
	asm("isb");
    74ea:	f3bf 8f6f 	isb	sy
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    74ee:	2003      	movs	r0, #3
    74f0:	4631      	mov	r1, r6
    74f2:	f7ff ff93 	bl	741c <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    74f6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    74fa:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
}
    74fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7500:	20001f00 	.word	0x20001f00
    7504:	20002f00 	.word	0x20002f00
    7508:	2000a704 	.word	0x2000a704

0000750c <rx_event>:

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    750c:	4b24      	ldr	r3, [pc, #144]	; (75a0 <rx_event+0x94>)
{
    750e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    7512:	881c      	ldrh	r4, [r3, #0]
    7514:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    7516:	69c5      	ldr	r5, [r0, #28]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    7518:	f3c3 430e 	ubfx	r3, r3, #16, #15
    751c:	1ae4      	subs	r4, r4, r3
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    751e:	2c00      	cmp	r4, #0
    7520:	dd24      	ble.n	756c <rx_event+0x60>
		// received a packet with data
		uint32_t head = rx_head;
    7522:	4920      	ldr	r1, [pc, #128]	; (75a4 <rx_event+0x98>)
		if (head != rx_tail) {
    7524:	4820      	ldr	r0, [pc, #128]	; (75a8 <rx_event+0x9c>)
		uint32_t head = rx_head;
    7526:	780a      	ldrb	r2, [r1, #0]
		if (head != rx_tail) {
    7528:	7800      	ldrb	r0, [r0, #0]
		uint32_t head = rx_head;
    752a:	b2d3      	uxtb	r3, r2
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
    752c:	4e1f      	ldr	r6, [pc, #124]	; (75ac <rx_event+0xa0>)
		if (head != rx_tail) {
    752e:	4282      	cmp	r2, r0
			uint32_t ii = rx_list[head];
    7530:	481f      	ldr	r0, [pc, #124]	; (75b0 <rx_event+0xa4>)
		if (head != rx_tail) {
    7532:	d007      	beq.n	7544 <rx_event+0x38>
			uint32_t ii = rx_list[head];
    7534:	f810 8003 	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    7538:	f836 7018 	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    753c:	f5c7 7200 	rsb	r2, r7, #512	; 0x200
    7540:	4294      	cmp	r4, r2
    7542:	d918      	bls.n	7576 <rx_event+0x6a>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    7544:	3301      	adds	r3, #1
		rx_index[i] = 0;
    7546:	2200      	movs	r2, #0
		rx_count[i] = len;
    7548:	f826 4015 	strh.w	r4, [r6, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
    754c:	2b08      	cmp	r3, #8
		rx_index[i] = 0;
    754e:	4e19      	ldr	r6, [pc, #100]	; (75b4 <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    7550:	bf88      	it	hi
    7552:	4613      	movhi	r3, r2
		rx_index[i] = 0;
    7554:	f826 2015 	strh.w	r2, [r6, r5, lsl #1]
		rx_list[head] = i;
		rx_head = head;
    7558:	bf98      	it	ls
    755a:	b2da      	uxtbls	r2, r3
		rx_list[head] = i;
    755c:	54c5      	strb	r5, [r0, r3]
		rx_available += len;
    755e:	4b16      	ldr	r3, [pc, #88]	; (75b8 <rx_event+0xac>)
		rx_head = head;
    7560:	700a      	strb	r2, [r1, #0]
		rx_available += len;
    7562:	681a      	ldr	r2, [r3, #0]
    7564:	4414      	add	r4, r2
    7566:	601c      	str	r4, [r3, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    7568:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx_queue_transfer(i);
    756c:	4628      	mov	r0, r5
}
    756e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_queue_transfer(i);
    7572:	f7ff bf9b 	b.w	74ac <rx_queue_transfer>
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    7576:	eb07 2048 	add.w	r0, r7, r8, lsl #9
    757a:	4910      	ldr	r1, [pc, #64]	; (75bc <rx_event+0xb0>)
    757c:	4622      	mov	r2, r4
				rx_count[ii] = count + len;
    757e:	4427      	add	r7, r4
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    7580:	4408      	add	r0, r1
    7582:	eb01 2145 	add.w	r1, r1, r5, lsl #9
    7586:	f7fe ff75 	bl	6474 <memcpy>
				rx_available += len;
    758a:	4a0b      	ldr	r2, [pc, #44]	; (75b8 <rx_event+0xac>)
				rx_queue_transfer(i);
    758c:	4628      	mov	r0, r5
				rx_count[ii] = count + len;
    758e:	f826 7018 	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    7592:	6813      	ldr	r3, [r2, #0]
    7594:	4423      	add	r3, r4
}
    7596:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				rx_available += len;
    759a:	6013      	str	r3, [r2, #0]
				rx_queue_transfer(i);
    759c:	f7ff bf86 	b.w	74ac <rx_queue_transfer>
    75a0:	2000a704 	.word	0x2000a704
    75a4:	2000a716 	.word	0x2000a716
    75a8:	2000a717 	.word	0x2000a717
    75ac:	2000a520 	.word	0x2000a520
    75b0:	2000a540 	.word	0x2000a540
    75b4:	2000a530 	.word	0x2000a530
    75b8:	2000a51c 	.word	0x2000a51c
    75bc:	20001f00 	.word	0x20001f00

000075c0 <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    75c0:	4b1d      	ldr	r3, [pc, #116]	; (7638 <usb_serial_flush_callback+0x78>)
    75c2:	781a      	ldrb	r2, [r3, #0]
    75c4:	2a00      	cmp	r2, #0
    75c6:	d136      	bne.n	7636 <usb_serial_flush_callback+0x76>
	if (!usb_configuration) return;
    75c8:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    75cc:	4a1b      	ldr	r2, [pc, #108]	; (763c <usb_serial_flush_callback+0x7c>)
    75ce:	7812      	ldrb	r2, [r2, #0]
    75d0:	b38a      	cbz	r2, 7636 <usb_serial_flush_callback+0x76>
{
    75d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_available == 0) return;
    75d6:	4d1a      	ldr	r5, [pc, #104]	; (7640 <usb_serial_flush_callback+0x80>)
    75d8:	882a      	ldrh	r2, [r5, #0]
    75da:	b352      	cbz	r2, 7632 <usb_serial_flush_callback+0x72>
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    75dc:	4e19      	ldr	r6, [pc, #100]	; (7644 <usb_serial_flush_callback+0x84>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    75de:	f5c2 6800 	rsb	r8, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    75e2:	4f19      	ldr	r7, [pc, #100]	; (7648 <usb_serial_flush_callback+0x88>)
    75e4:	7832      	ldrb	r2, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    75e6:	4c19      	ldr	r4, [pc, #100]	; (764c <usb_serial_flush_callback+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    75e8:	eb07 1742 	add.w	r7, r7, r2, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    75ec:	eb04 24c2 	add.w	r4, r4, r2, lsl #11
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    75f0:	4642      	mov	r2, r8
    75f2:	4638      	mov	r0, r7
    75f4:	4621      	mov	r1, r4
    75f6:	f7ff fee5 	bl	73c4 <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    75fa:	eb04 0208 	add.w	r2, r4, r8
	asm("dsb");
    75fe:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    7602:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7606:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    760a:	3420      	adds	r4, #32
	} while (location < end_addr);
    760c:	42a2      	cmp	r2, r4
    760e:	d8fa      	bhi.n	7606 <usb_serial_flush_callback+0x46>
	asm("dsb");
    7610:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7614:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    7618:	2004      	movs	r0, #4
    761a:	4639      	mov	r1, r7
    761c:	f7ff feea 	bl	73f4 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    7620:	7833      	ldrb	r3, [r6, #0]
    7622:	3301      	adds	r3, #1
    7624:	b2db      	uxtb	r3, r3
    7626:	2b03      	cmp	r3, #3
    7628:	bf88      	it	hi
    762a:	2300      	movhi	r3, #0
    762c:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    762e:	2300      	movs	r3, #0
    7630:	802b      	strh	r3, [r5, #0]
}
    7632:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7636:	4770      	bx	lr
    7638:	2000a71b 	.word	0x2000a71b
    763c:	2000a71d 	.word	0x2000a71d
    7640:	2000a706 	.word	0x2000a706
    7644:	2000a71a 	.word	0x2000a71a
    7648:	20003000 	.word	0x20003000
    764c:	20003080 	.word	0x20003080

00007650 <usb_serial_write.part.0>:
int usb_serial_write(const void *buffer, uint32_t size)
    7650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7654:	b085      	sub	sp, #20
	while (size > 0) {
    7656:	e9cd 1001 	strd	r1, r0, [sp, #4]
    765a:	2900      	cmp	r1, #0
    765c:	f000 80bf 	beq.w	77de <usb_serial_write.part.0+0x18e>
	uint32_t sent=0;
    7660:	2300      	movs	r3, #0
    7662:	4c60      	ldr	r4, [pc, #384]	; (77e4 <usb_serial_write.part.0+0x194>)
    7664:	f8df 8198 	ldr.w	r8, [pc, #408]	; 7800 <usb_serial_write.part.0+0x1b0>
    7668:	f8df a198 	ldr.w	sl, [pc, #408]	; 7804 <usb_serial_write.part.0+0x1b4>
				wait_begin_at = systick_millis_count;
    766c:	4f5e      	ldr	r7, [pc, #376]	; (77e8 <usb_serial_write.part.0+0x198>)
	uint32_t sent=0;
    766e:	9300      	str	r3, [sp, #0]
		tx_noautoflush = 1;
    7670:	2301      	movs	r3, #1
		transfer_t *xfer = tx_transfer + tx_head;
    7672:	4a5e      	ldr	r2, [pc, #376]	; (77ec <usb_serial_write.part.0+0x19c>)
		tx_noautoflush = 1;
    7674:	7023      	strb	r3, [r4, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    7676:	4b5e      	ldr	r3, [pc, #376]	; (77f0 <usb_serial_write.part.0+0x1a0>)
    7678:	7819      	ldrb	r1, [r3, #0]
		while (!tx_available) {
    767a:	f8b8 3000 	ldrh.w	r3, [r8]
		transfer_t *xfer = tx_transfer + tx_head;
    767e:	eb02 1941 	add.w	r9, r2, r1, lsl #5
		while (!tx_available) {
    7682:	2b00      	cmp	r3, #0
    7684:	f040 80a7 	bne.w	77d6 <usb_serial_write.part.0+0x186>
		uint32_t wait_begin_at=0;
    7688:	461e      	mov	r6, r3
		int waiting=0;
    768a:	461d      	mov	r5, r3
			tx_noautoflush = 0;
    768c:	469b      	mov	fp, r3
			uint32_t status = usb_transfer_status(xfer);
    768e:	4648      	mov	r0, r9
    7690:	f7ff fed2 	bl	7438 <usb_transfer_status>
			if (!(status & 0x80)) {
    7694:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    7698:	f000 808c 	beq.w	77b4 <usb_serial_write.part.0+0x164>
			asm("dsb" ::: "memory");
    769c:	f3bf 8f4f 	dsb	sy
			if (transmit_previous_timeout) return sent;
    76a0:	f89a 3000 	ldrb.w	r3, [sl]
			tx_noautoflush = 0;
    76a4:	f884 b000 	strb.w	fp, [r4]
			if (!waiting) {
    76a8:	b905      	cbnz	r5, 76ac <usb_serial_write.part.0+0x5c>
				wait_begin_at = systick_millis_count;
    76aa:	683e      	ldr	r6, [r7, #0]
			if (transmit_previous_timeout) return sent;
    76ac:	2b00      	cmp	r3, #0
    76ae:	d17d      	bne.n	77ac <usb_serial_write.part.0+0x15c>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    76b0:	683b      	ldr	r3, [r7, #0]
    76b2:	1b9b      	subs	r3, r3, r6
    76b4:	2b78      	cmp	r3, #120	; 0x78
    76b6:	f200 8087 	bhi.w	77c8 <usb_serial_write.part.0+0x178>
			if (!usb_configuration) return sent;
    76ba:	4b4e      	ldr	r3, [pc, #312]	; (77f4 <usb_serial_write.part.0+0x1a4>)
    76bc:	781b      	ldrb	r3, [r3, #0]
    76be:	2b00      	cmp	r3, #0
    76c0:	d074      	beq.n	77ac <usb_serial_write.part.0+0x15c>
			yield();
    76c2:	f000 fa9d 	bl	7c00 <yield>
			tx_noautoflush = 1;
    76c6:	2201      	movs	r2, #1
		while (!tx_available) {
    76c8:	f8b8 3000 	ldrh.w	r3, [r8]
    76cc:	4615      	mov	r5, r2
			tx_noautoflush = 1;
    76ce:	7022      	strb	r2, [r4, #0]
		while (!tx_available) {
    76d0:	2b00      	cmp	r3, #0
    76d2:	d0dc      	beq.n	768e <usb_serial_write.part.0+0x3e>
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    76d4:	4a46      	ldr	r2, [pc, #280]	; (77f0 <usb_serial_write.part.0+0x1a0>)
    76d6:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    76da:	7811      	ldrb	r1, [r2, #0]
    76dc:	461a      	mov	r2, r3
    76de:	eb00 20c1 	add.w	r0, r0, r1, lsl #11
    76e2:	4d45      	ldr	r5, [pc, #276]	; (77f8 <usb_serial_write.part.0+0x1a8>)
    76e4:	02c9      	lsls	r1, r1, #11
    76e6:	4428      	add	r0, r5
		if (size >= tx_available) {
    76e8:	9d01      	ldr	r5, [sp, #4]
    76ea:	4295      	cmp	r5, r2
    76ec:	d217      	bcs.n	771e <usb_serial_write.part.0+0xce>
			memcpy(txdata, data, size);
    76ee:	9303      	str	r3, [sp, #12]
    76f0:	e9dd 5101 	ldrd	r5, r1, [sp, #4]
    76f4:	462a      	mov	r2, r5
    76f6:	f7fe febd 	bl	6474 <memcpy>
			tx_available -= size;
    76fa:	9b03      	ldr	r3, [sp, #12]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    76fc:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
			tx_available -= size;
    7700:	1b5b      	subs	r3, r3, r5
    7702:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    7706:	4b3d      	ldr	r3, [pc, #244]	; (77fc <usb_serial_write.part.0+0x1ac>)
    7708:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		asm("dsb" ::: "memory");
    770c:	f3bf 8f4f 	dsb	sy
			sent += size;
    7710:	9800      	ldr	r0, [sp, #0]
		tx_noautoflush = 0;
    7712:	2300      	movs	r3, #0
			sent += size;
    7714:	4428      	add	r0, r5
		tx_noautoflush = 0;
    7716:	7023      	strb	r3, [r4, #0]
}
    7718:	b005      	add	sp, #20
    771a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    771e:	4b36      	ldr	r3, [pc, #216]	; (77f8 <usb_serial_write.part.0+0x1a8>)
    7720:	18cd      	adds	r5, r1, r3
			memcpy(txdata, data, tx_available);
    7722:	9902      	ldr	r1, [sp, #8]
    7724:	f7fe fea6 	bl	6474 <memcpy>
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    7728:	2300      	movs	r3, #0
    772a:	f44f 6200 	mov.w	r2, #2048	; 0x800
    772e:	4629      	mov	r1, r5
    7730:	4648      	mov	r0, r9
    7732:	f7ff fe47 	bl	73c4 <usb_prepare_transfer>
	asm("dsb");
    7736:	f3bf 8f4f 	dsb	sy
    773a:	f105 0220 	add.w	r2, r5, #32
	uint32_t end_addr = (uint32_t)addr + size;
    773e:	f505 6300 	add.w	r3, r5, #2048	; 0x800
    7742:	4293      	cmp	r3, r2
    7744:	bf34      	ite	cc
    7746:	2301      	movcc	r3, #1
    7748:	2340      	movcs	r3, #64	; 0x40
		SCB_CACHE_DCCIMVAC = location;
    774a:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    774e:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    7752:	f8c2 5f70 	str.w	r5, [r2, #3952]	; 0xf70
		location += 32;
    7756:	3520      	adds	r5, #32
	} while (location < end_addr);
    7758:	42ab      	cmp	r3, r5
    775a:	d1fa      	bne.n	7752 <usb_serial_write.part.0+0x102>
	asm("dsb");
    775c:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7760:	f3bf 8f6f 	isb	sy
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    7764:	2004      	movs	r0, #4
    7766:	4649      	mov	r1, r9
    7768:	f7ff fe44 	bl	73f4 <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    776c:	4a20      	ldr	r2, [pc, #128]	; (77f0 <usb_serial_write.part.0+0x1a0>)
    776e:	7813      	ldrb	r3, [r2, #0]
    7770:	3301      	adds	r3, #1
    7772:	b2db      	uxtb	r3, r3
    7774:	2b03      	cmp	r3, #3
    7776:	bf84      	itt	hi
    7778:	2300      	movhi	r3, #0
    777a:	4a1d      	ldrhi	r2, [pc, #116]	; (77f0 <usb_serial_write.part.0+0x1a0>)
    777c:	7013      	strb	r3, [r2, #0]
			size -= tx_available;
    777e:	f8b8 3000 	ldrh.w	r3, [r8]
    7782:	9a01      	ldr	r2, [sp, #4]
    7784:	1ad1      	subs	r1, r2, r3
			sent += tx_available;
    7786:	9a00      	ldr	r2, [sp, #0]
    7788:	441a      	add	r2, r3
			size -= tx_available;
    778a:	9101      	str	r1, [sp, #4]
			sent += tx_available;
    778c:	9200      	str	r2, [sp, #0]
			data += tx_available;
    778e:	9a02      	ldr	r2, [sp, #8]
    7790:	441a      	add	r2, r3
			tx_available = 0;
    7792:	2300      	movs	r3, #0
			data += tx_available;
    7794:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = 0;
    7796:	4a19      	ldr	r2, [pc, #100]	; (77fc <usb_serial_write.part.0+0x1ac>)
			tx_available = 0;
    7798:	f8a8 3000 	strh.w	r3, [r8]
	USB1_GPTIMER0CTRL = 0;
    779c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
		asm("dsb" ::: "memory");
    77a0:	f3bf 8f4f 	dsb	sy
		tx_noautoflush = 0;
    77a4:	7023      	strb	r3, [r4, #0]
	while (size > 0) {
    77a6:	2900      	cmp	r1, #0
    77a8:	f47f af62 	bne.w	7670 <usb_serial_write.part.0+0x20>
	return sent;
    77ac:	9800      	ldr	r0, [sp, #0]
}
    77ae:	b005      	add	sp, #20
    77b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tx_available = TX_SIZE;
    77b4:	f44f 6200 	mov.w	r2, #2048	; 0x800
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    77b8:	4b0d      	ldr	r3, [pc, #52]	; (77f0 <usb_serial_write.part.0+0x1a0>)
				transmit_previous_timeout = 0;
    77ba:	f88a 0000 	strb.w	r0, [sl]
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    77be:	7819      	ldrb	r1, [r3, #0]
				break;
    77c0:	4613      	mov	r3, r2
				tx_available = TX_SIZE;
    77c2:	f8a8 2000 	strh.w	r2, [r8]
				break;
    77c6:	e78a      	b.n	76de <usb_serial_write.part.0+0x8e>
				transmit_previous_timeout = 1;
    77c8:	2301      	movs	r3, #1
				return sent;
    77ca:	9800      	ldr	r0, [sp, #0]
				transmit_previous_timeout = 1;
    77cc:	f88a 3000 	strb.w	r3, [sl]
}
    77d0:	b005      	add	sp, #20
    77d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    77d6:	461a      	mov	r2, r3
    77d8:	f5c3 6000 	rsb	r0, r3, #2048	; 0x800
    77dc:	e77f      	b.n	76de <usb_serial_write.part.0+0x8e>
	while (size > 0) {
    77de:	9801      	ldr	r0, [sp, #4]
	return sent;
    77e0:	e7e5      	b.n	77ae <usb_serial_write.part.0+0x15e>
    77e2:	bf00      	nop
    77e4:	2000a71b 	.word	0x2000a71b
    77e8:	2000a5a8 	.word	0x2000a5a8
    77ec:	20003000 	.word	0x20003000
    77f0:	2000a71a 	.word	0x2000a71a
    77f4:	2000a71d 	.word	0x2000a71d
    77f8:	20003080 	.word	0x20003080
    77fc:	402e0000 	.word	0x402e0000
    7800:	2000a706 	.word	0x2000a706
    7804:	2000a719 	.word	0x2000a719

00007808 <usb_serial_reset>:
}
    7808:	4770      	bx	lr
    780a:	bf00      	nop

0000780c <usb_serial_configure>:
	if (usb_high_speed) {
    780c:	4b2d      	ldr	r3, [pc, #180]	; (78c4 <usb_serial_configure+0xb8>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
    780e:	2100      	movs	r1, #0
    7810:	2280      	movs	r2, #128	; 0x80
    7812:	482d      	ldr	r0, [pc, #180]	; (78c8 <usb_serial_configure+0xbc>)
{
    7814:	b570      	push	{r4, r5, r6, lr}
	if (usb_high_speed) {
    7816:	781b      	ldrb	r3, [r3, #0]
	tx_head = 0;
    7818:	2400      	movs	r4, #0
		tx_packet_size = CDC_TX_SIZE_480;
    781a:	4d2c      	ldr	r5, [pc, #176]	; (78cc <usb_serial_configure+0xc0>)
	if (usb_high_speed) {
    781c:	428b      	cmp	r3, r1
		rx_packet_size = CDC_RX_SIZE_480;
    781e:	4e2c      	ldr	r6, [pc, #176]	; (78d0 <usb_serial_configure+0xc4>)
	if (usb_high_speed) {
    7820:	bf0c      	ite	eq
    7822:	2340      	moveq	r3, #64	; 0x40
    7824:	f44f 7300 	movne.w	r3, #512	; 0x200
		tx_packet_size = CDC_TX_SIZE_480;
    7828:	802b      	strh	r3, [r5, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    782a:	8033      	strh	r3, [r6, #0]
	memset(tx_transfer, 0, sizeof(tx_transfer));
    782c:	f001 f91a 	bl	8a64 <memset>
	tx_head = 0;
    7830:	4a28      	ldr	r2, [pc, #160]	; (78d4 <usb_serial_configure+0xc8>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    7832:	4621      	mov	r1, r4
	tx_available = 0;
    7834:	4b28      	ldr	r3, [pc, #160]	; (78d8 <usb_serial_configure+0xcc>)
	tx_head = 0;
    7836:	7014      	strb	r4, [r2, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    7838:	f44f 7280 	mov.w	r2, #256	; 0x100
    783c:	4827      	ldr	r0, [pc, #156]	; (78dc <usb_serial_configure+0xd0>)
	tx_available = 0;
    783e:	801c      	strh	r4, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    7840:	f001 f910 	bl	8a64 <memset>
	memset(rx_count, 0, sizeof(rx_count));
    7844:	4a26      	ldr	r2, [pc, #152]	; (78e0 <usb_serial_configure+0xd4>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    7846:	2110      	movs	r1, #16
	memset(rx_index, 0, sizeof(rx_index));
    7848:	4b26      	ldr	r3, [pc, #152]	; (78e4 <usb_serial_configure+0xd8>)
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    784a:	2002      	movs	r0, #2
	memset(rx_count, 0, sizeof(rx_count));
    784c:	e9c2 4400 	strd	r4, r4, [r2]
    7850:	e9c2 4402 	strd	r4, r4, [r2, #8]
	rx_head = 0;
    7854:	4a24      	ldr	r2, [pc, #144]	; (78e8 <usb_serial_configure+0xdc>)
	memset(rx_index, 0, sizeof(rx_index));
    7856:	e9c3 4400 	strd	r4, r4, [r3]
	rx_head = 0;
    785a:	7014      	strb	r4, [r2, #0]
	rx_available = 0;
    785c:	4a23      	ldr	r2, [pc, #140]	; (78ec <usb_serial_configure+0xe0>)
	memset(rx_index, 0, sizeof(rx_index));
    785e:	e9c3 4402 	strd	r4, r4, [r3, #8]
	rx_tail = 0;
    7862:	4b23      	ldr	r3, [pc, #140]	; (78f0 <usb_serial_configure+0xe4>)
    7864:	701c      	strb	r4, [r3, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    7866:	4623      	mov	r3, r4
	rx_available = 0;
    7868:	6014      	str	r4, [r2, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    786a:	4622      	mov	r2, r4
    786c:	f7ff fd78 	bl	7360 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    7870:	4622      	mov	r2, r4
    7872:	8831      	ldrh	r1, [r6, #0]
    7874:	2003      	movs	r0, #3
    7876:	4b1f      	ldr	r3, [pc, #124]	; (78f4 <usb_serial_configure+0xe8>)
    7878:	f7ff fd40 	bl	72fc <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    787c:	4623      	mov	r3, r4
    787e:	2201      	movs	r2, #1
    7880:	8829      	ldrh	r1, [r5, #0]
    7882:	2004      	movs	r0, #4
    7884:	f7ff fd6c 	bl	7360 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    7888:	4620      	mov	r0, r4
    788a:	3401      	adds	r4, #1
    788c:	f7ff fe0e 	bl	74ac <rx_queue_transfer>
    7890:	2c08      	cmp	r4, #8
    7892:	d1f9      	bne.n	7888 <usb_serial_configure+0x7c>
	USB1_GPTIMER0CTRL = 0;
    7894:	4b18      	ldr	r3, [pc, #96]	; (78f8 <usb_serial_configure+0xec>)
    7896:	2100      	movs	r1, #0
	USB1_GPTIMER0LD = microseconds - 1;
    7898:	224a      	movs	r2, #74	; 0x4a
	usb_timer0_callback = callback;
    789a:	4818      	ldr	r0, [pc, #96]	; (78fc <usb_serial_configure+0xf0>)
    789c:	4c18      	ldr	r4, [pc, #96]	; (7900 <usb_serial_configure+0xf4>)
    789e:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    78a0:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    78a4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    78a8:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
	if (serialEvent) yield_active_check_flags |= YIELD_CHECK_USB_SERIAL;
    78ac:	4915      	ldr	r1, [pc, #84]	; (7904 <usb_serial_configure+0xf8>)
	USB1_USBINTR |= USB_USBINTR_TIE0;
    78ae:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    78b2:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if (serialEvent) yield_active_check_flags |= YIELD_CHECK_USB_SERIAL;
    78b6:	b121      	cbz	r1, 78c2 <usb_serial_configure+0xb6>
    78b8:	4a13      	ldr	r2, [pc, #76]	; (7908 <usb_serial_configure+0xfc>)
    78ba:	7813      	ldrb	r3, [r2, #0]
    78bc:	f043 0301 	orr.w	r3, r3, #1
    78c0:	7013      	strb	r3, [r2, #0]
}
    78c2:	bd70      	pop	{r4, r5, r6, pc}
    78c4:	2000a71e 	.word	0x2000a71e
    78c8:	20003000 	.word	0x20003000
    78cc:	2000a708 	.word	0x2000a708
    78d0:	2000a704 	.word	0x2000a704
    78d4:	2000a71a 	.word	0x2000a71a
    78d8:	2000a706 	.word	0x2000a706
    78dc:	20002f00 	.word	0x20002f00
    78e0:	2000a520 	.word	0x2000a520
    78e4:	2000a530 	.word	0x2000a530
    78e8:	2000a716 	.word	0x2000a716
    78ec:	2000a51c 	.word	0x2000a51c
    78f0:	2000a717 	.word	0x2000a717
    78f4:	0000750d 	.word	0x0000750d
    78f8:	402e0000 	.word	0x402e0000
    78fc:	2000a6fc 	.word	0x2000a6fc
    7900:	000075c1 	.word	0x000075c1
    7904:	00000000 	.word	0x00000000
    7908:	2000a721 	.word	0x2000a721

0000790c <usb_serial_read>:
{
    790c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
    7910:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7914:	f44f 3200 	mov.w	r2, #131072	; 0x20000
	uint32_t tail = rx_tail;
    7918:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 79e4 <usb_serial_read+0xd8>
{
    791c:	b083      	sub	sp, #12
	NVIC_DISABLE_IRQ(IRQ_USB1);
    791e:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
	while (count < size && tail != rx_head) {
    7922:	468b      	mov	fp, r1
	uint32_t tail = rx_tail;
    7924:	f89a 4000 	ldrb.w	r4, [sl]
	while (count < size && tail != rx_head) {
    7928:	2900      	cmp	r1, #0
    792a:	d04f      	beq.n	79cc <usb_serial_read+0xc0>
    792c:	4680      	mov	r8, r0
    792e:	b2e4      	uxtb	r4, r4
	uint32_t count=0;
    7930:	2700      	movs	r7, #0
		uint32_t avail = rx_count[i] - rx_index[i];
    7932:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 79e8 <usb_serial_read+0xdc>
	while (count < size && tail != rx_head) {
    7936:	4b26      	ldr	r3, [pc, #152]	; (79d0 <usb_serial_read+0xc4>)
		uint32_t len = size - count;
    7938:	ebab 0207 	sub.w	r2, fp, r7
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    793c:	4925      	ldr	r1, [pc, #148]	; (79d4 <usb_serial_read+0xc8>)
	while (count < size && tail != rx_head) {
    793e:	781b      	ldrb	r3, [r3, #0]
    7940:	42a3      	cmp	r3, r4
		if (++tail > RX_NUM) tail = 0;
    7942:	f104 0401 	add.w	r4, r4, #1
	while (count < size && tail != rx_head) {
    7946:	d03f      	beq.n	79c8 <usb_serial_read+0xbc>
		if (++tail > RX_NUM) tail = 0;
    7948:	2c09      	cmp	r4, #9
		uint32_t i = rx_list[tail];
    794a:	4b23      	ldr	r3, [pc, #140]	; (79d8 <usb_serial_read+0xcc>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    794c:	4640      	mov	r0, r8
		if (++tail > RX_NUM) tail = 0;
    794e:	bf28      	it	cs
    7950:	2400      	movcs	r4, #0
		uint32_t i = rx_list[tail];
    7952:	5d1e      	ldrb	r6, [r3, r4]
		uint32_t avail = rx_count[i] - rx_index[i];
    7954:	f839 c016 	ldrh.w	ip, [r9, r6, lsl #1]
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    7958:	eb0c 2346 	add.w	r3, ip, r6, lsl #9
    795c:	4419      	add	r1, r3
		uint32_t avail = rx_count[i] - rx_index[i];
    795e:	4b1f      	ldr	r3, [pc, #124]	; (79dc <usb_serial_read+0xd0>)
    7960:	f833 5016 	ldrh.w	r5, [r3, r6, lsl #1]
    7964:	eba5 050c 	sub.w	r5, r5, ip
		if (avail > len) {
    7968:	42aa      	cmp	r2, r5
    796a:	d21c      	bcs.n	79a6 <usb_serial_read+0x9a>
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    796c:	eb0c 2c46 	add.w	ip, ip, r6, lsl #9
    7970:	4918      	ldr	r1, [pc, #96]	; (79d4 <usb_serial_read+0xc8>)
			rx_available -= len;
    7972:	4c1b      	ldr	r4, [pc, #108]	; (79e0 <usb_serial_read+0xd4>)
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    7974:	4461      	add	r1, ip
    7976:	9201      	str	r2, [sp, #4]
    7978:	f7fe fd7c 	bl	6474 <memcpy>
			rx_available -= len;
    797c:	6821      	ldr	r1, [r4, #0]
			rx_index[i] += len;
    797e:	f839 5016 	ldrh.w	r5, [r9, r6, lsl #1]
	return count;
    7982:	4658      	mov	r0, fp
			rx_index[i] += len;
    7984:	9a01      	ldr	r2, [sp, #4]
			rx_available -= len;
    7986:	eba1 010b 	sub.w	r1, r1, fp
			rx_index[i] += len;
    798a:	442a      	add	r2, r5
			rx_available -= len;
    798c:	4439      	add	r1, r7
			rx_index[i] += len;
    798e:	f829 2016 	strh.w	r2, [r9, r6, lsl #1]
			rx_available -= len;
    7992:	6021      	str	r1, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
    7994:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7998:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    799c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
}
    79a0:	b003      	add	sp, #12
    79a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    79a6:	462a      	mov	r2, r5
			count += avail;
    79a8:	442f      	add	r7, r5
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    79aa:	f7fe fd63 	bl	6474 <memcpy>
			rx_available -= avail;
    79ae:	490c      	ldr	r1, [pc, #48]	; (79e0 <usb_serial_read+0xd4>)
			rx_tail = tail;
    79b0:	b2e3      	uxtb	r3, r4
			rx_queue_transfer(i);
    79b2:	4630      	mov	r0, r6
			rx_available -= avail;
    79b4:	680a      	ldr	r2, [r1, #0]
			p += avail;
    79b6:	44a8      	add	r8, r5
			rx_available -= avail;
    79b8:	1b52      	subs	r2, r2, r5
    79ba:	600a      	str	r2, [r1, #0]
			rx_tail = tail;
    79bc:	f88a 3000 	strb.w	r3, [sl]
			rx_queue_transfer(i);
    79c0:	f7ff fd74 	bl	74ac <rx_queue_transfer>
	while (count < size && tail != rx_head) {
    79c4:	45bb      	cmp	fp, r7
    79c6:	d8b6      	bhi.n	7936 <usb_serial_read+0x2a>
	return count;
    79c8:	4638      	mov	r0, r7
    79ca:	e7e3      	b.n	7994 <usb_serial_read+0x88>
	while (count < size && tail != rx_head) {
    79cc:	4608      	mov	r0, r1
    79ce:	e7e1      	b.n	7994 <usb_serial_read+0x88>
    79d0:	2000a716 	.word	0x2000a716
    79d4:	20001f00 	.word	0x20001f00
    79d8:	2000a540 	.word	0x2000a540
    79dc:	2000a520 	.word	0x2000a520
    79e0:	2000a51c 	.word	0x2000a51c
    79e4:	2000a717 	.word	0x2000a717
    79e8:	2000a530 	.word	0x2000a530

000079ec <usb_serial_peekchar>:
	if (tail == rx_head) return -1;
    79ec:	4b0b      	ldr	r3, [pc, #44]	; (7a1c <usb_serial_peekchar+0x30>)
	uint32_t tail = rx_tail;
    79ee:	4a0c      	ldr	r2, [pc, #48]	; (7a20 <usb_serial_peekchar+0x34>)
    79f0:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) return -1;
    79f2:	7819      	ldrb	r1, [r3, #0]
	uint32_t tail = rx_tail;
    79f4:	b2d3      	uxtb	r3, r2
	if (tail == rx_head) return -1;
    79f6:	428a      	cmp	r2, r1
    79f8:	d00d      	beq.n	7a16 <usb_serial_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    79fa:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    79fc:	4809      	ldr	r0, [pc, #36]	; (7a24 <usb_serial_peekchar+0x38>)
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    79fe:	4a0a      	ldr	r2, [pc, #40]	; (7a28 <usb_serial_peekchar+0x3c>)
	if (++tail > RX_NUM) tail = 0;
    7a00:	2b09      	cmp	r3, #9
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7a02:	490a      	ldr	r1, [pc, #40]	; (7a2c <usb_serial_peekchar+0x40>)
	if (++tail > RX_NUM) tail = 0;
    7a04:	bf28      	it	cs
    7a06:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    7a08:	5cc3      	ldrb	r3, [r0, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    7a0a:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
    7a0e:	eb02 2343 	add.w	r3, r2, r3, lsl #9
    7a12:	5c58      	ldrb	r0, [r3, r1]
    7a14:	4770      	bx	lr
	if (tail == rx_head) return -1;
    7a16:	f04f 30ff 	mov.w	r0, #4294967295
}
    7a1a:	4770      	bx	lr
    7a1c:	2000a716 	.word	0x2000a716
    7a20:	2000a717 	.word	0x2000a717
    7a24:	2000a540 	.word	0x2000a540
    7a28:	20001f00 	.word	0x20001f00
    7a2c:	2000a530 	.word	0x2000a530

00007a30 <usb_serial_available>:
	uint32_t n = rx_available;
    7a30:	4b04      	ldr	r3, [pc, #16]	; (7a44 <usb_serial_available+0x14>)
{
    7a32:	b510      	push	{r4, lr}
	uint32_t n = rx_available;
    7a34:	681c      	ldr	r4, [r3, #0]
	if (n == 0) yield();
    7a36:	b10c      	cbz	r4, 7a3c <usb_serial_available+0xc>
}
    7a38:	4620      	mov	r0, r4
    7a3a:	bd10      	pop	{r4, pc}
	if (n == 0) yield();
    7a3c:	f000 f8e0 	bl	7c00 <yield>
}
    7a40:	4620      	mov	r0, r4
    7a42:	bd10      	pop	{r4, pc}
    7a44:	2000a51c 	.word	0x2000a51c

00007a48 <usb_serial_flush_input>:
{
    7a48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t tail = rx_tail;
    7a4c:	4e14      	ldr	r6, [pc, #80]	; (7aa0 <usb_serial_flush_input+0x58>)
	while (tail != rx_head) {
    7a4e:	4d15      	ldr	r5, [pc, #84]	; (7aa4 <usb_serial_flush_input+0x5c>)
	uint32_t tail = rx_tail;
    7a50:	7833      	ldrb	r3, [r6, #0]
	while (tail != rx_head) {
    7a52:	782a      	ldrb	r2, [r5, #0]
    7a54:	4293      	cmp	r3, r2
    7a56:	d021      	beq.n	7a9c <usb_serial_flush_input+0x54>
    7a58:	b2dc      	uxtb	r4, r3
    7a5a:	f8df 9050 	ldr.w	r9, [pc, #80]	; 7aac <usb_serial_flush_input+0x64>
    7a5e:	f8df b050 	ldr.w	fp, [pc, #80]	; 7ab0 <usb_serial_flush_input+0x68>
    7a62:	f8df 8050 	ldr.w	r8, [pc, #80]	; 7ab4 <usb_serial_flush_input+0x6c>
    7a66:	4f10      	ldr	r7, [pc, #64]	; (7aa8 <usb_serial_flush_input+0x60>)
		if (++tail > RX_NUM) tail = 0;
    7a68:	3401      	adds	r4, #1
    7a6a:	2c08      	cmp	r4, #8
		rx_tail = tail;
    7a6c:	fa5f fa84 	uxtb.w	sl, r4
		if (++tail > RX_NUM) tail = 0;
    7a70:	d901      	bls.n	7a76 <usb_serial_flush_input+0x2e>
    7a72:	2400      	movs	r4, #0
    7a74:	46a2      	mov	sl, r4
		uint32_t i = rx_list[tail];
    7a76:	f819 0004 	ldrb.w	r0, [r9, r4]
		rx_available -= rx_count[i] - rx_index[i];
    7a7a:	f8db 3000 	ldr.w	r3, [fp]
    7a7e:	f838 2010 	ldrh.w	r2, [r8, r0, lsl #1]
    7a82:	f837 1010 	ldrh.w	r1, [r7, r0, lsl #1]
    7a86:	1a52      	subs	r2, r2, r1
    7a88:	1a9b      	subs	r3, r3, r2
    7a8a:	f8cb 3000 	str.w	r3, [fp]
		rx_queue_transfer(i);
    7a8e:	f7ff fd0d 	bl	74ac <rx_queue_transfer>
		rx_tail = tail;
    7a92:	f886 a000 	strb.w	sl, [r6]
	while (tail != rx_head) {
    7a96:	782b      	ldrb	r3, [r5, #0]
    7a98:	42a3      	cmp	r3, r4
    7a9a:	d1e5      	bne.n	7a68 <usb_serial_flush_input+0x20>
}
    7a9c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7aa0:	2000a717 	.word	0x2000a717
    7aa4:	2000a716 	.word	0x2000a716
    7aa8:	2000a530 	.word	0x2000a530
    7aac:	2000a540 	.word	0x2000a540
    7ab0:	2000a51c 	.word	0x2000a51c
    7ab4:	2000a520 	.word	0x2000a520

00007ab8 <usb_serial_getchar>:
{
    7ab8:	b500      	push	{lr}
    7aba:	b083      	sub	sp, #12
	if (usb_serial_read(&c, 1)) return c;
    7abc:	2101      	movs	r1, #1
    7abe:	f10d 0007 	add.w	r0, sp, #7
    7ac2:	f7ff ff23 	bl	790c <usb_serial_read>
    7ac6:	b120      	cbz	r0, 7ad2 <usb_serial_getchar+0x1a>
    7ac8:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
    7acc:	b003      	add	sp, #12
    7ace:	f85d fb04 	ldr.w	pc, [sp], #4
	return -1;
    7ad2:	f04f 30ff 	mov.w	r0, #4294967295
    7ad6:	e7f9      	b.n	7acc <usb_serial_getchar+0x14>

00007ad8 <usb_serial_putchar>:
	if (!usb_configuration) return 0;
    7ad8:	4b09      	ldr	r3, [pc, #36]	; (7b00 <usb_serial_putchar+0x28>)
{
    7ada:	b500      	push	{lr}
    7adc:	b083      	sub	sp, #12
	if (!usb_configuration) return 0;
    7ade:	781b      	ldrb	r3, [r3, #0]
{
    7ae0:	f88d 0007 	strb.w	r0, [sp, #7]
	if (!usb_configuration) return 0;
    7ae4:	b13b      	cbz	r3, 7af6 <usb_serial_putchar+0x1e>
    7ae6:	2101      	movs	r1, #1
    7ae8:	f10d 0007 	add.w	r0, sp, #7
    7aec:	f7ff fdb0 	bl	7650 <usb_serial_write.part.0>
}
    7af0:	b003      	add	sp, #12
    7af2:	f85d fb04 	ldr.w	pc, [sp], #4
    7af6:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    7afa:	b003      	add	sp, #12
    7afc:	f85d fb04 	ldr.w	pc, [sp], #4
    7b00:	2000a71d 	.word	0x2000a71d

00007b04 <usb_serial_write>:
	if (!usb_configuration) return 0;
    7b04:	4b04      	ldr	r3, [pc, #16]	; (7b18 <usb_serial_write+0x14>)
    7b06:	781b      	ldrb	r3, [r3, #0]
    7b08:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    7b0c:	b10b      	cbz	r3, 7b12 <usb_serial_write+0xe>
    7b0e:	f7ff bd9f 	b.w	7650 <usb_serial_write.part.0>
}
    7b12:	4610      	mov	r0, r2
    7b14:	4770      	bx	lr
    7b16:	bf00      	nop
    7b18:	2000a71d 	.word	0x2000a71d

00007b1c <usb_serial_write_buffer_free>:
{
    7b1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (uint32_t i=0; i < TX_NUM; i++) {
    7b20:	2400      	movs	r4, #0
	tx_noautoflush = 1;
    7b22:	f8df 8044 	ldr.w	r8, [pc, #68]	; 7b68 <usb_serial_write_buffer_free+0x4c>
    7b26:	2301      	movs	r3, #1
    7b28:	4d0d      	ldr	r5, [pc, #52]	; (7b60 <usb_serial_write_buffer_free+0x44>)
	uint32_t sum = 0;
    7b2a:	4627      	mov	r7, r4
    7b2c:	4e0d      	ldr	r6, [pc, #52]	; (7b64 <usb_serial_write_buffer_free+0x48>)
	tx_noautoflush = 1;
    7b2e:	f888 3000 	strb.w	r3, [r8]
		if (i == tx_head) continue;
    7b32:	7833      	ldrb	r3, [r6, #0]
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    7b34:	4628      	mov	r0, r5
	for (uint32_t i=0; i < TX_NUM; i++) {
    7b36:	3520      	adds	r5, #32
		if (i == tx_head) continue;
    7b38:	42a3      	cmp	r3, r4
	for (uint32_t i=0; i < TX_NUM; i++) {
    7b3a:	f104 0401 	add.w	r4, r4, #1
		if (i == tx_head) continue;
    7b3e:	d005      	beq.n	7b4c <usb_serial_write_buffer_free+0x30>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    7b40:	f7ff fc7a 	bl	7438 <usb_transfer_status>
    7b44:	0603      	lsls	r3, r0, #24
    7b46:	bf58      	it	pl
    7b48:	f507 6700 	addpl.w	r7, r7, #2048	; 0x800
	for (uint32_t i=0; i < TX_NUM; i++) {
    7b4c:	2c04      	cmp	r4, #4
    7b4e:	d1f0      	bne.n	7b32 <usb_serial_write_buffer_free+0x16>
	asm("dsb" ::: "memory");
    7b50:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    7b54:	2300      	movs	r3, #0
}
    7b56:	4638      	mov	r0, r7
	tx_noautoflush = 0;
    7b58:	f888 3000 	strb.w	r3, [r8]
}
    7b5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7b60:	20003000 	.word	0x20003000
    7b64:	2000a71a 	.word	0x2000a71a
    7b68:	2000a71b 	.word	0x2000a71b

00007b6c <usb_serial_flush_output>:
{
    7b6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!usb_configuration) return;
    7b70:	4b1d      	ldr	r3, [pc, #116]	; (7be8 <usb_serial_flush_output+0x7c>)
    7b72:	781b      	ldrb	r3, [r3, #0]
    7b74:	b113      	cbz	r3, 7b7c <usb_serial_flush_output+0x10>
	if (tx_available == 0) return;
    7b76:	4d1d      	ldr	r5, [pc, #116]	; (7bec <usb_serial_flush_output+0x80>)
    7b78:	882a      	ldrh	r2, [r5, #0]
    7b7a:	b90a      	cbnz	r2, 7b80 <usb_serial_flush_output+0x14>
}
    7b7c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	transfer_t *xfer = tx_transfer + tx_head;
    7b80:	4e1b      	ldr	r6, [pc, #108]	; (7bf0 <usb_serial_flush_output+0x84>)
	uint32_t txnum = TX_SIZE - tx_available;
    7b82:	f5c2 6900 	rsb	r9, r2, #2048	; 0x800
	transfer_t *xfer = tx_transfer + tx_head;
    7b86:	491b      	ldr	r1, [pc, #108]	; (7bf4 <usb_serial_flush_output+0x88>)
    7b88:	7833      	ldrb	r3, [r6, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7b8a:	464a      	mov	r2, r9
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    7b8c:	4c1a      	ldr	r4, [pc, #104]	; (7bf8 <usb_serial_flush_output+0x8c>)
	transfer_t *xfer = tx_transfer + tx_head;
    7b8e:	eb01 1843 	add.w	r8, r1, r3, lsl #5
	tx_noautoflush = 1;
    7b92:	4f1a      	ldr	r7, [pc, #104]	; (7bfc <usb_serial_flush_output+0x90>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    7b94:	eb04 24c3 	add.w	r4, r4, r3, lsl #11
	tx_noautoflush = 1;
    7b98:	2301      	movs	r3, #1
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7b9a:	4640      	mov	r0, r8
	tx_noautoflush = 1;
    7b9c:	703b      	strb	r3, [r7, #0]
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    7b9e:	4621      	mov	r1, r4
    7ba0:	2300      	movs	r3, #0
    7ba2:	f7ff fc0f 	bl	73c4 <usb_prepare_transfer>
	uint32_t end_addr = (uint32_t)addr + size;
    7ba6:	eb04 0209 	add.w	r2, r4, r9
	asm("dsb");
    7baa:	f3bf 8f4f 	dsb	sy
		SCB_CACHE_DCCIMVAC = location;
    7bae:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7bb2:	f8c3 4f70 	str.w	r4, [r3, #3952]	; 0xf70
		location += 32;
    7bb6:	3420      	adds	r4, #32
	} while (location < end_addr);
    7bb8:	42a2      	cmp	r2, r4
    7bba:	d8fa      	bhi.n	7bb2 <usb_serial_flush_output+0x46>
	asm("dsb");
    7bbc:	f3bf 8f4f 	dsb	sy
	asm("isb");
    7bc0:	f3bf 8f6f 	isb	sy
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    7bc4:	2004      	movs	r0, #4
    7bc6:	4641      	mov	r1, r8
    7bc8:	f7ff fc14 	bl	73f4 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    7bcc:	7833      	ldrb	r3, [r6, #0]
    7bce:	3301      	adds	r3, #1
    7bd0:	b2db      	uxtb	r3, r3
    7bd2:	2b03      	cmp	r3, #3
    7bd4:	bf88      	it	hi
    7bd6:	2300      	movhi	r3, #0
    7bd8:	7033      	strb	r3, [r6, #0]
	tx_available = 0;
    7bda:	2300      	movs	r3, #0
    7bdc:	802b      	strh	r3, [r5, #0]
	asm("dsb" ::: "memory");
    7bde:	f3bf 8f4f 	dsb	sy
	tx_noautoflush = 0;
    7be2:	703b      	strb	r3, [r7, #0]
}
    7be4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7be8:	2000a71d 	.word	0x2000a71d
    7bec:	2000a706 	.word	0x2000a706
    7bf0:	2000a71a 	.word	0x2000a71a
    7bf4:	20003000 	.word	0x20003000
    7bf8:	20003080 	.word	0x20003080
    7bfc:	2000a71b 	.word	0x2000a71b

00007c00 <yield>:
uint8_t yield_active_check_flags = 0;


void yield(void) __attribute__ ((weak));
void yield(void)
{
    7c00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const uint8_t check_flags = yield_active_check_flags;
    7c04:	4b2d      	ldr	r3, [pc, #180]	; (7cbc <yield+0xbc>)
    7c06:	781e      	ldrb	r6, [r3, #0]
	if (!check_flags) return;	// nothing to do
    7c08:	b166      	cbz	r6, 7c24 <yield+0x24>

	// TODO: do nothing if called from interrupt

	static uint8_t running=0;
	if (running) return; // TODO: does this need to be atomic?
    7c0a:	4f2d      	ldr	r7, [pc, #180]	; (7cc0 <yield+0xc0>)
    7c0c:	783b      	ldrb	r3, [r7, #0]
    7c0e:	b94b      	cbnz	r3, 7c24 <yield+0x24>
	running = 1;
    7c10:	2301      	movs	r3, #1

	// USB Serial - Add hack to minimize impact...
	if (check_flags & YIELD_CHECK_USB_SERIAL) {
    7c12:	07f1      	lsls	r1, r6, #31
	running = 1;
    7c14:	703b      	strb	r3, [r7, #0]
	if (check_flags & YIELD_CHECK_USB_SERIAL) {
    7c16:	d443      	bmi.n	7ca0 <yield+0xa0>
		if (SerialUSB2.available()) serialEventUSB2();
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    7c18:	07b2      	lsls	r2, r6, #30
    7c1a:	d426      	bmi.n	7c6a <yield+0x6a>
		HardwareSerialIMXRT::processSerialEventsList();
	}

	running = 0;
    7c1c:	2300      	movs	r3, #0
    7c1e:	703b      	strb	r3, [r7, #0]
	if (check_flags & YIELD_CHECK_EVENT_RESPONDER) {
    7c20:	0773      	lsls	r3, r6, #29
    7c22:	d401      	bmi.n	7c28 <yield+0x28>
		EventResponder::runFromYield();
	}
};
    7c24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (!firstYield) return;  
    7c28:	4b26      	ldr	r3, [pc, #152]	; (7cc4 <yield+0xc4>)
    7c2a:	681a      	ldr	r2, [r3, #0]
    7c2c:	2a00      	cmp	r2, #0
    7c2e:	d0f9      	beq.n	7c24 <yield+0x24>
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    7c30:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    7c34:	2a00      	cmp	r2, #0
    7c36:	d1f5      	bne.n	7c24 <yield+0x24>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    7c38:	f3ef 8510 	mrs	r5, PRIMASK
		__disable_irq();
    7c3c:	b672      	cpsid	i
		EventResponder *first = firstYield;
    7c3e:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    7c40:	2800      	cmp	r0, #0
    7c42:	d034      	beq.n	7cae <yield+0xae>
		if (runningFromYield) {
    7c44:	4c20      	ldr	r4, [pc, #128]	; (7cc8 <yield+0xc8>)
    7c46:	7821      	ldrb	r1, [r4, #0]
    7c48:	2900      	cmp	r1, #0
    7c4a:	d130      	bne.n	7cae <yield+0xae>
		runningFromYield = true;
    7c4c:	2201      	movs	r2, #1
    7c4e:	7022      	strb	r2, [r4, #0]
		firstYield = first->_next;
    7c50:	6942      	ldr	r2, [r0, #20]
    7c52:	601a      	str	r2, [r3, #0]
		if (firstYield) {
    7c54:	2a00      	cmp	r2, #0
    7c56:	d02e      	beq.n	7cb6 <yield+0xb6>
			firstYield->_prev = nullptr;
    7c58:	6191      	str	r1, [r2, #24]
		if (doit) __enable_irq();
    7c5a:	b905      	cbnz	r5, 7c5e <yield+0x5e>
    7c5c:	b662      	cpsie	i
		first->_triggered = false;
    7c5e:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    7c60:	6883      	ldr	r3, [r0, #8]
		first->_triggered = false;
    7c62:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    7c64:	4798      	blx	r3
		runningFromYield = false;
    7c66:	7025      	strb	r5, [r4, #0]
    7c68:	e7dc      	b.n	7c24 <yield+0x24>

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7c6a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 7cd0 <yield+0xd0>
    7c6e:	f898 3000 	ldrb.w	r3, [r8]
    7c72:	2b00      	cmp	r3, #0
    7c74:	d0d2      	beq.n	7c1c <yield+0x1c>
    7c76:	2500      	movs	r5, #0
    7c78:	f8df 9058 	ldr.w	r9, [pc, #88]	; 7cd4 <yield+0xd4>
    7c7c:	462b      	mov	r3, r5
			s_serials_with_serial_events[i]->doYieldCode();
    7c7e:	f859 4023 	ldr.w	r4, [r9, r3, lsl #2]
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7c82:	3501      	adds	r5, #1
	static HardwareSerialIMXRT 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    7c84:	6823      	ldr	r3, [r4, #0]
    7c86:	4620      	mov	r0, r4
    7c88:	691b      	ldr	r3, [r3, #16]
    7c8a:	4798      	blx	r3
    7c8c:	b110      	cbz	r0, 7c94 <yield+0x94>
    7c8e:	6963      	ldr	r3, [r4, #20]
    7c90:	689b      	ldr	r3, [r3, #8]
    7c92:	4798      	blx	r3
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    7c94:	f898 2000 	ldrb.w	r2, [r8]
    7c98:	b2eb      	uxtb	r3, r5
    7c9a:	429a      	cmp	r2, r3
    7c9c:	d8ef      	bhi.n	7c7e <yield+0x7e>
    7c9e:	e7bd      	b.n	7c1c <yield+0x1c>
        virtual int available() { return usb_serial_available(); }
    7ca0:	f7ff fec6 	bl	7a30 <usb_serial_available>
		if (Serial.available()) serialEvent();
    7ca4:	2800      	cmp	r0, #0
    7ca6:	d0b7      	beq.n	7c18 <yield+0x18>
    7ca8:	f3af 8000 	nop.w
    7cac:	e7b4      	b.n	7c18 <yield+0x18>
		if (doit) __enable_irq();
    7cae:	2d00      	cmp	r5, #0
    7cb0:	d1b8      	bne.n	7c24 <yield+0x24>
    7cb2:	b662      	cpsie	i
    7cb4:	e7b6      	b.n	7c24 <yield+0x24>
			lastYield = nullptr;
    7cb6:	4b05      	ldr	r3, [pc, #20]	; (7ccc <yield+0xcc>)
    7cb8:	601a      	str	r2, [r3, #0]
    7cba:	e7ce      	b.n	7c5a <yield+0x5a>
    7cbc:	2000a721 	.word	0x2000a721
    7cc0:	2000a70c 	.word	0x2000a70c
    7cc4:	2000a328 	.word	0x2000a328
    7cc8:	2000a70a 	.word	0x2000a70a
    7ccc:	2000a334 	.word	0x2000a334
    7cd0:	2000a70b 	.word	0x2000a70b
    7cd4:	2000a338 	.word	0x2000a338

00007cd8 <rtc_get>:
	uint32_t hi1 = SNVS_HPRTCMR;
    7cd8:	4a07      	ldr	r2, [pc, #28]	; (7cf8 <rtc_get+0x20>)
    7cda:	6a50      	ldr	r0, [r2, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
    7cdc:	6a93      	ldr	r3, [r2, #40]	; 0x28
		uint32_t hi2 = SNVS_HPRTCMR;
    7cde:	4619      	mov	r1, r3
    7ce0:	4684      	mov	ip, r0
    7ce2:	6a50      	ldr	r0, [r2, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    7ce4:	6a93      	ldr	r3, [r2, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    7ce6:	4299      	cmp	r1, r3
    7ce8:	d1f9      	bne.n	7cde <rtc_get+0x6>
    7cea:	4584      	cmp	ip, r0
    7cec:	d1f7      	bne.n	7cde <rtc_get+0x6>
			return (hi2 << 17) | (lo2 >> 15);
    7cee:	0bdb      	lsrs	r3, r3, #15
}
    7cf0:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
    7cf4:	4770      	bx	lr
    7cf6:	bf00      	nop
    7cf8:	400d4000 	.word	0x400d4000

00007cfc <_malloc_r>:
    7cfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7d00:	f101 060b 	add.w	r6, r1, #11
    7d04:	2e16      	cmp	r6, #22
    7d06:	b083      	sub	sp, #12
    7d08:	4604      	mov	r4, r0
    7d0a:	d824      	bhi.n	7d56 <_malloc_r+0x5a>
    7d0c:	2910      	cmp	r1, #16
    7d0e:	f200 80ba 	bhi.w	7e86 <_malloc_r+0x18a>
    7d12:	f000 faa3 	bl	825c <__malloc_lock>
    7d16:	2610      	movs	r6, #16
    7d18:	2218      	movs	r2, #24
    7d1a:	2002      	movs	r0, #2
    7d1c:	4fb5      	ldr	r7, [pc, #724]	; (7ff4 <_malloc_r+0x2f8>)
    7d1e:	443a      	add	r2, r7
    7d20:	f1a2 0108 	sub.w	r1, r2, #8
    7d24:	6853      	ldr	r3, [r2, #4]
    7d26:	428b      	cmp	r3, r1
    7d28:	f000 80ba 	beq.w	7ea0 <_malloc_r+0x1a4>
    7d2c:	685a      	ldr	r2, [r3, #4]
    7d2e:	68d9      	ldr	r1, [r3, #12]
    7d30:	f022 0203 	bic.w	r2, r2, #3
    7d34:	441a      	add	r2, r3
    7d36:	689d      	ldr	r5, [r3, #8]
    7d38:	60e9      	str	r1, [r5, #12]
    7d3a:	608d      	str	r5, [r1, #8]
    7d3c:	6851      	ldr	r1, [r2, #4]
    7d3e:	f041 0101 	orr.w	r1, r1, #1
    7d42:	4620      	mov	r0, r4
    7d44:	6051      	str	r1, [r2, #4]
    7d46:	f103 0508 	add.w	r5, r3, #8
    7d4a:	f000 fa8d 	bl	8268 <__malloc_unlock>
    7d4e:	4628      	mov	r0, r5
    7d50:	b003      	add	sp, #12
    7d52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7d56:	f036 0607 	bics.w	r6, r6, #7
    7d5a:	f100 8094 	bmi.w	7e86 <_malloc_r+0x18a>
    7d5e:	42b1      	cmp	r1, r6
    7d60:	f200 8091 	bhi.w	7e86 <_malloc_r+0x18a>
    7d64:	f000 fa7a 	bl	825c <__malloc_lock>
    7d68:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
    7d6c:	f0c0 819a 	bcc.w	80a4 <_malloc_r+0x3a8>
    7d70:	0a73      	lsrs	r3, r6, #9
    7d72:	f000 808f 	beq.w	7e94 <_malloc_r+0x198>
    7d76:	2b04      	cmp	r3, #4
    7d78:	f200 816f 	bhi.w	805a <_malloc_r+0x35e>
    7d7c:	09b3      	lsrs	r3, r6, #6
    7d7e:	f103 0039 	add.w	r0, r3, #57	; 0x39
    7d82:	f103 0c38 	add.w	ip, r3, #56	; 0x38
    7d86:	00c3      	lsls	r3, r0, #3
    7d88:	4f9a      	ldr	r7, [pc, #616]	; (7ff4 <_malloc_r+0x2f8>)
    7d8a:	443b      	add	r3, r7
    7d8c:	f1a3 0508 	sub.w	r5, r3, #8
    7d90:	685b      	ldr	r3, [r3, #4]
    7d92:	429d      	cmp	r5, r3
    7d94:	d106      	bne.n	7da4 <_malloc_r+0xa8>
    7d96:	e00c      	b.n	7db2 <_malloc_r+0xb6>
    7d98:	2900      	cmp	r1, #0
    7d9a:	f280 8127 	bge.w	7fec <_malloc_r+0x2f0>
    7d9e:	68db      	ldr	r3, [r3, #12]
    7da0:	429d      	cmp	r5, r3
    7da2:	d006      	beq.n	7db2 <_malloc_r+0xb6>
    7da4:	685a      	ldr	r2, [r3, #4]
    7da6:	f022 0203 	bic.w	r2, r2, #3
    7daa:	1b91      	subs	r1, r2, r6
    7dac:	290f      	cmp	r1, #15
    7dae:	ddf3      	ble.n	7d98 <_malloc_r+0x9c>
    7db0:	4660      	mov	r0, ip
    7db2:	693d      	ldr	r5, [r7, #16]
    7db4:	f8df c250 	ldr.w	ip, [pc, #592]	; 8008 <_malloc_r+0x30c>
    7db8:	4565      	cmp	r5, ip
    7dba:	d07c      	beq.n	7eb6 <_malloc_r+0x1ba>
    7dbc:	686a      	ldr	r2, [r5, #4]
    7dbe:	f022 0203 	bic.w	r2, r2, #3
    7dc2:	1b93      	subs	r3, r2, r6
    7dc4:	2b0f      	cmp	r3, #15
    7dc6:	f300 817b 	bgt.w	80c0 <_malloc_r+0x3c4>
    7dca:	2b00      	cmp	r3, #0
    7dcc:	e9c7 cc04 	strd	ip, ip, [r7, #16]
    7dd0:	f280 816c 	bge.w	80ac <_malloc_r+0x3b0>
    7dd4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    7dd8:	f080 811a 	bcs.w	8010 <_malloc_r+0x314>
    7ddc:	08d3      	lsrs	r3, r2, #3
    7dde:	6879      	ldr	r1, [r7, #4]
    7de0:	3301      	adds	r3, #1
    7de2:	ea4f 1e52 	mov.w	lr, r2, lsr #5
    7de6:	2201      	movs	r2, #1
    7de8:	fa02 f20e 	lsl.w	r2, r2, lr
    7dec:	430a      	orrs	r2, r1
    7dee:	f857 e033 	ldr.w	lr, [r7, r3, lsl #3]
    7df2:	f8c5 e008 	str.w	lr, [r5, #8]
    7df6:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
    7dfa:	3908      	subs	r1, #8
    7dfc:	60e9      	str	r1, [r5, #12]
    7dfe:	607a      	str	r2, [r7, #4]
    7e00:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
    7e04:	f8ce 500c 	str.w	r5, [lr, #12]
    7e08:	1083      	asrs	r3, r0, #2
    7e0a:	2101      	movs	r1, #1
    7e0c:	4099      	lsls	r1, r3
    7e0e:	4291      	cmp	r1, r2
    7e10:	d857      	bhi.n	7ec2 <_malloc_r+0x1c6>
    7e12:	4211      	tst	r1, r2
    7e14:	d106      	bne.n	7e24 <_malloc_r+0x128>
    7e16:	f020 0003 	bic.w	r0, r0, #3
    7e1a:	0049      	lsls	r1, r1, #1
    7e1c:	4211      	tst	r1, r2
    7e1e:	f100 0004 	add.w	r0, r0, #4
    7e22:	d0fa      	beq.n	7e1a <_malloc_r+0x11e>
    7e24:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    7e28:	464d      	mov	r5, r9
    7e2a:	4686      	mov	lr, r0
    7e2c:	f8d5 800c 	ldr.w	r8, [r5, #12]
    7e30:	4545      	cmp	r5, r8
    7e32:	d108      	bne.n	7e46 <_malloc_r+0x14a>
    7e34:	e11d      	b.n	8072 <_malloc_r+0x376>
    7e36:	2b00      	cmp	r3, #0
    7e38:	f280 8124 	bge.w	8084 <_malloc_r+0x388>
    7e3c:	f8d8 800c 	ldr.w	r8, [r8, #12]
    7e40:	4545      	cmp	r5, r8
    7e42:	f000 8116 	beq.w	8072 <_malloc_r+0x376>
    7e46:	f8d8 2004 	ldr.w	r2, [r8, #4]
    7e4a:	f022 0203 	bic.w	r2, r2, #3
    7e4e:	1b93      	subs	r3, r2, r6
    7e50:	2b0f      	cmp	r3, #15
    7e52:	ddf0      	ble.n	7e36 <_malloc_r+0x13a>
    7e54:	4620      	mov	r0, r4
    7e56:	e9d8 5402 	ldrd	r5, r4, [r8, #8]
    7e5a:	eb08 0106 	add.w	r1, r8, r6
    7e5e:	f046 0601 	orr.w	r6, r6, #1
    7e62:	f8c8 6004 	str.w	r6, [r8, #4]
    7e66:	60ec      	str	r4, [r5, #12]
    7e68:	60a5      	str	r5, [r4, #8]
    7e6a:	f043 0401 	orr.w	r4, r3, #1
    7e6e:	e9c7 1104 	strd	r1, r1, [r7, #16]
    7e72:	e9c1 cc02 	strd	ip, ip, [r1, #8]
    7e76:	604c      	str	r4, [r1, #4]
    7e78:	f848 3002 	str.w	r3, [r8, r2]
    7e7c:	f000 f9f4 	bl	8268 <__malloc_unlock>
    7e80:	f108 0508 	add.w	r5, r8, #8
    7e84:	e002      	b.n	7e8c <_malloc_r+0x190>
    7e86:	230c      	movs	r3, #12
    7e88:	6023      	str	r3, [r4, #0]
    7e8a:	2500      	movs	r5, #0
    7e8c:	4628      	mov	r0, r5
    7e8e:	b003      	add	sp, #12
    7e90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e94:	f44f 7300 	mov.w	r3, #512	; 0x200
    7e98:	2040      	movs	r0, #64	; 0x40
    7e9a:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
    7e9e:	e773      	b.n	7d88 <_malloc_r+0x8c>
    7ea0:	68d3      	ldr	r3, [r2, #12]
    7ea2:	429a      	cmp	r2, r3
    7ea4:	bf08      	it	eq
    7ea6:	3002      	addeq	r0, #2
    7ea8:	f47f af40 	bne.w	7d2c <_malloc_r+0x30>
    7eac:	693d      	ldr	r5, [r7, #16]
    7eae:	f8df c158 	ldr.w	ip, [pc, #344]	; 8008 <_malloc_r+0x30c>
    7eb2:	4565      	cmp	r5, ip
    7eb4:	d182      	bne.n	7dbc <_malloc_r+0xc0>
    7eb6:	687a      	ldr	r2, [r7, #4]
    7eb8:	1083      	asrs	r3, r0, #2
    7eba:	2101      	movs	r1, #1
    7ebc:	4099      	lsls	r1, r3
    7ebe:	4291      	cmp	r1, r2
    7ec0:	d9a7      	bls.n	7e12 <_malloc_r+0x116>
    7ec2:	68bd      	ldr	r5, [r7, #8]
    7ec4:	686b      	ldr	r3, [r5, #4]
    7ec6:	f023 0903 	bic.w	r9, r3, #3
    7eca:	454e      	cmp	r6, r9
    7ecc:	d803      	bhi.n	7ed6 <_malloc_r+0x1da>
    7ece:	eba9 0306 	sub.w	r3, r9, r6
    7ed2:	2b0f      	cmp	r3, #15
    7ed4:	dc7a      	bgt.n	7fcc <_malloc_r+0x2d0>
    7ed6:	f8df b134 	ldr.w	fp, [pc, #308]	; 800c <_malloc_r+0x310>
    7eda:	4b47      	ldr	r3, [pc, #284]	; (7ff8 <_malloc_r+0x2fc>)
    7edc:	f8db 2000 	ldr.w	r2, [fp]
    7ee0:	681b      	ldr	r3, [r3, #0]
    7ee2:	3201      	adds	r2, #1
    7ee4:	4433      	add	r3, r6
    7ee6:	eb05 0a09 	add.w	sl, r5, r9
    7eea:	f000 8133 	beq.w	8154 <_malloc_r+0x458>
    7eee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7ef2:	330f      	adds	r3, #15
    7ef4:	f423 687f 	bic.w	r8, r3, #4080	; 0xff0
    7ef8:	f028 080f 	bic.w	r8, r8, #15
    7efc:	4641      	mov	r1, r8
    7efe:	4620      	mov	r0, r4
    7f00:	f000 fe78 	bl	8bf4 <_sbrk_r>
    7f04:	1c41      	adds	r1, r0, #1
    7f06:	4602      	mov	r2, r0
    7f08:	f000 80f3 	beq.w	80f2 <_malloc_r+0x3f6>
    7f0c:	4582      	cmp	sl, r0
    7f0e:	f200 80ee 	bhi.w	80ee <_malloc_r+0x3f2>
    7f12:	4b3a      	ldr	r3, [pc, #232]	; (7ffc <_malloc_r+0x300>)
    7f14:	6819      	ldr	r1, [r3, #0]
    7f16:	4441      	add	r1, r8
    7f18:	6019      	str	r1, [r3, #0]
    7f1a:	4608      	mov	r0, r1
    7f1c:	f000 814e 	beq.w	81bc <_malloc_r+0x4c0>
    7f20:	f8db 1000 	ldr.w	r1, [fp]
    7f24:	9301      	str	r3, [sp, #4]
    7f26:	3101      	adds	r1, #1
    7f28:	bf1b      	ittet	ne
    7f2a:	eba2 010a 	subne.w	r1, r2, sl
    7f2e:	1809      	addne	r1, r1, r0
    7f30:	f8cb 2000 	streq.w	r2, [fp]
    7f34:	6019      	strne	r1, [r3, #0]
    7f36:	f012 0b07 	ands.w	fp, r2, #7
    7f3a:	f000 8117 	beq.w	816c <_malloc_r+0x470>
    7f3e:	f1cb 0108 	rsb	r1, fp, #8
    7f42:	440a      	add	r2, r1
    7f44:	f5cb 5180 	rsb	r1, fp, #4096	; 0x1000
    7f48:	4490      	add	r8, r2
    7f4a:	3108      	adds	r1, #8
    7f4c:	eba1 0108 	sub.w	r1, r1, r8
    7f50:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
    7f54:	4651      	mov	r1, sl
    7f56:	4620      	mov	r0, r4
    7f58:	9200      	str	r2, [sp, #0]
    7f5a:	f000 fe4b 	bl	8bf4 <_sbrk_r>
    7f5e:	1c42      	adds	r2, r0, #1
    7f60:	e9dd 2300 	ldrd	r2, r3, [sp]
    7f64:	f000 814f 	beq.w	8206 <_malloc_r+0x50a>
    7f68:	1a80      	subs	r0, r0, r2
    7f6a:	eb00 080a 	add.w	r8, r0, sl
    7f6e:	6819      	ldr	r1, [r3, #0]
    7f70:	60ba      	str	r2, [r7, #8]
    7f72:	f048 0001 	orr.w	r0, r8, #1
    7f76:	4451      	add	r1, sl
    7f78:	42bd      	cmp	r5, r7
    7f7a:	6050      	str	r0, [r2, #4]
    7f7c:	6019      	str	r1, [r3, #0]
    7f7e:	f000 8129 	beq.w	81d4 <_malloc_r+0x4d8>
    7f82:	f1b9 0f0f 	cmp.w	r9, #15
    7f86:	f240 8127 	bls.w	81d8 <_malloc_r+0x4dc>
    7f8a:	6868      	ldr	r0, [r5, #4]
    7f8c:	f1a9 0c0c 	sub.w	ip, r9, #12
    7f90:	f02c 0c07 	bic.w	ip, ip, #7
    7f94:	f000 0001 	and.w	r0, r0, #1
    7f98:	ea40 000c 	orr.w	r0, r0, ip
    7f9c:	6068      	str	r0, [r5, #4]
    7f9e:	f04f 0e05 	mov.w	lr, #5
    7fa2:	eb05 000c 	add.w	r0, r5, ip
    7fa6:	f1bc 0f0f 	cmp.w	ip, #15
    7faa:	e9c0 ee01 	strd	lr, lr, [r0, #4]
    7fae:	f200 8132 	bhi.w	8216 <_malloc_r+0x51a>
    7fb2:	6850      	ldr	r0, [r2, #4]
    7fb4:	4615      	mov	r5, r2
    7fb6:	4b12      	ldr	r3, [pc, #72]	; (8000 <_malloc_r+0x304>)
    7fb8:	681a      	ldr	r2, [r3, #0]
    7fba:	428a      	cmp	r2, r1
    7fbc:	bf38      	it	cc
    7fbe:	6019      	strcc	r1, [r3, #0]
    7fc0:	4b10      	ldr	r3, [pc, #64]	; (8004 <_malloc_r+0x308>)
    7fc2:	681a      	ldr	r2, [r3, #0]
    7fc4:	428a      	cmp	r2, r1
    7fc6:	bf38      	it	cc
    7fc8:	6019      	strcc	r1, [r3, #0]
    7fca:	e094      	b.n	80f6 <_malloc_r+0x3fa>
    7fcc:	19aa      	adds	r2, r5, r6
    7fce:	f043 0301 	orr.w	r3, r3, #1
    7fd2:	f046 0601 	orr.w	r6, r6, #1
    7fd6:	606e      	str	r6, [r5, #4]
    7fd8:	4620      	mov	r0, r4
    7fda:	60ba      	str	r2, [r7, #8]
    7fdc:	6053      	str	r3, [r2, #4]
    7fde:	f000 f943 	bl	8268 <__malloc_unlock>
    7fe2:	3508      	adds	r5, #8
    7fe4:	4628      	mov	r0, r5
    7fe6:	b003      	add	sp, #12
    7fe8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7fec:	68d9      	ldr	r1, [r3, #12]
    7fee:	441a      	add	r2, r3
    7ff0:	e6a1      	b.n	7d36 <_malloc_r+0x3a>
    7ff2:	bf00      	nop
    7ff4:	20001350 	.word	0x20001350
    7ff8:	2000a394 	.word	0x2000a394
    7ffc:	2000a364 	.word	0x2000a364
    8000:	2000a38c 	.word	0x2000a38c
    8004:	2000a390 	.word	0x2000a390
    8008:	20001358 	.word	0x20001358
    800c:	20001758 	.word	0x20001758
    8010:	f5b2 6f20 	cmp.w	r2, #2560	; 0xa00
    8014:	ea4f 2352 	mov.w	r3, r2, lsr #9
    8018:	d363      	bcc.n	80e2 <_malloc_r+0x3e6>
    801a:	2b14      	cmp	r3, #20
    801c:	f200 80b7 	bhi.w	818e <_malloc_r+0x492>
    8020:	f103 015c 	add.w	r1, r3, #92	; 0x5c
    8024:	00c9      	lsls	r1, r1, #3
    8026:	335b      	adds	r3, #91	; 0x5b
    8028:	eb07 0e01 	add.w	lr, r7, r1
    802c:	5879      	ldr	r1, [r7, r1]
    802e:	f1ae 0e08 	sub.w	lr, lr, #8
    8032:	458e      	cmp	lr, r1
    8034:	f000 8091 	beq.w	815a <_malloc_r+0x45e>
    8038:	684b      	ldr	r3, [r1, #4]
    803a:	f023 0303 	bic.w	r3, r3, #3
    803e:	4293      	cmp	r3, r2
    8040:	d902      	bls.n	8048 <_malloc_r+0x34c>
    8042:	6889      	ldr	r1, [r1, #8]
    8044:	458e      	cmp	lr, r1
    8046:	d1f7      	bne.n	8038 <_malloc_r+0x33c>
    8048:	f8d1 e00c 	ldr.w	lr, [r1, #12]
    804c:	687a      	ldr	r2, [r7, #4]
    804e:	e9c5 1e02 	strd	r1, lr, [r5, #8]
    8052:	f8ce 5008 	str.w	r5, [lr, #8]
    8056:	60cd      	str	r5, [r1, #12]
    8058:	e6d6      	b.n	7e08 <_malloc_r+0x10c>
    805a:	2b14      	cmp	r3, #20
    805c:	d959      	bls.n	8112 <_malloc_r+0x416>
    805e:	2b54      	cmp	r3, #84	; 0x54
    8060:	f200 809d 	bhi.w	819e <_malloc_r+0x4a2>
    8064:	0b33      	lsrs	r3, r6, #12
    8066:	f103 006f 	add.w	r0, r3, #111	; 0x6f
    806a:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
    806e:	00c3      	lsls	r3, r0, #3
    8070:	e68a      	b.n	7d88 <_malloc_r+0x8c>
    8072:	f10e 0e01 	add.w	lr, lr, #1
    8076:	f01e 0f03 	tst.w	lr, #3
    807a:	f105 0508 	add.w	r5, r5, #8
    807e:	f47f aed5 	bne.w	7e2c <_malloc_r+0x130>
    8082:	e051      	b.n	8128 <_malloc_r+0x42c>
    8084:	4442      	add	r2, r8
    8086:	4645      	mov	r5, r8
    8088:	6853      	ldr	r3, [r2, #4]
    808a:	f8d8 100c 	ldr.w	r1, [r8, #12]
    808e:	f043 0301 	orr.w	r3, r3, #1
    8092:	6053      	str	r3, [r2, #4]
    8094:	f855 3f08 	ldr.w	r3, [r5, #8]!
    8098:	4620      	mov	r0, r4
    809a:	60d9      	str	r1, [r3, #12]
    809c:	608b      	str	r3, [r1, #8]
    809e:	f000 f8e3 	bl	8268 <__malloc_unlock>
    80a2:	e6f3      	b.n	7e8c <_malloc_r+0x190>
    80a4:	08f0      	lsrs	r0, r6, #3
    80a6:	f106 0208 	add.w	r2, r6, #8
    80aa:	e637      	b.n	7d1c <_malloc_r+0x20>
    80ac:	442a      	add	r2, r5
    80ae:	4620      	mov	r0, r4
    80b0:	6853      	ldr	r3, [r2, #4]
    80b2:	f043 0301 	orr.w	r3, r3, #1
    80b6:	6053      	str	r3, [r2, #4]
    80b8:	3508      	adds	r5, #8
    80ba:	f000 f8d5 	bl	8268 <__malloc_unlock>
    80be:	e6e5      	b.n	7e8c <_malloc_r+0x190>
    80c0:	19a9      	adds	r1, r5, r6
    80c2:	4620      	mov	r0, r4
    80c4:	f046 0601 	orr.w	r6, r6, #1
    80c8:	f043 0401 	orr.w	r4, r3, #1
    80cc:	606e      	str	r6, [r5, #4]
    80ce:	e9c7 1104 	strd	r1, r1, [r7, #16]
    80d2:	e9c1 cc02 	strd	ip, ip, [r1, #8]
    80d6:	604c      	str	r4, [r1, #4]
    80d8:	50ab      	str	r3, [r5, r2]
    80da:	f000 f8c5 	bl	8268 <__malloc_unlock>
    80de:	3508      	adds	r5, #8
    80e0:	e6d4      	b.n	7e8c <_malloc_r+0x190>
    80e2:	0993      	lsrs	r3, r2, #6
    80e4:	f103 0139 	add.w	r1, r3, #57	; 0x39
    80e8:	00c9      	lsls	r1, r1, #3
    80ea:	3338      	adds	r3, #56	; 0x38
    80ec:	e79c      	b.n	8028 <_malloc_r+0x32c>
    80ee:	42bd      	cmp	r5, r7
    80f0:	d05f      	beq.n	81b2 <_malloc_r+0x4b6>
    80f2:	68bd      	ldr	r5, [r7, #8]
    80f4:	6868      	ldr	r0, [r5, #4]
    80f6:	f020 0803 	bic.w	r8, r0, #3
    80fa:	4546      	cmp	r6, r8
    80fc:	eba8 0306 	sub.w	r3, r8, r6
    8100:	d802      	bhi.n	8108 <_malloc_r+0x40c>
    8102:	2b0f      	cmp	r3, #15
    8104:	f73f af62 	bgt.w	7fcc <_malloc_r+0x2d0>
    8108:	4620      	mov	r0, r4
    810a:	f000 f8ad 	bl	8268 <__malloc_unlock>
    810e:	2500      	movs	r5, #0
    8110:	e6bc      	b.n	7e8c <_malloc_r+0x190>
    8112:	f103 005c 	add.w	r0, r3, #92	; 0x5c
    8116:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
    811a:	00c3      	lsls	r3, r0, #3
    811c:	e634      	b.n	7d88 <_malloc_r+0x8c>
    811e:	f859 3908 	ldr.w	r3, [r9], #-8
    8122:	454b      	cmp	r3, r9
    8124:	f040 8096 	bne.w	8254 <_malloc_r+0x558>
    8128:	f010 0f03 	tst.w	r0, #3
    812c:	f100 30ff 	add.w	r0, r0, #4294967295
    8130:	d1f5      	bne.n	811e <_malloc_r+0x422>
    8132:	687b      	ldr	r3, [r7, #4]
    8134:	ea23 0301 	bic.w	r3, r3, r1
    8138:	607b      	str	r3, [r7, #4]
    813a:	0049      	lsls	r1, r1, #1
    813c:	4299      	cmp	r1, r3
    813e:	f63f aec0 	bhi.w	7ec2 <_malloc_r+0x1c6>
    8142:	b919      	cbnz	r1, 814c <_malloc_r+0x450>
    8144:	e6bd      	b.n	7ec2 <_malloc_r+0x1c6>
    8146:	0049      	lsls	r1, r1, #1
    8148:	f10e 0e04 	add.w	lr, lr, #4
    814c:	4219      	tst	r1, r3
    814e:	d0fa      	beq.n	8146 <_malloc_r+0x44a>
    8150:	4670      	mov	r0, lr
    8152:	e667      	b.n	7e24 <_malloc_r+0x128>
    8154:	f103 0810 	add.w	r8, r3, #16
    8158:	e6d0      	b.n	7efc <_malloc_r+0x200>
    815a:	109a      	asrs	r2, r3, #2
    815c:	f04f 0801 	mov.w	r8, #1
    8160:	687b      	ldr	r3, [r7, #4]
    8162:	fa08 f202 	lsl.w	r2, r8, r2
    8166:	431a      	orrs	r2, r3
    8168:	607a      	str	r2, [r7, #4]
    816a:	e770      	b.n	804e <_malloc_r+0x352>
    816c:	eb02 0108 	add.w	r1, r2, r8
    8170:	4249      	negs	r1, r1
    8172:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
    8176:	4651      	mov	r1, sl
    8178:	4620      	mov	r0, r4
    817a:	9200      	str	r2, [sp, #0]
    817c:	f000 fd3a 	bl	8bf4 <_sbrk_r>
    8180:	1c43      	adds	r3, r0, #1
    8182:	e9dd 2300 	ldrd	r2, r3, [sp]
    8186:	f47f aeef 	bne.w	7f68 <_malloc_r+0x26c>
    818a:	46da      	mov	sl, fp
    818c:	e6ef      	b.n	7f6e <_malloc_r+0x272>
    818e:	2b54      	cmp	r3, #84	; 0x54
    8190:	d825      	bhi.n	81de <_malloc_r+0x4e2>
    8192:	0b13      	lsrs	r3, r2, #12
    8194:	f103 016f 	add.w	r1, r3, #111	; 0x6f
    8198:	00c9      	lsls	r1, r1, #3
    819a:	336e      	adds	r3, #110	; 0x6e
    819c:	e744      	b.n	8028 <_malloc_r+0x32c>
    819e:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    81a2:	d825      	bhi.n	81f0 <_malloc_r+0x4f4>
    81a4:	0bf3      	lsrs	r3, r6, #15
    81a6:	f103 0078 	add.w	r0, r3, #120	; 0x78
    81aa:	f103 0c77 	add.w	ip, r3, #119	; 0x77
    81ae:	00c3      	lsls	r3, r0, #3
    81b0:	e5ea      	b.n	7d88 <_malloc_r+0x8c>
    81b2:	4b29      	ldr	r3, [pc, #164]	; (8258 <_malloc_r+0x55c>)
    81b4:	6818      	ldr	r0, [r3, #0]
    81b6:	4440      	add	r0, r8
    81b8:	6018      	str	r0, [r3, #0]
    81ba:	e6b1      	b.n	7f20 <_malloc_r+0x224>
    81bc:	f3ca 0c0b 	ubfx	ip, sl, #0, #12
    81c0:	f1bc 0f00 	cmp.w	ip, #0
    81c4:	f47f aeac 	bne.w	7f20 <_malloc_r+0x224>
    81c8:	68bd      	ldr	r5, [r7, #8]
    81ca:	44c8      	add	r8, r9
    81cc:	f048 0001 	orr.w	r0, r8, #1
    81d0:	6068      	str	r0, [r5, #4]
    81d2:	e6f0      	b.n	7fb6 <_malloc_r+0x2ba>
    81d4:	4615      	mov	r5, r2
    81d6:	e6ee      	b.n	7fb6 <_malloc_r+0x2ba>
    81d8:	2301      	movs	r3, #1
    81da:	6053      	str	r3, [r2, #4]
    81dc:	e794      	b.n	8108 <_malloc_r+0x40c>
    81de:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    81e2:	d823      	bhi.n	822c <_malloc_r+0x530>
    81e4:	0bd3      	lsrs	r3, r2, #15
    81e6:	f103 0178 	add.w	r1, r3, #120	; 0x78
    81ea:	00c9      	lsls	r1, r1, #3
    81ec:	3377      	adds	r3, #119	; 0x77
    81ee:	e71b      	b.n	8028 <_malloc_r+0x32c>
    81f0:	f240 5254 	movw	r2, #1364	; 0x554
    81f4:	4293      	cmp	r3, r2
    81f6:	d823      	bhi.n	8240 <_malloc_r+0x544>
    81f8:	0cb3      	lsrs	r3, r6, #18
    81fa:	f103 007d 	add.w	r0, r3, #125	; 0x7d
    81fe:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
    8202:	00c3      	lsls	r3, r0, #3
    8204:	e5c0      	b.n	7d88 <_malloc_r+0x8c>
    8206:	f1ab 0b08 	sub.w	fp, fp, #8
    820a:	44d8      	add	r8, fp
    820c:	eba8 0802 	sub.w	r8, r8, r2
    8210:	f04f 0a00 	mov.w	sl, #0
    8214:	e6ab      	b.n	7f6e <_malloc_r+0x272>
    8216:	f105 0108 	add.w	r1, r5, #8
    821a:	4620      	mov	r0, r4
    821c:	9300      	str	r3, [sp, #0]
    821e:	f000 fe0d 	bl	8e3c <_free_r>
    8222:	68bd      	ldr	r5, [r7, #8]
    8224:	9b00      	ldr	r3, [sp, #0]
    8226:	6868      	ldr	r0, [r5, #4]
    8228:	6819      	ldr	r1, [r3, #0]
    822a:	e6c4      	b.n	7fb6 <_malloc_r+0x2ba>
    822c:	f240 5154 	movw	r1, #1364	; 0x554
    8230:	428b      	cmp	r3, r1
    8232:	d80b      	bhi.n	824c <_malloc_r+0x550>
    8234:	0c93      	lsrs	r3, r2, #18
    8236:	f103 017d 	add.w	r1, r3, #125	; 0x7d
    823a:	00c9      	lsls	r1, r1, #3
    823c:	337c      	adds	r3, #124	; 0x7c
    823e:	e6f3      	b.n	8028 <_malloc_r+0x32c>
    8240:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    8244:	207f      	movs	r0, #127	; 0x7f
    8246:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
    824a:	e59d      	b.n	7d88 <_malloc_r+0x8c>
    824c:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
    8250:	237e      	movs	r3, #126	; 0x7e
    8252:	e6e9      	b.n	8028 <_malloc_r+0x32c>
    8254:	687b      	ldr	r3, [r7, #4]
    8256:	e770      	b.n	813a <_malloc_r+0x43e>
    8258:	2000a364 	.word	0x2000a364

0000825c <__malloc_lock>:
    825c:	4801      	ldr	r0, [pc, #4]	; (8264 <__malloc_lock+0x8>)
    825e:	f000 bd1f 	b.w	8ca0 <__retarget_lock_acquire_recursive>
    8262:	bf00      	nop
    8264:	2000a35c 	.word	0x2000a35c

00008268 <__malloc_unlock>:
    8268:	4801      	ldr	r0, [pc, #4]	; (8270 <__malloc_unlock+0x8>)
    826a:	f000 bd1b 	b.w	8ca4 <__retarget_lock_release_recursive>
    826e:	bf00      	nop
    8270:	2000a35c 	.word	0x2000a35c

00008274 <_realloc_r>:
    8274:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8278:	4617      	mov	r7, r2
    827a:	2900      	cmp	r1, #0
    827c:	f000 8098 	beq.w	83b0 <_realloc_r+0x13c>
    8280:	460c      	mov	r4, r1
    8282:	f107 050b 	add.w	r5, r7, #11
    8286:	4680      	mov	r8, r0
    8288:	f7ff ffe8 	bl	825c <__malloc_lock>
    828c:	2d16      	cmp	r5, #22
    828e:	f854 1c04 	ldr.w	r1, [r4, #-4]
    8292:	d85b      	bhi.n	834c <_realloc_r+0xd8>
    8294:	2510      	movs	r5, #16
    8296:	462a      	mov	r2, r5
    8298:	42af      	cmp	r7, r5
    829a:	d85c      	bhi.n	8356 <_realloc_r+0xe2>
    829c:	f021 0603 	bic.w	r6, r1, #3
    82a0:	4296      	cmp	r6, r2
    82a2:	f1a4 0908 	sub.w	r9, r4, #8
    82a6:	da62      	bge.n	836e <_realloc_r+0xfa>
    82a8:	4bbc      	ldr	r3, [pc, #752]	; (859c <_realloc_r+0x328>)
    82aa:	f8d3 c008 	ldr.w	ip, [r3, #8]
    82ae:	eb09 0006 	add.w	r0, r9, r6
    82b2:	4584      	cmp	ip, r0
    82b4:	f000 8097 	beq.w	83e6 <_realloc_r+0x172>
    82b8:	f8d0 c004 	ldr.w	ip, [r0, #4]
    82bc:	f02c 0301 	bic.w	r3, ip, #1
    82c0:	4403      	add	r3, r0
    82c2:	685b      	ldr	r3, [r3, #4]
    82c4:	07db      	lsls	r3, r3, #31
    82c6:	d468      	bmi.n	839a <_realloc_r+0x126>
    82c8:	f02c 0c03 	bic.w	ip, ip, #3
    82cc:	eb06 030c 	add.w	r3, r6, ip
    82d0:	4293      	cmp	r3, r2
    82d2:	da47      	bge.n	8364 <_realloc_r+0xf0>
    82d4:	07cb      	lsls	r3, r1, #31
    82d6:	d410      	bmi.n	82fa <_realloc_r+0x86>
    82d8:	f854 3c08 	ldr.w	r3, [r4, #-8]
    82dc:	eba9 0a03 	sub.w	sl, r9, r3
    82e0:	f8da 3004 	ldr.w	r3, [sl, #4]
    82e4:	f023 0103 	bic.w	r1, r3, #3
    82e8:	448c      	add	ip, r1
    82ea:	44b4      	add	ip, r6
    82ec:	4594      	cmp	ip, r2
    82ee:	f280 8111 	bge.w	8514 <_realloc_r+0x2a0>
    82f2:	1873      	adds	r3, r6, r1
    82f4:	4293      	cmp	r3, r2
    82f6:	f280 80e8 	bge.w	84ca <_realloc_r+0x256>
    82fa:	4639      	mov	r1, r7
    82fc:	4640      	mov	r0, r8
    82fe:	f7ff fcfd 	bl	7cfc <_malloc_r>
    8302:	4607      	mov	r7, r0
    8304:	b1e0      	cbz	r0, 8340 <_realloc_r+0xcc>
    8306:	f854 3c04 	ldr.w	r3, [r4, #-4]
    830a:	f023 0301 	bic.w	r3, r3, #1
    830e:	444b      	add	r3, r9
    8310:	f1a0 0208 	sub.w	r2, r0, #8
    8314:	4293      	cmp	r3, r2
    8316:	f000 80d2 	beq.w	84be <_realloc_r+0x24a>
    831a:	1f32      	subs	r2, r6, #4
    831c:	2a24      	cmp	r2, #36	; 0x24
    831e:	f200 80f5 	bhi.w	850c <_realloc_r+0x298>
    8322:	2a13      	cmp	r2, #19
    8324:	f200 80ac 	bhi.w	8480 <_realloc_r+0x20c>
    8328:	4603      	mov	r3, r0
    832a:	4622      	mov	r2, r4
    832c:	6811      	ldr	r1, [r2, #0]
    832e:	6019      	str	r1, [r3, #0]
    8330:	6851      	ldr	r1, [r2, #4]
    8332:	6059      	str	r1, [r3, #4]
    8334:	6892      	ldr	r2, [r2, #8]
    8336:	609a      	str	r2, [r3, #8]
    8338:	4621      	mov	r1, r4
    833a:	4640      	mov	r0, r8
    833c:	f000 fd7e 	bl	8e3c <_free_r>
    8340:	4640      	mov	r0, r8
    8342:	f7ff ff91 	bl	8268 <__malloc_unlock>
    8346:	4638      	mov	r0, r7
    8348:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    834c:	f025 0507 	bic.w	r5, r5, #7
    8350:	2d00      	cmp	r5, #0
    8352:	462a      	mov	r2, r5
    8354:	daa0      	bge.n	8298 <_realloc_r+0x24>
    8356:	230c      	movs	r3, #12
    8358:	f8c8 3000 	str.w	r3, [r8]
    835c:	2700      	movs	r7, #0
    835e:	4638      	mov	r0, r7
    8360:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8364:	461e      	mov	r6, r3
    8366:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
    836a:	60d3      	str	r3, [r2, #12]
    836c:	609a      	str	r2, [r3, #8]
    836e:	1b73      	subs	r3, r6, r5
    8370:	2b0f      	cmp	r3, #15
    8372:	d822      	bhi.n	83ba <_realloc_r+0x146>
    8374:	f8d9 3004 	ldr.w	r3, [r9, #4]
    8378:	f003 0301 	and.w	r3, r3, #1
    837c:	4333      	orrs	r3, r6
    837e:	444e      	add	r6, r9
    8380:	f8c9 3004 	str.w	r3, [r9, #4]
    8384:	6873      	ldr	r3, [r6, #4]
    8386:	f043 0301 	orr.w	r3, r3, #1
    838a:	6073      	str	r3, [r6, #4]
    838c:	4640      	mov	r0, r8
    838e:	4627      	mov	r7, r4
    8390:	f7ff ff6a 	bl	8268 <__malloc_unlock>
    8394:	4638      	mov	r0, r7
    8396:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    839a:	07c9      	lsls	r1, r1, #31
    839c:	d4ad      	bmi.n	82fa <_realloc_r+0x86>
    839e:	f854 3c08 	ldr.w	r3, [r4, #-8]
    83a2:	eba9 0a03 	sub.w	sl, r9, r3
    83a6:	f8da 1004 	ldr.w	r1, [sl, #4]
    83aa:	f021 0103 	bic.w	r1, r1, #3
    83ae:	e7a0      	b.n	82f2 <_realloc_r+0x7e>
    83b0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    83b4:	4611      	mov	r1, r2
    83b6:	f7ff bca1 	b.w	7cfc <_malloc_r>
    83ba:	f8d9 2004 	ldr.w	r2, [r9, #4]
    83be:	eb09 0105 	add.w	r1, r9, r5
    83c2:	f002 0201 	and.w	r2, r2, #1
    83c6:	444e      	add	r6, r9
    83c8:	f043 0301 	orr.w	r3, r3, #1
    83cc:	432a      	orrs	r2, r5
    83ce:	f8c9 2004 	str.w	r2, [r9, #4]
    83d2:	604b      	str	r3, [r1, #4]
    83d4:	6873      	ldr	r3, [r6, #4]
    83d6:	f043 0301 	orr.w	r3, r3, #1
    83da:	3108      	adds	r1, #8
    83dc:	6073      	str	r3, [r6, #4]
    83de:	4640      	mov	r0, r8
    83e0:	f000 fd2c 	bl	8e3c <_free_r>
    83e4:	e7d2      	b.n	838c <_realloc_r+0x118>
    83e6:	f8dc 0004 	ldr.w	r0, [ip, #4]
    83ea:	f020 0b03 	bic.w	fp, r0, #3
    83ee:	eb06 0c0b 	add.w	ip, r6, fp
    83f2:	f105 0010 	add.w	r0, r5, #16
    83f6:	4584      	cmp	ip, r0
    83f8:	da4d      	bge.n	8496 <_realloc_r+0x222>
    83fa:	07c9      	lsls	r1, r1, #31
    83fc:	f53f af7d 	bmi.w	82fa <_realloc_r+0x86>
    8400:	f854 1c08 	ldr.w	r1, [r4, #-8]
    8404:	eba9 0a01 	sub.w	sl, r9, r1
    8408:	f8da 1004 	ldr.w	r1, [sl, #4]
    840c:	f021 0103 	bic.w	r1, r1, #3
    8410:	448b      	add	fp, r1
    8412:	44b3      	add	fp, r6
    8414:	4558      	cmp	r0, fp
    8416:	f73f af6c 	bgt.w	82f2 <_realloc_r+0x7e>
    841a:	4657      	mov	r7, sl
    841c:	f8da 100c 	ldr.w	r1, [sl, #12]
    8420:	f857 0f08 	ldr.w	r0, [r7, #8]!
    8424:	1f32      	subs	r2, r6, #4
    8426:	2a24      	cmp	r2, #36	; 0x24
    8428:	60c1      	str	r1, [r0, #12]
    842a:	6088      	str	r0, [r1, #8]
    842c:	f200 80db 	bhi.w	85e6 <_realloc_r+0x372>
    8430:	2a13      	cmp	r2, #19
    8432:	f240 80d6 	bls.w	85e2 <_realloc_r+0x36e>
    8436:	6821      	ldr	r1, [r4, #0]
    8438:	f8ca 1008 	str.w	r1, [sl, #8]
    843c:	6861      	ldr	r1, [r4, #4]
    843e:	f8ca 100c 	str.w	r1, [sl, #12]
    8442:	2a1b      	cmp	r2, #27
    8444:	f200 80df 	bhi.w	8606 <_realloc_r+0x392>
    8448:	3408      	adds	r4, #8
    844a:	f10a 0210 	add.w	r2, sl, #16
    844e:	6821      	ldr	r1, [r4, #0]
    8450:	6011      	str	r1, [r2, #0]
    8452:	6861      	ldr	r1, [r4, #4]
    8454:	6051      	str	r1, [r2, #4]
    8456:	68a1      	ldr	r1, [r4, #8]
    8458:	6091      	str	r1, [r2, #8]
    845a:	eb0a 0105 	add.w	r1, sl, r5
    845e:	ebab 0205 	sub.w	r2, fp, r5
    8462:	f042 0201 	orr.w	r2, r2, #1
    8466:	6099      	str	r1, [r3, #8]
    8468:	604a      	str	r2, [r1, #4]
    846a:	f8da 3004 	ldr.w	r3, [sl, #4]
    846e:	f003 0301 	and.w	r3, r3, #1
    8472:	432b      	orrs	r3, r5
    8474:	4640      	mov	r0, r8
    8476:	f8ca 3004 	str.w	r3, [sl, #4]
    847a:	f7ff fef5 	bl	8268 <__malloc_unlock>
    847e:	e76e      	b.n	835e <_realloc_r+0xea>
    8480:	6823      	ldr	r3, [r4, #0]
    8482:	6003      	str	r3, [r0, #0]
    8484:	6863      	ldr	r3, [r4, #4]
    8486:	6043      	str	r3, [r0, #4]
    8488:	2a1b      	cmp	r2, #27
    848a:	d868      	bhi.n	855e <_realloc_r+0x2ea>
    848c:	f104 0208 	add.w	r2, r4, #8
    8490:	f100 0308 	add.w	r3, r0, #8
    8494:	e74a      	b.n	832c <_realloc_r+0xb8>
    8496:	eb09 0205 	add.w	r2, r9, r5
    849a:	609a      	str	r2, [r3, #8]
    849c:	ebac 0305 	sub.w	r3, ip, r5
    84a0:	f043 0301 	orr.w	r3, r3, #1
    84a4:	6053      	str	r3, [r2, #4]
    84a6:	f854 3c04 	ldr.w	r3, [r4, #-4]
    84aa:	f003 0301 	and.w	r3, r3, #1
    84ae:	432b      	orrs	r3, r5
    84b0:	4640      	mov	r0, r8
    84b2:	f844 3c04 	str.w	r3, [r4, #-4]
    84b6:	f7ff fed7 	bl	8268 <__malloc_unlock>
    84ba:	4627      	mov	r7, r4
    84bc:	e74f      	b.n	835e <_realloc_r+0xea>
    84be:	f850 3c04 	ldr.w	r3, [r0, #-4]
    84c2:	f023 0303 	bic.w	r3, r3, #3
    84c6:	441e      	add	r6, r3
    84c8:	e751      	b.n	836e <_realloc_r+0xfa>
    84ca:	4657      	mov	r7, sl
    84cc:	f8da 100c 	ldr.w	r1, [sl, #12]
    84d0:	f857 0f08 	ldr.w	r0, [r7, #8]!
    84d4:	1f32      	subs	r2, r6, #4
    84d6:	2a24      	cmp	r2, #36	; 0x24
    84d8:	60c1      	str	r1, [r0, #12]
    84da:	6088      	str	r0, [r1, #8]
    84dc:	d84c      	bhi.n	8578 <_realloc_r+0x304>
    84de:	2a13      	cmp	r2, #19
    84e0:	d948      	bls.n	8574 <_realloc_r+0x300>
    84e2:	6821      	ldr	r1, [r4, #0]
    84e4:	f8ca 1008 	str.w	r1, [sl, #8]
    84e8:	6861      	ldr	r1, [r4, #4]
    84ea:	f8ca 100c 	str.w	r1, [sl, #12]
    84ee:	2a1b      	cmp	r2, #27
    84f0:	d856      	bhi.n	85a0 <_realloc_r+0x32c>
    84f2:	3408      	adds	r4, #8
    84f4:	f10a 0210 	add.w	r2, sl, #16
    84f8:	461e      	mov	r6, r3
    84fa:	6823      	ldr	r3, [r4, #0]
    84fc:	6013      	str	r3, [r2, #0]
    84fe:	6863      	ldr	r3, [r4, #4]
    8500:	6053      	str	r3, [r2, #4]
    8502:	68a3      	ldr	r3, [r4, #8]
    8504:	6093      	str	r3, [r2, #8]
    8506:	46d1      	mov	r9, sl
    8508:	463c      	mov	r4, r7
    850a:	e730      	b.n	836e <_realloc_r+0xfa>
    850c:	4621      	mov	r1, r4
    850e:	f000 fa2d 	bl	896c <memmove>
    8512:	e711      	b.n	8338 <_realloc_r+0xc4>
    8514:	e9d0 1302 	ldrd	r1, r3, [r0, #8]
    8518:	4657      	mov	r7, sl
    851a:	60cb      	str	r3, [r1, #12]
    851c:	6099      	str	r1, [r3, #8]
    851e:	f857 1f08 	ldr.w	r1, [r7, #8]!
    8522:	f8da 300c 	ldr.w	r3, [sl, #12]
    8526:	60cb      	str	r3, [r1, #12]
    8528:	1f32      	subs	r2, r6, #4
    852a:	2a24      	cmp	r2, #36	; 0x24
    852c:	6099      	str	r1, [r3, #8]
    852e:	d82d      	bhi.n	858c <_realloc_r+0x318>
    8530:	2a13      	cmp	r2, #19
    8532:	d929      	bls.n	8588 <_realloc_r+0x314>
    8534:	6823      	ldr	r3, [r4, #0]
    8536:	f8ca 3008 	str.w	r3, [sl, #8]
    853a:	6863      	ldr	r3, [r4, #4]
    853c:	f8ca 300c 	str.w	r3, [sl, #12]
    8540:	2a1b      	cmp	r2, #27
    8542:	d842      	bhi.n	85ca <_realloc_r+0x356>
    8544:	3408      	adds	r4, #8
    8546:	f10a 0310 	add.w	r3, sl, #16
    854a:	6822      	ldr	r2, [r4, #0]
    854c:	601a      	str	r2, [r3, #0]
    854e:	6862      	ldr	r2, [r4, #4]
    8550:	605a      	str	r2, [r3, #4]
    8552:	68a2      	ldr	r2, [r4, #8]
    8554:	609a      	str	r2, [r3, #8]
    8556:	4666      	mov	r6, ip
    8558:	46d1      	mov	r9, sl
    855a:	463c      	mov	r4, r7
    855c:	e707      	b.n	836e <_realloc_r+0xfa>
    855e:	68a3      	ldr	r3, [r4, #8]
    8560:	6083      	str	r3, [r0, #8]
    8562:	68e3      	ldr	r3, [r4, #12]
    8564:	60c3      	str	r3, [r0, #12]
    8566:	2a24      	cmp	r2, #36	; 0x24
    8568:	d026      	beq.n	85b8 <_realloc_r+0x344>
    856a:	f104 0210 	add.w	r2, r4, #16
    856e:	f100 0310 	add.w	r3, r0, #16
    8572:	e6db      	b.n	832c <_realloc_r+0xb8>
    8574:	463a      	mov	r2, r7
    8576:	e7bf      	b.n	84f8 <_realloc_r+0x284>
    8578:	4621      	mov	r1, r4
    857a:	4638      	mov	r0, r7
    857c:	461e      	mov	r6, r3
    857e:	46d1      	mov	r9, sl
    8580:	f000 f9f4 	bl	896c <memmove>
    8584:	463c      	mov	r4, r7
    8586:	e6f2      	b.n	836e <_realloc_r+0xfa>
    8588:	463b      	mov	r3, r7
    858a:	e7de      	b.n	854a <_realloc_r+0x2d6>
    858c:	4621      	mov	r1, r4
    858e:	4638      	mov	r0, r7
    8590:	4666      	mov	r6, ip
    8592:	46d1      	mov	r9, sl
    8594:	f000 f9ea 	bl	896c <memmove>
    8598:	463c      	mov	r4, r7
    859a:	e6e8      	b.n	836e <_realloc_r+0xfa>
    859c:	20001350 	.word	0x20001350
    85a0:	68a1      	ldr	r1, [r4, #8]
    85a2:	f8ca 1010 	str.w	r1, [sl, #16]
    85a6:	68e1      	ldr	r1, [r4, #12]
    85a8:	f8ca 1014 	str.w	r1, [sl, #20]
    85ac:	2a24      	cmp	r2, #36	; 0x24
    85ae:	d020      	beq.n	85f2 <_realloc_r+0x37e>
    85b0:	3410      	adds	r4, #16
    85b2:	f10a 0218 	add.w	r2, sl, #24
    85b6:	e79f      	b.n	84f8 <_realloc_r+0x284>
    85b8:	6923      	ldr	r3, [r4, #16]
    85ba:	6103      	str	r3, [r0, #16]
    85bc:	6961      	ldr	r1, [r4, #20]
    85be:	6141      	str	r1, [r0, #20]
    85c0:	f104 0218 	add.w	r2, r4, #24
    85c4:	f100 0318 	add.w	r3, r0, #24
    85c8:	e6b0      	b.n	832c <_realloc_r+0xb8>
    85ca:	68a3      	ldr	r3, [r4, #8]
    85cc:	f8ca 3010 	str.w	r3, [sl, #16]
    85d0:	68e3      	ldr	r3, [r4, #12]
    85d2:	f8ca 3014 	str.w	r3, [sl, #20]
    85d6:	2a24      	cmp	r2, #36	; 0x24
    85d8:	d021      	beq.n	861e <_realloc_r+0x3aa>
    85da:	3410      	adds	r4, #16
    85dc:	f10a 0318 	add.w	r3, sl, #24
    85e0:	e7b3      	b.n	854a <_realloc_r+0x2d6>
    85e2:	463a      	mov	r2, r7
    85e4:	e733      	b.n	844e <_realloc_r+0x1da>
    85e6:	4621      	mov	r1, r4
    85e8:	4638      	mov	r0, r7
    85ea:	f000 f9bf 	bl	896c <memmove>
    85ee:	4b16      	ldr	r3, [pc, #88]	; (8648 <_realloc_r+0x3d4>)
    85f0:	e733      	b.n	845a <_realloc_r+0x1e6>
    85f2:	6922      	ldr	r2, [r4, #16]
    85f4:	f8ca 2018 	str.w	r2, [sl, #24]
    85f8:	6962      	ldr	r2, [r4, #20]
    85fa:	f8ca 201c 	str.w	r2, [sl, #28]
    85fe:	3418      	adds	r4, #24
    8600:	f10a 0220 	add.w	r2, sl, #32
    8604:	e778      	b.n	84f8 <_realloc_r+0x284>
    8606:	68a1      	ldr	r1, [r4, #8]
    8608:	f8ca 1010 	str.w	r1, [sl, #16]
    860c:	68e1      	ldr	r1, [r4, #12]
    860e:	f8ca 1014 	str.w	r1, [sl, #20]
    8612:	2a24      	cmp	r2, #36	; 0x24
    8614:	d00d      	beq.n	8632 <_realloc_r+0x3be>
    8616:	3410      	adds	r4, #16
    8618:	f10a 0218 	add.w	r2, sl, #24
    861c:	e717      	b.n	844e <_realloc_r+0x1da>
    861e:	6923      	ldr	r3, [r4, #16]
    8620:	f8ca 3018 	str.w	r3, [sl, #24]
    8624:	6963      	ldr	r3, [r4, #20]
    8626:	f8ca 301c 	str.w	r3, [sl, #28]
    862a:	3418      	adds	r4, #24
    862c:	f10a 0320 	add.w	r3, sl, #32
    8630:	e78b      	b.n	854a <_realloc_r+0x2d6>
    8632:	6922      	ldr	r2, [r4, #16]
    8634:	f8ca 2018 	str.w	r2, [sl, #24]
    8638:	6962      	ldr	r2, [r4, #20]
    863a:	f8ca 201c 	str.w	r2, [sl, #28]
    863e:	3418      	adds	r4, #24
    8640:	f10a 0220 	add.w	r2, sl, #32
    8644:	e703      	b.n	844e <_realloc_r+0x1da>
    8646:	bf00      	nop
    8648:	20001350 	.word	0x20001350

0000864c <stdio_exit_handler>:
    864c:	4a02      	ldr	r2, [pc, #8]	; (8658 <stdio_exit_handler+0xc>)
    864e:	4903      	ldr	r1, [pc, #12]	; (865c <stdio_exit_handler+0x10>)
    8650:	4803      	ldr	r0, [pc, #12]	; (8660 <stdio_exit_handler+0x14>)
    8652:	f000 b8bb 	b.w	87cc <_fwalk_sglue>
    8656:	bf00      	nop
    8658:	20001760 	.word	0x20001760
    865c:	0000b34d 	.word	0x0000b34d
    8660:	20000fe8 	.word	0x20000fe8

00008664 <cleanup_stdio>:
    8664:	4b0c      	ldr	r3, [pc, #48]	; (8698 <cleanup_stdio+0x34>)
    8666:	6841      	ldr	r1, [r0, #4]
    8668:	4299      	cmp	r1, r3
    866a:	b510      	push	{r4, lr}
    866c:	4604      	mov	r4, r0
    866e:	d001      	beq.n	8674 <cleanup_stdio+0x10>
    8670:	f002 fe6c 	bl	b34c <_fclose_r>
    8674:	68a1      	ldr	r1, [r4, #8]
    8676:	4b09      	ldr	r3, [pc, #36]	; (869c <cleanup_stdio+0x38>)
    8678:	4299      	cmp	r1, r3
    867a:	d002      	beq.n	8682 <cleanup_stdio+0x1e>
    867c:	4620      	mov	r0, r4
    867e:	f002 fe65 	bl	b34c <_fclose_r>
    8682:	68e1      	ldr	r1, [r4, #12]
    8684:	4b06      	ldr	r3, [pc, #24]	; (86a0 <cleanup_stdio+0x3c>)
    8686:	4299      	cmp	r1, r3
    8688:	d004      	beq.n	8694 <cleanup_stdio+0x30>
    868a:	4620      	mov	r0, r4
    868c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    8690:	f002 be5c 	b.w	b34c <_fclose_r>
    8694:	bd10      	pop	{r4, pc}
    8696:	bf00      	nop
    8698:	2000a398 	.word	0x2000a398
    869c:	2000a400 	.word	0x2000a400
    86a0:	2000a468 	.word	0x2000a468

000086a4 <global_stdio_init.part.0>:
    86a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    86a8:	4c2a      	ldr	r4, [pc, #168]	; (8754 <global_stdio_init.part.0+0xb0>)
    86aa:	4b2b      	ldr	r3, [pc, #172]	; (8758 <global_stdio_init.part.0+0xb4>)
    86ac:	482b      	ldr	r0, [pc, #172]	; (875c <global_stdio_init.part.0+0xb8>)
    86ae:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 8770 <global_stdio_init.part.0+0xcc>
    86b2:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8774 <global_stdio_init.part.0+0xd0>
    86b6:	4f2a      	ldr	r7, [pc, #168]	; (8760 <global_stdio_init.part.0+0xbc>)
    86b8:	6018      	str	r0, [r3, #0]
    86ba:	2500      	movs	r5, #0
    86bc:	2304      	movs	r3, #4
    86be:	2208      	movs	r2, #8
    86c0:	4629      	mov	r1, r5
    86c2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    86c6:	4e27      	ldr	r6, [pc, #156]	; (8764 <global_stdio_init.part.0+0xc0>)
    86c8:	6665      	str	r5, [r4, #100]	; 0x64
    86ca:	e9c4 5302 	strd	r5, r3, [r4, #8]
    86ce:	e9c4 5500 	strd	r5, r5, [r4]
    86d2:	e9c4 5504 	strd	r5, r5, [r4, #16]
    86d6:	61a5      	str	r5, [r4, #24]
    86d8:	f000 f9c4 	bl	8a64 <memset>
    86dc:	4b22      	ldr	r3, [pc, #136]	; (8768 <global_stdio_init.part.0+0xc4>)
    86de:	6763      	str	r3, [r4, #116]	; 0x74
    86e0:	2208      	movs	r2, #8
    86e2:	4629      	mov	r1, r5
    86e4:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    86e8:	e9c4 4907 	strd	r4, r9, [r4, #28]
    86ec:	e9c4 8709 	strd	r8, r7, [r4, #36]	; 0x24
    86f0:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
    86f4:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
    86f8:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
    86fc:	6725      	str	r5, [r4, #112]	; 0x70
    86fe:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    8702:	62e6      	str	r6, [r4, #44]	; 0x2c
    8704:	f000 f9ae 	bl	8a64 <memset>
    8708:	4b18      	ldr	r3, [pc, #96]	; (876c <global_stdio_init.part.0+0xc8>)
    870a:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
    870e:	4629      	mov	r1, r5
    8710:	f104 0368 	add.w	r3, r4, #104	; 0x68
    8714:	2208      	movs	r2, #8
    8716:	f504 7096 	add.w	r0, r4, #300	; 0x12c
    871a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    871e:	e9c4 9822 	strd	r9, r8, [r4, #136]	; 0x88
    8722:	e9c4 7624 	strd	r7, r6, [r4, #144]	; 0x90
    8726:	e9c4 5534 	strd	r5, r5, [r4, #208]	; 0xd0
    872a:	e9c4 5538 	strd	r5, r5, [r4, #224]	; 0xe0
    872e:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
    8732:	f8c4 50d8 	str.w	r5, [r4, #216]	; 0xd8
    8736:	f8c4 50e8 	str.w	r5, [r4, #232]	; 0xe8
    873a:	f000 f993 	bl	8a64 <memset>
    873e:	f104 03d0 	add.w	r3, r4, #208	; 0xd0
    8742:	e9c4 983c 	strd	r9, r8, [r4, #240]	; 0xf0
    8746:	e9c4 763e 	strd	r7, r6, [r4, #248]	; 0xf8
    874a:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
    874e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8752:	bf00      	nop
    8754:	2000a398 	.word	0x2000a398
    8758:	2000a4d0 	.word	0x2000a4d0
    875c:	0000864d 	.word	0x0000864d
    8760:	00008879 	.word	0x00008879
    8764:	00008899 	.word	0x00008899
    8768:	00010009 	.word	0x00010009
    876c:	00020012 	.word	0x00020012
    8770:	00008815 	.word	0x00008815
    8774:	00008839 	.word	0x00008839

00008778 <__sinit>:
    8778:	b510      	push	{r4, lr}
    877a:	4604      	mov	r4, r0
    877c:	480a      	ldr	r0, [pc, #40]	; (87a8 <__sinit+0x30>)
    877e:	f000 fa8f 	bl	8ca0 <__retarget_lock_acquire_recursive>
    8782:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8784:	b923      	cbnz	r3, 8790 <__sinit+0x18>
    8786:	4b09      	ldr	r3, [pc, #36]	; (87ac <__sinit+0x34>)
    8788:	4a09      	ldr	r2, [pc, #36]	; (87b0 <__sinit+0x38>)
    878a:	681b      	ldr	r3, [r3, #0]
    878c:	6362      	str	r2, [r4, #52]	; 0x34
    878e:	b123      	cbz	r3, 879a <__sinit+0x22>
    8790:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    8794:	4804      	ldr	r0, [pc, #16]	; (87a8 <__sinit+0x30>)
    8796:	f000 ba85 	b.w	8ca4 <__retarget_lock_release_recursive>
    879a:	f7ff ff83 	bl	86a4 <global_stdio_init.part.0>
    879e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    87a2:	4801      	ldr	r0, [pc, #4]	; (87a8 <__sinit+0x30>)
    87a4:	f000 ba7e 	b.w	8ca4 <__retarget_lock_release_recursive>
    87a8:	2000a360 	.word	0x2000a360
    87ac:	2000a4d0 	.word	0x2000a4d0
    87b0:	00008665 	.word	0x00008665

000087b4 <__sfp_lock_acquire>:
    87b4:	4801      	ldr	r0, [pc, #4]	; (87bc <__sfp_lock_acquire+0x8>)
    87b6:	f000 ba73 	b.w	8ca0 <__retarget_lock_acquire_recursive>
    87ba:	bf00      	nop
    87bc:	2000a360 	.word	0x2000a360

000087c0 <__sfp_lock_release>:
    87c0:	4801      	ldr	r0, [pc, #4]	; (87c8 <__sfp_lock_release+0x8>)
    87c2:	f000 ba6f 	b.w	8ca4 <__retarget_lock_release_recursive>
    87c6:	bf00      	nop
    87c8:	2000a360 	.word	0x2000a360

000087cc <_fwalk_sglue>:
    87cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    87d0:	4680      	mov	r8, r0
    87d2:	460f      	mov	r7, r1
    87d4:	4616      	mov	r6, r2
    87d6:	f04f 0900 	mov.w	r9, #0
    87da:	e9d6 5401 	ldrd	r5, r4, [r6, #4]
    87de:	3d01      	subs	r5, #1
    87e0:	d411      	bmi.n	8806 <_fwalk_sglue+0x3a>
    87e2:	89a3      	ldrh	r3, [r4, #12]
    87e4:	2b01      	cmp	r3, #1
    87e6:	f105 35ff 	add.w	r5, r5, #4294967295
    87ea:	d908      	bls.n	87fe <_fwalk_sglue+0x32>
    87ec:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
    87f0:	3301      	adds	r3, #1
    87f2:	4621      	mov	r1, r4
    87f4:	d003      	beq.n	87fe <_fwalk_sglue+0x32>
    87f6:	4640      	mov	r0, r8
    87f8:	47b8      	blx	r7
    87fa:	ea49 0900 	orr.w	r9, r9, r0
    87fe:	1c6b      	adds	r3, r5, #1
    8800:	f104 0468 	add.w	r4, r4, #104	; 0x68
    8804:	d1ed      	bne.n	87e2 <_fwalk_sglue+0x16>
    8806:	6836      	ldr	r6, [r6, #0]
    8808:	2e00      	cmp	r6, #0
    880a:	d1e6      	bne.n	87da <_fwalk_sglue+0xe>
    880c:	4648      	mov	r0, r9
    880e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8812:	bf00      	nop

00008814 <__sread>:
    8814:	b510      	push	{r4, lr}
    8816:	460c      	mov	r4, r1
    8818:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    881c:	f000 f9d4 	bl	8bc8 <_read_r>
    8820:	2800      	cmp	r0, #0
    8822:	db03      	blt.n	882c <__sread+0x18>
    8824:	6d23      	ldr	r3, [r4, #80]	; 0x50
    8826:	4403      	add	r3, r0
    8828:	6523      	str	r3, [r4, #80]	; 0x50
    882a:	bd10      	pop	{r4, pc}
    882c:	89a3      	ldrh	r3, [r4, #12]
    882e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    8832:	81a3      	strh	r3, [r4, #12]
    8834:	bd10      	pop	{r4, pc}
    8836:	bf00      	nop

00008838 <__swrite>:
    8838:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    883c:	460c      	mov	r4, r1
    883e:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
    8842:	461f      	mov	r7, r3
    8844:	05cb      	lsls	r3, r1, #23
    8846:	4605      	mov	r5, r0
    8848:	4616      	mov	r6, r2
    884a:	d40b      	bmi.n	8864 <__swrite+0x2c>
    884c:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
    8850:	81a1      	strh	r1, [r4, #12]
    8852:	463b      	mov	r3, r7
    8854:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    8858:	4632      	mov	r2, r6
    885a:	4628      	mov	r0, r5
    885c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    8860:	f000 b9da 	b.w	8c18 <_write_r>
    8864:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    8868:	2302      	movs	r3, #2
    886a:	2200      	movs	r2, #0
    886c:	f000 f996 	bl	8b9c <_lseek_r>
    8870:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
    8874:	e7ea      	b.n	884c <__swrite+0x14>
    8876:	bf00      	nop

00008878 <__sseek>:
    8878:	b510      	push	{r4, lr}
    887a:	460c      	mov	r4, r1
    887c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    8880:	f000 f98c 	bl	8b9c <_lseek_r>
    8884:	89a3      	ldrh	r3, [r4, #12]
    8886:	1c42      	adds	r2, r0, #1
    8888:	bf0e      	itee	eq
    888a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    888e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    8892:	6520      	strne	r0, [r4, #80]	; 0x50
    8894:	81a3      	strh	r3, [r4, #12]
    8896:	bd10      	pop	{r4, pc}

00008898 <__sclose>:
    8898:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    889c:	f000 b96c 	b.w	8b78 <_close_r>

000088a0 <_vdprintf_r>:
    88a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    88a2:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    88a6:	af04      	add	r7, sp, #16
    88a8:	9300      	str	r3, [sp, #0]
    88aa:	4613      	mov	r3, r2
    88ac:	f44f 7200 	mov.w	r2, #512	; 0x200
    88b0:	460e      	mov	r6, r1
    88b2:	9203      	str	r2, [sp, #12]
    88b4:	4639      	mov	r1, r7
    88b6:	aa03      	add	r2, sp, #12
    88b8:	4605      	mov	r5, r0
    88ba:	f000 f825 	bl	8908 <_vasnprintf_r>
    88be:	b188      	cbz	r0, 88e4 <_vdprintf_r+0x44>
    88c0:	4604      	mov	r4, r0
    88c2:	4602      	mov	r2, r0
    88c4:	9b03      	ldr	r3, [sp, #12]
    88c6:	4631      	mov	r1, r6
    88c8:	4628      	mov	r0, r5
    88ca:	f000 f9a5 	bl	8c18 <_write_r>
    88ce:	42bc      	cmp	r4, r7
    88d0:	9003      	str	r0, [sp, #12]
    88d2:	d004      	beq.n	88de <_vdprintf_r+0x3e>
    88d4:	4628      	mov	r0, r5
    88d6:	4621      	mov	r1, r4
    88d8:	f000 fab0 	bl	8e3c <_free_r>
    88dc:	9803      	ldr	r0, [sp, #12]
    88de:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    88e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    88e4:	f04f 30ff 	mov.w	r0, #4294967295
    88e8:	e7f9      	b.n	88de <_vdprintf_r+0x3e>
    88ea:	bf00      	nop

000088ec <vdprintf>:
    88ec:	b410      	push	{r4}
    88ee:	4c05      	ldr	r4, [pc, #20]	; (8904 <vdprintf+0x18>)
    88f0:	4684      	mov	ip, r0
    88f2:	4613      	mov	r3, r2
    88f4:	6820      	ldr	r0, [r4, #0]
    88f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    88fa:	460a      	mov	r2, r1
    88fc:	4661      	mov	r1, ip
    88fe:	f7ff bfcf 	b.w	88a0 <_vdprintf_r>
    8902:	bf00      	nop
    8904:	2000176c 	.word	0x2000176c

00008908 <_vasnprintf_r>:
    8908:	b530      	push	{r4, r5, lr}
    890a:	6814      	ldr	r4, [r2, #0]
    890c:	4615      	mov	r5, r2
    890e:	b09b      	sub	sp, #108	; 0x6c
    8910:	461a      	mov	r2, r3
    8912:	b109      	cbz	r1, 8918 <_vasnprintf_r+0x10>
    8914:	2c00      	cmp	r4, #0
    8916:	d119      	bne.n	894c <_vasnprintf_r+0x44>
    8918:	2100      	movs	r1, #0
    891a:	f44f 7322 	mov.w	r3, #648	; 0x288
    891e:	f8ad 300c 	strh.w	r3, [sp, #12]
    8922:	9100      	str	r1, [sp, #0]
    8924:	9104      	str	r1, [sp, #16]
    8926:	f64f 73ff 	movw	r3, #65535	; 0xffff
    892a:	9102      	str	r1, [sp, #8]
    892c:	9105      	str	r1, [sp, #20]
    892e:	f8ad 300e 	strh.w	r3, [sp, #14]
    8932:	4669      	mov	r1, sp
    8934:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    8936:	f000 ff67 	bl	9808 <_svfprintf_r>
    893a:	2800      	cmp	r0, #0
    893c:	db13      	blt.n	8966 <_vasnprintf_r+0x5e>
    893e:	9b00      	ldr	r3, [sp, #0]
    8940:	6028      	str	r0, [r5, #0]
    8942:	2200      	movs	r2, #0
    8944:	701a      	strb	r2, [r3, #0]
    8946:	9804      	ldr	r0, [sp, #16]
    8948:	b01b      	add	sp, #108	; 0x6c
    894a:	bd30      	pop	{r4, r5, pc}
    894c:	f44f 63c1 	mov.w	r3, #1544	; 0x608
    8950:	9100      	str	r1, [sp, #0]
    8952:	9104      	str	r1, [sp, #16]
    8954:	f8ad 300c 	strh.w	r3, [sp, #12]
    8958:	4621      	mov	r1, r4
    895a:	dae4      	bge.n	8926 <_vasnprintf_r+0x1e>
    895c:	238b      	movs	r3, #139	; 0x8b
    895e:	6003      	str	r3, [r0, #0]
    8960:	2000      	movs	r0, #0
    8962:	b01b      	add	sp, #108	; 0x6c
    8964:	bd30      	pop	{r4, r5, pc}
    8966:	2000      	movs	r0, #0
    8968:	e7ee      	b.n	8948 <_vasnprintf_r+0x40>
    896a:	bf00      	nop

0000896c <memmove>:
    896c:	4288      	cmp	r0, r1
    896e:	d90d      	bls.n	898c <memmove+0x20>
    8970:	188b      	adds	r3, r1, r2
    8972:	4283      	cmp	r3, r0
    8974:	d90a      	bls.n	898c <memmove+0x20>
    8976:	eb00 0c02 	add.w	ip, r0, r2
    897a:	b1ba      	cbz	r2, 89ac <memmove+0x40>
    897c:	4662      	mov	r2, ip
    897e:	f813 cd01 	ldrb.w	ip, [r3, #-1]!
    8982:	f802 cd01 	strb.w	ip, [r2, #-1]!
    8986:	4299      	cmp	r1, r3
    8988:	d1f9      	bne.n	897e <memmove+0x12>
    898a:	4770      	bx	lr
    898c:	2a0f      	cmp	r2, #15
    898e:	d80e      	bhi.n	89ae <memmove+0x42>
    8990:	4603      	mov	r3, r0
    8992:	f102 3cff 	add.w	ip, r2, #4294967295
    8996:	b14a      	cbz	r2, 89ac <memmove+0x40>
    8998:	f10c 0c01 	add.w	ip, ip, #1
    899c:	3b01      	subs	r3, #1
    899e:	448c      	add	ip, r1
    89a0:	f811 2b01 	ldrb.w	r2, [r1], #1
    89a4:	f803 2f01 	strb.w	r2, [r3, #1]!
    89a8:	4561      	cmp	r1, ip
    89aa:	d1f9      	bne.n	89a0 <memmove+0x34>
    89ac:	4770      	bx	lr
    89ae:	ea40 0301 	orr.w	r3, r0, r1
    89b2:	079b      	lsls	r3, r3, #30
    89b4:	d150      	bne.n	8a58 <memmove+0xec>
    89b6:	f1a2 0310 	sub.w	r3, r2, #16
    89ba:	b570      	push	{r4, r5, r6, lr}
    89bc:	f101 0c20 	add.w	ip, r1, #32
    89c0:	f023 050f 	bic.w	r5, r3, #15
    89c4:	f101 0e10 	add.w	lr, r1, #16
    89c8:	f100 0410 	add.w	r4, r0, #16
    89cc:	44ac      	add	ip, r5
    89ce:	091b      	lsrs	r3, r3, #4
    89d0:	f85e 5c10 	ldr.w	r5, [lr, #-16]
    89d4:	f844 5c10 	str.w	r5, [r4, #-16]
    89d8:	f85e 5c0c 	ldr.w	r5, [lr, #-12]
    89dc:	f844 5c0c 	str.w	r5, [r4, #-12]
    89e0:	f85e 5c08 	ldr.w	r5, [lr, #-8]
    89e4:	f844 5c08 	str.w	r5, [r4, #-8]
    89e8:	f85e 5c04 	ldr.w	r5, [lr, #-4]
    89ec:	f844 5c04 	str.w	r5, [r4, #-4]
    89f0:	f10e 0e10 	add.w	lr, lr, #16
    89f4:	45e6      	cmp	lr, ip
    89f6:	f104 0410 	add.w	r4, r4, #16
    89fa:	d1e9      	bne.n	89d0 <memmove+0x64>
    89fc:	3301      	adds	r3, #1
    89fe:	f012 0f0c 	tst.w	r2, #12
    8a02:	eb01 1103 	add.w	r1, r1, r3, lsl #4
    8a06:	f002 040f 	and.w	r4, r2, #15
    8a0a:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    8a0e:	d027      	beq.n	8a60 <memmove+0xf4>
    8a10:	3c04      	subs	r4, #4
    8a12:	f024 0603 	bic.w	r6, r4, #3
    8a16:	ea4f 0c94 	mov.w	ip, r4, lsr #2
    8a1a:	441e      	add	r6, r3
    8a1c:	1f1c      	subs	r4, r3, #4
    8a1e:	468e      	mov	lr, r1
    8a20:	f85e 5b04 	ldr.w	r5, [lr], #4
    8a24:	f844 5f04 	str.w	r5, [r4, #4]!
    8a28:	42b4      	cmp	r4, r6
    8a2a:	d1f9      	bne.n	8a20 <memmove+0xb4>
    8a2c:	f10c 0401 	add.w	r4, ip, #1
    8a30:	f002 0203 	and.w	r2, r2, #3
    8a34:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    8a38:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    8a3c:	f102 3cff 	add.w	ip, r2, #4294967295
    8a40:	b14a      	cbz	r2, 8a56 <memmove+0xea>
    8a42:	f10c 0c01 	add.w	ip, ip, #1
    8a46:	3b01      	subs	r3, #1
    8a48:	448c      	add	ip, r1
    8a4a:	f811 2b01 	ldrb.w	r2, [r1], #1
    8a4e:	f803 2f01 	strb.w	r2, [r3, #1]!
    8a52:	4561      	cmp	r1, ip
    8a54:	d1f9      	bne.n	8a4a <memmove+0xde>
    8a56:	bd70      	pop	{r4, r5, r6, pc}
    8a58:	f102 3cff 	add.w	ip, r2, #4294967295
    8a5c:	4603      	mov	r3, r0
    8a5e:	e79b      	b.n	8998 <memmove+0x2c>
    8a60:	4622      	mov	r2, r4
    8a62:	e7eb      	b.n	8a3c <memmove+0xd0>

00008a64 <memset>:
    8a64:	0783      	lsls	r3, r0, #30
    8a66:	b530      	push	{r4, r5, lr}
    8a68:	d048      	beq.n	8afc <memset+0x98>
    8a6a:	1e54      	subs	r4, r2, #1
    8a6c:	2a00      	cmp	r2, #0
    8a6e:	d03f      	beq.n	8af0 <memset+0x8c>
    8a70:	b2ca      	uxtb	r2, r1
    8a72:	4603      	mov	r3, r0
    8a74:	e001      	b.n	8a7a <memset+0x16>
    8a76:	3c01      	subs	r4, #1
    8a78:	d33a      	bcc.n	8af0 <memset+0x8c>
    8a7a:	f803 2b01 	strb.w	r2, [r3], #1
    8a7e:	079d      	lsls	r5, r3, #30
    8a80:	d1f9      	bne.n	8a76 <memset+0x12>
    8a82:	2c03      	cmp	r4, #3
    8a84:	d92d      	bls.n	8ae2 <memset+0x7e>
    8a86:	b2cd      	uxtb	r5, r1
    8a88:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    8a8c:	2c0f      	cmp	r4, #15
    8a8e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    8a92:	d936      	bls.n	8b02 <memset+0x9e>
    8a94:	f1a4 0210 	sub.w	r2, r4, #16
    8a98:	f022 0c0f 	bic.w	ip, r2, #15
    8a9c:	f103 0e20 	add.w	lr, r3, #32
    8aa0:	44e6      	add	lr, ip
    8aa2:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    8aa6:	f103 0210 	add.w	r2, r3, #16
    8aaa:	e942 5504 	strd	r5, r5, [r2, #-16]
    8aae:	e942 5502 	strd	r5, r5, [r2, #-8]
    8ab2:	3210      	adds	r2, #16
    8ab4:	4572      	cmp	r2, lr
    8ab6:	d1f8      	bne.n	8aaa <memset+0x46>
    8ab8:	f10c 0201 	add.w	r2, ip, #1
    8abc:	f014 0f0c 	tst.w	r4, #12
    8ac0:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    8ac4:	f004 0c0f 	and.w	ip, r4, #15
    8ac8:	d013      	beq.n	8af2 <memset+0x8e>
    8aca:	f1ac 0304 	sub.w	r3, ip, #4
    8ace:	f023 0303 	bic.w	r3, r3, #3
    8ad2:	3304      	adds	r3, #4
    8ad4:	4413      	add	r3, r2
    8ad6:	f842 5b04 	str.w	r5, [r2], #4
    8ada:	4293      	cmp	r3, r2
    8adc:	d1fb      	bne.n	8ad6 <memset+0x72>
    8ade:	f00c 0403 	and.w	r4, ip, #3
    8ae2:	b12c      	cbz	r4, 8af0 <memset+0x8c>
    8ae4:	b2c9      	uxtb	r1, r1
    8ae6:	441c      	add	r4, r3
    8ae8:	f803 1b01 	strb.w	r1, [r3], #1
    8aec:	429c      	cmp	r4, r3
    8aee:	d1fb      	bne.n	8ae8 <memset+0x84>
    8af0:	bd30      	pop	{r4, r5, pc}
    8af2:	4664      	mov	r4, ip
    8af4:	4613      	mov	r3, r2
    8af6:	2c00      	cmp	r4, #0
    8af8:	d1f4      	bne.n	8ae4 <memset+0x80>
    8afa:	e7f9      	b.n	8af0 <memset+0x8c>
    8afc:	4603      	mov	r3, r0
    8afe:	4614      	mov	r4, r2
    8b00:	e7bf      	b.n	8a82 <memset+0x1e>
    8b02:	461a      	mov	r2, r3
    8b04:	46a4      	mov	ip, r4
    8b06:	e7e0      	b.n	8aca <memset+0x66>

00008b08 <strncpy>:
    8b08:	ea40 0301 	orr.w	r3, r0, r1
    8b0c:	079b      	lsls	r3, r3, #30
    8b0e:	b530      	push	{r4, r5, lr}
    8b10:	d101      	bne.n	8b16 <strncpy+0xe>
    8b12:	2a03      	cmp	r2, #3
    8b14:	d80f      	bhi.n	8b36 <strncpy+0x2e>
    8b16:	4684      	mov	ip, r0
    8b18:	f101 3eff 	add.w	lr, r1, #4294967295
    8b1c:	e007      	b.n	8b2e <strncpy+0x26>
    8b1e:	f81e 1f01 	ldrb.w	r1, [lr, #1]!
    8b22:	f803 1b01 	strb.w	r1, [r3], #1
    8b26:	1e54      	subs	r4, r2, #1
    8b28:	b1c1      	cbz	r1, 8b5c <strncpy+0x54>
    8b2a:	469c      	mov	ip, r3
    8b2c:	4622      	mov	r2, r4
    8b2e:	4663      	mov	r3, ip
    8b30:	2a00      	cmp	r2, #0
    8b32:	d1f4      	bne.n	8b1e <strncpy+0x16>
    8b34:	bd30      	pop	{r4, r5, pc}
    8b36:	460b      	mov	r3, r1
    8b38:	4684      	mov	ip, r0
    8b3a:	4619      	mov	r1, r3
    8b3c:	f853 5b04 	ldr.w	r5, [r3], #4
    8b40:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
    8b44:	ea24 0405 	bic.w	r4, r4, r5
    8b48:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
    8b4c:	d1e4      	bne.n	8b18 <strncpy+0x10>
    8b4e:	3a04      	subs	r2, #4
    8b50:	2a03      	cmp	r2, #3
    8b52:	f84c 5b04 	str.w	r5, [ip], #4
    8b56:	4619      	mov	r1, r3
    8b58:	d8ef      	bhi.n	8b3a <strncpy+0x32>
    8b5a:	e7dd      	b.n	8b18 <strncpy+0x10>
    8b5c:	4494      	add	ip, r2
    8b5e:	2c00      	cmp	r4, #0
    8b60:	d0e8      	beq.n	8b34 <strncpy+0x2c>
    8b62:	f803 1b01 	strb.w	r1, [r3], #1
    8b66:	4563      	cmp	r3, ip
    8b68:	d1fb      	bne.n	8b62 <strncpy+0x5a>
    8b6a:	bd30      	pop	{r4, r5, pc}

00008b6c <__locale_mb_cur_max>:
    8b6c:	4b01      	ldr	r3, [pc, #4]	; (8b74 <__locale_mb_cur_max+0x8>)
    8b6e:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
    8b72:	4770      	bx	lr
    8b74:	200011e4 	.word	0x200011e4

00008b78 <_close_r>:
    8b78:	b538      	push	{r3, r4, r5, lr}
    8b7a:	4d07      	ldr	r5, [pc, #28]	; (8b98 <_close_r+0x20>)
    8b7c:	2200      	movs	r2, #0
    8b7e:	4604      	mov	r4, r0
    8b80:	4608      	mov	r0, r1
    8b82:	602a      	str	r2, [r5, #0]
    8b84:	f7fd ff9c 	bl	6ac0 <_close>
    8b88:	1c43      	adds	r3, r0, #1
    8b8a:	d000      	beq.n	8b8e <_close_r+0x16>
    8b8c:	bd38      	pop	{r3, r4, r5, pc}
    8b8e:	682b      	ldr	r3, [r5, #0]
    8b90:	2b00      	cmp	r3, #0
    8b92:	d0fb      	beq.n	8b8c <_close_r+0x14>
    8b94:	6023      	str	r3, [r4, #0]
    8b96:	bd38      	pop	{r3, r4, r5, pc}
    8b98:	2000a4e8 	.word	0x2000a4e8

00008b9c <_lseek_r>:
    8b9c:	b538      	push	{r3, r4, r5, lr}
    8b9e:	460c      	mov	r4, r1
    8ba0:	4d08      	ldr	r5, [pc, #32]	; (8bc4 <_lseek_r+0x28>)
    8ba2:	4684      	mov	ip, r0
    8ba4:	4611      	mov	r1, r2
    8ba6:	4620      	mov	r0, r4
    8ba8:	461a      	mov	r2, r3
    8baa:	2300      	movs	r3, #0
    8bac:	602b      	str	r3, [r5, #0]
    8bae:	4664      	mov	r4, ip
    8bb0:	f7fd ff92 	bl	6ad8 <_lseek>
    8bb4:	1c43      	adds	r3, r0, #1
    8bb6:	d000      	beq.n	8bba <_lseek_r+0x1e>
    8bb8:	bd38      	pop	{r3, r4, r5, pc}
    8bba:	682b      	ldr	r3, [r5, #0]
    8bbc:	2b00      	cmp	r3, #0
    8bbe:	d0fb      	beq.n	8bb8 <_lseek_r+0x1c>
    8bc0:	6023      	str	r3, [r4, #0]
    8bc2:	bd38      	pop	{r3, r4, r5, pc}
    8bc4:	2000a4e8 	.word	0x2000a4e8

00008bc8 <_read_r>:
    8bc8:	b538      	push	{r3, r4, r5, lr}
    8bca:	460c      	mov	r4, r1
    8bcc:	4d08      	ldr	r5, [pc, #32]	; (8bf0 <_read_r+0x28>)
    8bce:	4684      	mov	ip, r0
    8bd0:	4611      	mov	r1, r2
    8bd2:	4620      	mov	r0, r4
    8bd4:	461a      	mov	r2, r3
    8bd6:	2300      	movs	r3, #0
    8bd8:	602b      	str	r3, [r5, #0]
    8bda:	4664      	mov	r4, ip
    8bdc:	f7fd ff6e 	bl	6abc <_read>
    8be0:	1c43      	adds	r3, r0, #1
    8be2:	d000      	beq.n	8be6 <_read_r+0x1e>
    8be4:	bd38      	pop	{r3, r4, r5, pc}
    8be6:	682b      	ldr	r3, [r5, #0]
    8be8:	2b00      	cmp	r3, #0
    8bea:	d0fb      	beq.n	8be4 <_read_r+0x1c>
    8bec:	6023      	str	r3, [r4, #0]
    8bee:	bd38      	pop	{r3, r4, r5, pc}
    8bf0:	2000a4e8 	.word	0x2000a4e8

00008bf4 <_sbrk_r>:
    8bf4:	b538      	push	{r3, r4, r5, lr}
    8bf6:	4d07      	ldr	r5, [pc, #28]	; (8c14 <_sbrk_r+0x20>)
    8bf8:	2200      	movs	r2, #0
    8bfa:	4604      	mov	r4, r0
    8bfc:	4608      	mov	r0, r1
    8bfe:	602a      	str	r2, [r5, #0]
    8c00:	f7fd ff42 	bl	6a88 <_sbrk>
    8c04:	1c43      	adds	r3, r0, #1
    8c06:	d000      	beq.n	8c0a <_sbrk_r+0x16>
    8c08:	bd38      	pop	{r3, r4, r5, pc}
    8c0a:	682b      	ldr	r3, [r5, #0]
    8c0c:	2b00      	cmp	r3, #0
    8c0e:	d0fb      	beq.n	8c08 <_sbrk_r+0x14>
    8c10:	6023      	str	r3, [r4, #0]
    8c12:	bd38      	pop	{r3, r4, r5, pc}
    8c14:	2000a4e8 	.word	0x2000a4e8

00008c18 <_write_r>:
    8c18:	b538      	push	{r3, r4, r5, lr}
    8c1a:	460c      	mov	r4, r1
    8c1c:	4d08      	ldr	r5, [pc, #32]	; (8c40 <_write_r+0x28>)
    8c1e:	4684      	mov	ip, r0
    8c20:	4611      	mov	r1, r2
    8c22:	4620      	mov	r0, r4
    8c24:	461a      	mov	r2, r3
    8c26:	2300      	movs	r3, #0
    8c28:	602b      	str	r3, [r5, #0]
    8c2a:	4664      	mov	r4, ip
    8c2c:	f7fc feea 	bl	5a04 <_write>
    8c30:	1c43      	adds	r3, r0, #1
    8c32:	d000      	beq.n	8c36 <_write_r+0x1e>
    8c34:	bd38      	pop	{r3, r4, r5, pc}
    8c36:	682b      	ldr	r3, [r5, #0]
    8c38:	2b00      	cmp	r3, #0
    8c3a:	d0fb      	beq.n	8c34 <_write_r+0x1c>
    8c3c:	6023      	str	r3, [r4, #0]
    8c3e:	bd38      	pop	{r3, r4, r5, pc}
    8c40:	2000a4e8 	.word	0x2000a4e8

00008c44 <__errno>:
    8c44:	4b01      	ldr	r3, [pc, #4]	; (8c4c <__errno+0x8>)
    8c46:	6818      	ldr	r0, [r3, #0]
    8c48:	4770      	bx	lr
    8c4a:	bf00      	nop
    8c4c:	2000176c 	.word	0x2000176c

00008c50 <__libc_init_array>:
    8c50:	b570      	push	{r4, r5, r6, lr}
    8c52:	4e0d      	ldr	r6, [pc, #52]	; (8c88 <__libc_init_array+0x38>)
    8c54:	4d0d      	ldr	r5, [pc, #52]	; (8c8c <__libc_init_array+0x3c>)
    8c56:	1b76      	subs	r6, r6, r5
    8c58:	10b6      	asrs	r6, r6, #2
    8c5a:	d006      	beq.n	8c6a <__libc_init_array+0x1a>
    8c5c:	2400      	movs	r4, #0
    8c5e:	f855 3b04 	ldr.w	r3, [r5], #4
    8c62:	3401      	adds	r4, #1
    8c64:	4798      	blx	r3
    8c66:	42a6      	cmp	r6, r4
    8c68:	d1f9      	bne.n	8c5e <__libc_init_array+0xe>
    8c6a:	4e09      	ldr	r6, [pc, #36]	; (8c90 <__libc_init_array+0x40>)
    8c6c:	4d09      	ldr	r5, [pc, #36]	; (8c94 <__libc_init_array+0x44>)
    8c6e:	1b76      	subs	r6, r6, r5
    8c70:	f005 f982 	bl	df78 <___init_veneer>
    8c74:	10b6      	asrs	r6, r6, #2
    8c76:	d006      	beq.n	8c86 <__libc_init_array+0x36>
    8c78:	2400      	movs	r4, #0
    8c7a:	f855 3b04 	ldr.w	r3, [r5], #4
    8c7e:	3401      	adds	r4, #1
    8c80:	4798      	blx	r3
    8c82:	42a6      	cmp	r6, r4
    8c84:	d1f9      	bne.n	8c7a <__libc_init_array+0x2a>
    8c86:	bd70      	pop	{r4, r5, r6, pc}
    8c88:	60001af0 	.word	0x60001af0
    8c8c:	60001af0 	.word	0x60001af0
    8c90:	60001b0c 	.word	0x60001b0c
    8c94:	60001af0 	.word	0x60001af0

00008c98 <__retarget_lock_init_recursive>:
    8c98:	4770      	bx	lr
    8c9a:	bf00      	nop

00008c9c <__retarget_lock_close_recursive>:
    8c9c:	4770      	bx	lr
    8c9e:	bf00      	nop

00008ca0 <__retarget_lock_acquire_recursive>:
    8ca0:	4770      	bx	lr
    8ca2:	bf00      	nop

00008ca4 <__retarget_lock_release_recursive>:
    8ca4:	4770      	bx	lr
    8ca6:	bf00      	nop
	...

00008cc0 <strlen>:
    8cc0:	f890 f000 	pld	[r0]
    8cc4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    8cc8:	f020 0107 	bic.w	r1, r0, #7
    8ccc:	f06f 0c00 	mvn.w	ip, #0
    8cd0:	f010 0407 	ands.w	r4, r0, #7
    8cd4:	f891 f020 	pld	[r1, #32]
    8cd8:	f040 8049 	bne.w	8d6e <strlen+0xae>
    8cdc:	f04f 0400 	mov.w	r4, #0
    8ce0:	f06f 0007 	mvn.w	r0, #7
    8ce4:	e9d1 2300 	ldrd	r2, r3, [r1]
    8ce8:	f891 f040 	pld	[r1, #64]	; 0x40
    8cec:	f100 0008 	add.w	r0, r0, #8
    8cf0:	fa82 f24c 	uadd8	r2, r2, ip
    8cf4:	faa4 f28c 	sel	r2, r4, ip
    8cf8:	fa83 f34c 	uadd8	r3, r3, ip
    8cfc:	faa2 f38c 	sel	r3, r2, ip
    8d00:	bb4b      	cbnz	r3, 8d56 <strlen+0x96>
    8d02:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    8d06:	fa82 f24c 	uadd8	r2, r2, ip
    8d0a:	f100 0008 	add.w	r0, r0, #8
    8d0e:	faa4 f28c 	sel	r2, r4, ip
    8d12:	fa83 f34c 	uadd8	r3, r3, ip
    8d16:	faa2 f38c 	sel	r3, r2, ip
    8d1a:	b9e3      	cbnz	r3, 8d56 <strlen+0x96>
    8d1c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    8d20:	fa82 f24c 	uadd8	r2, r2, ip
    8d24:	f100 0008 	add.w	r0, r0, #8
    8d28:	faa4 f28c 	sel	r2, r4, ip
    8d2c:	fa83 f34c 	uadd8	r3, r3, ip
    8d30:	faa2 f38c 	sel	r3, r2, ip
    8d34:	b97b      	cbnz	r3, 8d56 <strlen+0x96>
    8d36:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    8d3a:	f101 0120 	add.w	r1, r1, #32
    8d3e:	fa82 f24c 	uadd8	r2, r2, ip
    8d42:	f100 0008 	add.w	r0, r0, #8
    8d46:	faa4 f28c 	sel	r2, r4, ip
    8d4a:	fa83 f34c 	uadd8	r3, r3, ip
    8d4e:	faa2 f38c 	sel	r3, r2, ip
    8d52:	2b00      	cmp	r3, #0
    8d54:	d0c6      	beq.n	8ce4 <strlen+0x24>
    8d56:	2a00      	cmp	r2, #0
    8d58:	bf04      	itt	eq
    8d5a:	3004      	addeq	r0, #4
    8d5c:	461a      	moveq	r2, r3
    8d5e:	ba12      	rev	r2, r2
    8d60:	fab2 f282 	clz	r2, r2
    8d64:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    8d68:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    8d6c:	4770      	bx	lr
    8d6e:	e9d1 2300 	ldrd	r2, r3, [r1]
    8d72:	f004 0503 	and.w	r5, r4, #3
    8d76:	f1c4 0000 	rsb	r0, r4, #0
    8d7a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    8d7e:	f014 0f04 	tst.w	r4, #4
    8d82:	f891 f040 	pld	[r1, #64]	; 0x40
    8d86:	fa0c f505 	lsl.w	r5, ip, r5
    8d8a:	ea62 0205 	orn	r2, r2, r5
    8d8e:	bf1c      	itt	ne
    8d90:	ea63 0305 	ornne	r3, r3, r5
    8d94:	4662      	movne	r2, ip
    8d96:	f04f 0400 	mov.w	r4, #0
    8d9a:	e7a9      	b.n	8cf0 <strlen+0x30>

00008d9c <_malloc_trim_r>:
    8d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8d9e:	4f24      	ldr	r7, [pc, #144]	; (8e30 <_malloc_trim_r+0x94>)
    8da0:	460c      	mov	r4, r1
    8da2:	4606      	mov	r6, r0
    8da4:	f7ff fa5a 	bl	825c <__malloc_lock>
    8da8:	68bb      	ldr	r3, [r7, #8]
    8daa:	685d      	ldr	r5, [r3, #4]
    8dac:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
    8db0:	310f      	adds	r1, #15
    8db2:	f025 0503 	bic.w	r5, r5, #3
    8db6:	194b      	adds	r3, r1, r5
    8db8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
    8dbc:	f023 030f 	bic.w	r3, r3, #15
    8dc0:	f5a3 5480 	sub.w	r4, r3, #4096	; 0x1000
    8dc4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    8dc8:	db07      	blt.n	8dda <_malloc_trim_r+0x3e>
    8dca:	2100      	movs	r1, #0
    8dcc:	4630      	mov	r0, r6
    8dce:	f7ff ff11 	bl	8bf4 <_sbrk_r>
    8dd2:	68bb      	ldr	r3, [r7, #8]
    8dd4:	442b      	add	r3, r5
    8dd6:	4298      	cmp	r0, r3
    8dd8:	d004      	beq.n	8de4 <_malloc_trim_r+0x48>
    8dda:	4630      	mov	r0, r6
    8ddc:	f7ff fa44 	bl	8268 <__malloc_unlock>
    8de0:	2000      	movs	r0, #0
    8de2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8de4:	4261      	negs	r1, r4
    8de6:	4630      	mov	r0, r6
    8de8:	f7ff ff04 	bl	8bf4 <_sbrk_r>
    8dec:	3001      	adds	r0, #1
    8dee:	d00d      	beq.n	8e0c <_malloc_trim_r+0x70>
    8df0:	4a10      	ldr	r2, [pc, #64]	; (8e34 <_malloc_trim_r+0x98>)
    8df2:	68bb      	ldr	r3, [r7, #8]
    8df4:	1b2d      	subs	r5, r5, r4
    8df6:	f045 0501 	orr.w	r5, r5, #1
    8dfa:	605d      	str	r5, [r3, #4]
    8dfc:	6813      	ldr	r3, [r2, #0]
    8dfe:	4630      	mov	r0, r6
    8e00:	1b1b      	subs	r3, r3, r4
    8e02:	6013      	str	r3, [r2, #0]
    8e04:	f7ff fa30 	bl	8268 <__malloc_unlock>
    8e08:	2001      	movs	r0, #1
    8e0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8e0c:	2100      	movs	r1, #0
    8e0e:	4630      	mov	r0, r6
    8e10:	f7ff fef0 	bl	8bf4 <_sbrk_r>
    8e14:	68ba      	ldr	r2, [r7, #8]
    8e16:	1a83      	subs	r3, r0, r2
    8e18:	2b0f      	cmp	r3, #15
    8e1a:	ddde      	ble.n	8dda <_malloc_trim_r+0x3e>
    8e1c:	f043 0301 	orr.w	r3, r3, #1
    8e20:	6053      	str	r3, [r2, #4]
    8e22:	4b05      	ldr	r3, [pc, #20]	; (8e38 <_malloc_trim_r+0x9c>)
    8e24:	4903      	ldr	r1, [pc, #12]	; (8e34 <_malloc_trim_r+0x98>)
    8e26:	681b      	ldr	r3, [r3, #0]
    8e28:	1ac0      	subs	r0, r0, r3
    8e2a:	6008      	str	r0, [r1, #0]
    8e2c:	e7d5      	b.n	8dda <_malloc_trim_r+0x3e>
    8e2e:	bf00      	nop
    8e30:	20001350 	.word	0x20001350
    8e34:	2000a364 	.word	0x2000a364
    8e38:	20001758 	.word	0x20001758

00008e3c <_free_r>:
    8e3c:	2900      	cmp	r1, #0
    8e3e:	d061      	beq.n	8f04 <_free_r+0xc8>
    8e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8e42:	460c      	mov	r4, r1
    8e44:	4606      	mov	r6, r0
    8e46:	f7ff fa09 	bl	825c <__malloc_lock>
    8e4a:	f854 2c04 	ldr.w	r2, [r4, #-4]
    8e4e:	4f7b      	ldr	r7, [pc, #492]	; (903c <_free_r+0x200>)
    8e50:	f1a4 0508 	sub.w	r5, r4, #8
    8e54:	f022 0101 	bic.w	r1, r2, #1
    8e58:	eb05 0c01 	add.w	ip, r5, r1
    8e5c:	68b8      	ldr	r0, [r7, #8]
    8e5e:	f8dc 3004 	ldr.w	r3, [ip, #4]
    8e62:	4560      	cmp	r0, ip
    8e64:	f023 0303 	bic.w	r3, r3, #3
    8e68:	f000 808b 	beq.w	8f82 <_free_r+0x146>
    8e6c:	07d2      	lsls	r2, r2, #31
    8e6e:	f8cc 3004 	str.w	r3, [ip, #4]
    8e72:	d432      	bmi.n	8eda <_free_r+0x9e>
    8e74:	f854 2c08 	ldr.w	r2, [r4, #-8]
    8e78:	1aad      	subs	r5, r5, r2
    8e7a:	4411      	add	r1, r2
    8e7c:	68aa      	ldr	r2, [r5, #8]
    8e7e:	f107 0008 	add.w	r0, r7, #8
    8e82:	4282      	cmp	r2, r0
    8e84:	d06a      	beq.n	8f5c <_free_r+0x120>
    8e86:	eb0c 0403 	add.w	r4, ip, r3
    8e8a:	f8d4 e004 	ldr.w	lr, [r4, #4]
    8e8e:	68ec      	ldr	r4, [r5, #12]
    8e90:	60d4      	str	r4, [r2, #12]
    8e92:	f01e 0f01 	tst.w	lr, #1
    8e96:	60a2      	str	r2, [r4, #8]
    8e98:	f000 8097 	beq.w	8fca <_free_r+0x18e>
    8e9c:	f041 0301 	orr.w	r3, r1, #1
    8ea0:	606b      	str	r3, [r5, #4]
    8ea2:	f8cc 1000 	str.w	r1, [ip]
    8ea6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    8eaa:	d235      	bcs.n	8f18 <_free_r+0xdc>
    8eac:	6878      	ldr	r0, [r7, #4]
    8eae:	08cb      	lsrs	r3, r1, #3
    8eb0:	2201      	movs	r2, #1
    8eb2:	0949      	lsrs	r1, r1, #5
    8eb4:	3301      	adds	r3, #1
    8eb6:	408a      	lsls	r2, r1
    8eb8:	4302      	orrs	r2, r0
    8eba:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
    8ebe:	607a      	str	r2, [r7, #4]
    8ec0:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    8ec4:	3a08      	subs	r2, #8
    8ec6:	e9c5 1202 	strd	r1, r2, [r5, #8]
    8eca:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
    8ece:	60cd      	str	r5, [r1, #12]
    8ed0:	4630      	mov	r0, r6
    8ed2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8ed6:	f7ff b9c7 	b.w	8268 <__malloc_unlock>
    8eda:	eb0c 0203 	add.w	r2, ip, r3
    8ede:	6852      	ldr	r2, [r2, #4]
    8ee0:	07d0      	lsls	r0, r2, #31
    8ee2:	d410      	bmi.n	8f06 <_free_r+0xca>
    8ee4:	4419      	add	r1, r3
    8ee6:	f107 0008 	add.w	r0, r7, #8
    8eea:	f8dc 3008 	ldr.w	r3, [ip, #8]
    8eee:	4283      	cmp	r3, r0
    8ef0:	d073      	beq.n	8fda <_free_r+0x19e>
    8ef2:	f8dc 200c 	ldr.w	r2, [ip, #12]
    8ef6:	60da      	str	r2, [r3, #12]
    8ef8:	6093      	str	r3, [r2, #8]
    8efa:	f041 0301 	orr.w	r3, r1, #1
    8efe:	606b      	str	r3, [r5, #4]
    8f00:	5069      	str	r1, [r5, r1]
    8f02:	e7d0      	b.n	8ea6 <_free_r+0x6a>
    8f04:	4770      	bx	lr
    8f06:	f041 0301 	orr.w	r3, r1, #1
    8f0a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    8f0e:	f844 3c04 	str.w	r3, [r4, #-4]
    8f12:	f8cc 1000 	str.w	r1, [ip]
    8f16:	d3c9      	bcc.n	8eac <_free_r+0x70>
    8f18:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
    8f1c:	ea4f 2351 	mov.w	r3, r1, lsr #9
    8f20:	d248      	bcs.n	8fb4 <_free_r+0x178>
    8f22:	098b      	lsrs	r3, r1, #6
    8f24:	f103 0039 	add.w	r0, r3, #57	; 0x39
    8f28:	f103 0238 	add.w	r2, r3, #56	; 0x38
    8f2c:	00c3      	lsls	r3, r0, #3
    8f2e:	18f8      	adds	r0, r7, r3
    8f30:	58fb      	ldr	r3, [r7, r3]
    8f32:	3808      	subs	r0, #8
    8f34:	4298      	cmp	r0, r3
    8f36:	d059      	beq.n	8fec <_free_r+0x1b0>
    8f38:	685a      	ldr	r2, [r3, #4]
    8f3a:	f022 0203 	bic.w	r2, r2, #3
    8f3e:	428a      	cmp	r2, r1
    8f40:	d902      	bls.n	8f48 <_free_r+0x10c>
    8f42:	689b      	ldr	r3, [r3, #8]
    8f44:	4298      	cmp	r0, r3
    8f46:	d1f7      	bne.n	8f38 <_free_r+0xfc>
    8f48:	68d8      	ldr	r0, [r3, #12]
    8f4a:	e9c5 3002 	strd	r3, r0, [r5, #8]
    8f4e:	6085      	str	r5, [r0, #8]
    8f50:	60dd      	str	r5, [r3, #12]
    8f52:	4630      	mov	r0, r6
    8f54:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8f58:	f7ff b986 	b.w	8268 <__malloc_unlock>
    8f5c:	eb0c 0203 	add.w	r2, ip, r3
    8f60:	6852      	ldr	r2, [r2, #4]
    8f62:	07d2      	lsls	r2, r2, #31
    8f64:	d463      	bmi.n	902e <_free_r+0x1f2>
    8f66:	440b      	add	r3, r1
    8f68:	e9dc 1202 	ldrd	r1, r2, [ip, #8]
    8f6c:	60ca      	str	r2, [r1, #12]
    8f6e:	6091      	str	r1, [r2, #8]
    8f70:	f043 0201 	orr.w	r2, r3, #1
    8f74:	606a      	str	r2, [r5, #4]
    8f76:	4630      	mov	r0, r6
    8f78:	50eb      	str	r3, [r5, r3]
    8f7a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8f7e:	f7ff b973 	b.w	8268 <__malloc_unlock>
    8f82:	440b      	add	r3, r1
    8f84:	07d1      	lsls	r1, r2, #31
    8f86:	d407      	bmi.n	8f98 <_free_r+0x15c>
    8f88:	f854 2c08 	ldr.w	r2, [r4, #-8]
    8f8c:	1aad      	subs	r5, r5, r2
    8f8e:	4413      	add	r3, r2
    8f90:	e9d5 1202 	ldrd	r1, r2, [r5, #8]
    8f94:	60ca      	str	r2, [r1, #12]
    8f96:	6091      	str	r1, [r2, #8]
    8f98:	f043 0201 	orr.w	r2, r3, #1
    8f9c:	606a      	str	r2, [r5, #4]
    8f9e:	4a28      	ldr	r2, [pc, #160]	; (9040 <_free_r+0x204>)
    8fa0:	60bd      	str	r5, [r7, #8]
    8fa2:	6812      	ldr	r2, [r2, #0]
    8fa4:	429a      	cmp	r2, r3
    8fa6:	d893      	bhi.n	8ed0 <_free_r+0x94>
    8fa8:	4b26      	ldr	r3, [pc, #152]	; (9044 <_free_r+0x208>)
    8faa:	4630      	mov	r0, r6
    8fac:	6819      	ldr	r1, [r3, #0]
    8fae:	f7ff fef5 	bl	8d9c <_malloc_trim_r>
    8fb2:	e78d      	b.n	8ed0 <_free_r+0x94>
    8fb4:	2b14      	cmp	r3, #20
    8fb6:	d90a      	bls.n	8fce <_free_r+0x192>
    8fb8:	2b54      	cmp	r3, #84	; 0x54
    8fba:	d81f      	bhi.n	8ffc <_free_r+0x1c0>
    8fbc:	0b0b      	lsrs	r3, r1, #12
    8fbe:	f103 006f 	add.w	r0, r3, #111	; 0x6f
    8fc2:	f103 026e 	add.w	r2, r3, #110	; 0x6e
    8fc6:	00c3      	lsls	r3, r0, #3
    8fc8:	e7b1      	b.n	8f2e <_free_r+0xf2>
    8fca:	4419      	add	r1, r3
    8fcc:	e78d      	b.n	8eea <_free_r+0xae>
    8fce:	f103 005c 	add.w	r0, r3, #92	; 0x5c
    8fd2:	f103 025b 	add.w	r2, r3, #91	; 0x5b
    8fd6:	00c3      	lsls	r3, r0, #3
    8fd8:	e7a9      	b.n	8f2e <_free_r+0xf2>
    8fda:	f041 0301 	orr.w	r3, r1, #1
    8fde:	e9c7 5504 	strd	r5, r5, [r7, #16]
    8fe2:	e9c5 0002 	strd	r0, r0, [r5, #8]
    8fe6:	606b      	str	r3, [r5, #4]
    8fe8:	5069      	str	r1, [r5, r1]
    8fea:	e771      	b.n	8ed0 <_free_r+0x94>
    8fec:	6879      	ldr	r1, [r7, #4]
    8fee:	1092      	asrs	r2, r2, #2
    8ff0:	2401      	movs	r4, #1
    8ff2:	fa04 f202 	lsl.w	r2, r4, r2
    8ff6:	430a      	orrs	r2, r1
    8ff8:	607a      	str	r2, [r7, #4]
    8ffa:	e7a6      	b.n	8f4a <_free_r+0x10e>
    8ffc:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    9000:	d806      	bhi.n	9010 <_free_r+0x1d4>
    9002:	0bcb      	lsrs	r3, r1, #15
    9004:	f103 0078 	add.w	r0, r3, #120	; 0x78
    9008:	f103 0277 	add.w	r2, r3, #119	; 0x77
    900c:	00c3      	lsls	r3, r0, #3
    900e:	e78e      	b.n	8f2e <_free_r+0xf2>
    9010:	f240 5254 	movw	r2, #1364	; 0x554
    9014:	4293      	cmp	r3, r2
    9016:	d806      	bhi.n	9026 <_free_r+0x1ea>
    9018:	0c8b      	lsrs	r3, r1, #18
    901a:	f103 007d 	add.w	r0, r3, #125	; 0x7d
    901e:	f103 027c 	add.w	r2, r3, #124	; 0x7c
    9022:	00c3      	lsls	r3, r0, #3
    9024:	e783      	b.n	8f2e <_free_r+0xf2>
    9026:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    902a:	227e      	movs	r2, #126	; 0x7e
    902c:	e77f      	b.n	8f2e <_free_r+0xf2>
    902e:	f041 0301 	orr.w	r3, r1, #1
    9032:	606b      	str	r3, [r5, #4]
    9034:	f8cc 1000 	str.w	r1, [ip]
    9038:	e74a      	b.n	8ed0 <_free_r+0x94>
    903a:	bf00      	nop
    903c:	20001350 	.word	0x20001350
    9040:	2000175c 	.word	0x2000175c
    9044:	2000a394 	.word	0x2000a394

00009048 <__ascii_mbtowc>:
    9048:	b082      	sub	sp, #8
    904a:	b149      	cbz	r1, 9060 <__ascii_mbtowc+0x18>
    904c:	b15a      	cbz	r2, 9066 <__ascii_mbtowc+0x1e>
    904e:	b16b      	cbz	r3, 906c <__ascii_mbtowc+0x24>
    9050:	7813      	ldrb	r3, [r2, #0]
    9052:	600b      	str	r3, [r1, #0]
    9054:	7812      	ldrb	r2, [r2, #0]
    9056:	1e10      	subs	r0, r2, #0
    9058:	bf18      	it	ne
    905a:	2001      	movne	r0, #1
    905c:	b002      	add	sp, #8
    905e:	4770      	bx	lr
    9060:	a901      	add	r1, sp, #4
    9062:	2a00      	cmp	r2, #0
    9064:	d1f3      	bne.n	904e <__ascii_mbtowc+0x6>
    9066:	4610      	mov	r0, r2
    9068:	b002      	add	sp, #8
    906a:	4770      	bx	lr
    906c:	f06f 0001 	mvn.w	r0, #1
    9070:	e7f4      	b.n	905c <__ascii_mbtowc+0x14>
    9072:	bf00      	nop

00009074 <_Balloc>:
    9074:	6c43      	ldr	r3, [r0, #68]	; 0x44
    9076:	b570      	push	{r4, r5, r6, lr}
    9078:	4605      	mov	r5, r0
    907a:	460c      	mov	r4, r1
    907c:	b14b      	cbz	r3, 9092 <_Balloc+0x1e>
    907e:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    9082:	b180      	cbz	r0, 90a6 <_Balloc+0x32>
    9084:	6802      	ldr	r2, [r0, #0]
    9086:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    908a:	2300      	movs	r3, #0
    908c:	e9c0 3303 	strd	r3, r3, [r0, #12]
    9090:	bd70      	pop	{r4, r5, r6, pc}
    9092:	2221      	movs	r2, #33	; 0x21
    9094:	2104      	movs	r1, #4
    9096:	f002 fb2f 	bl	b6f8 <_calloc_r>
    909a:	4603      	mov	r3, r0
    909c:	6468      	str	r0, [r5, #68]	; 0x44
    909e:	2800      	cmp	r0, #0
    90a0:	d1ed      	bne.n	907e <_Balloc+0xa>
    90a2:	2000      	movs	r0, #0
    90a4:	bd70      	pop	{r4, r5, r6, pc}
    90a6:	2101      	movs	r1, #1
    90a8:	fa01 f604 	lsl.w	r6, r1, r4
    90ac:	1d72      	adds	r2, r6, #5
    90ae:	0092      	lsls	r2, r2, #2
    90b0:	4628      	mov	r0, r5
    90b2:	f002 fb21 	bl	b6f8 <_calloc_r>
    90b6:	2800      	cmp	r0, #0
    90b8:	d0f3      	beq.n	90a2 <_Balloc+0x2e>
    90ba:	e9c0 4601 	strd	r4, r6, [r0, #4]
    90be:	e7e4      	b.n	908a <_Balloc+0x16>

000090c0 <_Bfree>:
    90c0:	b131      	cbz	r1, 90d0 <_Bfree+0x10>
    90c2:	6c43      	ldr	r3, [r0, #68]	; 0x44
    90c4:	684a      	ldr	r2, [r1, #4]
    90c6:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    90ca:	6008      	str	r0, [r1, #0]
    90cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    90d0:	4770      	bx	lr
    90d2:	bf00      	nop

000090d4 <__multadd>:
    90d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    90d8:	690e      	ldr	r6, [r1, #16]
    90da:	4680      	mov	r8, r0
    90dc:	460f      	mov	r7, r1
    90de:	461d      	mov	r5, r3
    90e0:	f101 0e14 	add.w	lr, r1, #20
    90e4:	2000      	movs	r0, #0
    90e6:	f8de 1000 	ldr.w	r1, [lr]
    90ea:	b28c      	uxth	r4, r1
    90ec:	fb02 5304 	mla	r3, r2, r4, r5
    90f0:	0c09      	lsrs	r1, r1, #16
    90f2:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    90f6:	fb02 cc01 	mla	ip, r2, r1, ip
    90fa:	3001      	adds	r0, #1
    90fc:	b29c      	uxth	r4, r3
    90fe:	eb04 440c 	add.w	r4, r4, ip, lsl #16
    9102:	4286      	cmp	r6, r0
    9104:	f84e 4b04 	str.w	r4, [lr], #4
    9108:	ea4f 451c 	mov.w	r5, ip, lsr #16
    910c:	dceb      	bgt.n	90e6 <__multadd+0x12>
    910e:	b13d      	cbz	r5, 9120 <__multadd+0x4c>
    9110:	68bb      	ldr	r3, [r7, #8]
    9112:	42b3      	cmp	r3, r6
    9114:	dd07      	ble.n	9126 <__multadd+0x52>
    9116:	eb07 0386 	add.w	r3, r7, r6, lsl #2
    911a:	3601      	adds	r6, #1
    911c:	615d      	str	r5, [r3, #20]
    911e:	613e      	str	r6, [r7, #16]
    9120:	4638      	mov	r0, r7
    9122:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9126:	6879      	ldr	r1, [r7, #4]
    9128:	4640      	mov	r0, r8
    912a:	3101      	adds	r1, #1
    912c:	f7ff ffa2 	bl	9074 <_Balloc>
    9130:	4604      	mov	r4, r0
    9132:	b1b0      	cbz	r0, 9162 <__multadd+0x8e>
    9134:	693a      	ldr	r2, [r7, #16]
    9136:	3202      	adds	r2, #2
    9138:	f107 010c 	add.w	r1, r7, #12
    913c:	0092      	lsls	r2, r2, #2
    913e:	300c      	adds	r0, #12
    9140:	f7fd f998 	bl	6474 <memcpy>
    9144:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    9148:	687a      	ldr	r2, [r7, #4]
    914a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    914e:	6039      	str	r1, [r7, #0]
    9150:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
    9154:	4627      	mov	r7, r4
    9156:	eb07 0386 	add.w	r3, r7, r6, lsl #2
    915a:	3601      	adds	r6, #1
    915c:	615d      	str	r5, [r3, #20]
    915e:	613e      	str	r6, [r7, #16]
    9160:	e7de      	b.n	9120 <__multadd+0x4c>
    9162:	4b03      	ldr	r3, [pc, #12]	; (9170 <__multadd+0x9c>)
    9164:	4803      	ldr	r0, [pc, #12]	; (9174 <__multadd+0xa0>)
    9166:	4622      	mov	r2, r4
    9168:	21ba      	movs	r1, #186	; 0xba
    916a:	f002 faa5 	bl	b6b8 <__assert_func>
    916e:	bf00      	nop
    9170:	2000093c 	.word	0x2000093c
    9174:	20000950 	.word	0x20000950

00009178 <__hi0bits>:
    9178:	0c03      	lsrs	r3, r0, #16
    917a:	041b      	lsls	r3, r3, #16
    917c:	b9d3      	cbnz	r3, 91b4 <__hi0bits+0x3c>
    917e:	0400      	lsls	r0, r0, #16
    9180:	2310      	movs	r3, #16
    9182:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    9186:	bf04      	itt	eq
    9188:	0200      	lsleq	r0, r0, #8
    918a:	3308      	addeq	r3, #8
    918c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    9190:	bf04      	itt	eq
    9192:	0100      	lsleq	r0, r0, #4
    9194:	3304      	addeq	r3, #4
    9196:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    919a:	bf04      	itt	eq
    919c:	0080      	lsleq	r0, r0, #2
    919e:	3302      	addeq	r3, #2
    91a0:	2800      	cmp	r0, #0
    91a2:	db05      	blt.n	91b0 <__hi0bits+0x38>
    91a4:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
    91a8:	f103 0301 	add.w	r3, r3, #1
    91ac:	bf08      	it	eq
    91ae:	2320      	moveq	r3, #32
    91b0:	4618      	mov	r0, r3
    91b2:	4770      	bx	lr
    91b4:	2300      	movs	r3, #0
    91b6:	e7e4      	b.n	9182 <__hi0bits+0xa>

000091b8 <__lo0bits>:
    91b8:	6803      	ldr	r3, [r0, #0]
    91ba:	f013 0207 	ands.w	r2, r3, #7
    91be:	d008      	beq.n	91d2 <__lo0bits+0x1a>
    91c0:	07d9      	lsls	r1, r3, #31
    91c2:	d41f      	bmi.n	9204 <__lo0bits+0x4c>
    91c4:	079a      	lsls	r2, r3, #30
    91c6:	d522      	bpl.n	920e <__lo0bits+0x56>
    91c8:	085b      	lsrs	r3, r3, #1
    91ca:	6003      	str	r3, [r0, #0]
    91cc:	2201      	movs	r2, #1
    91ce:	4610      	mov	r0, r2
    91d0:	4770      	bx	lr
    91d2:	b299      	uxth	r1, r3
    91d4:	b909      	cbnz	r1, 91da <__lo0bits+0x22>
    91d6:	0c1b      	lsrs	r3, r3, #16
    91d8:	2210      	movs	r2, #16
    91da:	b2d9      	uxtb	r1, r3
    91dc:	b909      	cbnz	r1, 91e2 <__lo0bits+0x2a>
    91de:	3208      	adds	r2, #8
    91e0:	0a1b      	lsrs	r3, r3, #8
    91e2:	0719      	lsls	r1, r3, #28
    91e4:	bf04      	itt	eq
    91e6:	091b      	lsreq	r3, r3, #4
    91e8:	3204      	addeq	r2, #4
    91ea:	0799      	lsls	r1, r3, #30
    91ec:	bf04      	itt	eq
    91ee:	089b      	lsreq	r3, r3, #2
    91f0:	3202      	addeq	r2, #2
    91f2:	07d9      	lsls	r1, r3, #31
    91f4:	d403      	bmi.n	91fe <__lo0bits+0x46>
    91f6:	085b      	lsrs	r3, r3, #1
    91f8:	f102 0201 	add.w	r2, r2, #1
    91fc:	d005      	beq.n	920a <__lo0bits+0x52>
    91fe:	6003      	str	r3, [r0, #0]
    9200:	4610      	mov	r0, r2
    9202:	4770      	bx	lr
    9204:	2200      	movs	r2, #0
    9206:	4610      	mov	r0, r2
    9208:	4770      	bx	lr
    920a:	2220      	movs	r2, #32
    920c:	e7df      	b.n	91ce <__lo0bits+0x16>
    920e:	089b      	lsrs	r3, r3, #2
    9210:	2202      	movs	r2, #2
    9212:	6003      	str	r3, [r0, #0]
    9214:	4610      	mov	r0, r2
    9216:	4770      	bx	lr

00009218 <__i2b>:
    9218:	b538      	push	{r3, r4, r5, lr}
    921a:	6c43      	ldr	r3, [r0, #68]	; 0x44
    921c:	4604      	mov	r4, r0
    921e:	460d      	mov	r5, r1
    9220:	b14b      	cbz	r3, 9236 <__i2b+0x1e>
    9222:	6858      	ldr	r0, [r3, #4]
    9224:	b1b0      	cbz	r0, 9254 <__i2b+0x3c>
    9226:	6802      	ldr	r2, [r0, #0]
    9228:	605a      	str	r2, [r3, #4]
    922a:	2200      	movs	r2, #0
    922c:	2301      	movs	r3, #1
    922e:	e9c0 3504 	strd	r3, r5, [r0, #16]
    9232:	60c2      	str	r2, [r0, #12]
    9234:	bd38      	pop	{r3, r4, r5, pc}
    9236:	2221      	movs	r2, #33	; 0x21
    9238:	2104      	movs	r1, #4
    923a:	f002 fa5d 	bl	b6f8 <_calloc_r>
    923e:	4603      	mov	r3, r0
    9240:	6460      	str	r0, [r4, #68]	; 0x44
    9242:	2800      	cmp	r0, #0
    9244:	d1ed      	bne.n	9222 <__i2b+0xa>
    9246:	4b09      	ldr	r3, [pc, #36]	; (926c <__i2b+0x54>)
    9248:	4809      	ldr	r0, [pc, #36]	; (9270 <__i2b+0x58>)
    924a:	2200      	movs	r2, #0
    924c:	f240 1145 	movw	r1, #325	; 0x145
    9250:	f002 fa32 	bl	b6b8 <__assert_func>
    9254:	221c      	movs	r2, #28
    9256:	2101      	movs	r1, #1
    9258:	4620      	mov	r0, r4
    925a:	f002 fa4d 	bl	b6f8 <_calloc_r>
    925e:	2800      	cmp	r0, #0
    9260:	d0f1      	beq.n	9246 <__i2b+0x2e>
    9262:	2201      	movs	r2, #1
    9264:	2302      	movs	r3, #2
    9266:	e9c0 2301 	strd	r2, r3, [r0, #4]
    926a:	e7de      	b.n	922a <__i2b+0x12>
    926c:	2000093c 	.word	0x2000093c
    9270:	20000950 	.word	0x20000950

00009274 <__multiply>:
    9274:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9278:	690e      	ldr	r6, [r1, #16]
    927a:	6915      	ldr	r5, [r2, #16]
    927c:	42ae      	cmp	r6, r5
    927e:	b085      	sub	sp, #20
    9280:	4688      	mov	r8, r1
    9282:	4614      	mov	r4, r2
    9284:	db05      	blt.n	9292 <__multiply+0x1e>
    9286:	462a      	mov	r2, r5
    9288:	4623      	mov	r3, r4
    928a:	4635      	mov	r5, r6
    928c:	460c      	mov	r4, r1
    928e:	4616      	mov	r6, r2
    9290:	4698      	mov	r8, r3
    9292:	68a3      	ldr	r3, [r4, #8]
    9294:	6861      	ldr	r1, [r4, #4]
    9296:	19af      	adds	r7, r5, r6
    9298:	42bb      	cmp	r3, r7
    929a:	bfb8      	it	lt
    929c:	3101      	addlt	r1, #1
    929e:	f7ff fee9 	bl	9074 <_Balloc>
    92a2:	9001      	str	r0, [sp, #4]
    92a4:	2800      	cmp	r0, #0
    92a6:	f000 8087 	beq.w	93b8 <__multiply+0x144>
    92aa:	9b01      	ldr	r3, [sp, #4]
    92ac:	f103 0914 	add.w	r9, r3, #20
    92b0:	eb09 0a87 	add.w	sl, r9, r7, lsl #2
    92b4:	45d1      	cmp	r9, sl
    92b6:	d205      	bcs.n	92c4 <__multiply+0x50>
    92b8:	464b      	mov	r3, r9
    92ba:	2200      	movs	r2, #0
    92bc:	f843 2b04 	str.w	r2, [r3], #4
    92c0:	459a      	cmp	sl, r3
    92c2:	d8fb      	bhi.n	92bc <__multiply+0x48>
    92c4:	f108 0814 	add.w	r8, r8, #20
    92c8:	eb08 0b86 	add.w	fp, r8, r6, lsl #2
    92cc:	f104 0314 	add.w	r3, r4, #20
    92d0:	45d8      	cmp	r8, fp
    92d2:	461a      	mov	r2, r3
    92d4:	eb03 0585 	add.w	r5, r3, r5, lsl #2
    92d8:	d25f      	bcs.n	939a <__multiply+0x126>
    92da:	1b2b      	subs	r3, r5, r4
    92dc:	3b15      	subs	r3, #21
    92de:	f023 0303 	bic.w	r3, r3, #3
    92e2:	3304      	adds	r3, #4
    92e4:	3415      	adds	r4, #21
    92e6:	42a5      	cmp	r5, r4
    92e8:	bf38      	it	cc
    92ea:	2304      	movcc	r3, #4
    92ec:	e9cd a702 	strd	sl, r7, [sp, #8]
    92f0:	46ac      	mov	ip, r5
    92f2:	461f      	mov	r7, r3
    92f4:	4692      	mov	sl, r2
    92f6:	e005      	b.n	9304 <__multiply+0x90>
    92f8:	0c09      	lsrs	r1, r1, #16
    92fa:	d129      	bne.n	9350 <__multiply+0xdc>
    92fc:	45c3      	cmp	fp, r8
    92fe:	f109 0904 	add.w	r9, r9, #4
    9302:	d948      	bls.n	9396 <__multiply+0x122>
    9304:	f858 1b04 	ldr.w	r1, [r8], #4
    9308:	b28d      	uxth	r5, r1
    930a:	2d00      	cmp	r5, #0
    930c:	d0f4      	beq.n	92f8 <__multiply+0x84>
    930e:	4656      	mov	r6, sl
    9310:	464c      	mov	r4, r9
    9312:	2300      	movs	r3, #0
    9314:	f856 1b04 	ldr.w	r1, [r6], #4
    9318:	6822      	ldr	r2, [r4, #0]
    931a:	fa1f fe81 	uxth.w	lr, r1
    931e:	b290      	uxth	r0, r2
    9320:	0c09      	lsrs	r1, r1, #16
    9322:	fb05 000e 	mla	r0, r5, lr, r0
    9326:	0c12      	lsrs	r2, r2, #16
    9328:	4403      	add	r3, r0
    932a:	fb05 2201 	mla	r2, r5, r1, r2
    932e:	eb02 4213 	add.w	r2, r2, r3, lsr #16
    9332:	b29b      	uxth	r3, r3
    9334:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    9338:	45b4      	cmp	ip, r6
    933a:	f844 3b04 	str.w	r3, [r4], #4
    933e:	ea4f 4312 	mov.w	r3, r2, lsr #16
    9342:	d8e7      	bhi.n	9314 <__multiply+0xa0>
    9344:	f849 3007 	str.w	r3, [r9, r7]
    9348:	f858 1c04 	ldr.w	r1, [r8, #-4]
    934c:	0c09      	lsrs	r1, r1, #16
    934e:	d0d5      	beq.n	92fc <__multiply+0x88>
    9350:	f8d9 3000 	ldr.w	r3, [r9]
    9354:	4650      	mov	r0, sl
    9356:	461a      	mov	r2, r3
    9358:	464c      	mov	r4, r9
    935a:	2600      	movs	r6, #0
    935c:	8805      	ldrh	r5, [r0, #0]
    935e:	0c12      	lsrs	r2, r2, #16
    9360:	fb01 2205 	mla	r2, r1, r5, r2
    9364:	4416      	add	r6, r2
    9366:	b29b      	uxth	r3, r3
    9368:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    936c:	f844 3b04 	str.w	r3, [r4], #4
    9370:	f850 5b04 	ldr.w	r5, [r0], #4
    9374:	6822      	ldr	r2, [r4, #0]
    9376:	0c2d      	lsrs	r5, r5, #16
    9378:	b293      	uxth	r3, r2
    937a:	fb01 3305 	mla	r3, r1, r5, r3
    937e:	eb03 4316 	add.w	r3, r3, r6, lsr #16
    9382:	4584      	cmp	ip, r0
    9384:	ea4f 4613 	mov.w	r6, r3, lsr #16
    9388:	d8e8      	bhi.n	935c <__multiply+0xe8>
    938a:	45c3      	cmp	fp, r8
    938c:	f849 3007 	str.w	r3, [r9, r7]
    9390:	f109 0904 	add.w	r9, r9, #4
    9394:	d8b6      	bhi.n	9304 <__multiply+0x90>
    9396:	e9dd a702 	ldrd	sl, r7, [sp, #8]
    939a:	2f00      	cmp	r7, #0
    939c:	dc02      	bgt.n	93a4 <__multiply+0x130>
    939e:	e005      	b.n	93ac <__multiply+0x138>
    93a0:	3f01      	subs	r7, #1
    93a2:	d003      	beq.n	93ac <__multiply+0x138>
    93a4:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
    93a8:	2b00      	cmp	r3, #0
    93aa:	d0f9      	beq.n	93a0 <__multiply+0x12c>
    93ac:	9b01      	ldr	r3, [sp, #4]
    93ae:	4618      	mov	r0, r3
    93b0:	611f      	str	r7, [r3, #16]
    93b2:	b005      	add	sp, #20
    93b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    93b8:	4b03      	ldr	r3, [pc, #12]	; (93c8 <__multiply+0x154>)
    93ba:	4804      	ldr	r0, [pc, #16]	; (93cc <__multiply+0x158>)
    93bc:	9a01      	ldr	r2, [sp, #4]
    93be:	f44f 71b1 	mov.w	r1, #354	; 0x162
    93c2:	f002 f979 	bl	b6b8 <__assert_func>
    93c6:	bf00      	nop
    93c8:	2000093c 	.word	0x2000093c
    93cc:	20000950 	.word	0x20000950

000093d0 <__pow5mult>:
    93d0:	f012 0303 	ands.w	r3, r2, #3
    93d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    93d8:	4614      	mov	r4, r2
    93da:	4606      	mov	r6, r0
    93dc:	d132      	bne.n	9444 <__pow5mult+0x74>
    93de:	460d      	mov	r5, r1
    93e0:	10a4      	asrs	r4, r4, #2
    93e2:	d020      	beq.n	9426 <__pow5mult+0x56>
    93e4:	f8d6 8040 	ldr.w	r8, [r6, #64]	; 0x40
    93e8:	f1b8 0f00 	cmp.w	r8, #0
    93ec:	d033      	beq.n	9456 <__pow5mult+0x86>
    93ee:	07e3      	lsls	r3, r4, #31
    93f0:	f04f 0700 	mov.w	r7, #0
    93f4:	d407      	bmi.n	9406 <__pow5mult+0x36>
    93f6:	1064      	asrs	r4, r4, #1
    93f8:	d015      	beq.n	9426 <__pow5mult+0x56>
    93fa:	f8d8 0000 	ldr.w	r0, [r8]
    93fe:	b1a8      	cbz	r0, 942c <__pow5mult+0x5c>
    9400:	4680      	mov	r8, r0
    9402:	07e3      	lsls	r3, r4, #31
    9404:	d5f7      	bpl.n	93f6 <__pow5mult+0x26>
    9406:	4642      	mov	r2, r8
    9408:	4629      	mov	r1, r5
    940a:	4630      	mov	r0, r6
    940c:	f7ff ff32 	bl	9274 <__multiply>
    9410:	b1b5      	cbz	r5, 9440 <__pow5mult+0x70>
    9412:	6869      	ldr	r1, [r5, #4]
    9414:	6c73      	ldr	r3, [r6, #68]	; 0x44
    9416:	1064      	asrs	r4, r4, #1
    9418:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
    941c:	602a      	str	r2, [r5, #0]
    941e:	f843 5021 	str.w	r5, [r3, r1, lsl #2]
    9422:	4605      	mov	r5, r0
    9424:	d1e9      	bne.n	93fa <__pow5mult+0x2a>
    9426:	4628      	mov	r0, r5
    9428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    942c:	4642      	mov	r2, r8
    942e:	4641      	mov	r1, r8
    9430:	4630      	mov	r0, r6
    9432:	f7ff ff1f 	bl	9274 <__multiply>
    9436:	f8c8 0000 	str.w	r0, [r8]
    943a:	6007      	str	r7, [r0, #0]
    943c:	4680      	mov	r8, r0
    943e:	e7e0      	b.n	9402 <__pow5mult+0x32>
    9440:	4605      	mov	r5, r0
    9442:	e7d8      	b.n	93f6 <__pow5mult+0x26>
    9444:	3b01      	subs	r3, #1
    9446:	4a0f      	ldr	r2, [pc, #60]	; (9484 <__pow5mult+0xb4>)
    9448:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    944c:	2300      	movs	r3, #0
    944e:	f7ff fe41 	bl	90d4 <__multadd>
    9452:	4605      	mov	r5, r0
    9454:	e7c4      	b.n	93e0 <__pow5mult+0x10>
    9456:	2101      	movs	r1, #1
    9458:	4630      	mov	r0, r6
    945a:	f7ff fe0b 	bl	9074 <_Balloc>
    945e:	4680      	mov	r8, r0
    9460:	b140      	cbz	r0, 9474 <__pow5mult+0xa4>
    9462:	2301      	movs	r3, #1
    9464:	f240 2271 	movw	r2, #625	; 0x271
    9468:	e9c0 3204 	strd	r3, r2, [r0, #16]
    946c:	2300      	movs	r3, #0
    946e:	6430      	str	r0, [r6, #64]	; 0x40
    9470:	6003      	str	r3, [r0, #0]
    9472:	e7bc      	b.n	93ee <__pow5mult+0x1e>
    9474:	4b04      	ldr	r3, [pc, #16]	; (9488 <__pow5mult+0xb8>)
    9476:	4805      	ldr	r0, [pc, #20]	; (948c <__pow5mult+0xbc>)
    9478:	4642      	mov	r2, r8
    947a:	f240 1145 	movw	r1, #325	; 0x145
    947e:	f002 f91b 	bl	b6b8 <__assert_func>
    9482:	bf00      	nop
    9484:	20000dfc 	.word	0x20000dfc
    9488:	2000093c 	.word	0x2000093c
    948c:	20000950 	.word	0x20000950

00009490 <__lshift>:
    9490:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9494:	460d      	mov	r5, r1
    9496:	4614      	mov	r4, r2
    9498:	692f      	ldr	r7, [r5, #16]
    949a:	68ab      	ldr	r3, [r5, #8]
    949c:	6849      	ldr	r1, [r1, #4]
    949e:	eb07 1762 	add.w	r7, r7, r2, asr #5
    94a2:	1c7e      	adds	r6, r7, #1
    94a4:	429e      	cmp	r6, r3
    94a6:	4680      	mov	r8, r0
    94a8:	ea4f 1962 	mov.w	r9, r2, asr #5
    94ac:	dd04      	ble.n	94b8 <__lshift+0x28>
    94ae:	005b      	lsls	r3, r3, #1
    94b0:	429e      	cmp	r6, r3
    94b2:	f101 0101 	add.w	r1, r1, #1
    94b6:	dcfa      	bgt.n	94ae <__lshift+0x1e>
    94b8:	4640      	mov	r0, r8
    94ba:	f7ff fddb 	bl	9074 <_Balloc>
    94be:	4684      	mov	ip, r0
    94c0:	2800      	cmp	r0, #0
    94c2:	d052      	beq.n	956a <__lshift+0xda>
    94c4:	f1b9 0f00 	cmp.w	r9, #0
    94c8:	f100 0214 	add.w	r2, r0, #20
    94cc:	dd0e      	ble.n	94ec <__lshift+0x5c>
    94ce:	f109 0105 	add.w	r1, r9, #5
    94d2:	ea4f 0e81 	mov.w	lr, r1, lsl #2
    94d6:	4613      	mov	r3, r2
    94d8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    94dc:	2000      	movs	r0, #0
    94de:	f843 0b04 	str.w	r0, [r3], #4
    94e2:	428b      	cmp	r3, r1
    94e4:	d1fb      	bne.n	94de <__lshift+0x4e>
    94e6:	f1ae 0314 	sub.w	r3, lr, #20
    94ea:	441a      	add	r2, r3
    94ec:	6929      	ldr	r1, [r5, #16]
    94ee:	f105 0314 	add.w	r3, r5, #20
    94f2:	f014 0e1f 	ands.w	lr, r4, #31
    94f6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    94fa:	d02e      	beq.n	955a <__lshift+0xca>
    94fc:	f1ce 0920 	rsb	r9, lr, #32
    9500:	4610      	mov	r0, r2
    9502:	f04f 0a00 	mov.w	sl, #0
    9506:	681c      	ldr	r4, [r3, #0]
    9508:	fa04 f40e 	lsl.w	r4, r4, lr
    950c:	ea44 040a 	orr.w	r4, r4, sl
    9510:	f840 4b04 	str.w	r4, [r0], #4
    9514:	f853 4b04 	ldr.w	r4, [r3], #4
    9518:	4299      	cmp	r1, r3
    951a:	fa24 fa09 	lsr.w	sl, r4, r9
    951e:	d8f2      	bhi.n	9506 <__lshift+0x76>
    9520:	1b4b      	subs	r3, r1, r5
    9522:	3b15      	subs	r3, #21
    9524:	f023 0303 	bic.w	r3, r3, #3
    9528:	3304      	adds	r3, #4
    952a:	f105 0015 	add.w	r0, r5, #21
    952e:	4281      	cmp	r1, r0
    9530:	bf38      	it	cc
    9532:	2304      	movcc	r3, #4
    9534:	f1ba 0f00 	cmp.w	sl, #0
    9538:	bf18      	it	ne
    953a:	4637      	movne	r7, r6
    953c:	f842 a003 	str.w	sl, [r2, r3]
    9540:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    9544:	686a      	ldr	r2, [r5, #4]
    9546:	f8cc 7010 	str.w	r7, [ip, #16]
    954a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    954e:	6029      	str	r1, [r5, #0]
    9550:	4660      	mov	r0, ip
    9552:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
    9556:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    955a:	3a04      	subs	r2, #4
    955c:	f853 0b04 	ldr.w	r0, [r3], #4
    9560:	f842 0f04 	str.w	r0, [r2, #4]!
    9564:	4299      	cmp	r1, r3
    9566:	d8f9      	bhi.n	955c <__lshift+0xcc>
    9568:	e7ea      	b.n	9540 <__lshift+0xb0>
    956a:	4b03      	ldr	r3, [pc, #12]	; (9578 <__lshift+0xe8>)
    956c:	4803      	ldr	r0, [pc, #12]	; (957c <__lshift+0xec>)
    956e:	4662      	mov	r2, ip
    9570:	f44f 71ef 	mov.w	r1, #478	; 0x1de
    9574:	f002 f8a0 	bl	b6b8 <__assert_func>
    9578:	2000093c 	.word	0x2000093c
    957c:	20000950 	.word	0x20000950

00009580 <__mcmp>:
    9580:	690b      	ldr	r3, [r1, #16]
    9582:	4684      	mov	ip, r0
    9584:	6900      	ldr	r0, [r0, #16]
    9586:	1ac0      	subs	r0, r0, r3
    9588:	d116      	bne.n	95b8 <__mcmp+0x38>
    958a:	f10c 0c14 	add.w	ip, ip, #20
    958e:	3114      	adds	r1, #20
    9590:	eb0c 0283 	add.w	r2, ip, r3, lsl #2
    9594:	b410      	push	{r4}
    9596:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    959a:	e001      	b.n	95a0 <__mcmp+0x20>
    959c:	4594      	cmp	ip, r2
    959e:	d208      	bcs.n	95b2 <__mcmp+0x32>
    95a0:	f852 4d04 	ldr.w	r4, [r2, #-4]!
    95a4:	f853 1d04 	ldr.w	r1, [r3, #-4]!
    95a8:	428c      	cmp	r4, r1
    95aa:	d0f7      	beq.n	959c <__mcmp+0x1c>
    95ac:	d205      	bcs.n	95ba <__mcmp+0x3a>
    95ae:	f04f 30ff 	mov.w	r0, #4294967295
    95b2:	f85d 4b04 	ldr.w	r4, [sp], #4
    95b6:	4770      	bx	lr
    95b8:	4770      	bx	lr
    95ba:	2001      	movs	r0, #1
    95bc:	f85d 4b04 	ldr.w	r4, [sp], #4
    95c0:	4770      	bx	lr
    95c2:	bf00      	nop

000095c4 <__mdiff>:
    95c4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    95c8:	690f      	ldr	r7, [r1, #16]
    95ca:	6913      	ldr	r3, [r2, #16]
    95cc:	1aff      	subs	r7, r7, r3
    95ce:	2f00      	cmp	r7, #0
    95d0:	460e      	mov	r6, r1
    95d2:	4690      	mov	r8, r2
    95d4:	d17f      	bne.n	96d6 <__mdiff+0x112>
    95d6:	f101 0514 	add.w	r5, r1, #20
    95da:	3214      	adds	r2, #20
    95dc:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    95e0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    95e4:	e001      	b.n	95ea <__mdiff+0x26>
    95e6:	429d      	cmp	r5, r3
    95e8:	d278      	bcs.n	96dc <__mdiff+0x118>
    95ea:	f853 1d04 	ldr.w	r1, [r3, #-4]!
    95ee:	f852 4d04 	ldr.w	r4, [r2, #-4]!
    95f2:	42a1      	cmp	r1, r4
    95f4:	d0f7      	beq.n	95e6 <__mdiff+0x22>
    95f6:	d369      	bcc.n	96cc <__mdiff+0x108>
    95f8:	6871      	ldr	r1, [r6, #4]
    95fa:	f7ff fd3b 	bl	9074 <_Balloc>
    95fe:	4681      	mov	r9, r0
    9600:	2800      	cmp	r0, #0
    9602:	d077      	beq.n	96f4 <__mdiff+0x130>
    9604:	6935      	ldr	r5, [r6, #16]
    9606:	f8d8 2010 	ldr.w	r2, [r8, #16]
    960a:	60c7      	str	r7, [r0, #12]
    960c:	f108 0e14 	add.w	lr, r8, #20
    9610:	f106 0014 	add.w	r0, r6, #20
    9614:	f109 0a14 	add.w	sl, r9, #20
    9618:	f106 0110 	add.w	r1, r6, #16
    961c:	eb0e 0282 	add.w	r2, lr, r2, lsl #2
    9620:	eb00 0785 	add.w	r7, r0, r5, lsl #2
    9624:	4656      	mov	r6, sl
    9626:	f04f 0c00 	mov.w	ip, #0
    962a:	f85e 4b04 	ldr.w	r4, [lr], #4
    962e:	f851 bf04 	ldr.w	fp, [r1, #4]!
    9632:	b2a3      	uxth	r3, r4
    9634:	fa1c fc8b 	uxtah	ip, ip, fp
    9638:	ebac 0303 	sub.w	r3, ip, r3
    963c:	ea4f 4c14 	mov.w	ip, r4, lsr #16
    9640:	ebcc 4c1b 	rsb	ip, ip, fp, lsr #16
    9644:	eb0c 4c23 	add.w	ip, ip, r3, asr #16
    9648:	b29b      	uxth	r3, r3
    964a:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
    964e:	4572      	cmp	r2, lr
    9650:	f846 3b04 	str.w	r3, [r6], #4
    9654:	ea4f 4c2c 	mov.w	ip, ip, asr #16
    9658:	d8e7      	bhi.n	962a <__mdiff+0x66>
    965a:	eba2 0108 	sub.w	r1, r2, r8
    965e:	3915      	subs	r1, #21
    9660:	f108 0815 	add.w	r8, r8, #21
    9664:	4542      	cmp	r2, r8
    9666:	f021 0403 	bic.w	r4, r1, #3
    966a:	f104 0404 	add.w	r4, r4, #4
    966e:	bf38      	it	cc
    9670:	2404      	movcc	r4, #4
    9672:	4420      	add	r0, r4
    9674:	f021 0203 	bic.w	r2, r1, #3
    9678:	bf38      	it	cc
    967a:	2200      	movcc	r2, #0
    967c:	4287      	cmp	r7, r0
    967e:	4452      	add	r2, sl
    9680:	4454      	add	r4, sl
    9682:	d918      	bls.n	96b6 <__mdiff+0xf2>
    9684:	4626      	mov	r6, r4
    9686:	4601      	mov	r1, r0
    9688:	f851 3b04 	ldr.w	r3, [r1], #4
    968c:	fa1c fc83 	uxtah	ip, ip, r3
    9690:	ea4f 422c 	mov.w	r2, ip, asr #16
    9694:	eb02 4213 	add.w	r2, r2, r3, lsr #16
    9698:	fa1f fc8c 	uxth.w	ip, ip
    969c:	ea4c 4302 	orr.w	r3, ip, r2, lsl #16
    96a0:	428f      	cmp	r7, r1
    96a2:	f846 3b04 	str.w	r3, [r6], #4
    96a6:	ea4f 4c22 	mov.w	ip, r2, asr #16
    96aa:	d8ed      	bhi.n	9688 <__mdiff+0xc4>
    96ac:	3f01      	subs	r7, #1
    96ae:	1a3f      	subs	r7, r7, r0
    96b0:	f027 0703 	bic.w	r7, r7, #3
    96b4:	19e2      	adds	r2, r4, r7
    96b6:	b923      	cbnz	r3, 96c2 <__mdiff+0xfe>
    96b8:	f852 3d04 	ldr.w	r3, [r2, #-4]!
    96bc:	3d01      	subs	r5, #1
    96be:	2b00      	cmp	r3, #0
    96c0:	d0fa      	beq.n	96b8 <__mdiff+0xf4>
    96c2:	f8c9 5010 	str.w	r5, [r9, #16]
    96c6:	4648      	mov	r0, r9
    96c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    96cc:	4633      	mov	r3, r6
    96ce:	2701      	movs	r7, #1
    96d0:	4646      	mov	r6, r8
    96d2:	4698      	mov	r8, r3
    96d4:	e790      	b.n	95f8 <__mdiff+0x34>
    96d6:	dbf9      	blt.n	96cc <__mdiff+0x108>
    96d8:	2700      	movs	r7, #0
    96da:	e78d      	b.n	95f8 <__mdiff+0x34>
    96dc:	2100      	movs	r1, #0
    96de:	f7ff fcc9 	bl	9074 <_Balloc>
    96e2:	4681      	mov	r9, r0
    96e4:	b168      	cbz	r0, 9702 <__mdiff+0x13e>
    96e6:	2201      	movs	r2, #1
    96e8:	2300      	movs	r3, #0
    96ea:	e9c9 2304 	strd	r2, r3, [r9, #16]
    96ee:	4648      	mov	r0, r9
    96f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    96f4:	4b06      	ldr	r3, [pc, #24]	; (9710 <__mdiff+0x14c>)
    96f6:	4807      	ldr	r0, [pc, #28]	; (9714 <__mdiff+0x150>)
    96f8:	464a      	mov	r2, r9
    96fa:	f240 2145 	movw	r1, #581	; 0x245
    96fe:	f001 ffdb 	bl	b6b8 <__assert_func>
    9702:	4b03      	ldr	r3, [pc, #12]	; (9710 <__mdiff+0x14c>)
    9704:	4803      	ldr	r0, [pc, #12]	; (9714 <__mdiff+0x150>)
    9706:	464a      	mov	r2, r9
    9708:	f240 2137 	movw	r1, #567	; 0x237
    970c:	f001 ffd4 	bl	b6b8 <__assert_func>
    9710:	2000093c 	.word	0x2000093c
    9714:	20000950 	.word	0x20000950

00009718 <__d2b>:
    9718:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    971c:	4688      	mov	r8, r1
    971e:	b083      	sub	sp, #12
    9720:	2101      	movs	r1, #1
    9722:	ec57 6b10 	vmov	r6, r7, d0
    9726:	4615      	mov	r5, r2
    9728:	f7ff fca4 	bl	9074 <_Balloc>
    972c:	4604      	mov	r4, r0
    972e:	2800      	cmp	r0, #0
    9730:	d051      	beq.n	97d6 <__d2b+0xbe>
    9732:	f3c7 590a 	ubfx	r9, r7, #20, #11
    9736:	f3c7 0313 	ubfx	r3, r7, #0, #20
    973a:	f1b9 0f00 	cmp.w	r9, #0
    973e:	d001      	beq.n	9744 <__d2b+0x2c>
    9740:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    9744:	2e00      	cmp	r6, #0
    9746:	9301      	str	r3, [sp, #4]
    9748:	d118      	bne.n	977c <__d2b+0x64>
    974a:	a801      	add	r0, sp, #4
    974c:	f7ff fd34 	bl	91b8 <__lo0bits>
    9750:	9a01      	ldr	r2, [sp, #4]
    9752:	6162      	str	r2, [r4, #20]
    9754:	2201      	movs	r2, #1
    9756:	f100 0320 	add.w	r3, r0, #32
    975a:	6122      	str	r2, [r4, #16]
    975c:	f1b9 0f00 	cmp.w	r9, #0
    9760:	d025      	beq.n	97ae <__d2b+0x96>
    9762:	f2a9 4933 	subw	r9, r9, #1075	; 0x433
    9766:	eb09 0203 	add.w	r2, r9, r3
    976a:	4620      	mov	r0, r4
    976c:	f1c3 0335 	rsb	r3, r3, #53	; 0x35
    9770:	f8c8 2000 	str.w	r2, [r8]
    9774:	602b      	str	r3, [r5, #0]
    9776:	b003      	add	sp, #12
    9778:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    977c:	4668      	mov	r0, sp
    977e:	9600      	str	r6, [sp, #0]
    9780:	f7ff fd1a 	bl	91b8 <__lo0bits>
    9784:	4603      	mov	r3, r0
    9786:	b310      	cbz	r0, 97ce <__d2b+0xb6>
    9788:	e9dd 0200 	ldrd	r0, r2, [sp]
    978c:	f1c3 0120 	rsb	r1, r3, #32
    9790:	fa02 f101 	lsl.w	r1, r2, r1
    9794:	4301      	orrs	r1, r0
    9796:	40da      	lsrs	r2, r3
    9798:	6161      	str	r1, [r4, #20]
    979a:	9201      	str	r2, [sp, #4]
    979c:	2a00      	cmp	r2, #0
    979e:	61a2      	str	r2, [r4, #24]
    97a0:	bf14      	ite	ne
    97a2:	2202      	movne	r2, #2
    97a4:	2201      	moveq	r2, #1
    97a6:	6122      	str	r2, [r4, #16]
    97a8:	f1b9 0f00 	cmp.w	r9, #0
    97ac:	d1d9      	bne.n	9762 <__d2b+0x4a>
    97ae:	f2a3 4332 	subw	r3, r3, #1074	; 0x432
    97b2:	f8c8 3000 	str.w	r3, [r8]
    97b6:	eb04 0382 	add.w	r3, r4, r2, lsl #2
    97ba:	6918      	ldr	r0, [r3, #16]
    97bc:	f7ff fcdc 	bl	9178 <__hi0bits>
    97c0:	ebc0 1342 	rsb	r3, r0, r2, lsl #5
    97c4:	4620      	mov	r0, r4
    97c6:	602b      	str	r3, [r5, #0]
    97c8:	b003      	add	sp, #12
    97ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    97ce:	9a00      	ldr	r2, [sp, #0]
    97d0:	6162      	str	r2, [r4, #20]
    97d2:	9a01      	ldr	r2, [sp, #4]
    97d4:	e7e2      	b.n	979c <__d2b+0x84>
    97d6:	4b03      	ldr	r3, [pc, #12]	; (97e4 <__d2b+0xcc>)
    97d8:	4803      	ldr	r0, [pc, #12]	; (97e8 <__d2b+0xd0>)
    97da:	4622      	mov	r2, r4
    97dc:	f240 310f 	movw	r1, #783	; 0x30f
    97e0:	f001 ff6a 	bl	b6b8 <__assert_func>
    97e4:	2000093c 	.word	0x2000093c
    97e8:	20000950 	.word	0x20000950

000097ec <__ascii_wctomb>:
    97ec:	b149      	cbz	r1, 9802 <__ascii_wctomb+0x16>
    97ee:	2aff      	cmp	r2, #255	; 0xff
    97f0:	d802      	bhi.n	97f8 <__ascii_wctomb+0xc>
    97f2:	700a      	strb	r2, [r1, #0]
    97f4:	2001      	movs	r0, #1
    97f6:	4770      	bx	lr
    97f8:	238a      	movs	r3, #138	; 0x8a
    97fa:	6003      	str	r3, [r0, #0]
    97fc:	f04f 30ff 	mov.w	r0, #4294967295
    9800:	4770      	bx	lr
    9802:	4608      	mov	r0, r1
    9804:	4770      	bx	lr
    9806:	bf00      	nop

00009808 <_svfprintf_r>:
    9808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    980c:	ed2d 8b08 	vpush	{d8-d11}
    9810:	b0d1      	sub	sp, #324	; 0x144
    9812:	460c      	mov	r4, r1
    9814:	ee0b 1a10 	vmov	s22, r1
    9818:	4690      	mov	r8, r2
    981a:	9308      	str	r3, [sp, #32]
    981c:	4683      	mov	fp, r0
    981e:	f001 febb 	bl	b598 <_localeconv_r>
    9822:	6803      	ldr	r3, [r0, #0]
    9824:	9312      	str	r3, [sp, #72]	; 0x48
    9826:	4618      	mov	r0, r3
    9828:	f7ff fa4a 	bl	8cc0 <strlen>
    982c:	af20      	add	r7, sp, #128	; 0x80
    982e:	9010      	str	r0, [sp, #64]	; 0x40
    9830:	2208      	movs	r2, #8
    9832:	2100      	movs	r1, #0
    9834:	4638      	mov	r0, r7
    9836:	f7ff f915 	bl	8a64 <memset>
    983a:	89a3      	ldrh	r3, [r4, #12]
    983c:	061b      	lsls	r3, r3, #24
    983e:	d503      	bpl.n	9848 <_svfprintf_r+0x40>
    9840:	6923      	ldr	r3, [r4, #16]
    9842:	2b00      	cmp	r3, #0
    9844:	f000 8755 	beq.w	a6f2 <_svfprintf_r+0xeea>
    9848:	2300      	movs	r3, #0
    984a:	ed9f 8b83 	vldr	d8, [pc, #524]	; 9a58 <_svfprintf_r+0x250>
    984e:	ed9f 9b84 	vldr	d9, [pc, #528]	; 9a60 <_svfprintf_r+0x258>
    9852:	e9cd 3325 	strd	r3, r3, [sp, #148]	; 0x94
    9856:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
    985a:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
    985e:	aa27      	add	r2, sp, #156	; 0x9c
    9860:	930e      	str	r3, [sp, #56]	; 0x38
    9862:	9224      	str	r2, [sp, #144]	; 0x90
    9864:	4692      	mov	sl, r2
    9866:	9311      	str	r3, [sp, #68]	; 0x44
    9868:	9304      	str	r3, [sp, #16]
    986a:	4644      	mov	r4, r8
    986c:	46a1      	mov	r9, r4
    986e:	4b7e      	ldr	r3, [pc, #504]	; (9a68 <_svfprintf_r+0x260>)
    9870:	f8d3 50e4 	ldr.w	r5, [r3, #228]	; 0xe4
    9874:	f7ff f97a 	bl	8b6c <__locale_mb_cur_max>
    9878:	464a      	mov	r2, r9
    987a:	4603      	mov	r3, r0
    987c:	a91c      	add	r1, sp, #112	; 0x70
    987e:	9700      	str	r7, [sp, #0]
    9880:	4658      	mov	r0, fp
    9882:	47a8      	blx	r5
    9884:	2800      	cmp	r0, #0
    9886:	f000 80b0 	beq.w	99ea <_svfprintf_r+0x1e2>
    988a:	f2c0 80a6 	blt.w	99da <_svfprintf_r+0x1d2>
    988e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9890:	2a25      	cmp	r2, #37	; 0x25
    9892:	4603      	mov	r3, r0
    9894:	d001      	beq.n	989a <_svfprintf_r+0x92>
    9896:	4499      	add	r9, r3
    9898:	e7e9      	b.n	986e <_svfprintf_r+0x66>
    989a:	ebb9 0504 	subs.w	r5, r9, r4
    989e:	4606      	mov	r6, r0
    98a0:	f040 80a7 	bne.w	99f2 <_svfprintf_r+0x1ea>
    98a4:	2300      	movs	r3, #0
    98a6:	f04f 32ff 	mov.w	r2, #4294967295
    98aa:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    98ae:	4698      	mov	r8, r3
    98b0:	9306      	str	r3, [sp, #24]
    98b2:	f109 0901 	add.w	r9, r9, #1
    98b6:	f899 3000 	ldrb.w	r3, [r9]
    98ba:	9203      	str	r2, [sp, #12]
    98bc:	252b      	movs	r5, #43	; 0x2b
    98be:	2620      	movs	r6, #32
    98c0:	f109 0901 	add.w	r9, r9, #1
    98c4:	f1a3 0220 	sub.w	r2, r3, #32
    98c8:	2a5a      	cmp	r2, #90	; 0x5a
    98ca:	f200 80cf 	bhi.w	9a6c <_svfprintf_r+0x264>
    98ce:	e8df f012 	tbh	[pc, r2, lsl #1]
    98d2:	02e8      	.short	0x02e8
    98d4:	00cd00cd 	.word	0x00cd00cd
    98d8:	00cd02e3 	.word	0x00cd02e3
    98dc:	00cd00cd 	.word	0x00cd00cd
    98e0:	00cd006a 	.word	0x00cd006a
    98e4:	020500cd 	.word	0x020500cd
    98e8:	00cd0284 	.word	0x00cd0284
    98ec:	02c90210 	.word	0x02c90210
    98f0:	02bd00cd 	.word	0x02bd00cd
    98f4:	005b005b 	.word	0x005b005b
    98f8:	005b005b 	.word	0x005b005b
    98fc:	005b005b 	.word	0x005b005b
    9900:	005b005b 	.word	0x005b005b
    9904:	00cd005b 	.word	0x00cd005b
    9908:	00cd00cd 	.word	0x00cd00cd
    990c:	00cd00cd 	.word	0x00cd00cd
    9910:	00cd00cd 	.word	0x00cd00cd
    9914:	00cd0153 	.word	0x00cd0153
    9918:	021a0183 	.word	0x021a0183
    991c:	01530153 	.word	0x01530153
    9920:	00cd0153 	.word	0x00cd0153
    9924:	00cd00cd 	.word	0x00cd00cd
    9928:	021500cd 	.word	0x021500cd
    992c:	00cd00cd 	.word	0x00cd00cd
    9930:	00cd0296 	.word	0x00cd0296
    9934:	00cd00cd 	.word	0x00cd00cd
    9938:	00cd01ab 	.word	0x00cd01ab
    993c:	00cd02aa 	.word	0x00cd02aa
    9940:	06e300cd 	.word	0x06e300cd
    9944:	00cd00cd 	.word	0x00cd00cd
    9948:	00cd00cd 	.word	0x00cd00cd
    994c:	00cd00cd 	.word	0x00cd00cd
    9950:	00cd00cd 	.word	0x00cd00cd
    9954:	00cd0153 	.word	0x00cd0153
    9958:	01de0183 	.word	0x01de0183
    995c:	01530153 	.word	0x01530153
    9960:	02770153 	.word	0x02770153
    9964:	007f01de 	.word	0x007f01de
    9968:	028900cd 	.word	0x028900cd
    996c:	025f00cd 	.word	0x025f00cd
    9970:	022f06e0 	.word	0x022f06e0
    9974:	00cd007f 	.word	0x00cd007f
    9978:	007c01ab 	.word	0x007c01ab
    997c:	00cd06b8 	.word	0x00cd06b8
    9980:	06bd00cd 	.word	0x06bd00cd
    9984:	007c00cd 	.word	0x007c00cd
    9988:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    998c:	2100      	movs	r1, #0
    998e:	f819 3b01 	ldrb.w	r3, [r9], #1
    9992:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    9996:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    999a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    999e:	2a09      	cmp	r2, #9
    99a0:	d9f5      	bls.n	998e <_svfprintf_r+0x186>
    99a2:	9106      	str	r1, [sp, #24]
    99a4:	e78e      	b.n	98c4 <_svfprintf_r+0xbc>
    99a6:	4658      	mov	r0, fp
    99a8:	f001 fdf6 	bl	b598 <_localeconv_r>
    99ac:	6843      	ldr	r3, [r0, #4]
    99ae:	9315      	str	r3, [sp, #84]	; 0x54
    99b0:	4618      	mov	r0, r3
    99b2:	f7ff f985 	bl	8cc0 <strlen>
    99b6:	9016      	str	r0, [sp, #88]	; 0x58
    99b8:	4658      	mov	r0, fp
    99ba:	f001 fded 	bl	b598 <_localeconv_r>
    99be:	6883      	ldr	r3, [r0, #8]
    99c0:	9313      	str	r3, [sp, #76]	; 0x4c
    99c2:	9b16      	ldr	r3, [sp, #88]	; 0x58
    99c4:	2b00      	cmp	r3, #0
    99c6:	f040 862d 	bne.w	a624 <_svfprintf_r+0xe1c>
    99ca:	f899 3000 	ldrb.w	r3, [r9]
    99ce:	e777      	b.n	98c0 <_svfprintf_r+0xb8>
    99d0:	f899 3000 	ldrb.w	r3, [r9]
    99d4:	f048 0820 	orr.w	r8, r8, #32
    99d8:	e772      	b.n	98c0 <_svfprintf_r+0xb8>
    99da:	2208      	movs	r2, #8
    99dc:	2100      	movs	r1, #0
    99de:	4638      	mov	r0, r7
    99e0:	f7ff f840 	bl	8a64 <memset>
    99e4:	2301      	movs	r3, #1
    99e6:	4499      	add	r9, r3
    99e8:	e741      	b.n	986e <_svfprintf_r+0x66>
    99ea:	ebb9 0504 	subs.w	r5, r9, r4
    99ee:	4606      	mov	r6, r0
    99f0:	d011      	beq.n	9a16 <_svfprintf_r+0x20e>
    99f2:	9b26      	ldr	r3, [sp, #152]	; 0x98
    99f4:	442b      	add	r3, r5
    99f6:	9326      	str	r3, [sp, #152]	; 0x98
    99f8:	9b25      	ldr	r3, [sp, #148]	; 0x94
    99fa:	3301      	adds	r3, #1
    99fc:	2b07      	cmp	r3, #7
    99fe:	e9ca 4500 	strd	r4, r5, [sl]
    9a02:	9325      	str	r3, [sp, #148]	; 0x94
    9a04:	dc1c      	bgt.n	9a40 <_svfprintf_r+0x238>
    9a06:	f10a 0a08 	add.w	sl, sl, #8
    9a0a:	9b04      	ldr	r3, [sp, #16]
    9a0c:	442b      	add	r3, r5
    9a0e:	9304      	str	r3, [sp, #16]
    9a10:	2e00      	cmp	r6, #0
    9a12:	f47f af47 	bne.w	98a4 <_svfprintf_r+0x9c>
    9a16:	9b26      	ldr	r3, [sp, #152]	; 0x98
    9a18:	2b00      	cmp	r3, #0
    9a1a:	f041 820b 	bne.w	ae34 <_svfprintf_r+0x162c>
    9a1e:	ee1b 3a10 	vmov	r3, s22
    9a22:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    9a26:	f013 0f40 	tst.w	r3, #64	; 0x40
    9a2a:	9b04      	ldr	r3, [sp, #16]
    9a2c:	bf18      	it	ne
    9a2e:	f04f 33ff 	movne.w	r3, #4294967295
    9a32:	9304      	str	r3, [sp, #16]
    9a34:	9804      	ldr	r0, [sp, #16]
    9a36:	b051      	add	sp, #324	; 0x144
    9a38:	ecbd 8b08 	vpop	{d8-d11}
    9a3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9a40:	ee1b 1a10 	vmov	r1, s22
    9a44:	aa24      	add	r2, sp, #144	; 0x90
    9a46:	4658      	mov	r0, fp
    9a48:	f002 fde2 	bl	c610 <__ssprint_r>
    9a4c:	2800      	cmp	r0, #0
    9a4e:	d1e6      	bne.n	9a1e <_svfprintf_r+0x216>
    9a50:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9a54:	e7d9      	b.n	9a0a <_svfprintf_r+0x202>
    9a56:	bf00      	nop
	...
    9a60:	ffffffff 	.word	0xffffffff
    9a64:	7fefffff 	.word	0x7fefffff
    9a68:	200011e4 	.word	0x200011e4
    9a6c:	930b      	str	r3, [sp, #44]	; 0x2c
    9a6e:	2b00      	cmp	r3, #0
    9a70:	d0d1      	beq.n	9a16 <_svfprintf_r+0x20e>
    9a72:	2100      	movs	r1, #0
    9a74:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
    9a78:	f88d 30dc 	strb.w	r3, [sp, #220]	; 0xdc
    9a7c:	2301      	movs	r3, #1
    9a7e:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    9a82:	9302      	str	r3, [sp, #8]
    9a84:	9107      	str	r1, [sp, #28]
    9a86:	9305      	str	r3, [sp, #20]
    9a88:	9103      	str	r1, [sp, #12]
    9a8a:	910f      	str	r1, [sp, #60]	; 0x3c
    9a8c:	ac37      	add	r4, sp, #220	; 0xdc
    9a8e:	f018 0302 	ands.w	r3, r8, #2
    9a92:	9309      	str	r3, [sp, #36]	; 0x24
    9a94:	d002      	beq.n	9a9c <_svfprintf_r+0x294>
    9a96:	9b02      	ldr	r3, [sp, #8]
    9a98:	3302      	adds	r3, #2
    9a9a:	9302      	str	r3, [sp, #8]
    9a9c:	f018 0384 	ands.w	r3, r8, #132	; 0x84
    9aa0:	930a      	str	r3, [sp, #40]	; 0x28
    9aa2:	d105      	bne.n	9ab0 <_svfprintf_r+0x2a8>
    9aa4:	9b06      	ldr	r3, [sp, #24]
    9aa6:	9a02      	ldr	r2, [sp, #8]
    9aa8:	1a9d      	subs	r5, r3, r2
    9aaa:	2d00      	cmp	r5, #0
    9aac:	f300 8369 	bgt.w	a182 <_svfprintf_r+0x97a>
    9ab0:	9a26      	ldr	r2, [sp, #152]	; 0x98
    9ab2:	b189      	cbz	r1, 9ad8 <_svfprintf_r+0x2d0>
    9ab4:	9925      	ldr	r1, [sp, #148]	; 0x94
    9ab6:	f10d 0067 	add.w	r0, sp, #103	; 0x67
    9aba:	3101      	adds	r1, #1
    9abc:	3201      	adds	r2, #1
    9abe:	f8ca 0000 	str.w	r0, [sl]
    9ac2:	2907      	cmp	r1, #7
    9ac4:	f04f 0001 	mov.w	r0, #1
    9ac8:	9226      	str	r2, [sp, #152]	; 0x98
    9aca:	9125      	str	r1, [sp, #148]	; 0x94
    9acc:	f8ca 0004 	str.w	r0, [sl, #4]
    9ad0:	f300 83a2 	bgt.w	a218 <_svfprintf_r+0xa10>
    9ad4:	f10a 0a08 	add.w	sl, sl, #8
    9ad8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9ada:	b183      	cbz	r3, 9afe <_svfprintf_r+0x2f6>
    9adc:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9ade:	a91a      	add	r1, sp, #104	; 0x68
    9ae0:	3301      	adds	r3, #1
    9ae2:	3202      	adds	r2, #2
    9ae4:	f8ca 1000 	str.w	r1, [sl]
    9ae8:	2b07      	cmp	r3, #7
    9aea:	f04f 0102 	mov.w	r1, #2
    9aee:	9226      	str	r2, [sp, #152]	; 0x98
    9af0:	9325      	str	r3, [sp, #148]	; 0x94
    9af2:	f8ca 1004 	str.w	r1, [sl, #4]
    9af6:	f300 83a3 	bgt.w	a240 <_svfprintf_r+0xa38>
    9afa:	f10a 0a08 	add.w	sl, sl, #8
    9afe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9b00:	2b80      	cmp	r3, #128	; 0x80
    9b02:	f000 826c 	beq.w	9fde <_svfprintf_r+0x7d6>
    9b06:	9b03      	ldr	r3, [sp, #12]
    9b08:	9905      	ldr	r1, [sp, #20]
    9b0a:	1a5d      	subs	r5, r3, r1
    9b0c:	2d00      	cmp	r5, #0
    9b0e:	f300 82a5 	bgt.w	a05c <_svfprintf_r+0x854>
    9b12:	f418 7f80 	tst.w	r8, #256	; 0x100
    9b16:	f040 820d 	bne.w	9f34 <_svfprintf_r+0x72c>
    9b1a:	9b05      	ldr	r3, [sp, #20]
    9b1c:	f8ca 3004 	str.w	r3, [sl, #4]
    9b20:	441a      	add	r2, r3
    9b22:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9b24:	f8ca 4000 	str.w	r4, [sl]
    9b28:	3301      	adds	r3, #1
    9b2a:	2b07      	cmp	r3, #7
    9b2c:	9226      	str	r2, [sp, #152]	; 0x98
    9b2e:	9325      	str	r3, [sp, #148]	; 0x94
    9b30:	f300 831b 	bgt.w	a16a <_svfprintf_r+0x962>
    9b34:	f10a 0a08 	add.w	sl, sl, #8
    9b38:	f018 0f04 	tst.w	r8, #4
    9b3c:	d005      	beq.n	9b4a <_svfprintf_r+0x342>
    9b3e:	9b06      	ldr	r3, [sp, #24]
    9b40:	9902      	ldr	r1, [sp, #8]
    9b42:	1a5c      	subs	r4, r3, r1
    9b44:	2c00      	cmp	r4, #0
    9b46:	f300 8388 	bgt.w	a25a <_svfprintf_r+0xa52>
    9b4a:	9b04      	ldr	r3, [sp, #16]
    9b4c:	9906      	ldr	r1, [sp, #24]
    9b4e:	9802      	ldr	r0, [sp, #8]
    9b50:	4281      	cmp	r1, r0
    9b52:	bfac      	ite	ge
    9b54:	185b      	addge	r3, r3, r1
    9b56:	181b      	addlt	r3, r3, r0
    9b58:	9304      	str	r3, [sp, #16]
    9b5a:	2a00      	cmp	r2, #0
    9b5c:	f040 82b0 	bne.w	a0c0 <_svfprintf_r+0x8b8>
    9b60:	2300      	movs	r3, #0
    9b62:	9325      	str	r3, [sp, #148]	; 0x94
    9b64:	9b07      	ldr	r3, [sp, #28]
    9b66:	b11b      	cbz	r3, 9b70 <_svfprintf_r+0x368>
    9b68:	9907      	ldr	r1, [sp, #28]
    9b6a:	4658      	mov	r0, fp
    9b6c:	f7ff f966 	bl	8e3c <_free_r>
    9b70:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9b74:	464c      	mov	r4, r9
    9b76:	e679      	b.n	986c <_svfprintf_r+0x64>
    9b78:	930b      	str	r3, [sp, #44]	; 0x2c
    9b7a:	9b08      	ldr	r3, [sp, #32]
    9b7c:	3307      	adds	r3, #7
    9b7e:	f023 0307 	bic.w	r3, r3, #7
    9b82:	ecb3 8b02 	vldmia	r3!, {d8}
    9b86:	eeb0 7bc8 	vabs.f64	d7, d8
    9b8a:	eeb4 7b49 	vcmp.f64	d7, d9
    9b8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9b92:	9308      	str	r3, [sp, #32]
    9b94:	f340 84e9 	ble.w	a56a <_svfprintf_r+0xd62>
    9b98:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    9b9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9ba0:	f101 8059 	bmi.w	ac56 <_svfprintf_r+0x144e>
    9ba4:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    9ba8:	4cab      	ldr	r4, [pc, #684]	; (9e58 <_svfprintf_r+0x650>)
    9baa:	4bac      	ldr	r3, [pc, #688]	; (9e5c <_svfprintf_r+0x654>)
    9bac:	f028 0880 	bic.w	r8, r8, #128	; 0x80
    9bb0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    9bb2:	2a47      	cmp	r2, #71	; 0x47
    9bb4:	bfc8      	it	gt
    9bb6:	461c      	movgt	r4, r3
    9bb8:	2300      	movs	r3, #0
    9bba:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    9bbe:	2203      	movs	r2, #3
    9bc0:	9307      	str	r3, [sp, #28]
    9bc2:	9202      	str	r2, [sp, #8]
    9bc4:	9205      	str	r2, [sp, #20]
    9bc6:	9303      	str	r3, [sp, #12]
    9bc8:	930f      	str	r3, [sp, #60]	; 0x3c
    9bca:	2900      	cmp	r1, #0
    9bcc:	f43f af5f 	beq.w	9a8e <_svfprintf_r+0x286>
    9bd0:	9b02      	ldr	r3, [sp, #8]
    9bd2:	3301      	adds	r3, #1
    9bd4:	9302      	str	r3, [sp, #8]
    9bd6:	e75a      	b.n	9a8e <_svfprintf_r+0x286>
    9bd8:	2b43      	cmp	r3, #67	; 0x43
    9bda:	930b      	str	r3, [sp, #44]	; 0x2c
    9bdc:	d003      	beq.n	9be6 <_svfprintf_r+0x3de>
    9bde:	f018 0f10 	tst.w	r8, #16
    9be2:	f000 855d 	beq.w	a6a0 <_svfprintf_r+0xe98>
    9be6:	9d08      	ldr	r5, [sp, #32]
    9be8:	2208      	movs	r2, #8
    9bea:	2100      	movs	r1, #0
    9bec:	a822      	add	r0, sp, #136	; 0x88
    9bee:	ac37      	add	r4, sp, #220	; 0xdc
    9bf0:	f7fe ff38 	bl	8a64 <memset>
    9bf4:	ab22      	add	r3, sp, #136	; 0x88
    9bf6:	f855 2b04 	ldr.w	r2, [r5], #4
    9bfa:	4621      	mov	r1, r4
    9bfc:	4658      	mov	r0, fp
    9bfe:	f002 fcc1 	bl	c584 <_wcrtomb_r>
    9c02:	4603      	mov	r3, r0
    9c04:	3301      	adds	r3, #1
    9c06:	9005      	str	r0, [sp, #20]
    9c08:	f001 82ee 	beq.w	b1e8 <_svfprintf_r+0x19e0>
    9c0c:	9b05      	ldr	r3, [sp, #20]
    9c0e:	9508      	str	r5, [sp, #32]
    9c10:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9c14:	9302      	str	r3, [sp, #8]
    9c16:	2100      	movs	r1, #0
    9c18:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
    9c1c:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    9c20:	9107      	str	r1, [sp, #28]
    9c22:	9103      	str	r1, [sp, #12]
    9c24:	910f      	str	r1, [sp, #60]	; 0x3c
    9c26:	e732      	b.n	9a8e <_svfprintf_r+0x286>
    9c28:	930b      	str	r3, [sp, #44]	; 0x2c
    9c2a:	9b08      	ldr	r3, [sp, #32]
    9c2c:	461a      	mov	r2, r3
    9c2e:	2300      	movs	r3, #0
    9c30:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    9c34:	4613      	mov	r3, r2
    9c36:	f853 4b04 	ldr.w	r4, [r3], #4
    9c3a:	9308      	str	r3, [sp, #32]
    9c3c:	2c00      	cmp	r4, #0
    9c3e:	f000 8548 	beq.w	a6d2 <_svfprintf_r+0xeca>
    9c42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9c44:	2b53      	cmp	r3, #83	; 0x53
    9c46:	f000 86ec 	beq.w	aa22 <_svfprintf_r+0x121a>
    9c4a:	f018 0310 	ands.w	r3, r8, #16
    9c4e:	930c      	str	r3, [sp, #48]	; 0x30
    9c50:	f040 86e7 	bne.w	aa22 <_svfprintf_r+0x121a>
    9c54:	9b03      	ldr	r3, [sp, #12]
    9c56:	1c5d      	adds	r5, r3, #1
    9c58:	f001 80e5 	beq.w	ae26 <_svfprintf_r+0x161e>
    9c5c:	990c      	ldr	r1, [sp, #48]	; 0x30
    9c5e:	461a      	mov	r2, r3
    9c60:	4620      	mov	r0, r4
    9c62:	f001 fc9d 	bl	b5a0 <memchr>
    9c66:	9007      	str	r0, [sp, #28]
    9c68:	2800      	cmp	r0, #0
    9c6a:	f001 8328 	beq.w	b2be <_svfprintf_r+0x1ab6>
    9c6e:	9b07      	ldr	r3, [sp, #28]
    9c70:	1b1a      	subs	r2, r3, r4
    9c72:	9205      	str	r2, [sp, #20]
    9c74:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9c76:	9303      	str	r3, [sp, #12]
    9c78:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    9c7c:	930f      	str	r3, [sp, #60]	; 0x3c
    9c7e:	930d      	str	r3, [sp, #52]	; 0x34
    9c80:	9307      	str	r3, [sp, #28]
    9c82:	2373      	movs	r3, #115	; 0x73
    9c84:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    9c88:	9202      	str	r2, [sp, #8]
    9c8a:	930b      	str	r3, [sp, #44]	; 0x2c
    9c8c:	e79d      	b.n	9bca <_svfprintf_r+0x3c2>
    9c8e:	f018 0f20 	tst.w	r8, #32
    9c92:	930b      	str	r3, [sp, #44]	; 0x2c
    9c94:	9b08      	ldr	r3, [sp, #32]
    9c96:	d03d      	beq.n	9d14 <_svfprintf_r+0x50c>
    9c98:	3307      	adds	r3, #7
    9c9a:	f023 0307 	bic.w	r3, r3, #7
    9c9e:	461a      	mov	r2, r3
    9ca0:	4611      	mov	r1, r2
    9ca2:	685b      	ldr	r3, [r3, #4]
    9ca4:	f851 2b08 	ldr.w	r2, [r1], #8
    9ca8:	9108      	str	r1, [sp, #32]
    9caa:	4619      	mov	r1, r3
    9cac:	2b00      	cmp	r3, #0
    9cae:	f2c0 840c 	blt.w	a4ca <_svfprintf_r+0xcc2>
    9cb2:	9b03      	ldr	r3, [sp, #12]
    9cb4:	3301      	adds	r3, #1
    9cb6:	f000 829e 	beq.w	a1f6 <_svfprintf_r+0x9ee>
    9cba:	f028 0080 	bic.w	r0, r8, #128	; 0x80
    9cbe:	ea52 0301 	orrs.w	r3, r2, r1
    9cc2:	9002      	str	r0, [sp, #8]
    9cc4:	f040 8299 	bne.w	a1fa <_svfprintf_r+0x9f2>
    9cc8:	9b03      	ldr	r3, [sp, #12]
    9cca:	2b00      	cmp	r3, #0
    9ccc:	f040 829a 	bne.w	a204 <_svfprintf_r+0x9fc>
    9cd0:	4680      	mov	r8, r0
    9cd2:	2300      	movs	r3, #0
    9cd4:	9303      	str	r3, [sp, #12]
    9cd6:	9305      	str	r3, [sp, #20]
    9cd8:	ac50      	add	r4, sp, #320	; 0x140
    9cda:	e106      	b.n	9eea <_svfprintf_r+0x6e2>
    9cdc:	9b08      	ldr	r3, [sp, #32]
    9cde:	f853 2b04 	ldr.w	r2, [r3], #4
    9ce2:	9206      	str	r2, [sp, #24]
    9ce4:	2a00      	cmp	r2, #0
    9ce6:	f280 8419 	bge.w	a51c <_svfprintf_r+0xd14>
    9cea:	9a06      	ldr	r2, [sp, #24]
    9cec:	9308      	str	r3, [sp, #32]
    9cee:	4252      	negs	r2, r2
    9cf0:	9206      	str	r2, [sp, #24]
    9cf2:	f899 3000 	ldrb.w	r3, [r9]
    9cf6:	f048 0804 	orr.w	r8, r8, #4
    9cfa:	e5e1      	b.n	98c0 <_svfprintf_r+0xb8>
    9cfc:	f899 3000 	ldrb.w	r3, [r9]
    9d00:	f048 0808 	orr.w	r8, r8, #8
    9d04:	e5dc      	b.n	98c0 <_svfprintf_r+0xb8>
    9d06:	f048 0810 	orr.w	r8, r8, #16
    9d0a:	f018 0f20 	tst.w	r8, #32
    9d0e:	930b      	str	r3, [sp, #44]	; 0x2c
    9d10:	9b08      	ldr	r3, [sp, #32]
    9d12:	d1c1      	bne.n	9c98 <_svfprintf_r+0x490>
    9d14:	f018 0f10 	tst.w	r8, #16
    9d18:	f040 840b 	bne.w	a532 <_svfprintf_r+0xd2a>
    9d1c:	f018 0f40 	tst.w	r8, #64	; 0x40
    9d20:	f000 8403 	beq.w	a52a <_svfprintf_r+0xd22>
    9d24:	f933 2b04 	ldrsh.w	r2, [r3], #4
    9d28:	9308      	str	r3, [sp, #32]
    9d2a:	17d1      	asrs	r1, r2, #31
    9d2c:	460b      	mov	r3, r1
    9d2e:	e7bd      	b.n	9cac <_svfprintf_r+0x4a4>
    9d30:	9b08      	ldr	r3, [sp, #32]
    9d32:	f048 0202 	orr.w	r2, r8, #2
    9d36:	9202      	str	r2, [sp, #8]
    9d38:	f853 2b04 	ldr.w	r2, [r3], #4
    9d3c:	9308      	str	r3, [sp, #32]
    9d3e:	f647 0330 	movw	r3, #30768	; 0x7830
    9d42:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    9d46:	2078      	movs	r0, #120	; 0x78
    9d48:	4b45      	ldr	r3, [pc, #276]	; (9e60 <_svfprintf_r+0x658>)
    9d4a:	9311      	str	r3, [sp, #68]	; 0x44
    9d4c:	2100      	movs	r1, #0
    9d4e:	2302      	movs	r3, #2
    9d50:	900b      	str	r0, [sp, #44]	; 0x2c
    9d52:	2000      	movs	r0, #0
    9d54:	9c03      	ldr	r4, [sp, #12]
    9d56:	f88d 0067 	strb.w	r0, [sp, #103]	; 0x67
    9d5a:	1c60      	adds	r0, r4, #1
    9d5c:	f000 80ad 	beq.w	9eba <_svfprintf_r+0x6b2>
    9d60:	9802      	ldr	r0, [sp, #8]
    9d62:	f020 0880 	bic.w	r8, r0, #128	; 0x80
    9d66:	ea52 0001 	orrs.w	r0, r2, r1
    9d6a:	f040 80a4 	bne.w	9eb6 <_svfprintf_r+0x6ae>
    9d6e:	2c00      	cmp	r4, #0
    9d70:	f040 86ae 	bne.w	aad0 <_svfprintf_r+0x12c8>
    9d74:	2b00      	cmp	r3, #0
    9d76:	d1ac      	bne.n	9cd2 <_svfprintf_r+0x4ca>
    9d78:	9b02      	ldr	r3, [sp, #8]
    9d7a:	f013 0301 	ands.w	r3, r3, #1
    9d7e:	9305      	str	r3, [sp, #20]
    9d80:	f000 83d1 	beq.w	a526 <_svfprintf_r+0xd1e>
    9d84:	2330      	movs	r3, #48	; 0x30
    9d86:	f88d 313f 	strb.w	r3, [sp, #319]	; 0x13f
    9d8a:	f20d 143f 	addw	r4, sp, #319	; 0x13f
    9d8e:	e0ac      	b.n	9eea <_svfprintf_r+0x6e2>
    9d90:	f018 0f20 	tst.w	r8, #32
    9d94:	f040 83d4 	bne.w	a540 <_svfprintf_r+0xd38>
    9d98:	f018 0f10 	tst.w	r8, #16
    9d9c:	f040 869f 	bne.w	aade <_svfprintf_r+0x12d6>
    9da0:	f018 0f40 	tst.w	r8, #64	; 0x40
    9da4:	f040 8797 	bne.w	acd6 <_svfprintf_r+0x14ce>
    9da8:	f418 7f00 	tst.w	r8, #512	; 0x200
    9dac:	f000 8697 	beq.w	aade <_svfprintf_r+0x12d6>
    9db0:	9b08      	ldr	r3, [sp, #32]
    9db2:	9904      	ldr	r1, [sp, #16]
    9db4:	f853 2b04 	ldr.w	r2, [r3], #4
    9db8:	9308      	str	r3, [sp, #32]
    9dba:	7011      	strb	r1, [r2, #0]
    9dbc:	464c      	mov	r4, r9
    9dbe:	e555      	b.n	986c <_svfprintf_r+0x64>
    9dc0:	f899 3000 	ldrb.w	r3, [r9]
    9dc4:	2b68      	cmp	r3, #104	; 0x68
    9dc6:	bf03      	ittte	eq
    9dc8:	f899 3001 	ldrbeq.w	r3, [r9, #1]
    9dcc:	f448 7800 	orreq.w	r8, r8, #512	; 0x200
    9dd0:	f109 0901 	addeq.w	r9, r9, #1
    9dd4:	f048 0840 	orrne.w	r8, r8, #64	; 0x40
    9dd8:	e572      	b.n	98c0 <_svfprintf_r+0xb8>
    9dda:	f899 3000 	ldrb.w	r3, [r9]
    9dde:	f88d 5067 	strb.w	r5, [sp, #103]	; 0x67
    9de2:	e56d      	b.n	98c0 <_svfprintf_r+0xb8>
    9de4:	f899 3000 	ldrb.w	r3, [r9]
    9de8:	2b6c      	cmp	r3, #108	; 0x6c
    9dea:	bf03      	ittte	eq
    9dec:	f899 3001 	ldrbeq.w	r3, [r9, #1]
    9df0:	f048 0820 	orreq.w	r8, r8, #32
    9df4:	f109 0901 	addeq.w	r9, r9, #1
    9df8:	f048 0810 	orrne.w	r8, r8, #16
    9dfc:	e560      	b.n	98c0 <_svfprintf_r+0xb8>
    9dfe:	930b      	str	r3, [sp, #44]	; 0x2c
    9e00:	f048 0810 	orr.w	r8, r8, #16
    9e04:	f018 0120 	ands.w	r1, r8, #32
    9e08:	f000 8351 	beq.w	a4ae <_svfprintf_r+0xca6>
    9e0c:	9b08      	ldr	r3, [sp, #32]
    9e0e:	3307      	adds	r3, #7
    9e10:	f023 0307 	bic.w	r3, r3, #7
    9e14:	6859      	ldr	r1, [r3, #4]
    9e16:	f853 2b08 	ldr.w	r2, [r3], #8
    9e1a:	9308      	str	r3, [sp, #32]
    9e1c:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
    9e20:	9302      	str	r3, [sp, #8]
    9e22:	2300      	movs	r3, #0
    9e24:	e795      	b.n	9d52 <_svfprintf_r+0x54a>
    9e26:	930b      	str	r3, [sp, #44]	; 0x2c
    9e28:	f048 0310 	orr.w	r3, r8, #16
    9e2c:	9302      	str	r3, [sp, #8]
    9e2e:	9b02      	ldr	r3, [sp, #8]
    9e30:	f013 0120 	ands.w	r1, r3, #32
    9e34:	f000 8329 	beq.w	a48a <_svfprintf_r+0xc82>
    9e38:	9b08      	ldr	r3, [sp, #32]
    9e3a:	3307      	adds	r3, #7
    9e3c:	f023 0307 	bic.w	r3, r3, #7
    9e40:	6859      	ldr	r1, [r3, #4]
    9e42:	f853 2b08 	ldr.w	r2, [r3], #8
    9e46:	9308      	str	r3, [sp, #32]
    9e48:	2301      	movs	r3, #1
    9e4a:	e782      	b.n	9d52 <_svfprintf_r+0x54a>
    9e4c:	f899 3000 	ldrb.w	r3, [r9]
    9e50:	f048 0880 	orr.w	r8, r8, #128	; 0x80
    9e54:	e534      	b.n	98c0 <_svfprintf_r+0xb8>
    9e56:	bf00      	nop
    9e58:	20000b1c 	.word	0x20000b1c
    9e5c:	20000b20 	.word	0x20000b20
    9e60:	20000b2c 	.word	0x20000b2c
    9e64:	4649      	mov	r1, r9
    9e66:	f811 3b01 	ldrb.w	r3, [r1], #1
    9e6a:	2b2a      	cmp	r3, #42	; 0x2a
    9e6c:	f001 8249 	beq.w	b302 <_svfprintf_r+0x1afa>
    9e70:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    9e74:	2a09      	cmp	r2, #9
    9e76:	4689      	mov	r9, r1
    9e78:	bf98      	it	ls
    9e7a:	2100      	movls	r1, #0
    9e7c:	f201 8144 	bhi.w	b108 <_svfprintf_r+0x1900>
    9e80:	f819 3b01 	ldrb.w	r3, [r9], #1
    9e84:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    9e88:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    9e8c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    9e90:	2a09      	cmp	r2, #9
    9e92:	d9f5      	bls.n	9e80 <_svfprintf_r+0x678>
    9e94:	9103      	str	r1, [sp, #12]
    9e96:	e515      	b.n	98c4 <_svfprintf_r+0xbc>
    9e98:	f899 3000 	ldrb.w	r3, [r9]
    9e9c:	f048 0801 	orr.w	r8, r8, #1
    9ea0:	e50e      	b.n	98c0 <_svfprintf_r+0xb8>
    9ea2:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    9ea6:	2b00      	cmp	r3, #0
    9ea8:	f47f ad8f 	bne.w	99ca <_svfprintf_r+0x1c2>
    9eac:	f899 3000 	ldrb.w	r3, [r9]
    9eb0:	f88d 6067 	strb.w	r6, [sp, #103]	; 0x67
    9eb4:	e504      	b.n	98c0 <_svfprintf_r+0xb8>
    9eb6:	f8cd 8008 	str.w	r8, [sp, #8]
    9eba:	2b01      	cmp	r3, #1
    9ebc:	f000 819d 	beq.w	a1fa <_svfprintf_r+0x9f2>
    9ec0:	2b02      	cmp	r3, #2
    9ec2:	ac50      	add	r4, sp, #320	; 0x140
    9ec4:	d120      	bne.n	9f08 <_svfprintf_r+0x700>
    9ec6:	9811      	ldr	r0, [sp, #68]	; 0x44
    9ec8:	f002 030f 	and.w	r3, r2, #15
    9ecc:	0912      	lsrs	r2, r2, #4
    9ece:	5cc3      	ldrb	r3, [r0, r3]
    9ed0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    9ed4:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
    9ed8:	0909      	lsrs	r1, r1, #4
    9eda:	ea52 0301 	orrs.w	r3, r2, r1
    9ede:	d1f3      	bne.n	9ec8 <_svfprintf_r+0x6c0>
    9ee0:	ab50      	add	r3, sp, #320	; 0x140
    9ee2:	1b1b      	subs	r3, r3, r4
    9ee4:	f8dd 8008 	ldr.w	r8, [sp, #8]
    9ee8:	9305      	str	r3, [sp, #20]
    9eea:	9a05      	ldr	r2, [sp, #20]
    9eec:	9803      	ldr	r0, [sp, #12]
    9eee:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    9ef2:	4282      	cmp	r2, r0
    9ef4:	f04f 0300 	mov.w	r3, #0
    9ef8:	bfb8      	it	lt
    9efa:	4602      	movlt	r2, r0
    9efc:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    9f00:	9307      	str	r3, [sp, #28]
    9f02:	9202      	str	r2, [sp, #8]
    9f04:	930f      	str	r3, [sp, #60]	; 0x3c
    9f06:	e660      	b.n	9bca <_svfprintf_r+0x3c2>
    9f08:	f002 0307 	and.w	r3, r2, #7
    9f0c:	08d2      	lsrs	r2, r2, #3
    9f0e:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
    9f12:	08c9      	lsrs	r1, r1, #3
    9f14:	3330      	adds	r3, #48	; 0x30
    9f16:	ea52 0501 	orrs.w	r5, r2, r1
    9f1a:	4620      	mov	r0, r4
    9f1c:	f804 3d01 	strb.w	r3, [r4, #-1]!
    9f20:	d1f2      	bne.n	9f08 <_svfprintf_r+0x700>
    9f22:	9a02      	ldr	r2, [sp, #8]
    9f24:	07d1      	lsls	r1, r2, #31
    9f26:	f100 824d 	bmi.w	a3c4 <_svfprintf_r+0xbbc>
    9f2a:	ab50      	add	r3, sp, #320	; 0x140
    9f2c:	1b1b      	subs	r3, r3, r4
    9f2e:	4690      	mov	r8, r2
    9f30:	9305      	str	r3, [sp, #20]
    9f32:	e7da      	b.n	9eea <_svfprintf_r+0x6e2>
    9f34:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9f36:	2b65      	cmp	r3, #101	; 0x65
    9f38:	f340 80d4 	ble.w	a0e4 <_svfprintf_r+0x8dc>
    9f3c:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9f40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9f44:	f040 81c1 	bne.w	a2ca <_svfprintf_r+0xac2>
    9f48:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9f4a:	49ba      	ldr	r1, [pc, #744]	; (a234 <_svfprintf_r+0xa2c>)
    9f4c:	f8ca 1000 	str.w	r1, [sl]
    9f50:	3301      	adds	r3, #1
    9f52:	3201      	adds	r2, #1
    9f54:	2101      	movs	r1, #1
    9f56:	2b07      	cmp	r3, #7
    9f58:	9226      	str	r2, [sp, #152]	; 0x98
    9f5a:	9325      	str	r3, [sp, #148]	; 0x94
    9f5c:	f8ca 1004 	str.w	r1, [sl, #4]
    9f60:	f300 8551 	bgt.w	aa06 <_svfprintf_r+0x11fe>
    9f64:	f10a 0a08 	add.w	sl, sl, #8
    9f68:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    9f6a:	990e      	ldr	r1, [sp, #56]	; 0x38
    9f6c:	428b      	cmp	r3, r1
    9f6e:	f280 82d0 	bge.w	a512 <_svfprintf_r+0xd0a>
    9f72:	9b10      	ldr	r3, [sp, #64]	; 0x40
    9f74:	9912      	ldr	r1, [sp, #72]	; 0x48
    9f76:	441a      	add	r2, r3
    9f78:	e9ca 1300 	strd	r1, r3, [sl]
    9f7c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9f7e:	9226      	str	r2, [sp, #152]	; 0x98
    9f80:	3301      	adds	r3, #1
    9f82:	2b07      	cmp	r3, #7
    9f84:	9325      	str	r3, [sp, #148]	; 0x94
    9f86:	f300 8397 	bgt.w	a6b8 <_svfprintf_r+0xeb0>
    9f8a:	f10a 0a08 	add.w	sl, sl, #8
    9f8e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9f90:	1e5c      	subs	r4, r3, #1
    9f92:	2c00      	cmp	r4, #0
    9f94:	f77f add0 	ble.w	9b38 <_svfprintf_r+0x330>
    9f98:	2c10      	cmp	r4, #16
    9f9a:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9f9c:	f340 856e 	ble.w	aa7c <_svfprintf_r+0x1274>
    9fa0:	ee1b 6a10 	vmov	r6, s22
    9fa4:	2510      	movs	r5, #16
    9fa6:	e005      	b.n	9fb4 <_svfprintf_r+0x7ac>
    9fa8:	f10a 0a08 	add.w	sl, sl, #8
    9fac:	3c10      	subs	r4, #16
    9fae:	2c10      	cmp	r4, #16
    9fb0:	f340 8564 	ble.w	aa7c <_svfprintf_r+0x1274>
    9fb4:	3301      	adds	r3, #1
    9fb6:	49a0      	ldr	r1, [pc, #640]	; (a238 <_svfprintf_r+0xa30>)
    9fb8:	3210      	adds	r2, #16
    9fba:	2b07      	cmp	r3, #7
    9fbc:	e9ca 1500 	strd	r1, r5, [sl]
    9fc0:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    9fc4:	ddf0      	ble.n	9fa8 <_svfprintf_r+0x7a0>
    9fc6:	aa24      	add	r2, sp, #144	; 0x90
    9fc8:	4631      	mov	r1, r6
    9fca:	4658      	mov	r0, fp
    9fcc:	f002 fb20 	bl	c610 <__ssprint_r>
    9fd0:	2800      	cmp	r0, #0
    9fd2:	d17e      	bne.n	a0d2 <_svfprintf_r+0x8ca>
    9fd4:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    9fd8:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    9fdc:	e7e6      	b.n	9fac <_svfprintf_r+0x7a4>
    9fde:	9b06      	ldr	r3, [sp, #24]
    9fe0:	9902      	ldr	r1, [sp, #8]
    9fe2:	1a5d      	subs	r5, r3, r1
    9fe4:	2d00      	cmp	r5, #0
    9fe6:	f77f ad8e 	ble.w	9b06 <_svfprintf_r+0x2fe>
    9fea:	2d10      	cmp	r5, #16
    9fec:	9b25      	ldr	r3, [sp, #148]	; 0x94
    9fee:	dd21      	ble.n	a034 <_svfprintf_r+0x82c>
    9ff0:	9409      	str	r4, [sp, #36]	; 0x24
    9ff2:	2610      	movs	r6, #16
    9ff4:	ee1b 4a10 	vmov	r4, s22
    9ff8:	e004      	b.n	a004 <_svfprintf_r+0x7fc>
    9ffa:	3d10      	subs	r5, #16
    9ffc:	2d10      	cmp	r5, #16
    9ffe:	f10a 0a08 	add.w	sl, sl, #8
    a002:	dd16      	ble.n	a032 <_svfprintf_r+0x82a>
    a004:	3301      	adds	r3, #1
    a006:	498c      	ldr	r1, [pc, #560]	; (a238 <_svfprintf_r+0xa30>)
    a008:	3210      	adds	r2, #16
    a00a:	2b07      	cmp	r3, #7
    a00c:	e9ca 1600 	strd	r1, r6, [sl]
    a010:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a014:	ddf1      	ble.n	9ffa <_svfprintf_r+0x7f2>
    a016:	aa24      	add	r2, sp, #144	; 0x90
    a018:	4621      	mov	r1, r4
    a01a:	4658      	mov	r0, fp
    a01c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a020:	f002 faf6 	bl	c610 <__ssprint_r>
    a024:	2800      	cmp	r0, #0
    a026:	d154      	bne.n	a0d2 <_svfprintf_r+0x8ca>
    a028:	3d10      	subs	r5, #16
    a02a:	2d10      	cmp	r5, #16
    a02c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a030:	dce8      	bgt.n	a004 <_svfprintf_r+0x7fc>
    a032:	9c09      	ldr	r4, [sp, #36]	; 0x24
    a034:	4980      	ldr	r1, [pc, #512]	; (a238 <_svfprintf_r+0xa30>)
    a036:	f8ca 5004 	str.w	r5, [sl, #4]
    a03a:	3301      	adds	r3, #1
    a03c:	442a      	add	r2, r5
    a03e:	2b07      	cmp	r3, #7
    a040:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a044:	f8ca 1000 	str.w	r1, [sl]
    a048:	f300 8526 	bgt.w	aa98 <_svfprintf_r+0x1290>
    a04c:	9b03      	ldr	r3, [sp, #12]
    a04e:	9905      	ldr	r1, [sp, #20]
    a050:	1a5d      	subs	r5, r3, r1
    a052:	2d00      	cmp	r5, #0
    a054:	f10a 0a08 	add.w	sl, sl, #8
    a058:	f77f ad5b 	ble.w	9b12 <_svfprintf_r+0x30a>
    a05c:	2d10      	cmp	r5, #16
    a05e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a060:	dd1f      	ble.n	a0a2 <_svfprintf_r+0x89a>
    a062:	4651      	mov	r1, sl
    a064:	2610      	movs	r6, #16
    a066:	ee1b aa10 	vmov	sl, s22
    a06a:	e004      	b.n	a076 <_svfprintf_r+0x86e>
    a06c:	3d10      	subs	r5, #16
    a06e:	2d10      	cmp	r5, #16
    a070:	f101 0108 	add.w	r1, r1, #8
    a074:	dd14      	ble.n	a0a0 <_svfprintf_r+0x898>
    a076:	3301      	adds	r3, #1
    a078:	486f      	ldr	r0, [pc, #444]	; (a238 <_svfprintf_r+0xa30>)
    a07a:	3210      	adds	r2, #16
    a07c:	2b07      	cmp	r3, #7
    a07e:	e9c1 0600 	strd	r0, r6, [r1]
    a082:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a086:	ddf1      	ble.n	a06c <_svfprintf_r+0x864>
    a088:	aa24      	add	r2, sp, #144	; 0x90
    a08a:	4651      	mov	r1, sl
    a08c:	4658      	mov	r0, fp
    a08e:	f002 fabf 	bl	c610 <__ssprint_r>
    a092:	b9f0      	cbnz	r0, a0d2 <_svfprintf_r+0x8ca>
    a094:	3d10      	subs	r5, #16
    a096:	2d10      	cmp	r5, #16
    a098:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a09c:	a927      	add	r1, sp, #156	; 0x9c
    a09e:	dcea      	bgt.n	a076 <_svfprintf_r+0x86e>
    a0a0:	468a      	mov	sl, r1
    a0a2:	3301      	adds	r3, #1
    a0a4:	4964      	ldr	r1, [pc, #400]	; (a238 <_svfprintf_r+0xa30>)
    a0a6:	f8ca 5004 	str.w	r5, [sl, #4]
    a0aa:	442a      	add	r2, r5
    a0ac:	2b07      	cmp	r3, #7
    a0ae:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a0b2:	f8ca 1000 	str.w	r1, [sl]
    a0b6:	f300 81da 	bgt.w	a46e <_svfprintf_r+0xc66>
    a0ba:	f10a 0a08 	add.w	sl, sl, #8
    a0be:	e528      	b.n	9b12 <_svfprintf_r+0x30a>
    a0c0:	ee1b 1a10 	vmov	r1, s22
    a0c4:	aa24      	add	r2, sp, #144	; 0x90
    a0c6:	4658      	mov	r0, fp
    a0c8:	f002 faa2 	bl	c610 <__ssprint_r>
    a0cc:	2800      	cmp	r0, #0
    a0ce:	f43f ad47 	beq.w	9b60 <_svfprintf_r+0x358>
    a0d2:	9b07      	ldr	r3, [sp, #28]
    a0d4:	2b00      	cmp	r3, #0
    a0d6:	f43f aca2 	beq.w	9a1e <_svfprintf_r+0x216>
    a0da:	9907      	ldr	r1, [sp, #28]
    a0dc:	4658      	mov	r0, fp
    a0de:	f7fe fead 	bl	8e3c <_free_r>
    a0e2:	e49c      	b.n	9a1e <_svfprintf_r+0x216>
    a0e4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a0e6:	2b01      	cmp	r3, #1
    a0e8:	f340 817a 	ble.w	a3e0 <_svfprintf_r+0xbd8>
    a0ec:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a0ee:	f8ca 4000 	str.w	r4, [sl]
    a0f2:	3301      	adds	r3, #1
    a0f4:	3201      	adds	r2, #1
    a0f6:	2101      	movs	r1, #1
    a0f8:	2b07      	cmp	r3, #7
    a0fa:	9226      	str	r2, [sp, #152]	; 0x98
    a0fc:	9325      	str	r3, [sp, #148]	; 0x94
    a0fe:	f8ca 1004 	str.w	r1, [sl, #4]
    a102:	f300 81f8 	bgt.w	a4f6 <_svfprintf_r+0xcee>
    a106:	f10a 0a08 	add.w	sl, sl, #8
    a10a:	9910      	ldr	r1, [sp, #64]	; 0x40
    a10c:	9812      	ldr	r0, [sp, #72]	; 0x48
    a10e:	3301      	adds	r3, #1
    a110:	440a      	add	r2, r1
    a112:	2b07      	cmp	r3, #7
    a114:	e9ca 0100 	strd	r0, r1, [sl]
    a118:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a11c:	f300 81dd 	bgt.w	a4da <_svfprintf_r+0xcd2>
    a120:	f10a 0a08 	add.w	sl, sl, #8
    a124:	eeb5 8b40 	vcmp.f64	d8, #0.0
    a128:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a12c:	f000 8177 	beq.w	a41e <_svfprintf_r+0xc16>
    a130:	990e      	ldr	r1, [sp, #56]	; 0x38
    a132:	3301      	adds	r3, #1
    a134:	3901      	subs	r1, #1
    a136:	3401      	adds	r4, #1
    a138:	440a      	add	r2, r1
    a13a:	2b07      	cmp	r3, #7
    a13c:	f8ca 4000 	str.w	r4, [sl]
    a140:	9325      	str	r3, [sp, #148]	; 0x94
    a142:	f8ca 1004 	str.w	r1, [sl, #4]
    a146:	9226      	str	r2, [sp, #152]	; 0x98
    a148:	f300 815b 	bgt.w	a402 <_svfprintf_r+0xbfa>
    a14c:	f10a 0a08 	add.w	sl, sl, #8
    a150:	9914      	ldr	r1, [sp, #80]	; 0x50
    a152:	f8ca 1004 	str.w	r1, [sl, #4]
    a156:	3301      	adds	r3, #1
    a158:	440a      	add	r2, r1
    a15a:	2b07      	cmp	r3, #7
    a15c:	a91e      	add	r1, sp, #120	; 0x78
    a15e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a162:	f8ca 1000 	str.w	r1, [sl]
    a166:	f77f ace5 	ble.w	9b34 <_svfprintf_r+0x32c>
    a16a:	ee1b 1a10 	vmov	r1, s22
    a16e:	aa24      	add	r2, sp, #144	; 0x90
    a170:	4658      	mov	r0, fp
    a172:	f002 fa4d 	bl	c610 <__ssprint_r>
    a176:	2800      	cmp	r0, #0
    a178:	d1ab      	bne.n	a0d2 <_svfprintf_r+0x8ca>
    a17a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a17c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a180:	e4da      	b.n	9b38 <_svfprintf_r+0x330>
    a182:	2d10      	cmp	r5, #16
    a184:	e9dd 1225 	ldrd	r1, r2, [sp, #148]	; 0x94
    a188:	4e2c      	ldr	r6, [pc, #176]	; (a23c <_svfprintf_r+0xa34>)
    a18a:	dd24      	ble.n	a1d6 <_svfprintf_r+0x9ce>
    a18c:	9417      	str	r4, [sp, #92]	; 0x5c
    a18e:	2310      	movs	r3, #16
    a190:	ee1b 4a10 	vmov	r4, s22
    a194:	4608      	mov	r0, r1
    a196:	e004      	b.n	a1a2 <_svfprintf_r+0x99a>
    a198:	3d10      	subs	r5, #16
    a19a:	2d10      	cmp	r5, #16
    a19c:	f10a 0a08 	add.w	sl, sl, #8
    a1a0:	dd17      	ble.n	a1d2 <_svfprintf_r+0x9ca>
    a1a2:	3001      	adds	r0, #1
    a1a4:	3210      	adds	r2, #16
    a1a6:	2807      	cmp	r0, #7
    a1a8:	e9ca 6300 	strd	r6, r3, [sl]
    a1ac:	e9cd 0225 	strd	r0, r2, [sp, #148]	; 0x94
    a1b0:	ddf2      	ble.n	a198 <_svfprintf_r+0x990>
    a1b2:	aa24      	add	r2, sp, #144	; 0x90
    a1b4:	4621      	mov	r1, r4
    a1b6:	4658      	mov	r0, fp
    a1b8:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a1bc:	f002 fa28 	bl	c610 <__ssprint_r>
    a1c0:	2800      	cmp	r0, #0
    a1c2:	d186      	bne.n	a0d2 <_svfprintf_r+0x8ca>
    a1c4:	3d10      	subs	r5, #16
    a1c6:	2d10      	cmp	r5, #16
    a1c8:	e9dd 0225 	ldrd	r0, r2, [sp, #148]	; 0x94
    a1cc:	f04f 0310 	mov.w	r3, #16
    a1d0:	dce7      	bgt.n	a1a2 <_svfprintf_r+0x99a>
    a1d2:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    a1d4:	4601      	mov	r1, r0
    a1d6:	3101      	adds	r1, #1
    a1d8:	442a      	add	r2, r5
    a1da:	2907      	cmp	r1, #7
    a1dc:	e9cd 1225 	strd	r1, r2, [sp, #148]	; 0x94
    a1e0:	f8ca 6000 	str.w	r6, [sl]
    a1e4:	f8ca 5004 	str.w	r5, [sl, #4]
    a1e8:	f300 83bd 	bgt.w	a966 <_svfprintf_r+0x115e>
    a1ec:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    a1f0:	f10a 0a08 	add.w	sl, sl, #8
    a1f4:	e45d      	b.n	9ab2 <_svfprintf_r+0x2aa>
    a1f6:	f8cd 8008 	str.w	r8, [sp, #8]
    a1fa:	2a0a      	cmp	r2, #10
    a1fc:	f171 0300 	sbcs.w	r3, r1, #0
    a200:	f080 8345 	bcs.w	a88e <_svfprintf_r+0x1086>
    a204:	3230      	adds	r2, #48	; 0x30
    a206:	2301      	movs	r3, #1
    a208:	f8dd 8008 	ldr.w	r8, [sp, #8]
    a20c:	f88d 213f 	strb.w	r2, [sp, #319]	; 0x13f
    a210:	9305      	str	r3, [sp, #20]
    a212:	f20d 143f 	addw	r4, sp, #319	; 0x13f
    a216:	e668      	b.n	9eea <_svfprintf_r+0x6e2>
    a218:	ee1b 1a10 	vmov	r1, s22
    a21c:	aa24      	add	r2, sp, #144	; 0x90
    a21e:	4658      	mov	r0, fp
    a220:	f002 f9f6 	bl	c610 <__ssprint_r>
    a224:	2800      	cmp	r0, #0
    a226:	f47f af54 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a22a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a22c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a230:	e452      	b.n	9ad8 <_svfprintf_r+0x2d0>
    a232:	bf00      	nop
    a234:	20000524 	.word	0x20000524
    a238:	20000fc8 	.word	0x20000fc8
    a23c:	20000b5c 	.word	0x20000b5c
    a240:	ee1b 1a10 	vmov	r1, s22
    a244:	aa24      	add	r2, sp, #144	; 0x90
    a246:	4658      	mov	r0, fp
    a248:	f002 f9e2 	bl	c610 <__ssprint_r>
    a24c:	2800      	cmp	r0, #0
    a24e:	f47f af40 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a252:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a254:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a258:	e451      	b.n	9afe <_svfprintf_r+0x2f6>
    a25a:	2c10      	cmp	r4, #16
    a25c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a25e:	4ebe      	ldr	r6, [pc, #760]	; (a558 <_svfprintf_r+0xd50>)
    a260:	dd1f      	ble.n	a2a2 <_svfprintf_r+0xa9a>
    a262:	ee1b 8a10 	vmov	r8, s22
    a266:	2510      	movs	r5, #16
    a268:	e004      	b.n	a274 <_svfprintf_r+0xa6c>
    a26a:	3c10      	subs	r4, #16
    a26c:	2c10      	cmp	r4, #16
    a26e:	f10a 0a08 	add.w	sl, sl, #8
    a272:	dd16      	ble.n	a2a2 <_svfprintf_r+0xa9a>
    a274:	3301      	adds	r3, #1
    a276:	3210      	adds	r2, #16
    a278:	2b07      	cmp	r3, #7
    a27a:	e9ca 6500 	strd	r6, r5, [sl]
    a27e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a282:	ddf2      	ble.n	a26a <_svfprintf_r+0xa62>
    a284:	aa24      	add	r2, sp, #144	; 0x90
    a286:	4641      	mov	r1, r8
    a288:	4658      	mov	r0, fp
    a28a:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a28e:	f002 f9bf 	bl	c610 <__ssprint_r>
    a292:	2800      	cmp	r0, #0
    a294:	f47f af1d 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a298:	3c10      	subs	r4, #16
    a29a:	2c10      	cmp	r4, #16
    a29c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a2a0:	dce8      	bgt.n	a274 <_svfprintf_r+0xa6c>
    a2a2:	3301      	adds	r3, #1
    a2a4:	4422      	add	r2, r4
    a2a6:	2b07      	cmp	r3, #7
    a2a8:	e9ca 6400 	strd	r6, r4, [sl]
    a2ac:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a2b0:	f77f ac4b 	ble.w	9b4a <_svfprintf_r+0x342>
    a2b4:	ee1b 1a10 	vmov	r1, s22
    a2b8:	aa24      	add	r2, sp, #144	; 0x90
    a2ba:	4658      	mov	r0, fp
    a2bc:	f002 f9a8 	bl	c610 <__ssprint_r>
    a2c0:	2800      	cmp	r0, #0
    a2c2:	f47f af06 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a2c6:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a2c8:	e43f      	b.n	9b4a <_svfprintf_r+0x342>
    a2ca:	991b      	ldr	r1, [sp, #108]	; 0x6c
    a2cc:	2900      	cmp	r1, #0
    a2ce:	f340 835a 	ble.w	a986 <_svfprintf_r+0x117e>
    a2d2:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    a2d4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a2d6:	429e      	cmp	r6, r3
    a2d8:	bfa8      	it	ge
    a2da:	461e      	movge	r6, r3
    a2dc:	2e00      	cmp	r6, #0
    a2de:	dd0b      	ble.n	a2f8 <_svfprintf_r+0xaf0>
    a2e0:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a2e2:	3301      	adds	r3, #1
    a2e4:	4432      	add	r2, r6
    a2e6:	2b07      	cmp	r3, #7
    a2e8:	e9ca 4600 	strd	r4, r6, [sl]
    a2ec:	9226      	str	r2, [sp, #152]	; 0x98
    a2ee:	9325      	str	r3, [sp, #148]	; 0x94
    a2f0:	f300 8689 	bgt.w	b006 <_svfprintf_r+0x17fe>
    a2f4:	f10a 0a08 	add.w	sl, sl, #8
    a2f8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    a2fa:	2e00      	cmp	r6, #0
    a2fc:	bfa8      	it	ge
    a2fe:	1bad      	subge	r5, r5, r6
    a300:	2d00      	cmp	r5, #0
    a302:	f300 8203 	bgt.w	a70c <_svfprintf_r+0xf04>
    a306:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a308:	f418 6f80 	tst.w	r8, #1024	; 0x400
    a30c:	4423      	add	r3, r4
    a30e:	9305      	str	r3, [sp, #20]
    a310:	f040 821f 	bne.w	a752 <_svfprintf_r+0xf4a>
    a314:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a316:	990e      	ldr	r1, [sp, #56]	; 0x38
    a318:	428b      	cmp	r3, r1
    a31a:	db03      	blt.n	a324 <_svfprintf_r+0xb1c>
    a31c:	f018 0f01 	tst.w	r8, #1
    a320:	f000 84cf 	beq.w	acc2 <_svfprintf_r+0x14ba>
    a324:	9910      	ldr	r1, [sp, #64]	; 0x40
    a326:	9812      	ldr	r0, [sp, #72]	; 0x48
    a328:	440a      	add	r2, r1
    a32a:	e9ca 0100 	strd	r0, r1, [sl]
    a32e:	9925      	ldr	r1, [sp, #148]	; 0x94
    a330:	9226      	str	r2, [sp, #152]	; 0x98
    a332:	3101      	adds	r1, #1
    a334:	2907      	cmp	r1, #7
    a336:	9125      	str	r1, [sp, #148]	; 0x94
    a338:	f300 86a5 	bgt.w	b086 <_svfprintf_r+0x187e>
    a33c:	f10a 0a08 	add.w	sl, sl, #8
    a340:	990e      	ldr	r1, [sp, #56]	; 0x38
    a342:	1865      	adds	r5, r4, r1
    a344:	1acc      	subs	r4, r1, r3
    a346:	9b05      	ldr	r3, [sp, #20]
    a348:	1aed      	subs	r5, r5, r3
    a34a:	42a5      	cmp	r5, r4
    a34c:	bfa8      	it	ge
    a34e:	4625      	movge	r5, r4
    a350:	2d00      	cmp	r5, #0
    a352:	dd0d      	ble.n	a370 <_svfprintf_r+0xb68>
    a354:	f8ca 3000 	str.w	r3, [sl]
    a358:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a35a:	f8ca 5004 	str.w	r5, [sl, #4]
    a35e:	3301      	adds	r3, #1
    a360:	442a      	add	r2, r5
    a362:	2b07      	cmp	r3, #7
    a364:	9226      	str	r2, [sp, #152]	; 0x98
    a366:	9325      	str	r3, [sp, #148]	; 0x94
    a368:	f300 86bb 	bgt.w	b0e2 <_svfprintf_r+0x18da>
    a36c:	f10a 0a08 	add.w	sl, sl, #8
    a370:	2d00      	cmp	r5, #0
    a372:	bfa8      	it	ge
    a374:	1b64      	subge	r4, r4, r5
    a376:	2c00      	cmp	r4, #0
    a378:	f77f abde 	ble.w	9b38 <_svfprintf_r+0x330>
    a37c:	2c10      	cmp	r4, #16
    a37e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a380:	f340 837c 	ble.w	aa7c <_svfprintf_r+0x1274>
    a384:	ee1b 6a10 	vmov	r6, s22
    a388:	2510      	movs	r5, #16
    a38a:	e005      	b.n	a398 <_svfprintf_r+0xb90>
    a38c:	f10a 0a08 	add.w	sl, sl, #8
    a390:	3c10      	subs	r4, #16
    a392:	2c10      	cmp	r4, #16
    a394:	f340 8372 	ble.w	aa7c <_svfprintf_r+0x1274>
    a398:	3301      	adds	r3, #1
    a39a:	4970      	ldr	r1, [pc, #448]	; (a55c <_svfprintf_r+0xd54>)
    a39c:	3210      	adds	r2, #16
    a39e:	2b07      	cmp	r3, #7
    a3a0:	e9ca 1500 	strd	r1, r5, [sl]
    a3a4:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a3a8:	ddf0      	ble.n	a38c <_svfprintf_r+0xb84>
    a3aa:	aa24      	add	r2, sp, #144	; 0x90
    a3ac:	4631      	mov	r1, r6
    a3ae:	4658      	mov	r0, fp
    a3b0:	f002 f92e 	bl	c610 <__ssprint_r>
    a3b4:	2800      	cmp	r0, #0
    a3b6:	f47f ae8c 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a3ba:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a3be:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a3c2:	e7e5      	b.n	a390 <_svfprintf_r+0xb88>
    a3c4:	2b30      	cmp	r3, #48	; 0x30
    a3c6:	f43f ad8b 	beq.w	9ee0 <_svfprintf_r+0x6d8>
    a3ca:	2330      	movs	r3, #48	; 0x30
    a3cc:	3802      	subs	r0, #2
    a3ce:	f804 3c01 	strb.w	r3, [r4, #-1]
    a3d2:	ab50      	add	r3, sp, #320	; 0x140
    a3d4:	1a1b      	subs	r3, r3, r0
    a3d6:	f8dd 8008 	ldr.w	r8, [sp, #8]
    a3da:	9305      	str	r3, [sp, #20]
    a3dc:	4604      	mov	r4, r0
    a3de:	e584      	b.n	9eea <_svfprintf_r+0x6e2>
    a3e0:	f018 0f01 	tst.w	r8, #1
    a3e4:	f47f ae82 	bne.w	a0ec <_svfprintf_r+0x8e4>
    a3e8:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a3ea:	f8ca 4000 	str.w	r4, [sl]
    a3ee:	3301      	adds	r3, #1
    a3f0:	3201      	adds	r2, #1
    a3f2:	2101      	movs	r1, #1
    a3f4:	2b07      	cmp	r3, #7
    a3f6:	9226      	str	r2, [sp, #152]	; 0x98
    a3f8:	9325      	str	r3, [sp, #148]	; 0x94
    a3fa:	f8ca 1004 	str.w	r1, [sl, #4]
    a3fe:	f77f aea5 	ble.w	a14c <_svfprintf_r+0x944>
    a402:	ee1b 1a10 	vmov	r1, s22
    a406:	aa24      	add	r2, sp, #144	; 0x90
    a408:	4658      	mov	r0, fp
    a40a:	f002 f901 	bl	c610 <__ssprint_r>
    a40e:	2800      	cmp	r0, #0
    a410:	f47f ae5f 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a414:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a418:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a41c:	e698      	b.n	a150 <_svfprintf_r+0x948>
    a41e:	990e      	ldr	r1, [sp, #56]	; 0x38
    a420:	1e4c      	subs	r4, r1, #1
    a422:	2c00      	cmp	r4, #0
    a424:	f77f ae94 	ble.w	a150 <_svfprintf_r+0x948>
    a428:	2c10      	cmp	r4, #16
    a42a:	f340 8361 	ble.w	aaf0 <_svfprintf_r+0x12e8>
    a42e:	ee1b 6a10 	vmov	r6, s22
    a432:	2510      	movs	r5, #16
    a434:	e005      	b.n	a442 <_svfprintf_r+0xc3a>
    a436:	f10a 0a08 	add.w	sl, sl, #8
    a43a:	3c10      	subs	r4, #16
    a43c:	2c10      	cmp	r4, #16
    a43e:	f340 8357 	ble.w	aaf0 <_svfprintf_r+0x12e8>
    a442:	3301      	adds	r3, #1
    a444:	4945      	ldr	r1, [pc, #276]	; (a55c <_svfprintf_r+0xd54>)
    a446:	3210      	adds	r2, #16
    a448:	2b07      	cmp	r3, #7
    a44a:	e9ca 1500 	strd	r1, r5, [sl]
    a44e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a452:	ddf0      	ble.n	a436 <_svfprintf_r+0xc2e>
    a454:	aa24      	add	r2, sp, #144	; 0x90
    a456:	4631      	mov	r1, r6
    a458:	4658      	mov	r0, fp
    a45a:	f002 f8d9 	bl	c610 <__ssprint_r>
    a45e:	2800      	cmp	r0, #0
    a460:	f47f ae37 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a464:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a468:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a46c:	e7e5      	b.n	a43a <_svfprintf_r+0xc32>
    a46e:	ee1b 1a10 	vmov	r1, s22
    a472:	aa24      	add	r2, sp, #144	; 0x90
    a474:	4658      	mov	r0, fp
    a476:	f002 f8cb 	bl	c610 <__ssprint_r>
    a47a:	2800      	cmp	r0, #0
    a47c:	f47f ae29 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a480:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a482:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a486:	f7ff bb44 	b.w	9b12 <_svfprintf_r+0x30a>
    a48a:	9b02      	ldr	r3, [sp, #8]
    a48c:	f013 0310 	ands.w	r3, r3, #16
    a490:	f040 80c1 	bne.w	a616 <_svfprintf_r+0xe0e>
    a494:	9a02      	ldr	r2, [sp, #8]
    a496:	f012 0240 	ands.w	r2, r2, #64	; 0x40
    a49a:	f000 837a 	beq.w	ab92 <_svfprintf_r+0x138a>
    a49e:	9808      	ldr	r0, [sp, #32]
    a4a0:	f850 2b04 	ldr.w	r2, [r0], #4
    a4a4:	9008      	str	r0, [sp, #32]
    a4a6:	4619      	mov	r1, r3
    a4a8:	b292      	uxth	r2, r2
    a4aa:	2301      	movs	r3, #1
    a4ac:	e451      	b.n	9d52 <_svfprintf_r+0x54a>
    a4ae:	f018 0310 	ands.w	r3, r8, #16
    a4b2:	d155      	bne.n	a560 <_svfprintf_r+0xd58>
    a4b4:	f018 0240 	ands.w	r2, r8, #64	; 0x40
    a4b8:	f000 835d 	beq.w	ab76 <_svfprintf_r+0x136e>
    a4bc:	9808      	ldr	r0, [sp, #32]
    a4be:	f850 2b04 	ldr.w	r2, [r0], #4
    a4c2:	9008      	str	r0, [sp, #32]
    a4c4:	4619      	mov	r1, r3
    a4c6:	b292      	uxth	r2, r2
    a4c8:	e4a8      	b.n	9e1c <_svfprintf_r+0x614>
    a4ca:	4252      	negs	r2, r2
    a4cc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a4d0:	f8cd 8008 	str.w	r8, [sp, #8]
    a4d4:	202d      	movs	r0, #45	; 0x2d
    a4d6:	2301      	movs	r3, #1
    a4d8:	e43c      	b.n	9d54 <_svfprintf_r+0x54c>
    a4da:	ee1b 1a10 	vmov	r1, s22
    a4de:	aa24      	add	r2, sp, #144	; 0x90
    a4e0:	4658      	mov	r0, fp
    a4e2:	f002 f895 	bl	c610 <__ssprint_r>
    a4e6:	2800      	cmp	r0, #0
    a4e8:	f47f adf3 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a4ec:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a4f0:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a4f4:	e616      	b.n	a124 <_svfprintf_r+0x91c>
    a4f6:	ee1b 1a10 	vmov	r1, s22
    a4fa:	aa24      	add	r2, sp, #144	; 0x90
    a4fc:	4658      	mov	r0, fp
    a4fe:	f002 f887 	bl	c610 <__ssprint_r>
    a502:	2800      	cmp	r0, #0
    a504:	f47f ade5 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a508:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a50c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a510:	e5fb      	b.n	a10a <_svfprintf_r+0x902>
    a512:	f018 0f01 	tst.w	r8, #1
    a516:	f43f ab0f 	beq.w	9b38 <_svfprintf_r+0x330>
    a51a:	e52a      	b.n	9f72 <_svfprintf_r+0x76a>
    a51c:	9308      	str	r3, [sp, #32]
    a51e:	f899 3000 	ldrb.w	r3, [r9]
    a522:	f7ff b9cd 	b.w	98c0 <_svfprintf_r+0xb8>
    a526:	ac50      	add	r4, sp, #320	; 0x140
    a528:	e4df      	b.n	9eea <_svfprintf_r+0x6e2>
    a52a:	f418 7f00 	tst.w	r8, #512	; 0x200
    a52e:	f040 83db 	bne.w	ace8 <_svfprintf_r+0x14e0>
    a532:	f853 2b04 	ldr.w	r2, [r3], #4
    a536:	9308      	str	r3, [sp, #32]
    a538:	17d1      	asrs	r1, r2, #31
    a53a:	460b      	mov	r3, r1
    a53c:	f7ff bbb6 	b.w	9cac <_svfprintf_r+0x4a4>
    a540:	9b08      	ldr	r3, [sp, #32]
    a542:	9804      	ldr	r0, [sp, #16]
    a544:	f853 1b04 	ldr.w	r1, [r3], #4
    a548:	9308      	str	r3, [sp, #32]
    a54a:	17c2      	asrs	r2, r0, #31
    a54c:	e9c1 0200 	strd	r0, r2, [r1]
    a550:	464c      	mov	r4, r9
    a552:	f7ff b98b 	b.w	986c <_svfprintf_r+0x64>
    a556:	bf00      	nop
    a558:	20000b5c 	.word	0x20000b5c
    a55c:	20000fc8 	.word	0x20000fc8
    a560:	9b08      	ldr	r3, [sp, #32]
    a562:	f853 2b04 	ldr.w	r2, [r3], #4
    a566:	9308      	str	r3, [sp, #32]
    a568:	e458      	b.n	9e1c <_svfprintf_r+0x614>
    a56a:	eeb4 8b48 	vcmp.f64	d8, d8
    a56e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a572:	f180 8694 	bvs.w	b29e <_svfprintf_r+0x1a96>
    a576:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a578:	2b61      	cmp	r3, #97	; 0x61
    a57a:	f000 8552 	beq.w	b022 <_svfprintf_r+0x181a>
    a57e:	2b41      	cmp	r3, #65	; 0x41
    a580:	f000 85c0 	beq.w	b104 <_svfprintf_r+0x18fc>
    a584:	9b03      	ldr	r3, [sp, #12]
    a586:	3301      	adds	r3, #1
    a588:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a58a:	f023 0520 	bic.w	r5, r3, #32
    a58e:	f000 8480 	beq.w	ae92 <_svfprintf_r+0x168a>
    a592:	2d47      	cmp	r5, #71	; 0x47
    a594:	d104      	bne.n	a5a0 <_svfprintf_r+0xd98>
    a596:	9b03      	ldr	r3, [sp, #12]
    a598:	2b00      	cmp	r3, #0
    a59a:	bf08      	it	eq
    a59c:	2301      	moveq	r3, #1
    a59e:	9303      	str	r3, [sp, #12]
    a5a0:	ee18 3a90 	vmov	r3, s17
    a5a4:	2b00      	cmp	r3, #0
    a5a6:	f448 7280 	orr.w	r2, r8, #256	; 0x100
    a5aa:	4646      	mov	r6, r8
    a5ac:	f2c0 8618 	blt.w	b1e0 <_svfprintf_r+0x19d8>
    a5b0:	eeb0 ab48 	vmov.f64	d10, d8
    a5b4:	2300      	movs	r3, #0
    a5b6:	4690      	mov	r8, r2
    a5b8:	9309      	str	r3, [sp, #36]	; 0x24
    a5ba:	9307      	str	r3, [sp, #28]
    a5bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a5be:	3b41      	subs	r3, #65	; 0x41
    a5c0:	2b25      	cmp	r3, #37	; 0x25
    a5c2:	f200 8398 	bhi.w	acf6 <_svfprintf_r+0x14ee>
    a5c6:	e8df f013 	tbh	[pc, r3, lsl #1]
    a5ca:	046f      	.short	0x046f
    a5cc:	03960396 	.word	0x03960396
    a5d0:	04680396 	.word	0x04680396
    a5d4:	0396046c 	.word	0x0396046c
    a5d8:	03960396 	.word	0x03960396
    a5dc:	03960396 	.word	0x03960396
    a5e0:	03960396 	.word	0x03960396
    a5e4:	03960396 	.word	0x03960396
    a5e8:	03960396 	.word	0x03960396
    a5ec:	03960396 	.word	0x03960396
    a5f0:	03960396 	.word	0x03960396
    a5f4:	03960396 	.word	0x03960396
    a5f8:	03960396 	.word	0x03960396
    a5fc:	03960396 	.word	0x03960396
    a600:	03960396 	.word	0x03960396
    a604:	03960396 	.word	0x03960396
    a608:	03960396 	.word	0x03960396
    a60c:	03960396 	.word	0x03960396
    a610:	04680396 	.word	0x04680396
    a614:	046c      	.short	0x046c
    a616:	9b08      	ldr	r3, [sp, #32]
    a618:	f853 2b04 	ldr.w	r2, [r3], #4
    a61c:	9308      	str	r3, [sp, #32]
    a61e:	2301      	movs	r3, #1
    a620:	f7ff bb97 	b.w	9d52 <_svfprintf_r+0x54a>
    a624:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    a626:	2b00      	cmp	r3, #0
    a628:	f43f a9cf 	beq.w	99ca <_svfprintf_r+0x1c2>
    a62c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    a62e:	781b      	ldrb	r3, [r3, #0]
    a630:	2b00      	cmp	r3, #0
    a632:	f43f a9ca 	beq.w	99ca <_svfprintf_r+0x1c2>
    a636:	f899 3000 	ldrb.w	r3, [r9]
    a63a:	f448 6880 	orr.w	r8, r8, #1024	; 0x400
    a63e:	f7ff b93f 	b.w	98c0 <_svfprintf_r+0xb8>
    a642:	930b      	str	r3, [sp, #44]	; 0x2c
    a644:	f8cd 8008 	str.w	r8, [sp, #8]
    a648:	f7ff bbf1 	b.w	9e2e <_svfprintf_r+0x626>
    a64c:	930b      	str	r3, [sp, #44]	; 0x2c
    a64e:	4b9a      	ldr	r3, [pc, #616]	; (a8b8 <_svfprintf_r+0x10b0>)
    a650:	9311      	str	r3, [sp, #68]	; 0x44
    a652:	f018 0120 	ands.w	r1, r8, #32
    a656:	f000 8105 	beq.w	a864 <_svfprintf_r+0x105c>
    a65a:	9b08      	ldr	r3, [sp, #32]
    a65c:	3307      	adds	r3, #7
    a65e:	f023 0307 	bic.w	r3, r3, #7
    a662:	6859      	ldr	r1, [r3, #4]
    a664:	f853 2b08 	ldr.w	r2, [r3], #8
    a668:	9308      	str	r3, [sp, #32]
    a66a:	f018 0f01 	tst.w	r8, #1
    a66e:	d00a      	beq.n	a686 <_svfprintf_r+0xe7e>
    a670:	ea52 0301 	orrs.w	r3, r2, r1
    a674:	d007      	beq.n	a686 <_svfprintf_r+0xe7e>
    a676:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a678:	f88d 3069 	strb.w	r3, [sp, #105]	; 0x69
    a67c:	2330      	movs	r3, #48	; 0x30
    a67e:	f048 0802 	orr.w	r8, r8, #2
    a682:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
    a686:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
    a68a:	9302      	str	r3, [sp, #8]
    a68c:	2302      	movs	r3, #2
    a68e:	f7ff bb60 	b.w	9d52 <_svfprintf_r+0x54a>
    a692:	930b      	str	r3, [sp, #44]	; 0x2c
    a694:	f7ff bbb6 	b.w	9e04 <_svfprintf_r+0x5fc>
    a698:	930b      	str	r3, [sp, #44]	; 0x2c
    a69a:	4b88      	ldr	r3, [pc, #544]	; (a8bc <_svfprintf_r+0x10b4>)
    a69c:	9311      	str	r3, [sp, #68]	; 0x44
    a69e:	e7d8      	b.n	a652 <_svfprintf_r+0xe4a>
    a6a0:	9b08      	ldr	r3, [sp, #32]
    a6a2:	2101      	movs	r1, #1
    a6a4:	f853 2b04 	ldr.w	r2, [r3], #4
    a6a8:	9102      	str	r1, [sp, #8]
    a6aa:	f88d 20dc 	strb.w	r2, [sp, #220]	; 0xdc
    a6ae:	9308      	str	r3, [sp, #32]
    a6b0:	9105      	str	r1, [sp, #20]
    a6b2:	ac37      	add	r4, sp, #220	; 0xdc
    a6b4:	f7ff baaf 	b.w	9c16 <_svfprintf_r+0x40e>
    a6b8:	ee1b 1a10 	vmov	r1, s22
    a6bc:	aa24      	add	r2, sp, #144	; 0x90
    a6be:	4658      	mov	r0, fp
    a6c0:	f001 ffa6 	bl	c610 <__ssprint_r>
    a6c4:	2800      	cmp	r0, #0
    a6c6:	f47f ad04 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a6ca:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a6cc:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a6d0:	e45d      	b.n	9f8e <_svfprintf_r+0x786>
    a6d2:	9b03      	ldr	r3, [sp, #12]
    a6d4:	9407      	str	r4, [sp, #28]
    a6d6:	2b06      	cmp	r3, #6
    a6d8:	4622      	mov	r2, r4
    a6da:	bf28      	it	cs
    a6dc:	2306      	movcs	r3, #6
    a6de:	9403      	str	r4, [sp, #12]
    a6e0:	4621      	mov	r1, r4
    a6e2:	e9cd 220c 	strd	r2, r2, [sp, #48]	; 0x30
    a6e6:	4c76      	ldr	r4, [pc, #472]	; (a8c0 <_svfprintf_r+0x10b8>)
    a6e8:	9302      	str	r3, [sp, #8]
    a6ea:	9305      	str	r3, [sp, #20]
    a6ec:	920f      	str	r2, [sp, #60]	; 0x3c
    a6ee:	f7ff ba6c 	b.w	9bca <_svfprintf_r+0x3c2>
    a6f2:	2140      	movs	r1, #64	; 0x40
    a6f4:	4658      	mov	r0, fp
    a6f6:	f7fd fb01 	bl	7cfc <_malloc_r>
    a6fa:	6020      	str	r0, [r4, #0]
    a6fc:	6120      	str	r0, [r4, #16]
    a6fe:	2800      	cmp	r0, #0
    a700:	f000 860f 	beq.w	b322 <_svfprintf_r+0x1b1a>
    a704:	2340      	movs	r3, #64	; 0x40
    a706:	6163      	str	r3, [r4, #20]
    a708:	f7ff b89e 	b.w	9848 <_svfprintf_r+0x40>
    a70c:	2d10      	cmp	r5, #16
    a70e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a710:	f340 825d 	ble.w	abce <_svfprintf_r+0x13c6>
    a714:	4651      	mov	r1, sl
    a716:	2610      	movs	r6, #16
    a718:	ee1b aa10 	vmov	sl, s22
    a71c:	e004      	b.n	a728 <_svfprintf_r+0xf20>
    a71e:	3108      	adds	r1, #8
    a720:	3d10      	subs	r5, #16
    a722:	2d10      	cmp	r5, #16
    a724:	f340 8252 	ble.w	abcc <_svfprintf_r+0x13c4>
    a728:	3301      	adds	r3, #1
    a72a:	4866      	ldr	r0, [pc, #408]	; (a8c4 <_svfprintf_r+0x10bc>)
    a72c:	3210      	adds	r2, #16
    a72e:	2b07      	cmp	r3, #7
    a730:	e9c1 0600 	strd	r0, r6, [r1]
    a734:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a738:	ddf1      	ble.n	a71e <_svfprintf_r+0xf16>
    a73a:	aa24      	add	r2, sp, #144	; 0x90
    a73c:	4651      	mov	r1, sl
    a73e:	4658      	mov	r0, fp
    a740:	f001 ff66 	bl	c610 <__ssprint_r>
    a744:	2800      	cmp	r0, #0
    a746:	f47f acc4 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a74a:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a74e:	a927      	add	r1, sp, #156	; 0x9c
    a750:	e7e6      	b.n	a720 <_svfprintf_r+0xf18>
    a752:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a754:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    a758:	18e3      	adds	r3, r4, r3
    a75a:	9303      	str	r3, [sp, #12]
    a75c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a75e:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
    a762:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    a764:	9d05      	ldr	r5, [sp, #20]
    a766:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
    a76a:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    a76e:	940b      	str	r4, [sp, #44]	; 0x2c
    a770:	ee1b 1a10 	vmov	r1, s22
    a774:	4650      	mov	r0, sl
    a776:	2b00      	cmp	r3, #0
    a778:	d034      	beq.n	a7e4 <_svfprintf_r+0xfdc>
    a77a:	f1b8 0f00 	cmp.w	r8, #0
    a77e:	d135      	bne.n	a7ec <_svfprintf_r+0xfe4>
    a780:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a782:	3b01      	subs	r3, #1
    a784:	3e01      	subs	r6, #1
    a786:	930d      	str	r3, [sp, #52]	; 0x34
    a788:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a78a:	e9c0 3900 	strd	r3, r9, [r0]
    a78e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a790:	3301      	adds	r3, #1
    a792:	444a      	add	r2, r9
    a794:	2b07      	cmp	r3, #7
    a796:	9226      	str	r2, [sp, #152]	; 0x98
    a798:	9325      	str	r3, [sp, #148]	; 0x94
    a79a:	dc6c      	bgt.n	a876 <_svfprintf_r+0x106e>
    a79c:	3008      	adds	r0, #8
    a79e:	9b03      	ldr	r3, [sp, #12]
    a7a0:	f896 c000 	ldrb.w	ip, [r6]
    a7a4:	1b5b      	subs	r3, r3, r5
    a7a6:	4563      	cmp	r3, ip
    a7a8:	bfa8      	it	ge
    a7aa:	4663      	movge	r3, ip
    a7ac:	2b00      	cmp	r3, #0
    a7ae:	469a      	mov	sl, r3
    a7b0:	dd0c      	ble.n	a7cc <_svfprintf_r+0xfc4>
    a7b2:	9c25      	ldr	r4, [sp, #148]	; 0x94
    a7b4:	3401      	adds	r4, #1
    a7b6:	441a      	add	r2, r3
    a7b8:	2c07      	cmp	r4, #7
    a7ba:	e9c0 5300 	strd	r5, r3, [r0]
    a7be:	9226      	str	r2, [sp, #152]	; 0x98
    a7c0:	9425      	str	r4, [sp, #148]	; 0x94
    a7c2:	f300 8177 	bgt.w	aab4 <_svfprintf_r+0x12ac>
    a7c6:	f896 c000 	ldrb.w	ip, [r6]
    a7ca:	3008      	adds	r0, #8
    a7cc:	f1ba 0f00 	cmp.w	sl, #0
    a7d0:	bfac      	ite	ge
    a7d2:	ebac 040a 	subge.w	r4, ip, sl
    a7d6:	4664      	movlt	r4, ip
    a7d8:	2c00      	cmp	r4, #0
    a7da:	dc0a      	bgt.n	a7f2 <_svfprintf_r+0xfea>
    a7dc:	4465      	add	r5, ip
    a7de:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a7e0:	2b00      	cmp	r3, #0
    a7e2:	d1ca      	bne.n	a77a <_svfprintf_r+0xf72>
    a7e4:	f1b8 0f00 	cmp.w	r8, #0
    a7e8:	f000 83ac 	beq.w	af44 <_svfprintf_r+0x173c>
    a7ec:	f108 38ff 	add.w	r8, r8, #4294967295
    a7f0:	e7ca      	b.n	a788 <_svfprintf_r+0xf80>
    a7f2:	2c10      	cmp	r4, #16
    a7f4:	f8dd c094 	ldr.w	ip, [sp, #148]	; 0x94
    a7f8:	dd24      	ble.n	a844 <_svfprintf_r+0x103c>
    a7fa:	9505      	str	r5, [sp, #20]
    a7fc:	f04f 0a10 	mov.w	sl, #16
    a800:	4663      	mov	r3, ip
    a802:	460d      	mov	r5, r1
    a804:	e004      	b.n	a810 <_svfprintf_r+0x1008>
    a806:	3c10      	subs	r4, #16
    a808:	2c10      	cmp	r4, #16
    a80a:	f100 0008 	add.w	r0, r0, #8
    a80e:	dd16      	ble.n	a83e <_svfprintf_r+0x1036>
    a810:	3301      	adds	r3, #1
    a812:	492c      	ldr	r1, [pc, #176]	; (a8c4 <_svfprintf_r+0x10bc>)
    a814:	3210      	adds	r2, #16
    a816:	2b07      	cmp	r3, #7
    a818:	e9c0 1a00 	strd	r1, sl, [r0]
    a81c:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a820:	ddf1      	ble.n	a806 <_svfprintf_r+0xffe>
    a822:	aa24      	add	r2, sp, #144	; 0x90
    a824:	4629      	mov	r1, r5
    a826:	4658      	mov	r0, fp
    a828:	f001 fef2 	bl	c610 <__ssprint_r>
    a82c:	2800      	cmp	r0, #0
    a82e:	f47f ac50 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a832:	3c10      	subs	r4, #16
    a834:	2c10      	cmp	r4, #16
    a836:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    a83a:	a827      	add	r0, sp, #156	; 0x9c
    a83c:	dce8      	bgt.n	a810 <_svfprintf_r+0x1008>
    a83e:	4629      	mov	r1, r5
    a840:	9d05      	ldr	r5, [sp, #20]
    a842:	469c      	mov	ip, r3
    a844:	f10c 0301 	add.w	r3, ip, #1
    a848:	4422      	add	r2, r4
    a84a:	6044      	str	r4, [r0, #4]
    a84c:	2b07      	cmp	r3, #7
    a84e:	4c1d      	ldr	r4, [pc, #116]	; (a8c4 <_svfprintf_r+0x10bc>)
    a850:	6004      	str	r4, [r0, #0]
    a852:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a856:	f300 83c6 	bgt.w	afe6 <_svfprintf_r+0x17de>
    a85a:	f896 c000 	ldrb.w	ip, [r6]
    a85e:	3008      	adds	r0, #8
    a860:	4465      	add	r5, ip
    a862:	e7bc      	b.n	a7de <_svfprintf_r+0xfd6>
    a864:	f018 0310 	ands.w	r3, r8, #16
    a868:	f000 80c2 	beq.w	a9f0 <_svfprintf_r+0x11e8>
    a86c:	9b08      	ldr	r3, [sp, #32]
    a86e:	f853 2b04 	ldr.w	r2, [r3], #4
    a872:	9308      	str	r3, [sp, #32]
    a874:	e6f9      	b.n	a66a <_svfprintf_r+0xe62>
    a876:	aa24      	add	r2, sp, #144	; 0x90
    a878:	4658      	mov	r0, fp
    a87a:	9105      	str	r1, [sp, #20]
    a87c:	f001 fec8 	bl	c610 <__ssprint_r>
    a880:	2800      	cmp	r0, #0
    a882:	f47f ac26 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a886:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a888:	9905      	ldr	r1, [sp, #20]
    a88a:	a827      	add	r0, sp, #156	; 0x9c
    a88c:	e787      	b.n	a79e <_svfprintf_r+0xf96>
    a88e:	9802      	ldr	r0, [sp, #8]
    a890:	f8cd a01c 	str.w	sl, [sp, #28]
    a894:	ac50      	add	r4, sp, #320	; 0x140
    a896:	f400 6080 	and.w	r0, r0, #1024	; 0x400
    a89a:	2500      	movs	r5, #0
    a89c:	ee0a ba10 	vmov	s20, fp
    a8a0:	4b09      	ldr	r3, [pc, #36]	; (a8c8 <_svfprintf_r+0x10c0>)
    a8a2:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    a8a6:	f8cd 9014 	str.w	r9, [sp, #20]
    a8aa:	46a3      	mov	fp, r4
    a8ac:	f04f 0805 	mov.w	r8, #5
    a8b0:	46ac      	mov	ip, r5
    a8b2:	4604      	mov	r4, r0
    a8b4:	e010      	b.n	a8d8 <_svfprintf_r+0x10d0>
    a8b6:	bf00      	nop
    a8b8:	20000b2c 	.word	0x20000b2c
    a8bc:	20000b40 	.word	0x20000b40
    a8c0:	20000b54 	.word	0x20000b54
    a8c4:	20000fc8 	.word	0x20000fc8
    a8c8:	cccccccd 	.word	0xcccccccd
    a8cc:	2a0a      	cmp	r2, #10
    a8ce:	f171 0100 	sbcs.w	r1, r1, #0
    a8d2:	d336      	bcc.n	a942 <_svfprintf_r+0x113a>
    a8d4:	464a      	mov	r2, r9
    a8d6:	4631      	mov	r1, r6
    a8d8:	1850      	adds	r0, r2, r1
    a8da:	f140 0000 	adc.w	r0, r0, #0
    a8de:	fba3 5600 	umull	r5, r6, r3, r0
    a8e2:	f026 0503 	bic.w	r5, r6, #3
    a8e6:	eb05 0596 	add.w	r5, r5, r6, lsr #2
    a8ea:	1b40      	subs	r0, r0, r5
    a8ec:	1a15      	subs	r5, r2, r0
    a8ee:	f04f 36cc 	mov.w	r6, #3435973836	; 0xcccccccc
    a8f2:	f161 0e00 	sbc.w	lr, r1, #0
    a8f6:	fb06 f605 	mul.w	r6, r6, r5
    a8fa:	fba5 9503 	umull	r9, r5, r5, r3
    a8fe:	fb03 660e 	mla	r6, r3, lr, r6
    a902:	f009 0e01 	and.w	lr, r9, #1
    a906:	442e      	add	r6, r5
    a908:	fbae 5e08 	umull	r5, lr, lr, r8
    a90c:	182d      	adds	r5, r5, r0
    a90e:	ea4f 0959 	mov.w	r9, r9, lsr #1
    a912:	3530      	adds	r5, #48	; 0x30
    a914:	f80b 5c01 	strb.w	r5, [fp, #-1]
    a918:	ea49 79c6 	orr.w	r9, r9, r6, lsl #31
    a91c:	f10c 0c01 	add.w	ip, ip, #1
    a920:	f10b 3bff 	add.w	fp, fp, #4294967295
    a924:	0876      	lsrs	r6, r6, #1
    a926:	2c00      	cmp	r4, #0
    a928:	d0d0      	beq.n	a8cc <_svfprintf_r+0x10c4>
    a92a:	f89a 0000 	ldrb.w	r0, [sl]
    a92e:	4584      	cmp	ip, r0
    a930:	d1cc      	bne.n	a8cc <_svfprintf_r+0x10c4>
    a932:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    a936:	d0c9      	beq.n	a8cc <_svfprintf_r+0x10c4>
    a938:	2a0a      	cmp	r2, #10
    a93a:	f171 0100 	sbcs.w	r1, r1, #0
    a93e:	f080 818f 	bcs.w	ac60 <_svfprintf_r+0x1458>
    a942:	465c      	mov	r4, fp
    a944:	ab50      	add	r3, sp, #320	; 0x140
    a946:	1b1b      	subs	r3, r3, r4
    a948:	f8dd 9014 	ldr.w	r9, [sp, #20]
    a94c:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    a950:	ee1a ba10 	vmov	fp, s20
    a954:	f8dd a01c 	ldr.w	sl, [sp, #28]
    a958:	f8dd 8008 	ldr.w	r8, [sp, #8]
    a95c:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
    a960:	9305      	str	r3, [sp, #20]
    a962:	f7ff bac2 	b.w	9eea <_svfprintf_r+0x6e2>
    a966:	ee1b 1a10 	vmov	r1, s22
    a96a:	aa24      	add	r2, sp, #144	; 0x90
    a96c:	4658      	mov	r0, fp
    a96e:	f001 fe4f 	bl	c610 <__ssprint_r>
    a972:	2800      	cmp	r0, #0
    a974:	f47f abad 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    a978:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    a97c:	9a26      	ldr	r2, [sp, #152]	; 0x98
    a97e:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    a982:	f7ff b896 	b.w	9ab2 <_svfprintf_r+0x2aa>
    a986:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a988:	48be      	ldr	r0, [pc, #760]	; (ac84 <_svfprintf_r+0x147c>)
    a98a:	f8ca 0000 	str.w	r0, [sl]
    a98e:	3301      	adds	r3, #1
    a990:	3201      	adds	r2, #1
    a992:	2001      	movs	r0, #1
    a994:	2b07      	cmp	r3, #7
    a996:	9226      	str	r2, [sp, #152]	; 0x98
    a998:	9325      	str	r3, [sp, #148]	; 0x94
    a99a:	f8ca 0004 	str.w	r0, [sl, #4]
    a99e:	f300 8177 	bgt.w	ac90 <_svfprintf_r+0x1488>
    a9a2:	f10a 0a08 	add.w	sl, sl, #8
    a9a6:	2900      	cmp	r1, #0
    a9a8:	f040 80af 	bne.w	ab0a <_svfprintf_r+0x1302>
    a9ac:	990e      	ldr	r1, [sp, #56]	; 0x38
    a9ae:	f008 0301 	and.w	r3, r8, #1
    a9b2:	430b      	orrs	r3, r1
    a9b4:	f43f a8c0 	beq.w	9b38 <_svfprintf_r+0x330>
    a9b8:	9b10      	ldr	r3, [sp, #64]	; 0x40
    a9ba:	9912      	ldr	r1, [sp, #72]	; 0x48
    a9bc:	441a      	add	r2, r3
    a9be:	e9ca 1300 	strd	r1, r3, [sl]
    a9c2:	9b25      	ldr	r3, [sp, #148]	; 0x94
    a9c4:	9226      	str	r2, [sp, #152]	; 0x98
    a9c6:	3301      	adds	r3, #1
    a9c8:	2b07      	cmp	r3, #7
    a9ca:	9325      	str	r3, [sp, #148]	; 0x94
    a9cc:	f300 8252 	bgt.w	ae74 <_svfprintf_r+0x166c>
    a9d0:	f10a 0a08 	add.w	sl, sl, #8
    a9d4:	990e      	ldr	r1, [sp, #56]	; 0x38
    a9d6:	f8ca 4000 	str.w	r4, [sl]
    a9da:	3301      	adds	r3, #1
    a9dc:	440a      	add	r2, r1
    a9de:	2b07      	cmp	r3, #7
    a9e0:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    a9e4:	f8ca 1004 	str.w	r1, [sl, #4]
    a9e8:	f77f a8a4 	ble.w	9b34 <_svfprintf_r+0x32c>
    a9ec:	f7ff bbbd 	b.w	a16a <_svfprintf_r+0x962>
    a9f0:	f018 0240 	ands.w	r2, r8, #64	; 0x40
    a9f4:	f000 80dd 	beq.w	abb2 <_svfprintf_r+0x13aa>
    a9f8:	9808      	ldr	r0, [sp, #32]
    a9fa:	f850 2b04 	ldr.w	r2, [r0], #4
    a9fe:	9008      	str	r0, [sp, #32]
    aa00:	4619      	mov	r1, r3
    aa02:	b292      	uxth	r2, r2
    aa04:	e631      	b.n	a66a <_svfprintf_r+0xe62>
    aa06:	ee1b 1a10 	vmov	r1, s22
    aa0a:	aa24      	add	r2, sp, #144	; 0x90
    aa0c:	4658      	mov	r0, fp
    aa0e:	f001 fdff 	bl	c610 <__ssprint_r>
    aa12:	2800      	cmp	r0, #0
    aa14:	f47f ab5d 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    aa18:	9a26      	ldr	r2, [sp, #152]	; 0x98
    aa1a:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    aa1e:	f7ff baa3 	b.w	9f68 <_svfprintf_r+0x760>
    aa22:	ae22      	add	r6, sp, #136	; 0x88
    aa24:	2208      	movs	r2, #8
    aa26:	2100      	movs	r1, #0
    aa28:	4630      	mov	r0, r6
    aa2a:	941d      	str	r4, [sp, #116]	; 0x74
    aa2c:	f7fe f81a 	bl	8a64 <memset>
    aa30:	9b03      	ldr	r3, [sp, #12]
    aa32:	1c5a      	adds	r2, r3, #1
    aa34:	f000 80db 	beq.w	abee <_svfprintf_r+0x13e6>
    aa38:	2500      	movs	r5, #0
    aa3a:	f8cd 9008 	str.w	r9, [sp, #8]
    aa3e:	f8cd 801c 	str.w	r8, [sp, #28]
    aa42:	4699      	mov	r9, r3
    aa44:	46a8      	mov	r8, r5
    aa46:	e00c      	b.n	aa62 <_svfprintf_r+0x125a>
    aa48:	a937      	add	r1, sp, #220	; 0xdc
    aa4a:	4658      	mov	r0, fp
    aa4c:	f001 fd9a 	bl	c584 <_wcrtomb_r>
    aa50:	1c43      	adds	r3, r0, #1
    aa52:	4440      	add	r0, r8
    aa54:	f000 83c8 	beq.w	b1e8 <_svfprintf_r+0x19e0>
    aa58:	4548      	cmp	r0, r9
    aa5a:	dc08      	bgt.n	aa6e <_svfprintf_r+0x1266>
    aa5c:	f000 8418 	beq.w	b290 <_svfprintf_r+0x1a88>
    aa60:	4680      	mov	r8, r0
    aa62:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    aa64:	5952      	ldr	r2, [r2, r5]
    aa66:	4633      	mov	r3, r6
    aa68:	3504      	adds	r5, #4
    aa6a:	2a00      	cmp	r2, #0
    aa6c:	d1ec      	bne.n	aa48 <_svfprintf_r+0x1240>
    aa6e:	f8cd 8014 	str.w	r8, [sp, #20]
    aa72:	f8dd 9008 	ldr.w	r9, [sp, #8]
    aa76:	f8dd 801c 	ldr.w	r8, [sp, #28]
    aa7a:	e0c5      	b.n	ac08 <_svfprintf_r+0x1400>
    aa7c:	3301      	adds	r3, #1
    aa7e:	4982      	ldr	r1, [pc, #520]	; (ac88 <_svfprintf_r+0x1480>)
    aa80:	f8ca 4004 	str.w	r4, [sl, #4]
    aa84:	4422      	add	r2, r4
    aa86:	2b07      	cmp	r3, #7
    aa88:	f8ca 1000 	str.w	r1, [sl]
    aa8c:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    aa90:	f77f a850 	ble.w	9b34 <_svfprintf_r+0x32c>
    aa94:	f7ff bb69 	b.w	a16a <_svfprintf_r+0x962>
    aa98:	ee1b 1a10 	vmov	r1, s22
    aa9c:	aa24      	add	r2, sp, #144	; 0x90
    aa9e:	4658      	mov	r0, fp
    aaa0:	f001 fdb6 	bl	c610 <__ssprint_r>
    aaa4:	2800      	cmp	r0, #0
    aaa6:	f47f ab14 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    aaaa:	9a26      	ldr	r2, [sp, #152]	; 0x98
    aaac:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    aab0:	f7ff b829 	b.w	9b06 <_svfprintf_r+0x2fe>
    aab4:	aa24      	add	r2, sp, #144	; 0x90
    aab6:	4658      	mov	r0, fp
    aab8:	9105      	str	r1, [sp, #20]
    aaba:	f001 fda9 	bl	c610 <__ssprint_r>
    aabe:	2800      	cmp	r0, #0
    aac0:	f47f ab07 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    aac4:	f896 c000 	ldrb.w	ip, [r6]
    aac8:	9a26      	ldr	r2, [sp, #152]	; 0x98
    aaca:	9905      	ldr	r1, [sp, #20]
    aacc:	a827      	add	r0, sp, #156	; 0x9c
    aace:	e67d      	b.n	a7cc <_svfprintf_r+0xfc4>
    aad0:	2b01      	cmp	r3, #1
    aad2:	f8cd 8008 	str.w	r8, [sp, #8]
    aad6:	f47f a9f3 	bne.w	9ec0 <_svfprintf_r+0x6b8>
    aada:	f7ff bb93 	b.w	a204 <_svfprintf_r+0x9fc>
    aade:	9b08      	ldr	r3, [sp, #32]
    aae0:	9904      	ldr	r1, [sp, #16]
    aae2:	f853 2b04 	ldr.w	r2, [r3], #4
    aae6:	464c      	mov	r4, r9
    aae8:	6011      	str	r1, [r2, #0]
    aaea:	9308      	str	r3, [sp, #32]
    aaec:	f7fe bebe 	b.w	986c <_svfprintf_r+0x64>
    aaf0:	3301      	adds	r3, #1
    aaf2:	4965      	ldr	r1, [pc, #404]	; (ac88 <_svfprintf_r+0x1480>)
    aaf4:	f8ca 4004 	str.w	r4, [sl, #4]
    aaf8:	4422      	add	r2, r4
    aafa:	2b07      	cmp	r3, #7
    aafc:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    ab00:	f8ca 1000 	str.w	r1, [sl]
    ab04:	f77f ab22 	ble.w	a14c <_svfprintf_r+0x944>
    ab08:	e47b      	b.n	a402 <_svfprintf_r+0xbfa>
    ab0a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ab0c:	9812      	ldr	r0, [sp, #72]	; 0x48
    ab0e:	441a      	add	r2, r3
    ab10:	e9ca 0300 	strd	r0, r3, [sl]
    ab14:	9b25      	ldr	r3, [sp, #148]	; 0x94
    ab16:	9226      	str	r2, [sp, #152]	; 0x98
    ab18:	3301      	adds	r3, #1
    ab1a:	2b07      	cmp	r3, #7
    ab1c:	9325      	str	r3, [sp, #148]	; 0x94
    ab1e:	f300 81a9 	bgt.w	ae74 <_svfprintf_r+0x166c>
    ab22:	f10a 0a08 	add.w	sl, sl, #8
    ab26:	2900      	cmp	r1, #0
    ab28:	f6bf af54 	bge.w	a9d4 <_svfprintf_r+0x11cc>
    ab2c:	424d      	negs	r5, r1
    ab2e:	3110      	adds	r1, #16
    ab30:	f280 830f 	bge.w	b152 <_svfprintf_r+0x194a>
    ab34:	ee1b 1a10 	vmov	r1, s22
    ab38:	2610      	movs	r6, #16
    ab3a:	e005      	b.n	ab48 <_svfprintf_r+0x1340>
    ab3c:	f10a 0a08 	add.w	sl, sl, #8
    ab40:	3d10      	subs	r5, #16
    ab42:	2d10      	cmp	r5, #16
    ab44:	f340 8305 	ble.w	b152 <_svfprintf_r+0x194a>
    ab48:	3301      	adds	r3, #1
    ab4a:	484f      	ldr	r0, [pc, #316]	; (ac88 <_svfprintf_r+0x1480>)
    ab4c:	3210      	adds	r2, #16
    ab4e:	2b07      	cmp	r3, #7
    ab50:	e9ca 0600 	strd	r0, r6, [sl]
    ab54:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    ab58:	ddf0      	ble.n	ab3c <_svfprintf_r+0x1334>
    ab5a:	aa24      	add	r2, sp, #144	; 0x90
    ab5c:	4658      	mov	r0, fp
    ab5e:	9103      	str	r1, [sp, #12]
    ab60:	f001 fd56 	bl	c610 <__ssprint_r>
    ab64:	2800      	cmp	r0, #0
    ab66:	f47f aab4 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    ab6a:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    ab6e:	9903      	ldr	r1, [sp, #12]
    ab70:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    ab74:	e7e4      	b.n	ab40 <_svfprintf_r+0x1338>
    ab76:	9b08      	ldr	r3, [sp, #32]
    ab78:	f418 7100 	ands.w	r1, r8, #512	; 0x200
    ab7c:	bf1a      	itte	ne
    ab7e:	4611      	movne	r1, r2
    ab80:	f853 2b04 	ldrne.w	r2, [r3], #4
    ab84:	f853 2b04 	ldreq.w	r2, [r3], #4
    ab88:	9308      	str	r3, [sp, #32]
    ab8a:	bf18      	it	ne
    ab8c:	b2d2      	uxtbne	r2, r2
    ab8e:	f7ff b945 	b.w	9e1c <_svfprintf_r+0x614>
    ab92:	9b02      	ldr	r3, [sp, #8]
    ab94:	f413 7100 	ands.w	r1, r3, #512	; 0x200
    ab98:	9b08      	ldr	r3, [sp, #32]
    ab9a:	bf1a      	itte	ne
    ab9c:	4611      	movne	r1, r2
    ab9e:	f853 2b04 	ldrne.w	r2, [r3], #4
    aba2:	f853 2b04 	ldreq.w	r2, [r3], #4
    aba6:	9308      	str	r3, [sp, #32]
    aba8:	bf18      	it	ne
    abaa:	b2d2      	uxtbne	r2, r2
    abac:	2301      	movs	r3, #1
    abae:	f7ff b8d0 	b.w	9d52 <_svfprintf_r+0x54a>
    abb2:	9b08      	ldr	r3, [sp, #32]
    abb4:	f418 7100 	ands.w	r1, r8, #512	; 0x200
    abb8:	bf1a      	itte	ne
    abba:	4611      	movne	r1, r2
    abbc:	f853 2b04 	ldrne.w	r2, [r3], #4
    abc0:	f853 2b04 	ldreq.w	r2, [r3], #4
    abc4:	9308      	str	r3, [sp, #32]
    abc6:	bf18      	it	ne
    abc8:	b2d2      	uxtbne	r2, r2
    abca:	e54e      	b.n	a66a <_svfprintf_r+0xe62>
    abcc:	468a      	mov	sl, r1
    abce:	3301      	adds	r3, #1
    abd0:	492d      	ldr	r1, [pc, #180]	; (ac88 <_svfprintf_r+0x1480>)
    abd2:	f8ca 5004 	str.w	r5, [sl, #4]
    abd6:	442a      	add	r2, r5
    abd8:	2b07      	cmp	r3, #7
    abda:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    abde:	f8ca 1000 	str.w	r1, [sl]
    abe2:	f300 8139 	bgt.w	ae58 <_svfprintf_r+0x1650>
    abe6:	f10a 0a08 	add.w	sl, sl, #8
    abea:	f7ff bb8c 	b.w	a306 <_svfprintf_r+0xafe>
    abee:	2300      	movs	r3, #0
    abf0:	4619      	mov	r1, r3
    abf2:	9600      	str	r6, [sp, #0]
    abf4:	aa1d      	add	r2, sp, #116	; 0x74
    abf6:	4658      	mov	r0, fp
    abf8:	f001 fcea 	bl	c5d0 <_wcsrtombs_r>
    abfc:	4603      	mov	r3, r0
    abfe:	3301      	adds	r3, #1
    ac00:	9005      	str	r0, [sp, #20]
    ac02:	f000 82f1 	beq.w	b1e8 <_svfprintf_r+0x19e0>
    ac06:	941d      	str	r4, [sp, #116]	; 0x74
    ac08:	9b05      	ldr	r3, [sp, #20]
    ac0a:	2b00      	cmp	r3, #0
    ac0c:	d04e      	beq.n	acac <_svfprintf_r+0x14a4>
    ac0e:	2b63      	cmp	r3, #99	; 0x63
    ac10:	f300 8118 	bgt.w	ae44 <_svfprintf_r+0x163c>
    ac14:	2300      	movs	r3, #0
    ac16:	9307      	str	r3, [sp, #28]
    ac18:	ac37      	add	r4, sp, #220	; 0xdc
    ac1a:	2208      	movs	r2, #8
    ac1c:	2100      	movs	r1, #0
    ac1e:	4630      	mov	r0, r6
    ac20:	f7fd ff20 	bl	8a64 <memset>
    ac24:	9d05      	ldr	r5, [sp, #20]
    ac26:	9600      	str	r6, [sp, #0]
    ac28:	462b      	mov	r3, r5
    ac2a:	aa1d      	add	r2, sp, #116	; 0x74
    ac2c:	4621      	mov	r1, r4
    ac2e:	4658      	mov	r0, fp
    ac30:	f001 fcce 	bl	c5d0 <_wcsrtombs_r>
    ac34:	4285      	cmp	r5, r0
    ac36:	f040 837c 	bne.w	b332 <_svfprintf_r+0x1b2a>
    ac3a:	9a05      	ldr	r2, [sp, #20]
    ac3c:	2300      	movs	r3, #0
    ac3e:	54a3      	strb	r3, [r4, r2]
    ac40:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    ac44:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    ac48:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    ac4c:	9303      	str	r3, [sp, #12]
    ac4e:	9202      	str	r2, [sp, #8]
    ac50:	930f      	str	r3, [sp, #60]	; 0x3c
    ac52:	f7fe bfba 	b.w	9bca <_svfprintf_r+0x3c2>
    ac56:	212d      	movs	r1, #45	; 0x2d
    ac58:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    ac5c:	f7fe bfa4 	b.w	9ba8 <_svfprintf_r+0x3a0>
    ac60:	9b16      	ldr	r3, [sp, #88]	; 0x58
    ac62:	9915      	ldr	r1, [sp, #84]	; 0x54
    ac64:	ebab 0b03 	sub.w	fp, fp, r3
    ac68:	461a      	mov	r2, r3
    ac6a:	4658      	mov	r0, fp
    ac6c:	f7fd ff4c 	bl	8b08 <strncpy>
    ac70:	f89a 2001 	ldrb.w	r2, [sl, #1]
    ac74:	4b05      	ldr	r3, [pc, #20]	; (ac8c <_svfprintf_r+0x1484>)
    ac76:	b10a      	cbz	r2, ac7c <_svfprintf_r+0x1474>
    ac78:	f10a 0a01 	add.w	sl, sl, #1
    ac7c:	f04f 0c00 	mov.w	ip, #0
    ac80:	e628      	b.n	a8d4 <_svfprintf_r+0x10cc>
    ac82:	bf00      	nop
    ac84:	20000524 	.word	0x20000524
    ac88:	20000fc8 	.word	0x20000fc8
    ac8c:	cccccccd 	.word	0xcccccccd
    ac90:	ee1b 1a10 	vmov	r1, s22
    ac94:	aa24      	add	r2, sp, #144	; 0x90
    ac96:	4658      	mov	r0, fp
    ac98:	f001 fcba 	bl	c610 <__ssprint_r>
    ac9c:	2800      	cmp	r0, #0
    ac9e:	f47f aa18 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    aca2:	991b      	ldr	r1, [sp, #108]	; 0x6c
    aca4:	9a26      	ldr	r2, [sp, #152]	; 0x98
    aca6:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    acaa:	e67c      	b.n	a9a6 <_svfprintf_r+0x119e>
    acac:	9b05      	ldr	r3, [sp, #20]
    acae:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    acb2:	930f      	str	r3, [sp, #60]	; 0x3c
    acb4:	e9cd 3302 	strd	r3, r3, [sp, #8]
    acb8:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    acbc:	9307      	str	r3, [sp, #28]
    acbe:	f7fe bf84 	b.w	9bca <_svfprintf_r+0x3c2>
    acc2:	990e      	ldr	r1, [sp, #56]	; 0x38
    acc4:	9805      	ldr	r0, [sp, #20]
    acc6:	1865      	adds	r5, r4, r1
    acc8:	1a2d      	subs	r5, r5, r0
    acca:	1acc      	subs	r4, r1, r3
    accc:	42a5      	cmp	r5, r4
    acce:	bfa8      	it	ge
    acd0:	4625      	movge	r5, r4
    acd2:	f7ff bb4d 	b.w	a370 <_svfprintf_r+0xb68>
    acd6:	9b08      	ldr	r3, [sp, #32]
    acd8:	9904      	ldr	r1, [sp, #16]
    acda:	f853 2b04 	ldr.w	r2, [r3], #4
    acde:	9308      	str	r3, [sp, #32]
    ace0:	8011      	strh	r1, [r2, #0]
    ace2:	464c      	mov	r4, r9
    ace4:	f7fe bdc2 	b.w	986c <_svfprintf_r+0x64>
    ace8:	f913 2b04 	ldrsb.w	r2, [r3], #4
    acec:	9308      	str	r3, [sp, #32]
    acee:	17d1      	asrs	r1, r2, #31
    acf0:	460b      	mov	r3, r1
    acf2:	f7fe bfdb 	b.w	9cac <_svfprintf_r+0x4a4>
    acf6:	9a03      	ldr	r2, [sp, #12]
    acf8:	2102      	movs	r1, #2
    acfa:	ab22      	add	r3, sp, #136	; 0x88
    acfc:	9301      	str	r3, [sp, #4]
    acfe:	ab1d      	add	r3, sp, #116	; 0x74
    ad00:	9300      	str	r3, [sp, #0]
    ad02:	4658      	mov	r0, fp
    ad04:	ab1b      	add	r3, sp, #108	; 0x6c
    ad06:	eeb0 0b4a 	vmov.f64	d0, d10
    ad0a:	9202      	str	r2, [sp, #8]
    ad0c:	f000 fdc4 	bl	b898 <_dtoa_r>
    ad10:	2d47      	cmp	r5, #71	; 0x47
    ad12:	9a02      	ldr	r2, [sp, #8]
    ad14:	4604      	mov	r4, r0
    ad16:	f000 8161 	beq.w	afdc <_svfprintf_r+0x17d4>
    ad1a:	2d46      	cmp	r5, #70	; 0x46
    ad1c:	4410      	add	r0, r2
    ad1e:	d105      	bne.n	ad2c <_svfprintf_r+0x1524>
    ad20:	7823      	ldrb	r3, [r4, #0]
    ad22:	2b30      	cmp	r3, #48	; 0x30
    ad24:	f000 826f 	beq.w	b206 <_svfprintf_r+0x19fe>
    ad28:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    ad2a:	4410      	add	r0, r2
    ad2c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    ad30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad34:	f040 8146 	bne.w	afc4 <_svfprintf_r+0x17bc>
    ad38:	4603      	mov	r3, r0
    ad3a:	1b1b      	subs	r3, r3, r4
    ad3c:	930e      	str	r3, [sp, #56]	; 0x38
    ad3e:	2d47      	cmp	r5, #71	; 0x47
    ad40:	f000 8110 	beq.w	af64 <_svfprintf_r+0x175c>
    ad44:	2d46      	cmp	r5, #70	; 0x46
    ad46:	f000 81b5 	beq.w	b0b4 <_svfprintf_r+0x18ac>
    ad4a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    ad4c:	930c      	str	r3, [sp, #48]	; 0x30
    ad4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ad50:	2d41      	cmp	r5, #65	; 0x41
    ad52:	f103 33ff 	add.w	r3, r3, #4294967295
    ad56:	931b      	str	r3, [sp, #108]	; 0x6c
    ad58:	f000 81e5 	beq.w	b126 <_svfprintf_r+0x191e>
    ad5c:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
    ad60:	2100      	movs	r1, #0
    ad62:	2b00      	cmp	r3, #0
    ad64:	bfb8      	it	lt
    ad66:	9b0c      	ldrlt	r3, [sp, #48]	; 0x30
    ad68:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    ad6c:	bfba      	itte	lt
    ad6e:	f1c3 0301 	rsblt	r3, r3, #1
    ad72:	222d      	movlt	r2, #45	; 0x2d
    ad74:	222b      	movge	r2, #43	; 0x2b
    ad76:	2b09      	cmp	r3, #9
    ad78:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
    ad7c:	f340 81da 	ble.w	b134 <_svfprintf_r+0x192c>
    ad80:	f10d 058f 	add.w	r5, sp, #143	; 0x8f
    ad84:	f8df c41c 	ldr.w	ip, [pc, #1052]	; b1a4 <_svfprintf_r+0x199c>
    ad88:	462a      	mov	r2, r5
    ad8a:	4610      	mov	r0, r2
    ad8c:	fb8c 2103 	smull	r2, r1, ip, r3
    ad90:	17da      	asrs	r2, r3, #31
    ad92:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    ad96:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    ad9a:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
    ad9e:	3130      	adds	r1, #48	; 0x30
    ada0:	f800 1c01 	strb.w	r1, [r0, #-1]
    ada4:	4619      	mov	r1, r3
    ada6:	2963      	cmp	r1, #99	; 0x63
    ada8:	4613      	mov	r3, r2
    adaa:	f100 32ff 	add.w	r2, r0, #4294967295
    adae:	dcec      	bgt.n	ad8a <_svfprintf_r+0x1582>
    adb0:	3330      	adds	r3, #48	; 0x30
    adb2:	b2d9      	uxtb	r1, r3
    adb4:	1e83      	subs	r3, r0, #2
    adb6:	429d      	cmp	r5, r3
    adb8:	f802 1c01 	strb.w	r1, [r2, #-1]
    adbc:	f240 828b 	bls.w	b2d6 <_svfprintf_r+0x1ace>
    adc0:	4613      	mov	r3, r2
    adc2:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
    adc6:	e001      	b.n	adcc <_svfprintf_r+0x15c4>
    adc8:	f813 1b01 	ldrb.w	r1, [r3], #1
    adcc:	f802 1b01 	strb.w	r1, [r2], #1
    add0:	429d      	cmp	r5, r3
    add2:	d1f9      	bne.n	adc8 <_svfprintf_r+0x15c0>
    add4:	f10d 0391 	add.w	r3, sp, #145	; 0x91
    add8:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
    addc:	1a1b      	subs	r3, r3, r0
    adde:	4413      	add	r3, r2
    ade0:	aa1e      	add	r2, sp, #120	; 0x78
    ade2:	1a9b      	subs	r3, r3, r2
    ade4:	9314      	str	r3, [sp, #80]	; 0x50
    ade6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ade8:	9a14      	ldr	r2, [sp, #80]	; 0x50
    adea:	2b01      	cmp	r3, #1
    adec:	441a      	add	r2, r3
    adee:	9205      	str	r2, [sp, #20]
    adf0:	f340 8203 	ble.w	b1fa <_svfprintf_r+0x19f2>
    adf4:	9b05      	ldr	r3, [sp, #20]
    adf6:	9a10      	ldr	r2, [sp, #64]	; 0x40
    adf8:	4413      	add	r3, r2
    adfa:	9305      	str	r3, [sp, #20]
    adfc:	f426 6380 	bic.w	r3, r6, #1024	; 0x400
    ae00:	9a05      	ldr	r2, [sp, #20]
    ae02:	f443 7880 	orr.w	r8, r3, #256	; 0x100
    ae06:	2300      	movs	r3, #0
    ae08:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
    ae0c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
    ae10:	930f      	str	r3, [sp, #60]	; 0x3c
    ae12:	9202      	str	r2, [sp, #8]
    ae14:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ae16:	2b00      	cmp	r3, #0
    ae18:	f040 80b1 	bne.w	af7e <_svfprintf_r+0x1776>
    ae1c:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    ae20:	9303      	str	r3, [sp, #12]
    ae22:	f7fe bed2 	b.w	9bca <_svfprintf_r+0x3c2>
    ae26:	4620      	mov	r0, r4
    ae28:	f7fd ff4a 	bl	8cc0 <strlen>
    ae2c:	4602      	mov	r2, r0
    ae2e:	9005      	str	r0, [sp, #20]
    ae30:	f7fe bf20 	b.w	9c74 <_svfprintf_r+0x46c>
    ae34:	ee1b 1a10 	vmov	r1, s22
    ae38:	aa24      	add	r2, sp, #144	; 0x90
    ae3a:	4658      	mov	r0, fp
    ae3c:	f001 fbe8 	bl	c610 <__ssprint_r>
    ae40:	f7fe bded 	b.w	9a1e <_svfprintf_r+0x216>
    ae44:	1c59      	adds	r1, r3, #1
    ae46:	4658      	mov	r0, fp
    ae48:	f7fc ff58 	bl	7cfc <_malloc_r>
    ae4c:	4604      	mov	r4, r0
    ae4e:	2800      	cmp	r0, #0
    ae50:	f000 81ca 	beq.w	b1e8 <_svfprintf_r+0x19e0>
    ae54:	9007      	str	r0, [sp, #28]
    ae56:	e6e0      	b.n	ac1a <_svfprintf_r+0x1412>
    ae58:	ee1b 1a10 	vmov	r1, s22
    ae5c:	aa24      	add	r2, sp, #144	; 0x90
    ae5e:	4658      	mov	r0, fp
    ae60:	f001 fbd6 	bl	c610 <__ssprint_r>
    ae64:	2800      	cmp	r0, #0
    ae66:	f47f a934 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    ae6a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    ae6c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    ae70:	f7ff ba49 	b.w	a306 <_svfprintf_r+0xafe>
    ae74:	ee1b 1a10 	vmov	r1, s22
    ae78:	aa24      	add	r2, sp, #144	; 0x90
    ae7a:	4658      	mov	r0, fp
    ae7c:	f001 fbc8 	bl	c610 <__ssprint_r>
    ae80:	2800      	cmp	r0, #0
    ae82:	f47f a926 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    ae86:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    ae8a:	991b      	ldr	r1, [sp, #108]	; 0x6c
    ae8c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    ae90:	e649      	b.n	ab26 <_svfprintf_r+0x131e>
    ae92:	2306      	movs	r3, #6
    ae94:	9303      	str	r3, [sp, #12]
    ae96:	f7ff bb83 	b.w	a5a0 <_svfprintf_r+0xd98>
    ae9a:	9b03      	ldr	r3, [sp, #12]
    ae9c:	2102      	movs	r1, #2
    ae9e:	1c5a      	adds	r2, r3, #1
    aea0:	e72b      	b.n	acfa <_svfprintf_r+0x14f2>
    aea2:	9a03      	ldr	r2, [sp, #12]
    aea4:	2103      	movs	r1, #3
    aea6:	e728      	b.n	acfa <_svfprintf_r+0x14f2>
    aea8:	a81b      	add	r0, sp, #108	; 0x6c
    aeaa:	eeb0 0b4a 	vmov.f64	d0, d10
    aeae:	f000 fbc7 	bl	b640 <frexp>
    aeb2:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
    aeb6:	ee20 0b07 	vmul.f64	d0, d0, d7
    aeba:	eeb5 0b40 	vcmp.f64	d0, #0.0
    aebe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    aec2:	d101      	bne.n	aec8 <_svfprintf_r+0x16c0>
    aec4:	2301      	movs	r3, #1
    aec6:	931b      	str	r3, [sp, #108]	; 0x6c
    aec8:	48b3      	ldr	r0, [pc, #716]	; (b198 <_svfprintf_r+0x1990>)
    aeca:	9b03      	ldr	r3, [sp, #12]
    aecc:	eeb3 5b00 	vmov.f64	d5, #48	; 0x41800000  16.0
    aed0:	3b01      	subs	r3, #1
    aed2:	4622      	mov	r2, r4
    aed4:	e004      	b.n	aee0 <_svfprintf_r+0x16d8>
    aed6:	eeb5 0b40 	vcmp.f64	d0, #0.0
    aeda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    aede:	d013      	beq.n	af08 <_svfprintf_r+0x1700>
    aee0:	ee20 0b05 	vmul.f64	d0, d0, d5
    aee4:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    aee8:	f1b3 3fff 	cmp.w	r3, #4294967295
    aeec:	ee17 1a90 	vmov	r1, s15
    aef0:	5c41      	ldrb	r1, [r0, r1]
    aef2:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    aef6:	4694      	mov	ip, r2
    aef8:	ee30 0b46 	vsub.f64	d0, d0, d6
    aefc:	f802 1b01 	strb.w	r1, [r2], #1
    af00:	4619      	mov	r1, r3
    af02:	f103 33ff 	add.w	r3, r3, #4294967295
    af06:	d1e6      	bne.n	aed6 <_svfprintf_r+0x16ce>
    af08:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    af0c:	eeb4 0bc6 	vcmpe.f64	d0, d6
    af10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    af14:	f300 8148 	bgt.w	b1a8 <_svfprintf_r+0x19a0>
    af18:	eeb4 0b46 	vcmp.f64	d0, d6
    af1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    af20:	d104      	bne.n	af2c <_svfprintf_r+0x1724>
    af22:	ee17 3a90 	vmov	r3, s15
    af26:	07db      	lsls	r3, r3, #31
    af28:	f100 813e 	bmi.w	b1a8 <_svfprintf_r+0x19a0>
    af2c:	2900      	cmp	r1, #0
    af2e:	db06      	blt.n	af3e <_svfprintf_r+0x1736>
    af30:	1c4b      	adds	r3, r1, #1
    af32:	4413      	add	r3, r2
    af34:	2130      	movs	r1, #48	; 0x30
    af36:	f802 1b01 	strb.w	r1, [r2], #1
    af3a:	4293      	cmp	r3, r2
    af3c:	d1fb      	bne.n	af36 <_svfprintf_r+0x172e>
    af3e:	1b13      	subs	r3, r2, r4
    af40:	930e      	str	r3, [sp, #56]	; 0x38
    af42:	e6fc      	b.n	ad3e <_svfprintf_r+0x1536>
    af44:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    af46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    af48:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    af4c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    af50:	9613      	str	r6, [sp, #76]	; 0x4c
    af52:	18e3      	adds	r3, r4, r3
    af54:	429d      	cmp	r5, r3
    af56:	4629      	mov	r1, r5
    af58:	bf28      	it	cs
    af5a:	4619      	movcs	r1, r3
    af5c:	4682      	mov	sl, r0
    af5e:	9105      	str	r1, [sp, #20]
    af60:	f7ff b9d8 	b.w	a314 <_svfprintf_r+0xb0c>
    af64:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    af66:	930c      	str	r3, [sp, #48]	; 0x30
    af68:	1cda      	adds	r2, r3, #3
    af6a:	db02      	blt.n	af72 <_svfprintf_r+0x176a>
    af6c:	9a03      	ldr	r2, [sp, #12]
    af6e:	4293      	cmp	r3, r2
    af70:	dd0c      	ble.n	af8c <_svfprintf_r+0x1784>
    af72:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    af74:	3b02      	subs	r3, #2
    af76:	930b      	str	r3, [sp, #44]	; 0x2c
    af78:	f023 0520 	bic.w	r5, r3, #32
    af7c:	e6e7      	b.n	ad4e <_svfprintf_r+0x1546>
    af7e:	212d      	movs	r1, #45	; 0x2d
    af80:	2300      	movs	r3, #0
    af82:	f88d 1067 	strb.w	r1, [sp, #103]	; 0x67
    af86:	9303      	str	r3, [sp, #12]
    af88:	f7fe be22 	b.w	9bd0 <_svfprintf_r+0x3c8>
    af8c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    af8e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    af90:	4293      	cmp	r3, r2
    af92:	f2c0 80bd 	blt.w	b110 <_svfprintf_r+0x1908>
    af96:	07f0      	lsls	r0, r6, #31
    af98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    af9a:	f140 8132 	bpl.w	b202 <_svfprintf_r+0x19fa>
    af9e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    afa0:	4413      	add	r3, r2
    afa2:	9305      	str	r3, [sp, #20]
    afa4:	0571      	lsls	r1, r6, #21
    afa6:	d503      	bpl.n	afb0 <_svfprintf_r+0x17a8>
    afa8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    afaa:	2b00      	cmp	r3, #0
    afac:	f300 8135 	bgt.w	b21a <_svfprintf_r+0x1a12>
    afb0:	9b05      	ldr	r3, [sp, #20]
    afb2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    afb6:	9302      	str	r3, [sp, #8]
    afb8:	2367      	movs	r3, #103	; 0x67
    afba:	930b      	str	r3, [sp, #44]	; 0x2c
    afbc:	2300      	movs	r3, #0
    afbe:	930f      	str	r3, [sp, #60]	; 0x3c
    afc0:	930d      	str	r3, [sp, #52]	; 0x34
    afc2:	e727      	b.n	ae14 <_svfprintf_r+0x160c>
    afc4:	9b22      	ldr	r3, [sp, #136]	; 0x88
    afc6:	4283      	cmp	r3, r0
    afc8:	f4bf aeb7 	bcs.w	ad3a <_svfprintf_r+0x1532>
    afcc:	2130      	movs	r1, #48	; 0x30
    afce:	1c5a      	adds	r2, r3, #1
    afd0:	9222      	str	r2, [sp, #136]	; 0x88
    afd2:	7019      	strb	r1, [r3, #0]
    afd4:	9b22      	ldr	r3, [sp, #136]	; 0x88
    afd6:	4298      	cmp	r0, r3
    afd8:	d8f9      	bhi.n	afce <_svfprintf_r+0x17c6>
    afda:	e6ae      	b.n	ad3a <_svfprintf_r+0x1532>
    afdc:	07f3      	lsls	r3, r6, #31
    afde:	f100 80a7 	bmi.w	b130 <_svfprintf_r+0x1928>
    afe2:	9b22      	ldr	r3, [sp, #136]	; 0x88
    afe4:	e6a9      	b.n	ad3a <_svfprintf_r+0x1532>
    afe6:	aa24      	add	r2, sp, #144	; 0x90
    afe8:	4658      	mov	r0, fp
    afea:	9105      	str	r1, [sp, #20]
    afec:	f001 fb10 	bl	c610 <__ssprint_r>
    aff0:	2800      	cmp	r0, #0
    aff2:	f47f a86e 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    aff6:	f896 c000 	ldrb.w	ip, [r6]
    affa:	9a26      	ldr	r2, [sp, #152]	; 0x98
    affc:	9905      	ldr	r1, [sp, #20]
    affe:	a827      	add	r0, sp, #156	; 0x9c
    b000:	4465      	add	r5, ip
    b002:	f7ff bbec 	b.w	a7de <_svfprintf_r+0xfd6>
    b006:	ee1b 1a10 	vmov	r1, s22
    b00a:	aa24      	add	r2, sp, #144	; 0x90
    b00c:	4658      	mov	r0, fp
    b00e:	f001 faff 	bl	c610 <__ssprint_r>
    b012:	2800      	cmp	r0, #0
    b014:	f47f a85d 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    b018:	9a26      	ldr	r2, [sp, #152]	; 0x98
    b01a:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    b01e:	f7ff b96b 	b.w	a2f8 <_svfprintf_r+0xaf0>
    b022:	2378      	movs	r3, #120	; 0x78
    b024:	f88d 3069 	strb.w	r3, [sp, #105]	; 0x69
    b028:	2330      	movs	r3, #48	; 0x30
    b02a:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
    b02e:	9b03      	ldr	r3, [sp, #12]
    b030:	2b63      	cmp	r3, #99	; 0x63
    b032:	f048 0602 	orr.w	r6, r8, #2
    b036:	f300 80a6 	bgt.w	b186 <_svfprintf_r+0x197e>
    b03a:	2300      	movs	r3, #0
    b03c:	9307      	str	r3, [sp, #28]
    b03e:	ac37      	add	r4, sp, #220	; 0xdc
    b040:	ee18 3a90 	vmov	r3, s17
    b044:	2b00      	cmp	r3, #0
    b046:	f448 7881 	orr.w	r8, r8, #258	; 0x102
    b04a:	db2b      	blt.n	b0a4 <_svfprintf_r+0x189c>
    b04c:	eeb0 ab48 	vmov.f64	d10, d8
    b050:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b052:	f023 0520 	bic.w	r5, r3, #32
    b056:	2300      	movs	r3, #0
    b058:	9309      	str	r3, [sp, #36]	; 0x24
    b05a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b05c:	2b61      	cmp	r3, #97	; 0x61
    b05e:	f47f aaad 	bne.w	a5bc <_svfprintf_r+0xdb4>
    b062:	eeb0 0b4a 	vmov.f64	d0, d10
    b066:	a81b      	add	r0, sp, #108	; 0x6c
    b068:	f000 faea 	bl	b640 <frexp>
    b06c:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
    b070:	ee20 0b07 	vmul.f64	d0, d0, d7
    b074:	eeb5 0b40 	vcmp.f64	d0, #0.0
    b078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b07c:	d101      	bne.n	b082 <_svfprintf_r+0x187a>
    b07e:	2301      	movs	r3, #1
    b080:	931b      	str	r3, [sp, #108]	; 0x6c
    b082:	4846      	ldr	r0, [pc, #280]	; (b19c <_svfprintf_r+0x1994>)
    b084:	e721      	b.n	aeca <_svfprintf_r+0x16c2>
    b086:	ee1b 1a10 	vmov	r1, s22
    b08a:	aa24      	add	r2, sp, #144	; 0x90
    b08c:	4658      	mov	r0, fp
    b08e:	f001 fabf 	bl	c610 <__ssprint_r>
    b092:	2800      	cmp	r0, #0
    b094:	f47f a81d 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    b098:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    b09a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    b09c:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    b0a0:	f7ff b94e 	b.w	a340 <_svfprintf_r+0xb38>
    b0a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b0a6:	f023 0520 	bic.w	r5, r3, #32
    b0aa:	232d      	movs	r3, #45	; 0x2d
    b0ac:	9309      	str	r3, [sp, #36]	; 0x24
    b0ae:	eeb1 ab48 	vneg.f64	d10, d8
    b0b2:	e7d2      	b.n	b05a <_svfprintf_r+0x1852>
    b0b4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    b0b6:	920c      	str	r2, [sp, #48]	; 0x30
    b0b8:	2a00      	cmp	r2, #0
    b0ba:	f006 0301 	and.w	r3, r6, #1
    b0be:	f340 810d 	ble.w	b2dc <_svfprintf_r+0x1ad4>
    b0c2:	9903      	ldr	r1, [sp, #12]
    b0c4:	430b      	orrs	r3, r1
    b0c6:	f040 80cf 	bne.w	b268 <_svfprintf_r+0x1a60>
    b0ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b0cc:	9305      	str	r3, [sp, #20]
    b0ce:	2366      	movs	r3, #102	; 0x66
    b0d0:	930b      	str	r3, [sp, #44]	; 0x2c
    b0d2:	0572      	lsls	r2, r6, #21
    b0d4:	f100 80a3 	bmi.w	b21e <_svfprintf_r+0x1a16>
    b0d8:	9b05      	ldr	r3, [sp, #20]
    b0da:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    b0de:	9302      	str	r3, [sp, #8]
    b0e0:	e76c      	b.n	afbc <_svfprintf_r+0x17b4>
    b0e2:	ee1b 1a10 	vmov	r1, s22
    b0e6:	aa24      	add	r2, sp, #144	; 0x90
    b0e8:	4658      	mov	r0, fp
    b0ea:	f001 fa91 	bl	c610 <__ssprint_r>
    b0ee:	2800      	cmp	r0, #0
    b0f0:	f47e afef 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    b0f4:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
    b0f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b0f8:	9a26      	ldr	r2, [sp, #152]	; 0x98
    b0fa:	1b1c      	subs	r4, r3, r4
    b0fc:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    b100:	f7ff b936 	b.w	a370 <_svfprintf_r+0xb68>
    b104:	2358      	movs	r3, #88	; 0x58
    b106:	e78d      	b.n	b024 <_svfprintf_r+0x181c>
    b108:	2200      	movs	r2, #0
    b10a:	9203      	str	r2, [sp, #12]
    b10c:	f7fe bbda 	b.w	98c4 <_svfprintf_r+0xbc>
    b110:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b112:	9a10      	ldr	r2, [sp, #64]	; 0x40
    b114:	189a      	adds	r2, r3, r2
    b116:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b118:	9205      	str	r2, [sp, #20]
    b11a:	2b00      	cmp	r3, #0
    b11c:	f340 80ab 	ble.w	b276 <_svfprintf_r+0x1a6e>
    b120:	2367      	movs	r3, #103	; 0x67
    b122:	930b      	str	r3, [sp, #44]	; 0x2c
    b124:	e7d5      	b.n	b0d2 <_svfprintf_r+0x18ca>
    b126:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b128:	320f      	adds	r2, #15
    b12a:	b2d2      	uxtb	r2, r2
    b12c:	2101      	movs	r1, #1
    b12e:	e618      	b.n	ad62 <_svfprintf_r+0x155a>
    b130:	18a0      	adds	r0, r4, r2
    b132:	e5fb      	b.n	ad2c <_svfprintf_r+0x1524>
    b134:	2900      	cmp	r1, #0
    b136:	f040 80a8 	bne.w	b28a <_svfprintf_r+0x1a82>
    b13a:	2230      	movs	r2, #48	; 0x30
    b13c:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
    b140:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
    b144:	3330      	adds	r3, #48	; 0x30
    b146:	f802 3b01 	strb.w	r3, [r2], #1
    b14a:	ab1e      	add	r3, sp, #120	; 0x78
    b14c:	1ad3      	subs	r3, r2, r3
    b14e:	9314      	str	r3, [sp, #80]	; 0x50
    b150:	e649      	b.n	ade6 <_svfprintf_r+0x15de>
    b152:	3301      	adds	r3, #1
    b154:	4912      	ldr	r1, [pc, #72]	; (b1a0 <_svfprintf_r+0x1998>)
    b156:	f8ca 5004 	str.w	r5, [sl, #4]
    b15a:	442a      	add	r2, r5
    b15c:	2b07      	cmp	r3, #7
    b15e:	e9cd 3225 	strd	r3, r2, [sp, #148]	; 0x94
    b162:	f8ca 1000 	str.w	r1, [sl]
    b166:	f77f ac33 	ble.w	a9d0 <_svfprintf_r+0x11c8>
    b16a:	ee1b 1a10 	vmov	r1, s22
    b16e:	aa24      	add	r2, sp, #144	; 0x90
    b170:	4658      	mov	r0, fp
    b172:	f001 fa4d 	bl	c610 <__ssprint_r>
    b176:	2800      	cmp	r0, #0
    b178:	f47e afab 	bne.w	a0d2 <_svfprintf_r+0x8ca>
    b17c:	e9dd 3225 	ldrd	r3, r2, [sp, #148]	; 0x94
    b180:	f10d 0a9c 	add.w	sl, sp, #156	; 0x9c
    b184:	e426      	b.n	a9d4 <_svfprintf_r+0x11cc>
    b186:	1c59      	adds	r1, r3, #1
    b188:	4658      	mov	r0, fp
    b18a:	f7fc fdb7 	bl	7cfc <_malloc_r>
    b18e:	4604      	mov	r4, r0
    b190:	b350      	cbz	r0, b1e8 <_svfprintf_r+0x19e0>
    b192:	9007      	str	r0, [sp, #28]
    b194:	e754      	b.n	b040 <_svfprintf_r+0x1838>
    b196:	bf00      	nop
    b198:	20000b40 	.word	0x20000b40
    b19c:	20000b2c 	.word	0x20000b2c
    b1a0:	20000fc8 	.word	0x20000fc8
    b1a4:	66666667 	.word	0x66666667
    b1a8:	f8cd c088 	str.w	ip, [sp, #136]	; 0x88
    b1ac:	f812 1c01 	ldrb.w	r1, [r2, #-1]
    b1b0:	f890 c00f 	ldrb.w	ip, [r0, #15]
    b1b4:	4561      	cmp	r1, ip
    b1b6:	4613      	mov	r3, r2
    b1b8:	d10a      	bne.n	b1d0 <_svfprintf_r+0x19c8>
    b1ba:	f04f 0e30 	mov.w	lr, #48	; 0x30
    b1be:	f803 ec01 	strb.w	lr, [r3, #-1]
    b1c2:	9b22      	ldr	r3, [sp, #136]	; 0x88
    b1c4:	1e59      	subs	r1, r3, #1
    b1c6:	9122      	str	r1, [sp, #136]	; 0x88
    b1c8:	f813 1c01 	ldrb.w	r1, [r3, #-1]
    b1cc:	458c      	cmp	ip, r1
    b1ce:	d0f6      	beq.n	b1be <_svfprintf_r+0x19b6>
    b1d0:	2939      	cmp	r1, #57	; 0x39
    b1d2:	bf16      	itet	ne
    b1d4:	3101      	addne	r1, #1
    b1d6:	7a81      	ldrbeq	r1, [r0, #10]
    b1d8:	b2c9      	uxtbne	r1, r1
    b1da:	f803 1c01 	strb.w	r1, [r3, #-1]
    b1de:	e6ae      	b.n	af3e <_svfprintf_r+0x1736>
    b1e0:	2300      	movs	r3, #0
    b1e2:	4690      	mov	r8, r2
    b1e4:	9307      	str	r3, [sp, #28]
    b1e6:	e760      	b.n	b0aa <_svfprintf_r+0x18a2>
    b1e8:	ee1b 2a10 	vmov	r2, s22
    b1ec:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
    b1f0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b1f4:	8193      	strh	r3, [r2, #12]
    b1f6:	f7fe bc16 	b.w	9a26 <_svfprintf_r+0x21e>
    b1fa:	07f5      	lsls	r5, r6, #31
    b1fc:	f57f adfe 	bpl.w	adfc <_svfprintf_r+0x15f4>
    b200:	e5f8      	b.n	adf4 <_svfprintf_r+0x15ec>
    b202:	9305      	str	r3, [sp, #20]
    b204:	e6ce      	b.n	afa4 <_svfprintf_r+0x179c>
    b206:	eeb5 ab40 	vcmp.f64	d10, #0.0
    b20a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b20e:	f43f ad8b 	beq.w	ad28 <_svfprintf_r+0x1520>
    b212:	f1c2 0201 	rsb	r2, r2, #1
    b216:	921b      	str	r2, [sp, #108]	; 0x6c
    b218:	e587      	b.n	ad2a <_svfprintf_r+0x1522>
    b21a:	2367      	movs	r3, #103	; 0x67
    b21c:	930b      	str	r3, [sp, #44]	; 0x2c
    b21e:	9913      	ldr	r1, [sp, #76]	; 0x4c
    b220:	780b      	ldrb	r3, [r1, #0]
    b222:	2bff      	cmp	r3, #255	; 0xff
    b224:	d079      	beq.n	b31a <_svfprintf_r+0x1b12>
    b226:	2500      	movs	r5, #0
    b228:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    b22a:	4628      	mov	r0, r5
    b22c:	e003      	b.n	b236 <_svfprintf_r+0x1a2e>
    b22e:	3001      	adds	r0, #1
    b230:	3101      	adds	r1, #1
    b232:	2bff      	cmp	r3, #255	; 0xff
    b234:	d008      	beq.n	b248 <_svfprintf_r+0x1a40>
    b236:	4293      	cmp	r3, r2
    b238:	da06      	bge.n	b248 <_svfprintf_r+0x1a40>
    b23a:	1ad2      	subs	r2, r2, r3
    b23c:	784b      	ldrb	r3, [r1, #1]
    b23e:	2b00      	cmp	r3, #0
    b240:	d1f5      	bne.n	b22e <_svfprintf_r+0x1a26>
    b242:	780b      	ldrb	r3, [r1, #0]
    b244:	3501      	adds	r5, #1
    b246:	e7f4      	b.n	b232 <_svfprintf_r+0x1a2a>
    b248:	920c      	str	r2, [sp, #48]	; 0x30
    b24a:	9113      	str	r1, [sp, #76]	; 0x4c
    b24c:	900d      	str	r0, [sp, #52]	; 0x34
    b24e:	950f      	str	r5, [sp, #60]	; 0x3c
    b250:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    b252:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b254:	9916      	ldr	r1, [sp, #88]	; 0x58
    b256:	4413      	add	r3, r2
    b258:	9a05      	ldr	r2, [sp, #20]
    b25a:	fb01 2303 	mla	r3, r1, r3, r2
    b25e:	9305      	str	r3, [sp, #20]
    b260:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    b264:	9302      	str	r3, [sp, #8]
    b266:	e5d5      	b.n	ae14 <_svfprintf_r+0x160c>
    b268:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b26a:	18d3      	adds	r3, r2, r3
    b26c:	4419      	add	r1, r3
    b26e:	2366      	movs	r3, #102	; 0x66
    b270:	9105      	str	r1, [sp, #20]
    b272:	930b      	str	r3, [sp, #44]	; 0x2c
    b274:	e72d      	b.n	b0d2 <_svfprintf_r+0x18ca>
    b276:	f1c3 0301 	rsb	r3, r3, #1
    b27a:	441a      	add	r2, r3
    b27c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    b280:	9302      	str	r3, [sp, #8]
    b282:	2367      	movs	r3, #103	; 0x67
    b284:	9205      	str	r2, [sp, #20]
    b286:	930b      	str	r3, [sp, #44]	; 0x2c
    b288:	e698      	b.n	afbc <_svfprintf_r+0x17b4>
    b28a:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
    b28e:	e759      	b.n	b144 <_svfprintf_r+0x193c>
    b290:	9b03      	ldr	r3, [sp, #12]
    b292:	f8dd 9008 	ldr.w	r9, [sp, #8]
    b296:	f8dd 801c 	ldr.w	r8, [sp, #28]
    b29a:	9305      	str	r3, [sp, #20]
    b29c:	e4b4      	b.n	ac08 <_svfprintf_r+0x1400>
    b29e:	ee18 3a90 	vmov	r3, s17
    b2a2:	2b00      	cmp	r3, #0
    b2a4:	bfb4      	ite	lt
    b2a6:	212d      	movlt	r1, #45	; 0x2d
    b2a8:	f89d 1067 	ldrbge.w	r1, [sp, #103]	; 0x67
    b2ac:	4c25      	ldr	r4, [pc, #148]	; (b344 <_svfprintf_r+0x1b3c>)
    b2ae:	4b26      	ldr	r3, [pc, #152]	; (b348 <_svfprintf_r+0x1b40>)
    b2b0:	bfb8      	it	lt
    b2b2:	f88d 1067 	strblt.w	r1, [sp, #103]	; 0x67
    b2b6:	f028 0880 	bic.w	r8, r8, #128	; 0x80
    b2ba:	f7fe bc79 	b.w	9bb0 <_svfprintf_r+0x3a8>
    b2be:	9b03      	ldr	r3, [sp, #12]
    b2c0:	9302      	str	r3, [sp, #8]
    b2c2:	9305      	str	r3, [sp, #20]
    b2c4:	2373      	movs	r3, #115	; 0x73
    b2c6:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
    b2ca:	9003      	str	r0, [sp, #12]
    b2cc:	900f      	str	r0, [sp, #60]	; 0x3c
    b2ce:	900d      	str	r0, [sp, #52]	; 0x34
    b2d0:	930b      	str	r3, [sp, #44]	; 0x2c
    b2d2:	f7fe bc7a 	b.w	9bca <_svfprintf_r+0x3c2>
    b2d6:	2302      	movs	r3, #2
    b2d8:	9314      	str	r3, [sp, #80]	; 0x50
    b2da:	e584      	b.n	ade6 <_svfprintf_r+0x15de>
    b2dc:	9a03      	ldr	r2, [sp, #12]
    b2de:	4313      	orrs	r3, r2
    b2e0:	d105      	bne.n	b2ee <_svfprintf_r+0x1ae6>
    b2e2:	2301      	movs	r3, #1
    b2e4:	2266      	movs	r2, #102	; 0x66
    b2e6:	9302      	str	r3, [sp, #8]
    b2e8:	920b      	str	r2, [sp, #44]	; 0x2c
    b2ea:	9305      	str	r3, [sp, #20]
    b2ec:	e666      	b.n	afbc <_svfprintf_r+0x17b4>
    b2ee:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b2f0:	3301      	adds	r3, #1
    b2f2:	441a      	add	r2, r3
    b2f4:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    b2f8:	9302      	str	r3, [sp, #8]
    b2fa:	2366      	movs	r3, #102	; 0x66
    b2fc:	9205      	str	r2, [sp, #20]
    b2fe:	930b      	str	r3, [sp, #44]	; 0x2c
    b300:	e65c      	b.n	afbc <_svfprintf_r+0x17b4>
    b302:	9a08      	ldr	r2, [sp, #32]
    b304:	f899 3001 	ldrb.w	r3, [r9, #1]
    b308:	4689      	mov	r9, r1
    b30a:	f852 1b04 	ldr.w	r1, [r2], #4
    b30e:	9208      	str	r2, [sp, #32]
    b310:	ea41 71e1 	orr.w	r1, r1, r1, asr #31
    b314:	9103      	str	r1, [sp, #12]
    b316:	f7fe bad3 	b.w	98c0 <_svfprintf_r+0xb8>
    b31a:	2300      	movs	r3, #0
    b31c:	930f      	str	r3, [sp, #60]	; 0x3c
    b31e:	930d      	str	r3, [sp, #52]	; 0x34
    b320:	e796      	b.n	b250 <_svfprintf_r+0x1a48>
    b322:	230c      	movs	r3, #12
    b324:	f8cb 3000 	str.w	r3, [fp]
    b328:	f04f 33ff 	mov.w	r3, #4294967295
    b32c:	9304      	str	r3, [sp, #16]
    b32e:	f7fe bb81 	b.w	9a34 <_svfprintf_r+0x22c>
    b332:	ee1b 2a10 	vmov	r2, s22
    b336:	8993      	ldrh	r3, [r2, #12]
    b338:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b33c:	8193      	strh	r3, [r2, #12]
    b33e:	f7fe bec8 	b.w	a0d2 <_svfprintf_r+0x8ca>
    b342:	bf00      	nop
    b344:	20000b24 	.word	0x20000b24
    b348:	20000b28 	.word	0x20000b28

0000b34c <_fclose_r>:
    b34c:	b570      	push	{r4, r5, r6, lr}
    b34e:	2900      	cmp	r1, #0
    b350:	d04b      	beq.n	b3ea <_fclose_r+0x9e>
    b352:	4606      	mov	r6, r0
    b354:	460c      	mov	r4, r1
    b356:	b110      	cbz	r0, b35e <_fclose_r+0x12>
    b358:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b35a:	2b00      	cmp	r3, #0
    b35c:	d048      	beq.n	b3f0 <_fclose_r+0xa4>
    b35e:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b360:	07d8      	lsls	r0, r3, #31
    b362:	d534      	bpl.n	b3ce <_fclose_r+0x82>
    b364:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    b368:	2b00      	cmp	r3, #0
    b36a:	d03e      	beq.n	b3ea <_fclose_r+0x9e>
    b36c:	4621      	mov	r1, r4
    b36e:	4630      	mov	r0, r6
    b370:	f000 f850 	bl	b414 <__sflush_r>
    b374:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    b376:	4605      	mov	r5, r0
    b378:	b133      	cbz	r3, b388 <_fclose_r+0x3c>
    b37a:	69e1      	ldr	r1, [r4, #28]
    b37c:	4630      	mov	r0, r6
    b37e:	4798      	blx	r3
    b380:	2800      	cmp	r0, #0
    b382:	bfb8      	it	lt
    b384:	f04f 35ff 	movlt.w	r5, #4294967295
    b388:	89a3      	ldrh	r3, [r4, #12]
    b38a:	061a      	lsls	r2, r3, #24
    b38c:	d43c      	bmi.n	b408 <_fclose_r+0xbc>
    b38e:	6b21      	ldr	r1, [r4, #48]	; 0x30
    b390:	b141      	cbz	r1, b3a4 <_fclose_r+0x58>
    b392:	f104 0340 	add.w	r3, r4, #64	; 0x40
    b396:	4299      	cmp	r1, r3
    b398:	d002      	beq.n	b3a0 <_fclose_r+0x54>
    b39a:	4630      	mov	r0, r6
    b39c:	f7fd fd4e 	bl	8e3c <_free_r>
    b3a0:	2300      	movs	r3, #0
    b3a2:	6323      	str	r3, [r4, #48]	; 0x30
    b3a4:	6c61      	ldr	r1, [r4, #68]	; 0x44
    b3a6:	b121      	cbz	r1, b3b2 <_fclose_r+0x66>
    b3a8:	4630      	mov	r0, r6
    b3aa:	f7fd fd47 	bl	8e3c <_free_r>
    b3ae:	2300      	movs	r3, #0
    b3b0:	6463      	str	r3, [r4, #68]	; 0x44
    b3b2:	f7fd f9ff 	bl	87b4 <__sfp_lock_acquire>
    b3b6:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b3b8:	2200      	movs	r2, #0
    b3ba:	07db      	lsls	r3, r3, #31
    b3bc:	81a2      	strh	r2, [r4, #12]
    b3be:	d51f      	bpl.n	b400 <_fclose_r+0xb4>
    b3c0:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b3c2:	f7fd fc6b 	bl	8c9c <__retarget_lock_close_recursive>
    b3c6:	f7fd f9fb 	bl	87c0 <__sfp_lock_release>
    b3ca:	4628      	mov	r0, r5
    b3cc:	bd70      	pop	{r4, r5, r6, pc}
    b3ce:	89a3      	ldrh	r3, [r4, #12]
    b3d0:	0599      	lsls	r1, r3, #22
    b3d2:	d4cb      	bmi.n	b36c <_fclose_r+0x20>
    b3d4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b3d6:	f7fd fc63 	bl	8ca0 <__retarget_lock_acquire_recursive>
    b3da:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    b3de:	2b00      	cmp	r3, #0
    b3e0:	d1c4      	bne.n	b36c <_fclose_r+0x20>
    b3e2:	6e65      	ldr	r5, [r4, #100]	; 0x64
    b3e4:	f015 0501 	ands.w	r5, r5, #1
    b3e8:	d005      	beq.n	b3f6 <_fclose_r+0xaa>
    b3ea:	2500      	movs	r5, #0
    b3ec:	4628      	mov	r0, r5
    b3ee:	bd70      	pop	{r4, r5, r6, pc}
    b3f0:	f7fd f9c2 	bl	8778 <__sinit>
    b3f4:	e7b3      	b.n	b35e <_fclose_r+0x12>
    b3f6:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b3f8:	f7fd fc54 	bl	8ca4 <__retarget_lock_release_recursive>
    b3fc:	4628      	mov	r0, r5
    b3fe:	bd70      	pop	{r4, r5, r6, pc}
    b400:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b402:	f7fd fc4f 	bl	8ca4 <__retarget_lock_release_recursive>
    b406:	e7db      	b.n	b3c0 <_fclose_r+0x74>
    b408:	6921      	ldr	r1, [r4, #16]
    b40a:	4630      	mov	r0, r6
    b40c:	f7fd fd16 	bl	8e3c <_free_r>
    b410:	e7bd      	b.n	b38e <_fclose_r+0x42>
    b412:	bf00      	nop

0000b414 <__sflush_r>:
    b414:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    b418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b41c:	460c      	mov	r4, r1
    b41e:	0711      	lsls	r1, r2, #28
    b420:	4680      	mov	r8, r0
    b422:	d447      	bmi.n	b4b4 <__sflush_r+0xa0>
    b424:	6863      	ldr	r3, [r4, #4]
    b426:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    b42a:	2b00      	cmp	r3, #0
    b42c:	81a2      	strh	r2, [r4, #12]
    b42e:	dd5e      	ble.n	b4ee <__sflush_r+0xda>
    b430:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    b432:	2d00      	cmp	r5, #0
    b434:	d058      	beq.n	b4e8 <__sflush_r+0xd4>
    b436:	2300      	movs	r3, #0
    b438:	f8d8 6000 	ldr.w	r6, [r8]
    b43c:	f8c8 3000 	str.w	r3, [r8]
    b440:	b293      	uxth	r3, r2
    b442:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    b446:	d156      	bne.n	b4f6 <__sflush_r+0xe2>
    b448:	2301      	movs	r3, #1
    b44a:	69e1      	ldr	r1, [r4, #28]
    b44c:	4640      	mov	r0, r8
    b44e:	47a8      	blx	r5
    b450:	1c43      	adds	r3, r0, #1
    b452:	d067      	beq.n	b524 <__sflush_r+0x110>
    b454:	89a3      	ldrh	r3, [r4, #12]
    b456:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    b458:	075f      	lsls	r7, r3, #29
    b45a:	d505      	bpl.n	b468 <__sflush_r+0x54>
    b45c:	6863      	ldr	r3, [r4, #4]
    b45e:	1ac0      	subs	r0, r0, r3
    b460:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b462:	b10b      	cbz	r3, b468 <__sflush_r+0x54>
    b464:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    b466:	1ac0      	subs	r0, r0, r3
    b468:	69e1      	ldr	r1, [r4, #28]
    b46a:	4602      	mov	r2, r0
    b46c:	2300      	movs	r3, #0
    b46e:	4640      	mov	r0, r8
    b470:	47a8      	blx	r5
    b472:	1c41      	adds	r1, r0, #1
    b474:	d141      	bne.n	b4fa <__sflush_r+0xe6>
    b476:	f8d8 3000 	ldr.w	r3, [r8]
    b47a:	2b00      	cmp	r3, #0
    b47c:	d03d      	beq.n	b4fa <__sflush_r+0xe6>
    b47e:	2b1d      	cmp	r3, #29
    b480:	d001      	beq.n	b486 <__sflush_r+0x72>
    b482:	2b16      	cmp	r3, #22
    b484:	d156      	bne.n	b534 <__sflush_r+0x120>
    b486:	89a3      	ldrh	r3, [r4, #12]
    b488:	6922      	ldr	r2, [r4, #16]
    b48a:	6022      	str	r2, [r4, #0]
    b48c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    b490:	2100      	movs	r1, #0
    b492:	6061      	str	r1, [r4, #4]
    b494:	81a3      	strh	r3, [r4, #12]
    b496:	6b21      	ldr	r1, [r4, #48]	; 0x30
    b498:	f8c8 6000 	str.w	r6, [r8]
    b49c:	b321      	cbz	r1, b4e8 <__sflush_r+0xd4>
    b49e:	f104 0340 	add.w	r3, r4, #64	; 0x40
    b4a2:	4299      	cmp	r1, r3
    b4a4:	d002      	beq.n	b4ac <__sflush_r+0x98>
    b4a6:	4640      	mov	r0, r8
    b4a8:	f7fd fcc8 	bl	8e3c <_free_r>
    b4ac:	2000      	movs	r0, #0
    b4ae:	6320      	str	r0, [r4, #48]	; 0x30
    b4b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b4b4:	6926      	ldr	r6, [r4, #16]
    b4b6:	b1be      	cbz	r6, b4e8 <__sflush_r+0xd4>
    b4b8:	b293      	uxth	r3, r2
    b4ba:	6825      	ldr	r5, [r4, #0]
    b4bc:	6026      	str	r6, [r4, #0]
    b4be:	079a      	lsls	r2, r3, #30
    b4c0:	bf0c      	ite	eq
    b4c2:	6963      	ldreq	r3, [r4, #20]
    b4c4:	2300      	movne	r3, #0
    b4c6:	1bad      	subs	r5, r5, r6
    b4c8:	60a3      	str	r3, [r4, #8]
    b4ca:	e00b      	b.n	b4e4 <__sflush_r+0xd0>
    b4cc:	462b      	mov	r3, r5
    b4ce:	4632      	mov	r2, r6
    b4d0:	69e1      	ldr	r1, [r4, #28]
    b4d2:	6a67      	ldr	r7, [r4, #36]	; 0x24
    b4d4:	4640      	mov	r0, r8
    b4d6:	47b8      	blx	r7
    b4d8:	f1b0 0c00 	subs.w	ip, r0, #0
    b4dc:	eba5 050c 	sub.w	r5, r5, ip
    b4e0:	4466      	add	r6, ip
    b4e2:	dd17      	ble.n	b514 <__sflush_r+0x100>
    b4e4:	2d00      	cmp	r5, #0
    b4e6:	dcf1      	bgt.n	b4cc <__sflush_r+0xb8>
    b4e8:	2000      	movs	r0, #0
    b4ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b4ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    b4f0:	2b00      	cmp	r3, #0
    b4f2:	dc9d      	bgt.n	b430 <__sflush_r+0x1c>
    b4f4:	e7f8      	b.n	b4e8 <__sflush_r+0xd4>
    b4f6:	6d20      	ldr	r0, [r4, #80]	; 0x50
    b4f8:	e7ae      	b.n	b458 <__sflush_r+0x44>
    b4fa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    b4fe:	6922      	ldr	r2, [r4, #16]
    b500:	6022      	str	r2, [r4, #0]
    b502:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    b506:	81a3      	strh	r3, [r4, #12]
    b508:	2200      	movs	r2, #0
    b50a:	04db      	lsls	r3, r3, #19
    b50c:	6062      	str	r2, [r4, #4]
    b50e:	d5c2      	bpl.n	b496 <__sflush_r+0x82>
    b510:	6520      	str	r0, [r4, #80]	; 0x50
    b512:	e7c0      	b.n	b496 <__sflush_r+0x82>
    b514:	89a3      	ldrh	r3, [r4, #12]
    b516:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b51a:	f04f 30ff 	mov.w	r0, #4294967295
    b51e:	81a3      	strh	r3, [r4, #12]
    b520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b524:	f8d8 3000 	ldr.w	r3, [r8]
    b528:	2b00      	cmp	r3, #0
    b52a:	d093      	beq.n	b454 <__sflush_r+0x40>
    b52c:	2b1d      	cmp	r3, #29
    b52e:	d006      	beq.n	b53e <__sflush_r+0x12a>
    b530:	2b16      	cmp	r3, #22
    b532:	d004      	beq.n	b53e <__sflush_r+0x12a>
    b534:	89a3      	ldrh	r3, [r4, #12]
    b536:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b53a:	81a3      	strh	r3, [r4, #12]
    b53c:	e7d5      	b.n	b4ea <__sflush_r+0xd6>
    b53e:	f8c8 6000 	str.w	r6, [r8]
    b542:	e7d1      	b.n	b4e8 <__sflush_r+0xd4>

0000b544 <_fflush_r>:
    b544:	b538      	push	{r3, r4, r5, lr}
    b546:	460c      	mov	r4, r1
    b548:	4605      	mov	r5, r0
    b54a:	b108      	cbz	r0, b550 <_fflush_r+0xc>
    b54c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b54e:	b303      	cbz	r3, b592 <_fflush_r+0x4e>
    b550:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
    b554:	b188      	cbz	r0, b57a <_fflush_r+0x36>
    b556:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b558:	07db      	lsls	r3, r3, #31
    b55a:	d401      	bmi.n	b560 <_fflush_r+0x1c>
    b55c:	0581      	lsls	r1, r0, #22
    b55e:	d50f      	bpl.n	b580 <_fflush_r+0x3c>
    b560:	4628      	mov	r0, r5
    b562:	4621      	mov	r1, r4
    b564:	f7ff ff56 	bl	b414 <__sflush_r>
    b568:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b56a:	07da      	lsls	r2, r3, #31
    b56c:	4605      	mov	r5, r0
    b56e:	d402      	bmi.n	b576 <_fflush_r+0x32>
    b570:	89a3      	ldrh	r3, [r4, #12]
    b572:	059b      	lsls	r3, r3, #22
    b574:	d508      	bpl.n	b588 <_fflush_r+0x44>
    b576:	4628      	mov	r0, r5
    b578:	bd38      	pop	{r3, r4, r5, pc}
    b57a:	4605      	mov	r5, r0
    b57c:	4628      	mov	r0, r5
    b57e:	bd38      	pop	{r3, r4, r5, pc}
    b580:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b582:	f7fd fb8d 	bl	8ca0 <__retarget_lock_acquire_recursive>
    b586:	e7eb      	b.n	b560 <_fflush_r+0x1c>
    b588:	6da0      	ldr	r0, [r4, #88]	; 0x58
    b58a:	f7fd fb8b 	bl	8ca4 <__retarget_lock_release_recursive>
    b58e:	4628      	mov	r0, r5
    b590:	bd38      	pop	{r3, r4, r5, pc}
    b592:	f7fd f8f1 	bl	8778 <__sinit>
    b596:	e7db      	b.n	b550 <_fflush_r+0xc>

0000b598 <_localeconv_r>:
    b598:	4800      	ldr	r0, [pc, #0]	; (b59c <_localeconv_r+0x4>)
    b59a:	4770      	bx	lr
    b59c:	200012d4 	.word	0x200012d4

0000b5a0 <memchr>:
    b5a0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b5a4:	2a10      	cmp	r2, #16
    b5a6:	db2b      	blt.n	b600 <memchr+0x60>
    b5a8:	f010 0f07 	tst.w	r0, #7
    b5ac:	d008      	beq.n	b5c0 <memchr+0x20>
    b5ae:	f810 3b01 	ldrb.w	r3, [r0], #1
    b5b2:	3a01      	subs	r2, #1
    b5b4:	428b      	cmp	r3, r1
    b5b6:	d02d      	beq.n	b614 <memchr+0x74>
    b5b8:	f010 0f07 	tst.w	r0, #7
    b5bc:	b342      	cbz	r2, b610 <memchr+0x70>
    b5be:	d1f6      	bne.n	b5ae <memchr+0xe>
    b5c0:	b4f0      	push	{r4, r5, r6, r7}
    b5c2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    b5c6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    b5ca:	f022 0407 	bic.w	r4, r2, #7
    b5ce:	f07f 0700 	mvns.w	r7, #0
    b5d2:	2300      	movs	r3, #0
    b5d4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    b5d8:	3c08      	subs	r4, #8
    b5da:	ea85 0501 	eor.w	r5, r5, r1
    b5de:	ea86 0601 	eor.w	r6, r6, r1
    b5e2:	fa85 f547 	uadd8	r5, r5, r7
    b5e6:	faa3 f587 	sel	r5, r3, r7
    b5ea:	fa86 f647 	uadd8	r6, r6, r7
    b5ee:	faa5 f687 	sel	r6, r5, r7
    b5f2:	b98e      	cbnz	r6, b618 <memchr+0x78>
    b5f4:	d1ee      	bne.n	b5d4 <memchr+0x34>
    b5f6:	bcf0      	pop	{r4, r5, r6, r7}
    b5f8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b5fc:	f002 0207 	and.w	r2, r2, #7
    b600:	b132      	cbz	r2, b610 <memchr+0x70>
    b602:	f810 3b01 	ldrb.w	r3, [r0], #1
    b606:	3a01      	subs	r2, #1
    b608:	ea83 0301 	eor.w	r3, r3, r1
    b60c:	b113      	cbz	r3, b614 <memchr+0x74>
    b60e:	d1f8      	bne.n	b602 <memchr+0x62>
    b610:	2000      	movs	r0, #0
    b612:	4770      	bx	lr
    b614:	3801      	subs	r0, #1
    b616:	4770      	bx	lr
    b618:	2d00      	cmp	r5, #0
    b61a:	bf06      	itte	eq
    b61c:	4635      	moveq	r5, r6
    b61e:	3803      	subeq	r0, #3
    b620:	3807      	subne	r0, #7
    b622:	f015 0f01 	tst.w	r5, #1
    b626:	d107      	bne.n	b638 <memchr+0x98>
    b628:	3001      	adds	r0, #1
    b62a:	f415 7f80 	tst.w	r5, #256	; 0x100
    b62e:	bf02      	ittt	eq
    b630:	3001      	addeq	r0, #1
    b632:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    b636:	3001      	addeq	r0, #1
    b638:	bcf0      	pop	{r4, r5, r6, r7}
    b63a:	3801      	subs	r0, #1
    b63c:	4770      	bx	lr
    b63e:	bf00      	nop

0000b640 <frexp>:
    b640:	b430      	push	{r4, r5}
    b642:	b082      	sub	sp, #8
    b644:	ed8d 0b00 	vstr	d0, [sp]
    b648:	9a01      	ldr	r2, [sp, #4]
    b64a:	4c19      	ldr	r4, [pc, #100]	; (b6b0 <frexp+0x70>)
    b64c:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    b650:	2100      	movs	r1, #0
    b652:	42a3      	cmp	r3, r4
    b654:	6001      	str	r1, [r0, #0]
    b656:	dc21      	bgt.n	b69c <frexp+0x5c>
    b658:	9c00      	ldr	r4, [sp, #0]
    b65a:	431c      	orrs	r4, r3
    b65c:	d01e      	beq.n	b69c <frexp+0x5c>
    b65e:	4c15      	ldr	r4, [pc, #84]	; (b6b4 <frexp+0x74>)
    b660:	4014      	ands	r4, r2
    b662:	b954      	cbnz	r4, b67a <frexp+0x3a>
    b664:	ed9f 7b10 	vldr	d7, [pc, #64]	; b6a8 <frexp+0x68>
    b668:	ee20 7b07 	vmul.f64	d7, d0, d7
    b66c:	ed8d 7b00 	vstr	d7, [sp]
    b670:	9a01      	ldr	r2, [sp, #4]
    b672:	f06f 0135 	mvn.w	r1, #53	; 0x35
    b676:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    b67a:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
    b67e:	e9dd 4500 	ldrd	r4, r5, [sp]
    b682:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
    b686:	f042 557f 	orr.w	r5, r2, #1069547520	; 0x3fc00000
    b68a:	151b      	asrs	r3, r3, #20
    b68c:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
    b690:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    b694:	e9cd 4500 	strd	r4, r5, [sp]
    b698:	440b      	add	r3, r1
    b69a:	6003      	str	r3, [r0, #0]
    b69c:	ed9d 0b00 	vldr	d0, [sp]
    b6a0:	b002      	add	sp, #8
    b6a2:	bc30      	pop	{r4, r5}
    b6a4:	4770      	bx	lr
    b6a6:	bf00      	nop
    b6a8:	00000000 	.word	0x00000000
    b6ac:	43500000 	.word	0x43500000
    b6b0:	7fefffff 	.word	0x7fefffff
    b6b4:	7ff00000 	.word	0x7ff00000

0000b6b8 <__assert_func>:
    b6b8:	b500      	push	{lr}
    b6ba:	4c0b      	ldr	r4, [pc, #44]	; (b6e8 <__assert_func+0x30>)
    b6bc:	6825      	ldr	r5, [r4, #0]
    b6be:	4614      	mov	r4, r2
    b6c0:	68ee      	ldr	r6, [r5, #12]
    b6c2:	461a      	mov	r2, r3
    b6c4:	b085      	sub	sp, #20
    b6c6:	4603      	mov	r3, r0
    b6c8:	460d      	mov	r5, r1
    b6ca:	b14c      	cbz	r4, b6e0 <__assert_func+0x28>
    b6cc:	4907      	ldr	r1, [pc, #28]	; (b6ec <__assert_func+0x34>)
    b6ce:	9500      	str	r5, [sp, #0]
    b6d0:	e9cd 1401 	strd	r1, r4, [sp, #4]
    b6d4:	4630      	mov	r0, r6
    b6d6:	4906      	ldr	r1, [pc, #24]	; (b6f0 <__assert_func+0x38>)
    b6d8:	f000 ff86 	bl	c5e8 <fiprintf>
    b6dc:	f7fb fa00 	bl	6ae0 <abort>
    b6e0:	4904      	ldr	r1, [pc, #16]	; (b6f4 <__assert_func+0x3c>)
    b6e2:	460c      	mov	r4, r1
    b6e4:	e7f3      	b.n	b6ce <__assert_func+0x16>
    b6e6:	bf00      	nop
    b6e8:	2000176c 	.word	0x2000176c
    b6ec:	200008fc 	.word	0x200008fc
    b6f0:	2000090c 	.word	0x2000090c
    b6f4:	200004a8 	.word	0x200004a8

0000b6f8 <_calloc_r>:
    b6f8:	b538      	push	{r3, r4, r5, lr}
    b6fa:	fba1 1402 	umull	r1, r4, r1, r2
    b6fe:	bb8c      	cbnz	r4, b764 <_calloc_r+0x6c>
    b700:	f7fc fafc 	bl	7cfc <_malloc_r>
    b704:	4605      	mov	r5, r0
    b706:	b1e0      	cbz	r0, b742 <_calloc_r+0x4a>
    b708:	f850 2c04 	ldr.w	r2, [r0, #-4]
    b70c:	f022 0203 	bic.w	r2, r2, #3
    b710:	3a04      	subs	r2, #4
    b712:	2a24      	cmp	r2, #36	; 0x24
    b714:	d817      	bhi.n	b746 <_calloc_r+0x4e>
    b716:	2a13      	cmp	r2, #19
    b718:	d91a      	bls.n	b750 <_calloc_r+0x58>
    b71a:	2a1b      	cmp	r2, #27
    b71c:	e9c0 4400 	strd	r4, r4, [r0]
    b720:	d91d      	bls.n	b75e <_calloc_r+0x66>
    b722:	2a24      	cmp	r2, #36	; 0x24
    b724:	bf14      	ite	ne
    b726:	f100 0210 	addne.w	r2, r0, #16
    b72a:	f100 0218 	addeq.w	r2, r0, #24
    b72e:	f04f 0300 	mov.w	r3, #0
    b732:	e9c0 4402 	strd	r4, r4, [r0, #8]
    b736:	bf04      	itt	eq
    b738:	6104      	streq	r4, [r0, #16]
    b73a:	6144      	streq	r4, [r0, #20]
    b73c:	e9c2 3300 	strd	r3, r3, [r2]
    b740:	6093      	str	r3, [r2, #8]
    b742:	4628      	mov	r0, r5
    b744:	bd38      	pop	{r3, r4, r5, pc}
    b746:	4621      	mov	r1, r4
    b748:	f7fd f98c 	bl	8a64 <memset>
    b74c:	4628      	mov	r0, r5
    b74e:	bd38      	pop	{r3, r4, r5, pc}
    b750:	4602      	mov	r2, r0
    b752:	2300      	movs	r3, #0
    b754:	e9c2 3300 	strd	r3, r3, [r2]
    b758:	6093      	str	r3, [r2, #8]
    b75a:	4628      	mov	r0, r5
    b75c:	bd38      	pop	{r3, r4, r5, pc}
    b75e:	f100 0208 	add.w	r2, r0, #8
    b762:	e7f6      	b.n	b752 <_calloc_r+0x5a>
    b764:	f7fd fa6e 	bl	8c44 <__errno>
    b768:	230c      	movs	r3, #12
    b76a:	2500      	movs	r5, #0
    b76c:	6003      	str	r3, [r0, #0]
    b76e:	e7e8      	b.n	b742 <_calloc_r+0x4a>

0000b770 <quorem>:
    b770:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b774:	6903      	ldr	r3, [r0, #16]
    b776:	690c      	ldr	r4, [r1, #16]
    b778:	42a3      	cmp	r3, r4
    b77a:	b083      	sub	sp, #12
    b77c:	f2c0 8087 	blt.w	b88e <quorem+0x11e>
    b780:	3c01      	subs	r4, #1
    b782:	f101 0514 	add.w	r5, r1, #20
    b786:	00a3      	lsls	r3, r4, #2
    b788:	f100 0814 	add.w	r8, r0, #20
    b78c:	9300      	str	r3, [sp, #0]
    b78e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    b792:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
    b796:	3301      	adds	r3, #1
    b798:	4681      	mov	r9, r0
    b79a:	429a      	cmp	r2, r3
    b79c:	eb08 0084 	add.w	r0, r8, r4, lsl #2
    b7a0:	eb05 0784 	add.w	r7, r5, r4, lsl #2
    b7a4:	9001      	str	r0, [sp, #4]
    b7a6:	fbb2 f6f3 	udiv	r6, r2, r3
    b7aa:	d33b      	bcc.n	b824 <quorem+0xb4>
    b7ac:	f04f 0c00 	mov.w	ip, #0
    b7b0:	46ae      	mov	lr, r5
    b7b2:	4640      	mov	r0, r8
    b7b4:	46e2      	mov	sl, ip
    b7b6:	4663      	mov	r3, ip
    b7b8:	f85e bb04 	ldr.w	fp, [lr], #4
    b7bc:	6802      	ldr	r2, [r0, #0]
    b7be:	fa1f fc8b 	uxth.w	ip, fp
    b7c2:	fb06 330c 	mla	r3, r6, ip, r3
    b7c6:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    b7ca:	ea4f 4b1b 	mov.w	fp, fp, lsr #16
    b7ce:	fb06 cc0b 	mla	ip, r6, fp, ip
    b7d2:	b29b      	uxth	r3, r3
    b7d4:	ebaa 0303 	sub.w	r3, sl, r3
    b7d8:	fa1f fa8c 	uxth.w	sl, ip
    b7dc:	fa13 f382 	uxtah	r3, r3, r2
    b7e0:	ebca 4212 	rsb	r2, sl, r2, lsr #16
    b7e4:	eb02 4223 	add.w	r2, r2, r3, asr #16
    b7e8:	b29b      	uxth	r3, r3
    b7ea:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    b7ee:	4577      	cmp	r7, lr
    b7f0:	f840 3b04 	str.w	r3, [r0], #4
    b7f4:	ea4f 4a22 	mov.w	sl, r2, asr #16
    b7f8:	ea4f 431c 	mov.w	r3, ip, lsr #16
    b7fc:	d2dc      	bcs.n	b7b8 <quorem+0x48>
    b7fe:	9b00      	ldr	r3, [sp, #0]
    b800:	f858 3003 	ldr.w	r3, [r8, r3]
    b804:	b973      	cbnz	r3, b824 <quorem+0xb4>
    b806:	9b01      	ldr	r3, [sp, #4]
    b808:	3b04      	subs	r3, #4
    b80a:	4598      	cmp	r8, r3
    b80c:	d304      	bcc.n	b818 <quorem+0xa8>
    b80e:	e007      	b.n	b820 <quorem+0xb0>
    b810:	4598      	cmp	r8, r3
    b812:	f104 34ff 	add.w	r4, r4, #4294967295
    b816:	d203      	bcs.n	b820 <quorem+0xb0>
    b818:	f853 2904 	ldr.w	r2, [r3], #-4
    b81c:	2a00      	cmp	r2, #0
    b81e:	d0f7      	beq.n	b810 <quorem+0xa0>
    b820:	f8c9 4010 	str.w	r4, [r9, #16]
    b824:	4648      	mov	r0, r9
    b826:	f7fd feab 	bl	9580 <__mcmp>
    b82a:	2800      	cmp	r0, #0
    b82c:	db2b      	blt.n	b886 <quorem+0x116>
    b82e:	3601      	adds	r6, #1
    b830:	4641      	mov	r1, r8
    b832:	2300      	movs	r3, #0
    b834:	f855 0b04 	ldr.w	r0, [r5], #4
    b838:	f8d1 c000 	ldr.w	ip, [r1]
    b83c:	b282      	uxth	r2, r0
    b83e:	1a9a      	subs	r2, r3, r2
    b840:	0c03      	lsrs	r3, r0, #16
    b842:	fa12 f28c 	uxtah	r2, r2, ip
    b846:	ebc3 431c 	rsb	r3, r3, ip, lsr #16
    b84a:	eb03 4322 	add.w	r3, r3, r2, asr #16
    b84e:	b292      	uxth	r2, r2
    b850:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    b854:	42af      	cmp	r7, r5
    b856:	f841 2b04 	str.w	r2, [r1], #4
    b85a:	ea4f 4323 	mov.w	r3, r3, asr #16
    b85e:	d2e9      	bcs.n	b834 <quorem+0xc4>
    b860:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
    b864:	eb08 0384 	add.w	r3, r8, r4, lsl #2
    b868:	b96a      	cbnz	r2, b886 <quorem+0x116>
    b86a:	3b04      	subs	r3, #4
    b86c:	4598      	cmp	r8, r3
    b86e:	d304      	bcc.n	b87a <quorem+0x10a>
    b870:	e007      	b.n	b882 <quorem+0x112>
    b872:	4598      	cmp	r8, r3
    b874:	f104 34ff 	add.w	r4, r4, #4294967295
    b878:	d203      	bcs.n	b882 <quorem+0x112>
    b87a:	f853 2904 	ldr.w	r2, [r3], #-4
    b87e:	2a00      	cmp	r2, #0
    b880:	d0f7      	beq.n	b872 <quorem+0x102>
    b882:	f8c9 4010 	str.w	r4, [r9, #16]
    b886:	4630      	mov	r0, r6
    b888:	b003      	add	sp, #12
    b88a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b88e:	2000      	movs	r0, #0
    b890:	b003      	add	sp, #12
    b892:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b896:	bf00      	nop

0000b898 <_dtoa_r>:
    b898:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b89c:	ed2d 8b02 	vpush	{d8}
    b8a0:	b08f      	sub	sp, #60	; 0x3c
    b8a2:	ed8d 0b02 	vstr	d0, [sp, #8]
    b8a6:	9101      	str	r1, [sp, #4]
    b8a8:	6b81      	ldr	r1, [r0, #56]	; 0x38
    b8aa:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    b8ac:	9305      	str	r3, [sp, #20]
    b8ae:	ec57 6b10 	vmov	r6, r7, d0
    b8b2:	4604      	mov	r4, r0
    b8b4:	4693      	mov	fp, r2
    b8b6:	b141      	cbz	r1, b8ca <_dtoa_r+0x32>
    b8b8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    b8ba:	604a      	str	r2, [r1, #4]
    b8bc:	2301      	movs	r3, #1
    b8be:	4093      	lsls	r3, r2
    b8c0:	608b      	str	r3, [r1, #8]
    b8c2:	f7fd fbfd 	bl	90c0 <_Bfree>
    b8c6:	2300      	movs	r3, #0
    b8c8:	63a3      	str	r3, [r4, #56]	; 0x38
    b8ca:	f1b7 0800 	subs.w	r8, r7, #0
    b8ce:	bfb4      	ite	lt
    b8d0:	2301      	movlt	r3, #1
    b8d2:	2300      	movge	r3, #0
    b8d4:	602b      	str	r3, [r5, #0]
    b8d6:	4bbe      	ldr	r3, [pc, #760]	; (bbd0 <_dtoa_r+0x338>)
    b8d8:	bfbc      	itt	lt
    b8da:	f028 4800 	biclt.w	r8, r8, #2147483648	; 0x80000000
    b8de:	f8cd 800c 	strlt.w	r8, [sp, #12]
    b8e2:	ea33 0308 	bics.w	r3, r3, r8
    b8e6:	f000 809f 	beq.w	ba28 <_dtoa_r+0x190>
    b8ea:	ed9d 8b02 	vldr	d8, [sp, #8]
    b8ee:	eeb5 8b40 	vcmp.f64	d8, #0.0
    b8f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b8f6:	d111      	bne.n	b91c <_dtoa_r+0x84>
    b8f8:	9a05      	ldr	r2, [sp, #20]
    b8fa:	2301      	movs	r3, #1
    b8fc:	6013      	str	r3, [r2, #0]
    b8fe:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    b900:	2b00      	cmp	r3, #0
    b902:	f000 823f 	beq.w	bd84 <_dtoa_r+0x4ec>
    b906:	4bb3      	ldr	r3, [pc, #716]	; (bbd4 <_dtoa_r+0x33c>)
    b908:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    b90a:	6013      	str	r3, [r2, #0]
    b90c:	3b01      	subs	r3, #1
    b90e:	9300      	str	r3, [sp, #0]
    b910:	9800      	ldr	r0, [sp, #0]
    b912:	b00f      	add	sp, #60	; 0x3c
    b914:	ecbd 8b02 	vpop	{d8}
    b918:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b91c:	aa0c      	add	r2, sp, #48	; 0x30
    b91e:	a90d      	add	r1, sp, #52	; 0x34
    b920:	4620      	mov	r0, r4
    b922:	eeb0 0b48 	vmov.f64	d0, d8
    b926:	f7fd fef7 	bl	9718 <__d2b>
    b92a:	ea5f 5318 	movs.w	r3, r8, lsr #20
    b92e:	4605      	mov	r5, r0
    b930:	f040 8092 	bne.w	ba58 <_dtoa_r+0x1c0>
    b934:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
    b938:	440b      	add	r3, r1
    b93a:	f203 4232 	addw	r2, r3, #1074	; 0x432
    b93e:	2a20      	cmp	r2, #32
    b940:	f340 82fa 	ble.w	bf38 <_dtoa_r+0x6a0>
    b944:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
    b948:	fa08 f802 	lsl.w	r8, r8, r2
    b94c:	f203 4212 	addw	r2, r3, #1042	; 0x412
    b950:	40d6      	lsrs	r6, r2
    b952:	ea48 0206 	orr.w	r2, r8, r6
    b956:	ee07 2a10 	vmov	s14, r2
    b95a:	eeb8 7b47 	vcvt.f64.u32	d7, s14
    b95e:	1e58      	subs	r0, r3, #1
    b960:	ee17 6a90 	vmov	r6, s15
    b964:	ec53 2b17 	vmov	r2, r3, d7
    b968:	f04f 0a01 	mov.w	sl, #1
    b96c:	f1a6 73f8 	sub.w	r3, r6, #32505856	; 0x1f00000
    b970:	ed9f 3b91 	vldr	d3, [pc, #580]	; bbb8 <_dtoa_r+0x320>
    b974:	ed9f 7b92 	vldr	d7, [pc, #584]	; bbc0 <_dtoa_r+0x328>
    b978:	ed9f 5b93 	vldr	d5, [pc, #588]	; bbc8 <_dtoa_r+0x330>
    b97c:	ee06 0a90 	vmov	s13, r0
    b980:	ec43 2b12 	vmov	d2, r2, r3
    b984:	eeb8 4be6 	vcvt.f64.s32	d4, s13
    b988:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    b98c:	ee32 6b46 	vsub.f64	d6, d2, d6
    b990:	eea6 7b03 	vfma.f64	d7, d6, d3
    b994:	eea4 7b05 	vfma.f64	d7, d4, d5
    b998:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    b99c:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    b9a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b9a4:	ee16 7a90 	vmov	r7, s13
    b9a8:	d508      	bpl.n	b9bc <_dtoa_r+0x124>
    b9aa:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    b9ae:	eeb4 6b47 	vcmp.f64	d6, d7
    b9b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b9b6:	bf18      	it	ne
    b9b8:	f107 37ff 	addne.w	r7, r7, #4294967295
    b9bc:	2f16      	cmp	r7, #22
    b9be:	f200 8145 	bhi.w	bc4c <_dtoa_r+0x3b4>
    b9c2:	4b85      	ldr	r3, [pc, #532]	; (bbd8 <_dtoa_r+0x340>)
    b9c4:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
    b9c8:	ed93 7b00 	vldr	d7, [r3]
    b9cc:	eeb4 8bc7 	vcmpe.f64	d8, d7
    b9d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b9d4:	d557      	bpl.n	ba86 <_dtoa_r+0x1ee>
    b9d6:	1a09      	subs	r1, r1, r0
    b9d8:	2300      	movs	r3, #0
    b9da:	f1b1 0801 	subs.w	r8, r1, #1
    b9de:	f107 37ff 	add.w	r7, r7, #4294967295
    b9e2:	930a      	str	r3, [sp, #40]	; 0x28
    b9e4:	f100 8139 	bmi.w	bc5a <_dtoa_r+0x3c2>
    b9e8:	2300      	movs	r3, #0
    b9ea:	9306      	str	r3, [sp, #24]
    b9ec:	2f00      	cmp	r7, #0
    b9ee:	da52      	bge.n	ba96 <_dtoa_r+0x1fe>
    b9f0:	9b06      	ldr	r3, [sp, #24]
    b9f2:	9704      	str	r7, [sp, #16]
    b9f4:	1bdb      	subs	r3, r3, r7
    b9f6:	9306      	str	r3, [sp, #24]
    b9f8:	427b      	negs	r3, r7
    b9fa:	9308      	str	r3, [sp, #32]
    b9fc:	9b01      	ldr	r3, [sp, #4]
    b9fe:	2b09      	cmp	r3, #9
    ba00:	f04f 0700 	mov.w	r7, #0
    ba04:	d84e      	bhi.n	baa4 <_dtoa_r+0x20c>
    ba06:	2b05      	cmp	r3, #5
    ba08:	f340 829d 	ble.w	bf46 <_dtoa_r+0x6ae>
    ba0c:	3b04      	subs	r3, #4
    ba0e:	9301      	str	r3, [sp, #4]
    ba10:	2600      	movs	r6, #0
    ba12:	9b01      	ldr	r3, [sp, #4]
    ba14:	1e9a      	subs	r2, r3, #2
    ba16:	2a03      	cmp	r2, #3
    ba18:	f200 8125 	bhi.w	bc66 <_dtoa_r+0x3ce>
    ba1c:	e8df f012 	tbh	[pc, r2, lsl #1]
    ba20:	03a703aa 	.word	0x03a703aa
    ba24:	037e039d 	.word	0x037e039d
    ba28:	9a05      	ldr	r2, [sp, #20]
    ba2a:	f3c8 0813 	ubfx	r8, r8, #0, #20
    ba2e:	f242 730f 	movw	r3, #9999	; 0x270f
    ba32:	ea58 0806 	orrs.w	r8, r8, r6
    ba36:	6013      	str	r3, [r2, #0]
    ba38:	d11e      	bne.n	ba78 <_dtoa_r+0x1e0>
    ba3a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    ba3c:	2b00      	cmp	r3, #0
    ba3e:	f000 8591 	beq.w	c564 <_dtoa_r+0xccc>
    ba42:	4b66      	ldr	r3, [pc, #408]	; (bbdc <_dtoa_r+0x344>)
    ba44:	9300      	str	r3, [sp, #0]
    ba46:	3308      	adds	r3, #8
    ba48:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    ba4a:	9800      	ldr	r0, [sp, #0]
    ba4c:	6013      	str	r3, [r2, #0]
    ba4e:	b00f      	add	sp, #60	; 0x3c
    ba50:	ecbd 8b02 	vpop	{d8}
    ba54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ba58:	ee18 6a90 	vmov	r6, s17
    ba5c:	f3c6 0613 	ubfx	r6, r6, #0, #20
    ba60:	f2a3 30ff 	subw	r0, r3, #1023	; 0x3ff
    ba64:	ec53 2b18 	vmov	r2, r3, d8
    ba68:	f046 537f 	orr.w	r3, r6, #1069547520	; 0x3fc00000
    ba6c:	990c      	ldr	r1, [sp, #48]	; 0x30
    ba6e:	f04f 0a00 	mov.w	sl, #0
    ba72:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    ba76:	e77b      	b.n	b970 <_dtoa_r+0xd8>
    ba78:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    ba7a:	2b00      	cmp	r3, #0
    ba7c:	f040 833b 	bne.w	c0f6 <_dtoa_r+0x85e>
    ba80:	4b57      	ldr	r3, [pc, #348]	; (bbe0 <_dtoa_r+0x348>)
    ba82:	9300      	str	r3, [sp, #0]
    ba84:	e744      	b.n	b910 <_dtoa_r+0x78>
    ba86:	1a09      	subs	r1, r1, r0
    ba88:	2300      	movs	r3, #0
    ba8a:	f1b1 0801 	subs.w	r8, r1, #1
    ba8e:	930a      	str	r3, [sp, #40]	; 0x28
    ba90:	f100 80e3 	bmi.w	bc5a <_dtoa_r+0x3c2>
    ba94:	9306      	str	r3, [sp, #24]
    ba96:	2300      	movs	r3, #0
    ba98:	9308      	str	r3, [sp, #32]
    ba9a:	9b01      	ldr	r3, [sp, #4]
    ba9c:	9704      	str	r7, [sp, #16]
    ba9e:	2b09      	cmp	r3, #9
    baa0:	44b8      	add	r8, r7
    baa2:	d9b0      	bls.n	ba06 <_dtoa_r+0x16e>
    baa4:	2300      	movs	r3, #0
    baa6:	2601      	movs	r6, #1
    baa8:	9301      	str	r3, [sp, #4]
    baaa:	9607      	str	r6, [sp, #28]
    baac:	f04f 39ff 	mov.w	r9, #4294967295
    bab0:	469b      	mov	fp, r3
    bab2:	2100      	movs	r1, #0
    bab4:	63e1      	str	r1, [r4, #60]	; 0x3c
    bab6:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
    baba:	4620      	mov	r0, r4
    babc:	f7fd fada 	bl	9074 <_Balloc>
    bac0:	9000      	str	r0, [sp, #0]
    bac2:	2800      	cmp	r0, #0
    bac4:	f000 8540 	beq.w	c548 <_dtoa_r+0xcb0>
    bac8:	9b00      	ldr	r3, [sp, #0]
    baca:	63a3      	str	r3, [r4, #56]	; 0x38
    bacc:	f1b9 0f0e 	cmp.w	r9, #14
    bad0:	f200 80dc 	bhi.w	bc8c <_dtoa_r+0x3f4>
    bad4:	2e00      	cmp	r6, #0
    bad6:	f000 80d9 	beq.w	bc8c <_dtoa_r+0x3f4>
    bada:	9b04      	ldr	r3, [sp, #16]
    badc:	2b00      	cmp	r3, #0
    bade:	f340 83de 	ble.w	c29e <_dtoa_r+0xa06>
    bae2:	4a3d      	ldr	r2, [pc, #244]	; (bbd8 <_dtoa_r+0x340>)
    bae4:	f003 010f 	and.w	r1, r3, #15
    bae8:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    baec:	ed92 7b00 	vldr	d7, [r2]
    baf0:	111a      	asrs	r2, r3, #4
    baf2:	05db      	lsls	r3, r3, #23
    baf4:	f140 8382 	bpl.w	c1fc <_dtoa_r+0x964>
    baf8:	493a      	ldr	r1, [pc, #232]	; (bbe4 <_dtoa_r+0x34c>)
    bafa:	ed91 6b08 	vldr	d6, [r1, #32]
    bafe:	f002 020f 	and.w	r2, r2, #15
    bb02:	2003      	movs	r0, #3
    bb04:	ee88 5b06 	vdiv.f64	d5, d8, d6
    bb08:	b15a      	cbz	r2, bb22 <_dtoa_r+0x28a>
    bb0a:	4936      	ldr	r1, [pc, #216]	; (bbe4 <_dtoa_r+0x34c>)
    bb0c:	07d6      	lsls	r6, r2, #31
    bb0e:	d504      	bpl.n	bb1a <_dtoa_r+0x282>
    bb10:	ed91 6b00 	vldr	d6, [r1]
    bb14:	3001      	adds	r0, #1
    bb16:	ee27 7b06 	vmul.f64	d7, d7, d6
    bb1a:	1052      	asrs	r2, r2, #1
    bb1c:	f101 0108 	add.w	r1, r1, #8
    bb20:	d1f4      	bne.n	bb0c <_dtoa_r+0x274>
    bb22:	ee85 6b07 	vdiv.f64	d6, d5, d7
    bb26:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    bb28:	b13b      	cbz	r3, bb3a <_dtoa_r+0x2a2>
    bb2a:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    bb2e:	eeb4 6bc7 	vcmpe.f64	d6, d7
    bb32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bb36:	f100 84ae 	bmi.w	c496 <_dtoa_r+0xbfe>
    bb3a:	ee07 0a90 	vmov	s15, r0
    bb3e:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    bb42:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    bb46:	eea5 7b06 	vfma.f64	d7, d5, d6
    bb4a:	ee17 2a90 	vmov	r2, s15
    bb4e:	ec51 0b17 	vmov	r0, r1, d7
    bb52:	f1a2 7150 	sub.w	r1, r2, #54525952	; 0x3400000
    bb56:	f1b9 0f00 	cmp.w	r9, #0
    bb5a:	f000 8388 	beq.w	c26e <_dtoa_r+0x9d6>
    bb5e:	9e04      	ldr	r6, [sp, #16]
    bb60:	464a      	mov	r2, r9
    bb62:	9b07      	ldr	r3, [sp, #28]
    bb64:	2b00      	cmp	r3, #0
    bb66:	f000 8447 	beq.w	c3f8 <_dtoa_r+0xb60>
    bb6a:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    bb6e:	4b1a      	ldr	r3, [pc, #104]	; (bbd8 <_dtoa_r+0x340>)
    bb70:	eefd 4bc6 	vcvt.s32.f64	s9, d6
    bb74:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
    bb78:	eeb8 7be4 	vcvt.f64.s32	d7, s9
    bb7c:	ee36 7b47 	vsub.f64	d7, d6, d7
    bb80:	ed1c 6b02 	vldr	d6, [ip, #-8]
    bb84:	ee83 5b06 	vdiv.f64	d5, d3, d6
    bb88:	ec41 0b16 	vmov	d6, r0, r1
    bb8c:	ee14 0a90 	vmov	r0, s9
    bb90:	ee35 5b46 	vsub.f64	d5, d5, d6
    bb94:	9900      	ldr	r1, [sp, #0]
    bb96:	eeb4 5bc7 	vcmpe.f64	d5, d7
    bb9a:	3030      	adds	r0, #48	; 0x30
    bb9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bba0:	f801 0b01 	strb.w	r0, [r1], #1
    bba4:	f300 84ac 	bgt.w	c500 <_dtoa_r+0xc68>
    bba8:	eeb7 2b00 	vmov.f64	d2, #112	; 0x3f800000  1.0
    bbac:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    bbb0:	f04f 0c00 	mov.w	ip, #0
    bbb4:	e031      	b.n	bc1a <_dtoa_r+0x382>
    bbb6:	bf00      	nop
    bbb8:	636f4361 	.word	0x636f4361
    bbbc:	3fd287a7 	.word	0x3fd287a7
    bbc0:	8b60c8b3 	.word	0x8b60c8b3
    bbc4:	3fc68a28 	.word	0x3fc68a28
    bbc8:	509f79fb 	.word	0x509f79fb
    bbcc:	3fd34413 	.word	0x3fd34413
    bbd0:	7ff00000 	.word	0x7ff00000
    bbd4:	20000525 	.word	0x20000525
    bbd8:	200002a8 	.word	0x200002a8
    bbdc:	20000ab0 	.word	0x20000ab0
    bbe0:	20000abc 	.word	0x20000abc
    bbe4:	20000280 	.word	0x20000280
    bbe8:	f10c 0c01 	add.w	ip, ip, #1
    bbec:	4594      	cmp	ip, r2
    bbee:	da4d      	bge.n	bc8c <_dtoa_r+0x3f4>
    bbf0:	ee27 7b04 	vmul.f64	d7, d7, d4
    bbf4:	ee25 5b04 	vmul.f64	d5, d5, d4
    bbf8:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    bbfc:	ee16 3a90 	vmov	r3, s13
    bc00:	eeb8 3be6 	vcvt.f64.s32	d3, s13
    bc04:	3330      	adds	r3, #48	; 0x30
    bc06:	ee37 7b43 	vsub.f64	d7, d7, d3
    bc0a:	eeb4 7bc5 	vcmpe.f64	d7, d5
    bc0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bc12:	f801 3b01 	strb.w	r3, [r1], #1
    bc16:	f100 8473 	bmi.w	c500 <_dtoa_r+0xc68>
    bc1a:	ee32 6b47 	vsub.f64	d6, d2, d7
    bc1e:	eeb4 6bc5 	vcmpe.f64	d6, d5
    bc22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bc26:	d5df      	bpl.n	bbe8 <_dtoa_r+0x350>
    bc28:	9a00      	ldr	r2, [sp, #0]
    bc2a:	9604      	str	r6, [sp, #16]
    bc2c:	e002      	b.n	bc34 <_dtoa_r+0x39c>
    bc2e:	428a      	cmp	r2, r1
    bc30:	f000 8450 	beq.w	c4d4 <_dtoa_r+0xc3c>
    bc34:	4689      	mov	r9, r1
    bc36:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
    bc3a:	2b39      	cmp	r3, #57	; 0x39
    bc3c:	d0f7      	beq.n	bc2e <_dtoa_r+0x396>
    bc3e:	3301      	adds	r3, #1
    bc40:	b2db      	uxtb	r3, r3
    bc42:	700b      	strb	r3, [r1, #0]
    bc44:	9b04      	ldr	r3, [sp, #16]
    bc46:	3301      	adds	r3, #1
    bc48:	9304      	str	r3, [sp, #16]
    bc4a:	e155      	b.n	bef8 <_dtoa_r+0x660>
    bc4c:	1a09      	subs	r1, r1, r0
    bc4e:	2301      	movs	r3, #1
    bc50:	f1b1 0801 	subs.w	r8, r1, #1
    bc54:	930a      	str	r3, [sp, #40]	; 0x28
    bc56:	f57f aec7 	bpl.w	b9e8 <_dtoa_r+0x150>
    bc5a:	f1c1 0301 	rsb	r3, r1, #1
    bc5e:	9306      	str	r3, [sp, #24]
    bc60:	f04f 0800 	mov.w	r8, #0
    bc64:	e6c2      	b.n	b9ec <_dtoa_r+0x154>
    bc66:	2600      	movs	r6, #0
    bc68:	63e6      	str	r6, [r4, #60]	; 0x3c
    bc6a:	4631      	mov	r1, r6
    bc6c:	4620      	mov	r0, r4
    bc6e:	f7fd fa01 	bl	9074 <_Balloc>
    bc72:	9000      	str	r0, [sp, #0]
    bc74:	2800      	cmp	r0, #0
    bc76:	f000 8467 	beq.w	c548 <_dtoa_r+0xcb0>
    bc7a:	9b00      	ldr	r3, [sp, #0]
    bc7c:	63a3      	str	r3, [r4, #56]	; 0x38
    bc7e:	f04f 33ff 	mov.w	r3, #4294967295
    bc82:	930b      	str	r3, [sp, #44]	; 0x2c
    bc84:	4699      	mov	r9, r3
    bc86:	2301      	movs	r3, #1
    bc88:	46b3      	mov	fp, r6
    bc8a:	9307      	str	r3, [sp, #28]
    bc8c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    bc8e:	2a00      	cmp	r2, #0
    bc90:	db55      	blt.n	bd3e <_dtoa_r+0x4a6>
    bc92:	9904      	ldr	r1, [sp, #16]
    bc94:	290e      	cmp	r1, #14
    bc96:	dc52      	bgt.n	bd3e <_dtoa_r+0x4a6>
    bc98:	4bb7      	ldr	r3, [pc, #732]	; (bf78 <_dtoa_r+0x6e0>)
    bc9a:	f1bb 0f00 	cmp.w	fp, #0
    bc9e:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    bca2:	ed93 6b00 	vldr	d6, [r3]
    bca6:	da15      	bge.n	bcd4 <_dtoa_r+0x43c>
    bca8:	f1b9 0f00 	cmp.w	r9, #0
    bcac:	dc12      	bgt.n	bcd4 <_dtoa_r+0x43c>
    bcae:	f040 82f2 	bne.w	c296 <_dtoa_r+0x9fe>
    bcb2:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    bcb6:	ee26 7b07 	vmul.f64	d7, d6, d7
    bcba:	eeb4 8bc7 	vcmpe.f64	d8, d7
    bcbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bcc2:	46ca      	mov	sl, r9
    bcc4:	464e      	mov	r6, r9
    bcc6:	f200 826d 	bhi.w	c1a4 <_dtoa_r+0x90c>
    bcca:	f8dd 8000 	ldr.w	r8, [sp]
    bcce:	ea6f 0b0b 	mvn.w	fp, fp
    bcd2:	e270      	b.n	c1b6 <_dtoa_r+0x91e>
    bcd4:	ee88 7b06 	vdiv.f64	d7, d8, d6
    bcd8:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    bcdc:	9900      	ldr	r1, [sp, #0]
    bcde:	ee17 3a10 	vmov	r3, s14
    bce2:	f1b9 0f01 	cmp.w	r9, #1
    bce6:	f103 0330 	add.w	r3, r3, #48	; 0x30
    bcea:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    bcee:	f801 3b01 	strb.w	r3, [r1], #1
    bcf2:	eea5 8b46 	vfms.f64	d8, d5, d6
    bcf6:	f000 8334 	beq.w	c362 <_dtoa_r+0xaca>
    bcfa:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    bcfe:	2301      	movs	r3, #1
    bd00:	e011      	b.n	bd26 <_dtoa_r+0x48e>
    bd02:	ee88 7b06 	vdiv.f64	d7, d8, d6
    bd06:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    bd0a:	3301      	adds	r3, #1
    bd0c:	ee17 2a10 	vmov	r2, s14
    bd10:	454b      	cmp	r3, r9
    bd12:	f102 0230 	add.w	r2, r2, #48	; 0x30
    bd16:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    bd1a:	f801 2b01 	strb.w	r2, [r1], #1
    bd1e:	eea5 8b46 	vfms.f64	d8, d5, d6
    bd22:	f000 831e 	beq.w	c362 <_dtoa_r+0xaca>
    bd26:	ee28 8b04 	vmul.f64	d8, d8, d4
    bd2a:	eeb5 8b40 	vcmp.f64	d8, #0.0
    bd2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bd32:	d1e6      	bne.n	bd02 <_dtoa_r+0x46a>
    bd34:	9b04      	ldr	r3, [sp, #16]
    bd36:	3301      	adds	r3, #1
    bd38:	9304      	str	r3, [sp, #16]
    bd3a:	4689      	mov	r9, r1
    bd3c:	e0dc      	b.n	bef8 <_dtoa_r+0x660>
    bd3e:	9b07      	ldr	r3, [sp, #28]
    bd40:	b343      	cbz	r3, bd94 <_dtoa_r+0x4fc>
    bd42:	9b01      	ldr	r3, [sp, #4]
    bd44:	2b01      	cmp	r3, #1
    bd46:	f340 8276 	ble.w	c236 <_dtoa_r+0x99e>
    bd4a:	9b08      	ldr	r3, [sp, #32]
    bd4c:	f109 3aff 	add.w	sl, r9, #4294967295
    bd50:	4553      	cmp	r3, sl
    bd52:	f280 823f 	bge.w	c1d4 <_dtoa_r+0x93c>
    bd56:	9b08      	ldr	r3, [sp, #32]
    bd58:	f8cd a020 	str.w	sl, [sp, #32]
    bd5c:	ebaa 0203 	sub.w	r2, sl, r3
    bd60:	4417      	add	r7, r2
    bd62:	f04f 0a00 	mov.w	sl, #0
    bd66:	f1b9 0f00 	cmp.w	r9, #0
    bd6a:	f2c0 8325 	blt.w	c3b8 <_dtoa_r+0xb20>
    bd6e:	9b06      	ldr	r3, [sp, #24]
    bd70:	9309      	str	r3, [sp, #36]	; 0x24
    bd72:	444b      	add	r3, r9
    bd74:	44c8      	add	r8, r9
    bd76:	9306      	str	r3, [sp, #24]
    bd78:	2101      	movs	r1, #1
    bd7a:	4620      	mov	r0, r4
    bd7c:	f7fd fa4c 	bl	9218 <__i2b>
    bd80:	4606      	mov	r6, r0
    bd82:	e00c      	b.n	bd9e <_dtoa_r+0x506>
    bd84:	4b7d      	ldr	r3, [pc, #500]	; (bf7c <_dtoa_r+0x6e4>)
    bd86:	9300      	str	r3, [sp, #0]
    bd88:	9800      	ldr	r0, [sp, #0]
    bd8a:	b00f      	add	sp, #60	; 0x3c
    bd8c:	ecbd 8b02 	vpop	{d8}
    bd90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bd94:	9b06      	ldr	r3, [sp, #24]
    bd96:	f8dd a020 	ldr.w	sl, [sp, #32]
    bd9a:	9e07      	ldr	r6, [sp, #28]
    bd9c:	9309      	str	r3, [sp, #36]	; 0x24
    bd9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bda0:	b16b      	cbz	r3, bdbe <_dtoa_r+0x526>
    bda2:	f1b8 0f00 	cmp.w	r8, #0
    bda6:	dd0a      	ble.n	bdbe <_dtoa_r+0x526>
    bda8:	4543      	cmp	r3, r8
    bdaa:	9906      	ldr	r1, [sp, #24]
    bdac:	461a      	mov	r2, r3
    bdae:	bfa8      	it	ge
    bdb0:	4642      	movge	r2, r8
    bdb2:	1a89      	subs	r1, r1, r2
    bdb4:	1a9b      	subs	r3, r3, r2
    bdb6:	9106      	str	r1, [sp, #24]
    bdb8:	9309      	str	r3, [sp, #36]	; 0x24
    bdba:	eba8 0802 	sub.w	r8, r8, r2
    bdbe:	9b08      	ldr	r3, [sp, #32]
    bdc0:	b163      	cbz	r3, bddc <_dtoa_r+0x544>
    bdc2:	9b07      	ldr	r3, [sp, #28]
    bdc4:	2b00      	cmp	r3, #0
    bdc6:	f000 82a7 	beq.w	c318 <_dtoa_r+0xa80>
    bdca:	f1ba 0f00 	cmp.w	sl, #0
    bdce:	f300 8204 	bgt.w	c1da <_dtoa_r+0x942>
    bdd2:	9b08      	ldr	r3, [sp, #32]
    bdd4:	ebb3 020a 	subs.w	r2, r3, sl
    bdd8:	f040 82ff 	bne.w	c3da <_dtoa_r+0xb42>
    bddc:	2101      	movs	r1, #1
    bdde:	4620      	mov	r0, r4
    bde0:	f7fd fa1a 	bl	9218 <__i2b>
    bde4:	2f00      	cmp	r7, #0
    bde6:	4682      	mov	sl, r0
    bde8:	f300 80af 	bgt.w	bf4a <_dtoa_r+0x6b2>
    bdec:	9b01      	ldr	r3, [sp, #4]
    bdee:	2b01      	cmp	r3, #1
    bdf0:	f340 8187 	ble.w	c102 <_dtoa_r+0x86a>
    bdf4:	2300      	movs	r3, #0
    bdf6:	9308      	str	r3, [sp, #32]
    bdf8:	2001      	movs	r0, #1
    bdfa:	2f00      	cmp	r7, #0
    bdfc:	f040 80b1 	bne.w	bf62 <_dtoa_r+0x6ca>
    be00:	4440      	add	r0, r8
    be02:	f010 001f 	ands.w	r0, r0, #31
    be06:	f000 817a 	beq.w	c0fe <_dtoa_r+0x866>
    be0a:	f1c0 0220 	rsb	r2, r0, #32
    be0e:	2a04      	cmp	r2, #4
    be10:	f300 8088 	bgt.w	bf24 <_dtoa_r+0x68c>
    be14:	f040 81f6 	bne.w	c204 <_dtoa_r+0x96c>
    be18:	9b06      	ldr	r3, [sp, #24]
    be1a:	2b00      	cmp	r3, #0
    be1c:	dd05      	ble.n	be2a <_dtoa_r+0x592>
    be1e:	4629      	mov	r1, r5
    be20:	461a      	mov	r2, r3
    be22:	4620      	mov	r0, r4
    be24:	f7fd fb34 	bl	9490 <__lshift>
    be28:	4605      	mov	r5, r0
    be2a:	f1b8 0f00 	cmp.w	r8, #0
    be2e:	dd05      	ble.n	be3c <_dtoa_r+0x5a4>
    be30:	4651      	mov	r1, sl
    be32:	4642      	mov	r2, r8
    be34:	4620      	mov	r0, r4
    be36:	f7fd fb2b 	bl	9490 <__lshift>
    be3a:	4682      	mov	sl, r0
    be3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    be3e:	2b00      	cmp	r3, #0
    be40:	f040 813f 	bne.w	c0c2 <_dtoa_r+0x82a>
    be44:	f1b9 0f00 	cmp.w	r9, #0
    be48:	f340 8125 	ble.w	c096 <_dtoa_r+0x7fe>
    be4c:	9b07      	ldr	r3, [sp, #28]
    be4e:	2b00      	cmp	r3, #0
    be50:	f040 80a3 	bne.w	bf9a <_dtoa_r+0x702>
    be54:	9b04      	ldr	r3, [sp, #16]
    be56:	3301      	adds	r3, #1
    be58:	9304      	str	r3, [sp, #16]
    be5a:	f8dd 8000 	ldr.w	r8, [sp]
    be5e:	2701      	movs	r7, #1
    be60:	e007      	b.n	be72 <_dtoa_r+0x5da>
    be62:	4629      	mov	r1, r5
    be64:	2300      	movs	r3, #0
    be66:	220a      	movs	r2, #10
    be68:	4620      	mov	r0, r4
    be6a:	f7fd f933 	bl	90d4 <__multadd>
    be6e:	3701      	adds	r7, #1
    be70:	4605      	mov	r5, r0
    be72:	4651      	mov	r1, sl
    be74:	4628      	mov	r0, r5
    be76:	f7ff fc7b 	bl	b770 <quorem>
    be7a:	45b9      	cmp	r9, r7
    be7c:	f100 0030 	add.w	r0, r0, #48	; 0x30
    be80:	f808 0b01 	strb.w	r0, [r8], #1
    be84:	dced      	bgt.n	be62 <_dtoa_r+0x5ca>
    be86:	f1b9 0f00 	cmp.w	r9, #0
    be8a:	9a00      	ldr	r2, [sp, #0]
    be8c:	bfcc      	ite	gt
    be8e:	46cb      	movgt	fp, r9
    be90:	f04f 0b01 	movle.w	fp, #1
    be94:	4603      	mov	r3, r0
    be96:	4493      	add	fp, r2
    be98:	2700      	movs	r7, #0
    be9a:	4629      	mov	r1, r5
    be9c:	2201      	movs	r2, #1
    be9e:	4620      	mov	r0, r4
    bea0:	9301      	str	r3, [sp, #4]
    bea2:	f7fd faf5 	bl	9490 <__lshift>
    bea6:	4651      	mov	r1, sl
    bea8:	4605      	mov	r5, r0
    beaa:	f7fd fb69 	bl	9580 <__mcmp>
    beae:	2800      	cmp	r0, #0
    beb0:	f340 81af 	ble.w	c212 <_dtoa_r+0x97a>
    beb4:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    beb8:	9a00      	ldr	r2, [sp, #0]
    beba:	f10b 3bff 	add.w	fp, fp, #4294967295
    bebe:	e004      	b.n	beca <_dtoa_r+0x632>
    bec0:	455a      	cmp	r2, fp
    bec2:	f000 81b1 	beq.w	c228 <_dtoa_r+0x990>
    bec6:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    beca:	2b39      	cmp	r3, #57	; 0x39
    becc:	f10b 0901 	add.w	r9, fp, #1
    bed0:	d0f6      	beq.n	bec0 <_dtoa_r+0x628>
    bed2:	3301      	adds	r3, #1
    bed4:	f88b 3000 	strb.w	r3, [fp]
    bed8:	4651      	mov	r1, sl
    beda:	4620      	mov	r0, r4
    bedc:	f7fd f8f0 	bl	90c0 <_Bfree>
    bee0:	b156      	cbz	r6, bef8 <_dtoa_r+0x660>
    bee2:	b12f      	cbz	r7, bef0 <_dtoa_r+0x658>
    bee4:	42b7      	cmp	r7, r6
    bee6:	d003      	beq.n	bef0 <_dtoa_r+0x658>
    bee8:	4639      	mov	r1, r7
    beea:	4620      	mov	r0, r4
    beec:	f7fd f8e8 	bl	90c0 <_Bfree>
    bef0:	4631      	mov	r1, r6
    bef2:	4620      	mov	r0, r4
    bef4:	f7fd f8e4 	bl	90c0 <_Bfree>
    bef8:	4629      	mov	r1, r5
    befa:	4620      	mov	r0, r4
    befc:	f7fd f8e0 	bl	90c0 <_Bfree>
    bf00:	2300      	movs	r3, #0
    bf02:	f889 3000 	strb.w	r3, [r9]
    bf06:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    bf0a:	601a      	str	r2, [r3, #0]
    bf0c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    bf0e:	2b00      	cmp	r3, #0
    bf10:	f43f acfe 	beq.w	b910 <_dtoa_r+0x78>
    bf14:	9800      	ldr	r0, [sp, #0]
    bf16:	f8c3 9000 	str.w	r9, [r3]
    bf1a:	b00f      	add	sp, #60	; 0x3c
    bf1c:	ecbd 8b02 	vpop	{d8}
    bf20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bf24:	f1c0 001c 	rsb	r0, r0, #28
    bf28:	9b06      	ldr	r3, [sp, #24]
    bf2a:	4403      	add	r3, r0
    bf2c:	9306      	str	r3, [sp, #24]
    bf2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bf30:	4403      	add	r3, r0
    bf32:	9309      	str	r3, [sp, #36]	; 0x24
    bf34:	4480      	add	r8, r0
    bf36:	e76f      	b.n	be18 <_dtoa_r+0x580>
    bf38:	f1c2 0220 	rsb	r2, r2, #32
    bf3c:	fa06 f202 	lsl.w	r2, r6, r2
    bf40:	ee07 2a10 	vmov	s14, r2
    bf44:	e509      	b.n	b95a <_dtoa_r+0xc2>
    bf46:	2601      	movs	r6, #1
    bf48:	e563      	b.n	ba12 <_dtoa_r+0x17a>
    bf4a:	4601      	mov	r1, r0
    bf4c:	463a      	mov	r2, r7
    bf4e:	4620      	mov	r0, r4
    bf50:	f7fd fa3e 	bl	93d0 <__pow5mult>
    bf54:	9b01      	ldr	r3, [sp, #4]
    bf56:	2b01      	cmp	r3, #1
    bf58:	4682      	mov	sl, r0
    bf5a:	f340 81c5 	ble.w	c2e8 <_dtoa_r+0xa50>
    bf5e:	2300      	movs	r3, #0
    bf60:	9308      	str	r3, [sp, #32]
    bf62:	f8da 2010 	ldr.w	r2, [sl, #16]
    bf66:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
    bf6a:	6910      	ldr	r0, [r2, #16]
    bf6c:	f7fd f904 	bl	9178 <__hi0bits>
    bf70:	f1c0 0020 	rsb	r0, r0, #32
    bf74:	e744      	b.n	be00 <_dtoa_r+0x568>
    bf76:	bf00      	nop
    bf78:	200002a8 	.word	0x200002a8
    bf7c:	20000524 	.word	0x20000524
    bf80:	4631      	mov	r1, r6
    bf82:	2300      	movs	r3, #0
    bf84:	220a      	movs	r2, #10
    bf86:	4620      	mov	r0, r4
    bf88:	f7fd f8a4 	bl	90d4 <__multadd>
    bf8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bf8e:	2b00      	cmp	r3, #0
    bf90:	4606      	mov	r6, r0
    bf92:	f340 82ce 	ble.w	c532 <_dtoa_r+0xc9a>
    bf96:	9704      	str	r7, [sp, #16]
    bf98:	4699      	mov	r9, r3
    bf9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bf9c:	2b00      	cmp	r3, #0
    bf9e:	dd05      	ble.n	bfac <_dtoa_r+0x714>
    bfa0:	4631      	mov	r1, r6
    bfa2:	461a      	mov	r2, r3
    bfa4:	4620      	mov	r0, r4
    bfa6:	f7fd fa73 	bl	9490 <__lshift>
    bfaa:	4606      	mov	r6, r0
    bfac:	9b08      	ldr	r3, [sp, #32]
    bfae:	2b00      	cmp	r3, #0
    bfb0:	f040 81eb 	bne.w	c38a <_dtoa_r+0xaf2>
    bfb4:	46b0      	mov	r8, r6
    bfb6:	9b02      	ldr	r3, [sp, #8]
    bfb8:	9f00      	ldr	r7, [sp, #0]
    bfba:	f003 0201 	and.w	r2, r3, #1
    bfbe:	1e7b      	subs	r3, r7, #1
    bfc0:	444b      	add	r3, r9
    bfc2:	9308      	str	r3, [sp, #32]
    bfc4:	9b01      	ldr	r3, [sp, #4]
    bfc6:	920a      	str	r2, [sp, #40]	; 0x28
    bfc8:	4313      	orrs	r3, r2
    bfca:	9309      	str	r3, [sp, #36]	; 0x24
    bfcc:	4651      	mov	r1, sl
    bfce:	4628      	mov	r0, r5
    bfd0:	f7ff fbce 	bl	b770 <quorem>
    bfd4:	4631      	mov	r1, r6
    bfd6:	4683      	mov	fp, r0
    bfd8:	4628      	mov	r0, r5
    bfda:	f7fd fad1 	bl	9580 <__mcmp>
    bfde:	4642      	mov	r2, r8
    bfe0:	4651      	mov	r1, sl
    bfe2:	4681      	mov	r9, r0
    bfe4:	4620      	mov	r0, r4
    bfe6:	f7fd faed 	bl	95c4 <__mdiff>
    bfea:	68c2      	ldr	r2, [r0, #12]
    bfec:	4601      	mov	r1, r0
    bfee:	f10b 0330 	add.w	r3, fp, #48	; 0x30
    bff2:	2a00      	cmp	r2, #0
    bff4:	d142      	bne.n	c07c <_dtoa_r+0x7e4>
    bff6:	e9cd 0306 	strd	r0, r3, [sp, #24]
    bffa:	4628      	mov	r0, r5
    bffc:	f7fd fac0 	bl	9580 <__mcmp>
    c000:	9906      	ldr	r1, [sp, #24]
    c002:	9002      	str	r0, [sp, #8]
    c004:	4620      	mov	r0, r4
    c006:	f7fd f85b 	bl	90c0 <_Bfree>
    c00a:	9a02      	ldr	r2, [sp, #8]
    c00c:	9b07      	ldr	r3, [sp, #28]
    c00e:	b91a      	cbnz	r2, c018 <_dtoa_r+0x780>
    c010:	9909      	ldr	r1, [sp, #36]	; 0x24
    c012:	2900      	cmp	r1, #0
    c014:	f000 827e 	beq.w	c514 <_dtoa_r+0xc7c>
    c018:	f1b9 0f00 	cmp.w	r9, #0
    c01c:	f2c0 8183 	blt.w	c326 <_dtoa_r+0xa8e>
    c020:	9901      	ldr	r1, [sp, #4]
    c022:	ea49 0901 	orr.w	r9, r9, r1
    c026:	990a      	ldr	r1, [sp, #40]	; 0x28
    c028:	ea51 0909 	orrs.w	r9, r1, r9
    c02c:	f000 817b 	beq.w	c326 <_dtoa_r+0xa8e>
    c030:	2a00      	cmp	r2, #0
    c032:	f300 81c6 	bgt.w	c3c2 <_dtoa_r+0xb2a>
    c036:	9a08      	ldr	r2, [sp, #32]
    c038:	703b      	strb	r3, [r7, #0]
    c03a:	f107 0901 	add.w	r9, r7, #1
    c03e:	4297      	cmp	r7, r2
    c040:	46cb      	mov	fp, r9
    c042:	f000 81c4 	beq.w	c3ce <_dtoa_r+0xb36>
    c046:	4629      	mov	r1, r5
    c048:	2300      	movs	r3, #0
    c04a:	220a      	movs	r2, #10
    c04c:	4620      	mov	r0, r4
    c04e:	f7fd f841 	bl	90d4 <__multadd>
    c052:	4546      	cmp	r6, r8
    c054:	4605      	mov	r5, r0
    c056:	4631      	mov	r1, r6
    c058:	f04f 0300 	mov.w	r3, #0
    c05c:	f04f 020a 	mov.w	r2, #10
    c060:	4620      	mov	r0, r4
    c062:	d012      	beq.n	c08a <_dtoa_r+0x7f2>
    c064:	f7fd f836 	bl	90d4 <__multadd>
    c068:	4641      	mov	r1, r8
    c06a:	4606      	mov	r6, r0
    c06c:	2300      	movs	r3, #0
    c06e:	220a      	movs	r2, #10
    c070:	4620      	mov	r0, r4
    c072:	f7fd f82f 	bl	90d4 <__multadd>
    c076:	464f      	mov	r7, r9
    c078:	4680      	mov	r8, r0
    c07a:	e7a7      	b.n	bfcc <_dtoa_r+0x734>
    c07c:	4620      	mov	r0, r4
    c07e:	9302      	str	r3, [sp, #8]
    c080:	f7fd f81e 	bl	90c0 <_Bfree>
    c084:	9b02      	ldr	r3, [sp, #8]
    c086:	2201      	movs	r2, #1
    c088:	e7c6      	b.n	c018 <_dtoa_r+0x780>
    c08a:	f7fd f823 	bl	90d4 <__multadd>
    c08e:	464f      	mov	r7, r9
    c090:	4606      	mov	r6, r0
    c092:	4680      	mov	r8, r0
    c094:	e79a      	b.n	bfcc <_dtoa_r+0x734>
    c096:	9b01      	ldr	r3, [sp, #4]
    c098:	2b02      	cmp	r3, #2
    c09a:	dc71      	bgt.n	c180 <_dtoa_r+0x8e8>
    c09c:	9b07      	ldr	r3, [sp, #28]
    c09e:	2b00      	cmp	r3, #0
    c0a0:	f47f af7b 	bne.w	bf9a <_dtoa_r+0x702>
    c0a4:	9b04      	ldr	r3, [sp, #16]
    c0a6:	4651      	mov	r1, sl
    c0a8:	3301      	adds	r3, #1
    c0aa:	4628      	mov	r0, r5
    c0ac:	9304      	str	r3, [sp, #16]
    c0ae:	f7ff fb5f 	bl	b770 <quorem>
    c0b2:	f8dd b000 	ldr.w	fp, [sp]
    c0b6:	f100 0330 	add.w	r3, r0, #48	; 0x30
    c0ba:	f80b 3b01 	strb.w	r3, [fp], #1
    c0be:	2700      	movs	r7, #0
    c0c0:	e6eb      	b.n	be9a <_dtoa_r+0x602>
    c0c2:	4651      	mov	r1, sl
    c0c4:	4628      	mov	r0, r5
    c0c6:	f7fd fa5b 	bl	9580 <__mcmp>
    c0ca:	2800      	cmp	r0, #0
    c0cc:	f6bf aeba 	bge.w	be44 <_dtoa_r+0x5ac>
    c0d0:	4629      	mov	r1, r5
    c0d2:	2300      	movs	r3, #0
    c0d4:	220a      	movs	r2, #10
    c0d6:	4620      	mov	r0, r4
    c0d8:	f7fc fffc 	bl	90d4 <__multadd>
    c0dc:	9b04      	ldr	r3, [sp, #16]
    c0de:	1e5f      	subs	r7, r3, #1
    c0e0:	9b07      	ldr	r3, [sp, #28]
    c0e2:	4605      	mov	r5, r0
    c0e4:	2b00      	cmp	r3, #0
    c0e6:	f47f af4b 	bne.w	bf80 <_dtoa_r+0x6e8>
    c0ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    c0ec:	2b00      	cmp	r3, #0
    c0ee:	f340 8218 	ble.w	c522 <_dtoa_r+0xc8a>
    c0f2:	4699      	mov	r9, r3
    c0f4:	e6b1      	b.n	be5a <_dtoa_r+0x5c2>
    c0f6:	4bbc      	ldr	r3, [pc, #752]	; (c3e8 <_dtoa_r+0xb50>)
    c0f8:	9300      	str	r3, [sp, #0]
    c0fa:	3303      	adds	r3, #3
    c0fc:	e4a4      	b.n	ba48 <_dtoa_r+0x1b0>
    c0fe:	201c      	movs	r0, #28
    c100:	e712      	b.n	bf28 <_dtoa_r+0x690>
    c102:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    c106:	2800      	cmp	r0, #0
    c108:	f47f ae74 	bne.w	bdf4 <_dtoa_r+0x55c>
    c10c:	f3c1 0213 	ubfx	r2, r1, #0, #20
    c110:	2a00      	cmp	r2, #0
    c112:	f000 80f4 	beq.w	c2fe <_dtoa_r+0xa66>
    c116:	9b02      	ldr	r3, [sp, #8]
    c118:	9308      	str	r3, [sp, #32]
    c11a:	e66d      	b.n	bdf8 <_dtoa_r+0x560>
    c11c:	2301      	movs	r3, #1
    c11e:	9307      	str	r3, [sp, #28]
    c120:	9b04      	ldr	r3, [sp, #16]
    c122:	445b      	add	r3, fp
    c124:	f103 0901 	add.w	r9, r3, #1
    c128:	f1b9 0f01 	cmp.w	r9, #1
    c12c:	46cc      	mov	ip, r9
    c12e:	930b      	str	r3, [sp, #44]	; 0x2c
    c130:	bfb8      	it	lt
    c132:	f04f 0c01 	movlt.w	ip, #1
    c136:	2100      	movs	r1, #0
    c138:	f1bc 0f17 	cmp.w	ip, #23
    c13c:	63e1      	str	r1, [r4, #60]	; 0x3c
    c13e:	f77f acbc 	ble.w	baba <_dtoa_r+0x222>
    c142:	2001      	movs	r0, #1
    c144:	2204      	movs	r2, #4
    c146:	0052      	lsls	r2, r2, #1
    c148:	f102 0314 	add.w	r3, r2, #20
    c14c:	4563      	cmp	r3, ip
    c14e:	4601      	mov	r1, r0
    c150:	f100 0001 	add.w	r0, r0, #1
    c154:	d9f7      	bls.n	c146 <_dtoa_r+0x8ae>
    c156:	63e1      	str	r1, [r4, #60]	; 0x3c
    c158:	e4af      	b.n	baba <_dtoa_r+0x222>
    c15a:	2301      	movs	r3, #1
    c15c:	9307      	str	r3, [sp, #28]
    c15e:	f1bb 0f00 	cmp.w	fp, #0
    c162:	dd52      	ble.n	c20a <_dtoa_r+0x972>
    c164:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
    c168:	46d9      	mov	r9, fp
    c16a:	46dc      	mov	ip, fp
    c16c:	e7e3      	b.n	c136 <_dtoa_r+0x89e>
    c16e:	2300      	movs	r3, #0
    c170:	9307      	str	r3, [sp, #28]
    c172:	e7d5      	b.n	c120 <_dtoa_r+0x888>
    c174:	2300      	movs	r3, #0
    c176:	9307      	str	r3, [sp, #28]
    c178:	e7f1      	b.n	c15e <_dtoa_r+0x8c6>
    c17a:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    c17e:	9704      	str	r7, [sp, #16]
    c180:	f1b9 0f00 	cmp.w	r9, #0
    c184:	f47f ada1 	bne.w	bcca <_dtoa_r+0x432>
    c188:	4651      	mov	r1, sl
    c18a:	464b      	mov	r3, r9
    c18c:	2205      	movs	r2, #5
    c18e:	4620      	mov	r0, r4
    c190:	f7fc ffa0 	bl	90d4 <__multadd>
    c194:	4601      	mov	r1, r0
    c196:	4682      	mov	sl, r0
    c198:	4628      	mov	r0, r5
    c19a:	f7fd f9f1 	bl	9580 <__mcmp>
    c19e:	2800      	cmp	r0, #0
    c1a0:	f77f ad93 	ble.w	bcca <_dtoa_r+0x432>
    c1a4:	9b04      	ldr	r3, [sp, #16]
    c1a6:	f103 0b01 	add.w	fp, r3, #1
    c1aa:	9b00      	ldr	r3, [sp, #0]
    c1ac:	2231      	movs	r2, #49	; 0x31
    c1ae:	4698      	mov	r8, r3
    c1b0:	f803 2b01 	strb.w	r2, [r3], #1
    c1b4:	9300      	str	r3, [sp, #0]
    c1b6:	4651      	mov	r1, sl
    c1b8:	4620      	mov	r0, r4
    c1ba:	f7fc ff81 	bl	90c0 <_Bfree>
    c1be:	f10b 0301 	add.w	r3, fp, #1
    c1c2:	f8dd 9000 	ldr.w	r9, [sp]
    c1c6:	9304      	str	r3, [sp, #16]
    c1c8:	f8cd 8000 	str.w	r8, [sp]
    c1cc:	2e00      	cmp	r6, #0
    c1ce:	f47f ae8f 	bne.w	bef0 <_dtoa_r+0x658>
    c1d2:	e691      	b.n	bef8 <_dtoa_r+0x660>
    c1d4:	eba3 0a0a 	sub.w	sl, r3, sl
    c1d8:	e5c5      	b.n	bd66 <_dtoa_r+0x4ce>
    c1da:	4631      	mov	r1, r6
    c1dc:	4652      	mov	r2, sl
    c1de:	4620      	mov	r0, r4
    c1e0:	f7fd f8f6 	bl	93d0 <__pow5mult>
    c1e4:	462a      	mov	r2, r5
    c1e6:	4601      	mov	r1, r0
    c1e8:	4606      	mov	r6, r0
    c1ea:	4620      	mov	r0, r4
    c1ec:	f7fd f842 	bl	9274 <__multiply>
    c1f0:	4629      	mov	r1, r5
    c1f2:	4605      	mov	r5, r0
    c1f4:	4620      	mov	r0, r4
    c1f6:	f7fc ff63 	bl	90c0 <_Bfree>
    c1fa:	e5ea      	b.n	bdd2 <_dtoa_r+0x53a>
    c1fc:	2002      	movs	r0, #2
    c1fe:	eeb0 5b48 	vmov.f64	d5, d8
    c202:	e481      	b.n	bb08 <_dtoa_r+0x270>
    c204:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    c208:	e68e      	b.n	bf28 <_dtoa_r+0x690>
    c20a:	f04f 0b01 	mov.w	fp, #1
    c20e:	46d9      	mov	r9, fp
    c210:	e44f      	b.n	bab2 <_dtoa_r+0x21a>
    c212:	d103      	bne.n	c21c <_dtoa_r+0x984>
    c214:	9b01      	ldr	r3, [sp, #4]
    c216:	07db      	lsls	r3, r3, #31
    c218:	f53f ae4c 	bmi.w	beb4 <_dtoa_r+0x61c>
    c21c:	46d9      	mov	r9, fp
    c21e:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    c222:	2b30      	cmp	r3, #48	; 0x30
    c224:	d0fa      	beq.n	c21c <_dtoa_r+0x984>
    c226:	e657      	b.n	bed8 <_dtoa_r+0x640>
    c228:	9b04      	ldr	r3, [sp, #16]
    c22a:	9a00      	ldr	r2, [sp, #0]
    c22c:	3301      	adds	r3, #1
    c22e:	9304      	str	r3, [sp, #16]
    c230:	2331      	movs	r3, #49	; 0x31
    c232:	7013      	strb	r3, [r2, #0]
    c234:	e650      	b.n	bed8 <_dtoa_r+0x640>
    c236:	f1ba 0f00 	cmp.w	sl, #0
    c23a:	f000 8123 	beq.w	c484 <_dtoa_r+0xbec>
    c23e:	f202 4233 	addw	r2, r2, #1075	; 0x433
    c242:	9b06      	ldr	r3, [sp, #24]
    c244:	9309      	str	r3, [sp, #36]	; 0x24
    c246:	4413      	add	r3, r2
    c248:	f8dd a020 	ldr.w	sl, [sp, #32]
    c24c:	9306      	str	r3, [sp, #24]
    c24e:	4490      	add	r8, r2
    c250:	e592      	b.n	bd78 <_dtoa_r+0x4e0>
    c252:	ee07 0a90 	vmov	s15, r0
    c256:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
    c25a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    c25e:	eea6 5b07 	vfma.f64	d5, d6, d7
    c262:	ee15 2a90 	vmov	r2, s11
    c266:	ec51 0b15 	vmov	r0, r1, d5
    c26a:	f1a2 7150 	sub.w	r1, r2, #54525952	; 0x3400000
    c26e:	ec41 0b15 	vmov	d5, r0, r1
    c272:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    c276:	ee36 7b47 	vsub.f64	d7, d6, d7
    c27a:	eeb4 7bc5 	vcmpe.f64	d7, d5
    c27e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c282:	f300 8137 	bgt.w	c4f4 <_dtoa_r+0xc5c>
    c286:	eeb1 5b45 	vneg.f64	d5, d5
    c28a:	eeb4 7bc5 	vcmpe.f64	d7, d5
    c28e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c292:	f57f acfb 	bpl.w	bc8c <_dtoa_r+0x3f4>
    c296:	f04f 0a00 	mov.w	sl, #0
    c29a:	4656      	mov	r6, sl
    c29c:	e515      	b.n	bcca <_dtoa_r+0x432>
    c29e:	f000 80f5 	beq.w	c48c <_dtoa_r+0xbf4>
    c2a2:	9b04      	ldr	r3, [sp, #16]
    c2a4:	4951      	ldr	r1, [pc, #324]	; (c3ec <_dtoa_r+0xb54>)
    c2a6:	425a      	negs	r2, r3
    c2a8:	f002 000f 	and.w	r0, r2, #15
    c2ac:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
    c2b0:	ed91 6b00 	vldr	d6, [r1]
    c2b4:	1112      	asrs	r2, r2, #4
    c2b6:	ee28 6b06 	vmul.f64	d6, d8, d6
    c2ba:	f000 8142 	beq.w	c542 <_dtoa_r+0xcaa>
    c2be:	eeb0 7b46 	vmov.f64	d7, d6
    c2c2:	494b      	ldr	r1, [pc, #300]	; (c3f0 <_dtoa_r+0xb58>)
    c2c4:	2600      	movs	r6, #0
    c2c6:	2002      	movs	r0, #2
    c2c8:	07d3      	lsls	r3, r2, #31
    c2ca:	d505      	bpl.n	c2d8 <_dtoa_r+0xa40>
    c2cc:	ed91 5b00 	vldr	d5, [r1]
    c2d0:	3001      	adds	r0, #1
    c2d2:	2601      	movs	r6, #1
    c2d4:	ee27 7b05 	vmul.f64	d7, d7, d5
    c2d8:	1052      	asrs	r2, r2, #1
    c2da:	f101 0108 	add.w	r1, r1, #8
    c2de:	d1f3      	bne.n	c2c8 <_dtoa_r+0xa30>
    c2e0:	2e00      	cmp	r6, #0
    c2e2:	fe06 6b07 	vseleq.f64	d6, d6, d7
    c2e6:	e41e      	b.n	bb26 <_dtoa_r+0x28e>
    c2e8:	9b02      	ldr	r3, [sp, #8]
    c2ea:	2b00      	cmp	r3, #0
    c2ec:	f47f ae37 	bne.w	bf5e <_dtoa_r+0x6c6>
    c2f0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    c2f4:	f3c1 0213 	ubfx	r2, r1, #0, #20
    c2f8:	2a00      	cmp	r2, #0
    c2fa:	f040 8137 	bne.w	c56c <_dtoa_r+0xcd4>
    c2fe:	4a3d      	ldr	r2, [pc, #244]	; (c3f4 <_dtoa_r+0xb5c>)
    c300:	400a      	ands	r2, r1
    c302:	2a00      	cmp	r2, #0
    c304:	f000 80fa 	beq.w	c4fc <_dtoa_r+0xc64>
    c308:	9b06      	ldr	r3, [sp, #24]
    c30a:	3301      	adds	r3, #1
    c30c:	9306      	str	r3, [sp, #24]
    c30e:	2301      	movs	r3, #1
    c310:	f108 0801 	add.w	r8, r8, #1
    c314:	9308      	str	r3, [sp, #32]
    c316:	e56f      	b.n	bdf8 <_dtoa_r+0x560>
    c318:	4629      	mov	r1, r5
    c31a:	9a08      	ldr	r2, [sp, #32]
    c31c:	4620      	mov	r0, r4
    c31e:	f7fd f857 	bl	93d0 <__pow5mult>
    c322:	4605      	mov	r5, r0
    c324:	e55a      	b.n	bddc <_dtoa_r+0x544>
    c326:	2a00      	cmp	r2, #0
    c328:	dd12      	ble.n	c350 <_dtoa_r+0xab8>
    c32a:	4629      	mov	r1, r5
    c32c:	2201      	movs	r2, #1
    c32e:	4620      	mov	r0, r4
    c330:	9301      	str	r3, [sp, #4]
    c332:	f7fd f8ad 	bl	9490 <__lshift>
    c336:	4651      	mov	r1, sl
    c338:	4605      	mov	r5, r0
    c33a:	f7fd f921 	bl	9580 <__mcmp>
    c33e:	2800      	cmp	r0, #0
    c340:	9b01      	ldr	r3, [sp, #4]
    c342:	f340 80e1 	ble.w	c508 <_dtoa_r+0xc70>
    c346:	2b39      	cmp	r3, #57	; 0x39
    c348:	f000 80ca 	beq.w	c4e0 <_dtoa_r+0xc48>
    c34c:	f10b 0331 	add.w	r3, fp, #49	; 0x31
    c350:	46b9      	mov	r9, r7
    c352:	f809 3b01 	strb.w	r3, [r9], #1
    c356:	9b04      	ldr	r3, [sp, #16]
    c358:	3301      	adds	r3, #1
    c35a:	4637      	mov	r7, r6
    c35c:	9304      	str	r3, [sp, #16]
    c35e:	4646      	mov	r6, r8
    c360:	e5ba      	b.n	bed8 <_dtoa_r+0x640>
    c362:	ee38 8b08 	vadd.f64	d8, d8, d8
    c366:	eeb4 8bc6 	vcmpe.f64	d8, d6
    c36a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c36e:	dc0a      	bgt.n	c386 <_dtoa_r+0xaee>
    c370:	eeb4 8b46 	vcmp.f64	d8, d6
    c374:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c378:	f47f acdc 	bne.w	bd34 <_dtoa_r+0x49c>
    c37c:	ee17 3a10 	vmov	r3, s14
    c380:	07d8      	lsls	r0, r3, #31
    c382:	f57f acd7 	bpl.w	bd34 <_dtoa_r+0x49c>
    c386:	9a00      	ldr	r2, [sp, #0]
    c388:	e454      	b.n	bc34 <_dtoa_r+0x39c>
    c38a:	6871      	ldr	r1, [r6, #4]
    c38c:	4620      	mov	r0, r4
    c38e:	f7fc fe71 	bl	9074 <_Balloc>
    c392:	4607      	mov	r7, r0
    c394:	2800      	cmp	r0, #0
    c396:	f000 80de 	beq.w	c556 <_dtoa_r+0xcbe>
    c39a:	6933      	ldr	r3, [r6, #16]
    c39c:	3302      	adds	r3, #2
    c39e:	009a      	lsls	r2, r3, #2
    c3a0:	f106 010c 	add.w	r1, r6, #12
    c3a4:	300c      	adds	r0, #12
    c3a6:	f7fa f865 	bl	6474 <memcpy>
    c3aa:	4639      	mov	r1, r7
    c3ac:	2201      	movs	r2, #1
    c3ae:	4620      	mov	r0, r4
    c3b0:	f7fd f86e 	bl	9490 <__lshift>
    c3b4:	4680      	mov	r8, r0
    c3b6:	e5fe      	b.n	bfb6 <_dtoa_r+0x71e>
    c3b8:	9b06      	ldr	r3, [sp, #24]
    c3ba:	eba3 0309 	sub.w	r3, r3, r9
    c3be:	9309      	str	r3, [sp, #36]	; 0x24
    c3c0:	e4da      	b.n	bd78 <_dtoa_r+0x4e0>
    c3c2:	2b39      	cmp	r3, #57	; 0x39
    c3c4:	f000 808c 	beq.w	c4e0 <_dtoa_r+0xc48>
    c3c8:	46b9      	mov	r9, r7
    c3ca:	3301      	adds	r3, #1
    c3cc:	e7c1      	b.n	c352 <_dtoa_r+0xaba>
    c3ce:	9a04      	ldr	r2, [sp, #16]
    c3d0:	3201      	adds	r2, #1
    c3d2:	4637      	mov	r7, r6
    c3d4:	9204      	str	r2, [sp, #16]
    c3d6:	4646      	mov	r6, r8
    c3d8:	e55f      	b.n	be9a <_dtoa_r+0x602>
    c3da:	4629      	mov	r1, r5
    c3dc:	4620      	mov	r0, r4
    c3de:	f7fc fff7 	bl	93d0 <__pow5mult>
    c3e2:	4605      	mov	r5, r0
    c3e4:	e4fa      	b.n	bddc <_dtoa_r+0x544>
    c3e6:	bf00      	nop
    c3e8:	20000abc 	.word	0x20000abc
    c3ec:	200002a8 	.word	0x200002a8
    c3f0:	20000280 	.word	0x20000280
    c3f4:	7ff00000 	.word	0x7ff00000
    c3f8:	4b5e      	ldr	r3, [pc, #376]	; (c574 <_dtoa_r+0xcdc>)
    c3fa:	eefd 5bc6 	vcvt.s32.f64	s11, d6
    c3fe:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
    c402:	ed1c 3b02 	vldr	d3, [ip, #-8]
    c406:	eeb8 7be5 	vcvt.f64.s32	d7, s11
    c40a:	ee36 7b47 	vsub.f64	d7, d6, d7
    c40e:	ec41 0b16 	vmov	d6, r0, r1
    c412:	ee15 1a90 	vmov	r1, s11
    c416:	ee23 3b06 	vmul.f64	d3, d3, d6
    c41a:	9800      	ldr	r0, [sp, #0]
    c41c:	3130      	adds	r1, #48	; 0x30
    c41e:	2a01      	cmp	r2, #1
    c420:	f800 1b01 	strb.w	r1, [r0], #1
    c424:	f000 8083 	beq.w	c52e <_dtoa_r+0xc96>
    c428:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    c42c:	9b00      	ldr	r3, [sp, #0]
    c42e:	1899      	adds	r1, r3, r2
    c430:	ee27 7b04 	vmul.f64	d7, d7, d4
    c434:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    c438:	ee16 3a90 	vmov	r3, s13
    c43c:	3330      	adds	r3, #48	; 0x30
    c43e:	f800 3b01 	strb.w	r3, [r0], #1
    c442:	4281      	cmp	r1, r0
    c444:	eeb8 5be6 	vcvt.f64.s32	d5, s13
    c448:	ee37 7b45 	vsub.f64	d7, d7, d5
    c44c:	d1f0      	bne.n	c430 <_dtoa_r+0xb98>
    c44e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    c452:	ee33 5b06 	vadd.f64	d5, d3, d6
    c456:	eeb4 5bc7 	vcmpe.f64	d5, d7
    c45a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c45e:	f53f abe3 	bmi.w	bc28 <_dtoa_r+0x390>
    c462:	ee36 6b43 	vsub.f64	d6, d6, d3
    c466:	eeb4 6bc7 	vcmpe.f64	d6, d7
    c46a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c46e:	f77f ac0d 	ble.w	bc8c <_dtoa_r+0x3f4>
    c472:	4689      	mov	r9, r1
    c474:	3901      	subs	r1, #1
    c476:	f819 3c01 	ldrb.w	r3, [r9, #-1]
    c47a:	2b30      	cmp	r3, #48	; 0x30
    c47c:	d0f9      	beq.n	c472 <_dtoa_r+0xbda>
    c47e:	1c73      	adds	r3, r6, #1
    c480:	9304      	str	r3, [sp, #16]
    c482:	e539      	b.n	bef8 <_dtoa_r+0x660>
    c484:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c486:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
    c48a:	e6da      	b.n	c242 <_dtoa_r+0x9aa>
    c48c:	2002      	movs	r0, #2
    c48e:	eeb0 6b48 	vmov.f64	d6, d8
    c492:	f7ff bb48 	b.w	bb26 <_dtoa_r+0x28e>
    c496:	f1b9 0f00 	cmp.w	r9, #0
    c49a:	f43f aeda 	beq.w	c252 <_dtoa_r+0x9ba>
    c49e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c4a0:	2a00      	cmp	r2, #0
    c4a2:	f77f abf3 	ble.w	bc8c <_dtoa_r+0x3f4>
    c4a6:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    c4aa:	ee26 6b04 	vmul.f64	d6, d6, d4
    c4ae:	3001      	adds	r0, #1
    c4b0:	ee07 0a90 	vmov	s15, r0
    c4b4:	9b04      	ldr	r3, [sp, #16]
    c4b6:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    c4ba:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    c4be:	eea6 7b05 	vfma.f64	d7, d6, d5
    c4c2:	ee17 ca90 	vmov	ip, s15
    c4c6:	ec51 0b17 	vmov	r0, r1, d7
    c4ca:	1e5e      	subs	r6, r3, #1
    c4cc:	f1ac 7150 	sub.w	r1, ip, #54525952	; 0x3400000
    c4d0:	f7ff bb47 	b.w	bb62 <_dtoa_r+0x2ca>
    c4d4:	9b04      	ldr	r3, [sp, #16]
    c4d6:	3301      	adds	r3, #1
    c4d8:	9304      	str	r3, [sp, #16]
    c4da:	2331      	movs	r3, #49	; 0x31
    c4dc:	f7ff bbb1 	b.w	bc42 <_dtoa_r+0x3aa>
    c4e0:	9b04      	ldr	r3, [sp, #16]
    c4e2:	46bb      	mov	fp, r7
    c4e4:	3301      	adds	r3, #1
    c4e6:	9304      	str	r3, [sp, #16]
    c4e8:	2339      	movs	r3, #57	; 0x39
    c4ea:	4637      	mov	r7, r6
    c4ec:	f80b 3b01 	strb.w	r3, [fp], #1
    c4f0:	4646      	mov	r6, r8
    c4f2:	e4e1      	b.n	beb8 <_dtoa_r+0x620>
    c4f4:	f04f 0a00 	mov.w	sl, #0
    c4f8:	4656      	mov	r6, sl
    c4fa:	e653      	b.n	c1a4 <_dtoa_r+0x90c>
    c4fc:	9208      	str	r2, [sp, #32]
    c4fe:	e47b      	b.n	bdf8 <_dtoa_r+0x560>
    c500:	1c73      	adds	r3, r6, #1
    c502:	9304      	str	r3, [sp, #16]
    c504:	4689      	mov	r9, r1
    c506:	e4f7      	b.n	bef8 <_dtoa_r+0x660>
    c508:	f47f af22 	bne.w	c350 <_dtoa_r+0xab8>
    c50c:	07da      	lsls	r2, r3, #31
    c50e:	f57f af1f 	bpl.w	c350 <_dtoa_r+0xab8>
    c512:	e718      	b.n	c346 <_dtoa_r+0xaae>
    c514:	2b39      	cmp	r3, #57	; 0x39
    c516:	d0e3      	beq.n	c4e0 <_dtoa_r+0xc48>
    c518:	f1b9 0f00 	cmp.w	r9, #0
    c51c:	f73f af16 	bgt.w	c34c <_dtoa_r+0xab4>
    c520:	e716      	b.n	c350 <_dtoa_r+0xab8>
    c522:	9b01      	ldr	r3, [sp, #4]
    c524:	2b02      	cmp	r3, #2
    c526:	f73f ae28 	bgt.w	c17a <_dtoa_r+0x8e2>
    c52a:	9704      	str	r7, [sp, #16]
    c52c:	e5ba      	b.n	c0a4 <_dtoa_r+0x80c>
    c52e:	4601      	mov	r1, r0
    c530:	e78d      	b.n	c44e <_dtoa_r+0xbb6>
    c532:	9b01      	ldr	r3, [sp, #4]
    c534:	2b02      	cmp	r3, #2
    c536:	f73f ae20 	bgt.w	c17a <_dtoa_r+0x8e2>
    c53a:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    c53e:	9704      	str	r7, [sp, #16]
    c540:	e52b      	b.n	bf9a <_dtoa_r+0x702>
    c542:	2002      	movs	r0, #2
    c544:	f7ff baef 	b.w	bb26 <_dtoa_r+0x28e>
    c548:	4b0b      	ldr	r3, [pc, #44]	; (c578 <_dtoa_r+0xce0>)
    c54a:	480c      	ldr	r0, [pc, #48]	; (c57c <_dtoa_r+0xce4>)
    c54c:	2200      	movs	r2, #0
    c54e:	f240 11af 	movw	r1, #431	; 0x1af
    c552:	f7ff f8b1 	bl	b6b8 <__assert_func>
    c556:	4b08      	ldr	r3, [pc, #32]	; (c578 <_dtoa_r+0xce0>)
    c558:	4808      	ldr	r0, [pc, #32]	; (c57c <_dtoa_r+0xce4>)
    c55a:	463a      	mov	r2, r7
    c55c:	f240 21ef 	movw	r1, #751	; 0x2ef
    c560:	f7ff f8aa 	bl	b6b8 <__assert_func>
    c564:	4b06      	ldr	r3, [pc, #24]	; (c580 <_dtoa_r+0xce8>)
    c566:	9300      	str	r3, [sp, #0]
    c568:	f7ff b9d2 	b.w	b910 <_dtoa_r+0x78>
    c56c:	9b02      	ldr	r3, [sp, #8]
    c56e:	9308      	str	r3, [sp, #32]
    c570:	e4f7      	b.n	bf62 <_dtoa_r+0x6ca>
    c572:	bf00      	nop
    c574:	200002a8 	.word	0x200002a8
    c578:	2000093c 	.word	0x2000093c
    c57c:	20000ac0 	.word	0x20000ac0
    c580:	20000ab0 	.word	0x20000ab0

0000c584 <_wcrtomb_r>:
    c584:	b570      	push	{r4, r5, r6, lr}
    c586:	4605      	mov	r5, r0
    c588:	b084      	sub	sp, #16
    c58a:	b15b      	cbz	r3, c5a4 <_wcrtomb_r+0x20>
    c58c:	461c      	mov	r4, r3
    c58e:	b169      	cbz	r1, c5ac <_wcrtomb_r+0x28>
    c590:	4b0e      	ldr	r3, [pc, #56]	; (c5cc <_wcrtomb_r+0x48>)
    c592:	4628      	mov	r0, r5
    c594:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
    c598:	4623      	mov	r3, r4
    c59a:	47b0      	blx	r6
    c59c:	1c43      	adds	r3, r0, #1
    c59e:	d00f      	beq.n	c5c0 <_wcrtomb_r+0x3c>
    c5a0:	b004      	add	sp, #16
    c5a2:	bd70      	pop	{r4, r5, r6, pc}
    c5a4:	f500 7482 	add.w	r4, r0, #260	; 0x104
    c5a8:	2900      	cmp	r1, #0
    c5aa:	d1f1      	bne.n	c590 <_wcrtomb_r+0xc>
    c5ac:	4a07      	ldr	r2, [pc, #28]	; (c5cc <_wcrtomb_r+0x48>)
    c5ae:	4623      	mov	r3, r4
    c5b0:	f8d2 60e0 	ldr.w	r6, [r2, #224]	; 0xe0
    c5b4:	4628      	mov	r0, r5
    c5b6:	460a      	mov	r2, r1
    c5b8:	a901      	add	r1, sp, #4
    c5ba:	47b0      	blx	r6
    c5bc:	1c43      	adds	r3, r0, #1
    c5be:	d1ef      	bne.n	c5a0 <_wcrtomb_r+0x1c>
    c5c0:	2200      	movs	r2, #0
    c5c2:	238a      	movs	r3, #138	; 0x8a
    c5c4:	6022      	str	r2, [r4, #0]
    c5c6:	602b      	str	r3, [r5, #0]
    c5c8:	b004      	add	sp, #16
    c5ca:	bd70      	pop	{r4, r5, r6, pc}
    c5cc:	200011e4 	.word	0x200011e4

0000c5d0 <_wcsrtombs_r>:
    c5d0:	b510      	push	{r4, lr}
    c5d2:	b082      	sub	sp, #8
    c5d4:	9c04      	ldr	r4, [sp, #16]
    c5d6:	e9cd 3400 	strd	r3, r4, [sp]
    c5da:	f04f 33ff 	mov.w	r3, #4294967295
    c5de:	f001 fbc7 	bl	dd70 <_wcsnrtombs_r>
    c5e2:	b002      	add	sp, #8
    c5e4:	bd10      	pop	{r4, pc}
    c5e6:	bf00      	nop

0000c5e8 <fiprintf>:
    c5e8:	b40e      	push	{r1, r2, r3}
    c5ea:	b510      	push	{r4, lr}
    c5ec:	b083      	sub	sp, #12
    c5ee:	ab05      	add	r3, sp, #20
    c5f0:	4c06      	ldr	r4, [pc, #24]	; (c60c <fiprintf+0x24>)
    c5f2:	f853 2b04 	ldr.w	r2, [r3], #4
    c5f6:	9301      	str	r3, [sp, #4]
    c5f8:	4601      	mov	r1, r0
    c5fa:	6820      	ldr	r0, [r4, #0]
    c5fc:	f000 f8c4 	bl	c788 <_vfiprintf_r>
    c600:	b003      	add	sp, #12
    c602:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c606:	b003      	add	sp, #12
    c608:	4770      	bx	lr
    c60a:	bf00      	nop
    c60c:	2000176c 	.word	0x2000176c

0000c610 <__ssprint_r>:
    c610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c614:	6893      	ldr	r3, [r2, #8]
    c616:	6817      	ldr	r7, [r2, #0]
    c618:	b083      	sub	sp, #12
    c61a:	4692      	mov	sl, r2
    c61c:	2b00      	cmp	r3, #0
    c61e:	d070      	beq.n	c702 <__ssprint_r+0xf2>
    c620:	4681      	mov	r9, r0
    c622:	688a      	ldr	r2, [r1, #8]
    c624:	6808      	ldr	r0, [r1, #0]
    c626:	460c      	mov	r4, r1
    c628:	3708      	adds	r7, #8
    c62a:	e043      	b.n	c6b4 <__ssprint_r+0xa4>
    c62c:	89a3      	ldrh	r3, [r4, #12]
    c62e:	f413 6f90 	tst.w	r3, #1152	; 0x480
    c632:	d02e      	beq.n	c692 <__ssprint_r+0x82>
    c634:	e9d4 1604 	ldrd	r1, r6, [r4, #16]
    c638:	eba0 0801 	sub.w	r8, r0, r1
    c63c:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    c640:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
    c644:	f108 0001 	add.w	r0, r8, #1
    c648:	1076      	asrs	r6, r6, #1
    c64a:	4428      	add	r0, r5
    c64c:	42b0      	cmp	r0, r6
    c64e:	4632      	mov	r2, r6
    c650:	bf84      	itt	hi
    c652:	4606      	movhi	r6, r0
    c654:	4632      	movhi	r2, r6
    c656:	055b      	lsls	r3, r3, #21
    c658:	d537      	bpl.n	c6ca <__ssprint_r+0xba>
    c65a:	4611      	mov	r1, r2
    c65c:	4648      	mov	r0, r9
    c65e:	f7fb fb4d 	bl	7cfc <_malloc_r>
    c662:	9001      	str	r0, [sp, #4]
    c664:	2800      	cmp	r0, #0
    c666:	d03a      	beq.n	c6de <__ssprint_r+0xce>
    c668:	4642      	mov	r2, r8
    c66a:	6921      	ldr	r1, [r4, #16]
    c66c:	f7f9 ff02 	bl	6474 <memcpy>
    c670:	89a2      	ldrh	r2, [r4, #12]
    c672:	9b01      	ldr	r3, [sp, #4]
    c674:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    c678:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    c67c:	81a2      	strh	r2, [r4, #12]
    c67e:	eba6 0208 	sub.w	r2, r6, r8
    c682:	eb03 0008 	add.w	r0, r3, r8
    c686:	6166      	str	r6, [r4, #20]
    c688:	60a2      	str	r2, [r4, #8]
    c68a:	6123      	str	r3, [r4, #16]
    c68c:	6020      	str	r0, [r4, #0]
    c68e:	462e      	mov	r6, r5
    c690:	46a8      	mov	r8, r5
    c692:	4642      	mov	r2, r8
    c694:	4659      	mov	r1, fp
    c696:	f7fc f969 	bl	896c <memmove>
    c69a:	f8da 3008 	ldr.w	r3, [sl, #8]
    c69e:	68a2      	ldr	r2, [r4, #8]
    c6a0:	6820      	ldr	r0, [r4, #0]
    c6a2:	1b92      	subs	r2, r2, r6
    c6a4:	4440      	add	r0, r8
    c6a6:	1b5b      	subs	r3, r3, r5
    c6a8:	60a2      	str	r2, [r4, #8]
    c6aa:	6020      	str	r0, [r4, #0]
    c6ac:	f8ca 3008 	str.w	r3, [sl, #8]
    c6b0:	b33b      	cbz	r3, c702 <__ssprint_r+0xf2>
    c6b2:	3708      	adds	r7, #8
    c6b4:	e957 b502 	ldrd	fp, r5, [r7, #-8]
    c6b8:	2d00      	cmp	r5, #0
    c6ba:	d0fa      	beq.n	c6b2 <__ssprint_r+0xa2>
    c6bc:	42aa      	cmp	r2, r5
    c6be:	4616      	mov	r6, r2
    c6c0:	4690      	mov	r8, r2
    c6c2:	d9b3      	bls.n	c62c <__ssprint_r+0x1c>
    c6c4:	462e      	mov	r6, r5
    c6c6:	46a8      	mov	r8, r5
    c6c8:	e7e3      	b.n	c692 <__ssprint_r+0x82>
    c6ca:	4648      	mov	r0, r9
    c6cc:	f7fb fdd2 	bl	8274 <_realloc_r>
    c6d0:	4603      	mov	r3, r0
    c6d2:	2800      	cmp	r0, #0
    c6d4:	d1d3      	bne.n	c67e <__ssprint_r+0x6e>
    c6d6:	6921      	ldr	r1, [r4, #16]
    c6d8:	4648      	mov	r0, r9
    c6da:	f7fc fbaf 	bl	8e3c <_free_r>
    c6de:	89a3      	ldrh	r3, [r4, #12]
    c6e0:	220c      	movs	r2, #12
    c6e2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c6e6:	f8c9 2000 	str.w	r2, [r9]
    c6ea:	f04f 30ff 	mov.w	r0, #4294967295
    c6ee:	81a3      	strh	r3, [r4, #12]
    c6f0:	2200      	movs	r2, #0
    c6f2:	2300      	movs	r3, #0
    c6f4:	f8ca 2008 	str.w	r2, [sl, #8]
    c6f8:	f8ca 3004 	str.w	r3, [sl, #4]
    c6fc:	b003      	add	sp, #12
    c6fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c702:	2000      	movs	r0, #0
    c704:	2300      	movs	r3, #0
    c706:	f8ca 3004 	str.w	r3, [sl, #4]
    c70a:	b003      	add	sp, #12
    c70c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000c710 <__sprint_r.part.0>:
    c710:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c714:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    c716:	049c      	lsls	r4, r3, #18
    c718:	4690      	mov	r8, r2
    c71a:	d52d      	bpl.n	c778 <__sprint_r.part.0+0x68>
    c71c:	6893      	ldr	r3, [r2, #8]
    c71e:	6812      	ldr	r2, [r2, #0]
    c720:	b343      	cbz	r3, c774 <__sprint_r.part.0+0x64>
    c722:	468b      	mov	fp, r1
    c724:	4606      	mov	r6, r0
    c726:	f102 0908 	add.w	r9, r2, #8
    c72a:	e959 5a02 	ldrd	r5, sl, [r9, #-8]
    c72e:	ea5f 079a 	movs.w	r7, sl, lsr #2
    c732:	d015      	beq.n	c760 <__sprint_r.part.0+0x50>
    c734:	3d04      	subs	r5, #4
    c736:	2400      	movs	r4, #0
    c738:	e001      	b.n	c73e <__sprint_r.part.0+0x2e>
    c73a:	42a7      	cmp	r7, r4
    c73c:	d00e      	beq.n	c75c <__sprint_r.part.0+0x4c>
    c73e:	f855 1f04 	ldr.w	r1, [r5, #4]!
    c742:	465a      	mov	r2, fp
    c744:	4630      	mov	r0, r6
    c746:	f001 fa5b 	bl	dc00 <_fputwc_r>
    c74a:	1c43      	adds	r3, r0, #1
    c74c:	f104 0401 	add.w	r4, r4, #1
    c750:	d1f3      	bne.n	c73a <__sprint_r.part.0+0x2a>
    c752:	2300      	movs	r3, #0
    c754:	e9c8 3301 	strd	r3, r3, [r8, #4]
    c758:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c75c:	f8d8 3008 	ldr.w	r3, [r8, #8]
    c760:	f02a 0a03 	bic.w	sl, sl, #3
    c764:	eba3 030a 	sub.w	r3, r3, sl
    c768:	f8c8 3008 	str.w	r3, [r8, #8]
    c76c:	f109 0908 	add.w	r9, r9, #8
    c770:	2b00      	cmp	r3, #0
    c772:	d1da      	bne.n	c72a <__sprint_r.part.0+0x1a>
    c774:	2000      	movs	r0, #0
    c776:	e7ec      	b.n	c752 <__sprint_r.part.0+0x42>
    c778:	f001 f80c 	bl	d794 <__sfvwrite_r>
    c77c:	2300      	movs	r3, #0
    c77e:	e9c8 3301 	strd	r3, r3, [r8, #4]
    c782:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c786:	bf00      	nop

0000c788 <_vfiprintf_r>:
    c788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c78c:	ed2d 8b02 	vpush	{d8}
    c790:	b0c5      	sub	sp, #276	; 0x114
    c792:	f10d 0a50 	add.w	sl, sp, #80	; 0x50
    c796:	4683      	mov	fp, r0
    c798:	ee08 1a10 	vmov	s16, r1
    c79c:	4616      	mov	r6, r2
    c79e:	2100      	movs	r1, #0
    c7a0:	2208      	movs	r2, #8
    c7a2:	4650      	mov	r0, sl
    c7a4:	461c      	mov	r4, r3
    c7a6:	9307      	str	r3, [sp, #28]
    c7a8:	f7fc f95c 	bl	8a64 <memset>
    c7ac:	f1bb 0f00 	cmp.w	fp, #0
    c7b0:	d004      	beq.n	c7bc <_vfiprintf_r+0x34>
    c7b2:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
    c7b6:	2b00      	cmp	r3, #0
    c7b8:	f000 86a0 	beq.w	d4fc <_vfiprintf_r+0xd74>
    c7bc:	ee18 2a10 	vmov	r2, s16
    c7c0:	6e53      	ldr	r3, [r2, #100]	; 0x64
    c7c2:	07db      	lsls	r3, r3, #31
    c7c4:	f140 8513 	bpl.w	d1ee <_vfiprintf_r+0xa66>
    c7c8:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
    c7cc:	b28a      	uxth	r2, r1
    c7ce:	0495      	lsls	r5, r2, #18
    c7d0:	d40b      	bmi.n	c7ea <_vfiprintf_r+0x62>
    c7d2:	ee18 3a10 	vmov	r3, s16
    c7d6:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
    c7da:	8199      	strh	r1, [r3, #12]
    c7dc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    c7de:	b28a      	uxth	r2, r1
    c7e0:	ee18 1a10 	vmov	r1, s16
    c7e4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    c7e8:	664b      	str	r3, [r1, #100]	; 0x64
    c7ea:	0710      	lsls	r0, r2, #28
    c7ec:	f140 8105 	bpl.w	c9fa <_vfiprintf_r+0x272>
    c7f0:	ee18 3a10 	vmov	r3, s16
    c7f4:	691b      	ldr	r3, [r3, #16]
    c7f6:	2b00      	cmp	r3, #0
    c7f8:	f000 80ff 	beq.w	c9fa <_vfiprintf_r+0x272>
    c7fc:	f002 031a 	and.w	r3, r2, #26
    c800:	2b0a      	cmp	r3, #10
    c802:	f000 810a 	beq.w	ca1a <_vfiprintf_r+0x292>
    c806:	2300      	movs	r3, #0
    c808:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
    c80c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
    c810:	aa1b      	add	r2, sp, #108	; 0x6c
    c812:	930c      	str	r3, [sp, #48]	; 0x30
    c814:	9218      	str	r2, [sp, #96]	; 0x60
    c816:	4691      	mov	r9, r2
    c818:	930b      	str	r3, [sp, #44]	; 0x2c
    c81a:	9305      	str	r3, [sp, #20]
    c81c:	46b0      	mov	r8, r6
    c81e:	4644      	mov	r4, r8
    c820:	4ba8      	ldr	r3, [pc, #672]	; (cac4 <_vfiprintf_r+0x33c>)
    c822:	f8d3 50e4 	ldr.w	r5, [r3, #228]	; 0xe4
    c826:	f7fc f9a1 	bl	8b6c <__locale_mb_cur_max>
    c82a:	4622      	mov	r2, r4
    c82c:	4603      	mov	r3, r0
    c82e:	a912      	add	r1, sp, #72	; 0x48
    c830:	f8cd a000 	str.w	sl, [sp]
    c834:	4658      	mov	r0, fp
    c836:	47a8      	blx	r5
    c838:	2800      	cmp	r0, #0
    c83a:	f000 8145 	beq.w	cac8 <_vfiprintf_r+0x340>
    c83e:	f2c0 8139 	blt.w	cab4 <_vfiprintf_r+0x32c>
    c842:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c844:	2a25      	cmp	r2, #37	; 0x25
    c846:	4603      	mov	r3, r0
    c848:	d001      	beq.n	c84e <_vfiprintf_r+0xc6>
    c84a:	441c      	add	r4, r3
    c84c:	e7e8      	b.n	c820 <_vfiprintf_r+0x98>
    c84e:	ebb4 0608 	subs.w	r6, r4, r8
    c852:	4605      	mov	r5, r0
    c854:	f040 813c 	bne.w	cad0 <_vfiprintf_r+0x348>
    c858:	2300      	movs	r3, #0
    c85a:	7861      	ldrb	r1, [r4, #1]
    c85c:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    c860:	f104 0801 	add.w	r8, r4, #1
    c864:	9306      	str	r3, [sp, #24]
    c866:	f04f 37ff 	mov.w	r7, #4294967295
    c86a:	461e      	mov	r6, r3
    c86c:	242b      	movs	r4, #43	; 0x2b
    c86e:	f108 0801 	add.w	r8, r8, #1
    c872:	f1a1 0320 	sub.w	r3, r1, #32
    c876:	2b5a      	cmp	r3, #90	; 0x5a
    c878:	f200 8178 	bhi.w	cb6c <_vfiprintf_r+0x3e4>
    c87c:	e8df f013 	tbh	[pc, r3, lsl #1]
    c880:	017602b5 	.word	0x017602b5
    c884:	02b00176 	.word	0x02b00176
    c888:	01760176 	.word	0x01760176
    c88c:	006a0176 	.word	0x006a0176
    c890:	01760176 	.word	0x01760176
    c894:	028d027d 	.word	0x028d027d
    c898:	02880176 	.word	0x02880176
    c89c:	01760297 	.word	0x01760297
    c8a0:	005b0292 	.word	0x005b0292
    c8a4:	005b005b 	.word	0x005b005b
    c8a8:	005b005b 	.word	0x005b005b
    c8ac:	005b005b 	.word	0x005b005b
    c8b0:	005b005b 	.word	0x005b005b
    c8b4:	01760176 	.word	0x01760176
    c8b8:	01760176 	.word	0x01760176
    c8bc:	01760176 	.word	0x01760176
    c8c0:	01760176 	.word	0x01760176
    c8c4:	025c0176 	.word	0x025c0176
    c8c8:	01760084 	.word	0x01760084
    c8cc:	01760176 	.word	0x01760176
    c8d0:	01760176 	.word	0x01760176
    c8d4:	01760176 	.word	0x01760176
    c8d8:	01760176 	.word	0x01760176
    c8dc:	00e80176 	.word	0x00e80176
    c8e0:	01760176 	.word	0x01760176
    c8e4:	02330176 	.word	0x02330176
    c8e8:	02da0176 	.word	0x02da0176
    c8ec:	01760176 	.word	0x01760176
    c8f0:	0176058b 	.word	0x0176058b
    c8f4:	01760176 	.word	0x01760176
    c8f8:	01760176 	.word	0x01760176
    c8fc:	01760176 	.word	0x01760176
    c900:	01760176 	.word	0x01760176
    c904:	025c0176 	.word	0x025c0176
    c908:	01760086 	.word	0x01760086
    c90c:	01760176 	.word	0x01760176
    c910:	008602cd 	.word	0x008602cd
    c914:	0176007f 	.word	0x0176007f
    c918:	017602c0 	.word	0x017602c0
    c91c:	00ea02fd 	.word	0x00ea02fd
    c920:	007f02ed 	.word	0x007f02ed
    c924:	02330176 	.word	0x02330176
    c928:	0569007c 	.word	0x0569007c
    c92c:	01760176 	.word	0x01760176
    c930:	0176056b 	.word	0x0176056b
    c934:	007c      	.short	0x007c
    c936:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    c93a:	2200      	movs	r2, #0
    c93c:	f818 1b01 	ldrb.w	r1, [r8], #1
    c940:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    c944:	eb03 0242 	add.w	r2, r3, r2, lsl #1
    c948:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    c94c:	2b09      	cmp	r3, #9
    c94e:	d9f5      	bls.n	c93c <_vfiprintf_r+0x1b4>
    c950:	9206      	str	r2, [sp, #24]
    c952:	e78e      	b.n	c872 <_vfiprintf_r+0xea>
    c954:	4658      	mov	r0, fp
    c956:	f7fe fe1f 	bl	b598 <_localeconv_r>
    c95a:	6843      	ldr	r3, [r0, #4]
    c95c:	930d      	str	r3, [sp, #52]	; 0x34
    c95e:	4618      	mov	r0, r3
    c960:	f7fc f9ae 	bl	8cc0 <strlen>
    c964:	900e      	str	r0, [sp, #56]	; 0x38
    c966:	4605      	mov	r5, r0
    c968:	4658      	mov	r0, fp
    c96a:	f7fe fe15 	bl	b598 <_localeconv_r>
    c96e:	6883      	ldr	r3, [r0, #8]
    c970:	930b      	str	r3, [sp, #44]	; 0x2c
    c972:	2d00      	cmp	r5, #0
    c974:	f040 84d6 	bne.w	d324 <_vfiprintf_r+0xb9c>
    c978:	f898 1000 	ldrb.w	r1, [r8]
    c97c:	e777      	b.n	c86e <_vfiprintf_r+0xe6>
    c97e:	f898 1000 	ldrb.w	r1, [r8]
    c982:	f046 0620 	orr.w	r6, r6, #32
    c986:	e772      	b.n	c86e <_vfiprintf_r+0xe6>
    c988:	f046 0610 	orr.w	r6, r6, #16
    c98c:	06b4      	lsls	r4, r6, #26
    c98e:	f140 818e 	bpl.w	ccae <_vfiprintf_r+0x526>
    c992:	9b07      	ldr	r3, [sp, #28]
    c994:	3307      	adds	r3, #7
    c996:	f023 0307 	bic.w	r3, r3, #7
    c99a:	461a      	mov	r2, r3
    c99c:	6859      	ldr	r1, [r3, #4]
    c99e:	f852 3b08 	ldr.w	r3, [r2], #8
    c9a2:	9207      	str	r2, [sp, #28]
    c9a4:	460a      	mov	r2, r1
    c9a6:	2900      	cmp	r1, #0
    c9a8:	f2c0 8470 	blt.w	d28c <_vfiprintf_r+0xb04>
    c9ac:	1c79      	adds	r1, r7, #1
    c9ae:	f000 85a2 	beq.w	d4f6 <_vfiprintf_r+0xd6e>
    c9b2:	f026 0180 	bic.w	r1, r6, #128	; 0x80
    c9b6:	9103      	str	r1, [sp, #12]
    c9b8:	ea53 0102 	orrs.w	r1, r3, r2
    c9bc:	f000 843f 	beq.w	d23e <_vfiprintf_r+0xab6>
    c9c0:	2b0a      	cmp	r3, #10
    c9c2:	f172 0100 	sbcs.w	r1, r2, #0
    c9c6:	f080 8541 	bcs.w	d44c <_vfiprintf_r+0xcc4>
    c9ca:	3330      	adds	r3, #48	; 0x30
    c9cc:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
    c9d0:	9e03      	ldr	r6, [sp, #12]
    c9d2:	2301      	movs	r3, #1
    c9d4:	9304      	str	r3, [sp, #16]
    c9d6:	f20d 140f 	addw	r4, sp, #271	; 0x10f
    c9da:	9b04      	ldr	r3, [sp, #16]
    c9dc:	42bb      	cmp	r3, r7
    c9de:	bfb8      	it	lt
    c9e0:	463b      	movlt	r3, r7
    c9e2:	9303      	str	r3, [sp, #12]
    c9e4:	2300      	movs	r3, #0
    c9e6:	9308      	str	r3, [sp, #32]
    c9e8:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    c9ec:	2b00      	cmp	r3, #0
    c9ee:	f000 80cb 	beq.w	cb88 <_vfiprintf_r+0x400>
    c9f2:	9b03      	ldr	r3, [sp, #12]
    c9f4:	3301      	adds	r3, #1
    c9f6:	9303      	str	r3, [sp, #12]
    c9f8:	e0c6      	b.n	cb88 <_vfiprintf_r+0x400>
    c9fa:	ee18 1a10 	vmov	r1, s16
    c9fe:	4658      	mov	r0, fp
    ca00:	ee18 5a10 	vmov	r5, s16
    ca04:	f001 f840 	bl	da88 <__swsetup_r>
    ca08:	2800      	cmp	r0, #0
    ca0a:	f040 8652 	bne.w	d6b2 <_vfiprintf_r+0xf2a>
    ca0e:	89aa      	ldrh	r2, [r5, #12]
    ca10:	f002 031a 	and.w	r3, r2, #26
    ca14:	2b0a      	cmp	r3, #10
    ca16:	f47f aef6 	bne.w	c806 <_vfiprintf_r+0x7e>
    ca1a:	ee18 1a10 	vmov	r1, s16
    ca1e:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
    ca22:	2b00      	cmp	r3, #0
    ca24:	f6ff aeef 	blt.w	c806 <_vfiprintf_r+0x7e>
    ca28:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    ca2a:	07db      	lsls	r3, r3, #31
    ca2c:	d402      	bmi.n	ca34 <_vfiprintf_r+0x2ac>
    ca2e:	0597      	lsls	r7, r2, #22
    ca30:	f140 8612 	bpl.w	d658 <_vfiprintf_r+0xed0>
    ca34:	ee18 1a10 	vmov	r1, s16
    ca38:	4623      	mov	r3, r4
    ca3a:	4632      	mov	r2, r6
    ca3c:	4658      	mov	r0, fp
    ca3e:	f000 fe69 	bl	d714 <__sbprintf>
    ca42:	9005      	str	r0, [sp, #20]
    ca44:	9805      	ldr	r0, [sp, #20]
    ca46:	b045      	add	sp, #276	; 0x114
    ca48:	ecbd 8b02 	vpop	{d8}
    ca4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ca50:	f046 0610 	orr.w	r6, r6, #16
    ca54:	f016 0220 	ands.w	r2, r6, #32
    ca58:	f000 8136 	beq.w	ccc8 <_vfiprintf_r+0x540>
    ca5c:	9b07      	ldr	r3, [sp, #28]
    ca5e:	3307      	adds	r3, #7
    ca60:	f023 0307 	bic.w	r3, r3, #7
    ca64:	4619      	mov	r1, r3
    ca66:	685a      	ldr	r2, [r3, #4]
    ca68:	f851 3b08 	ldr.w	r3, [r1], #8
    ca6c:	9107      	str	r1, [sp, #28]
    ca6e:	f426 6180 	bic.w	r1, r6, #1024	; 0x400
    ca72:	9103      	str	r1, [sp, #12]
    ca74:	2100      	movs	r1, #0
    ca76:	2000      	movs	r0, #0
    ca78:	f88d 0043 	strb.w	r0, [sp, #67]	; 0x43
    ca7c:	1c78      	adds	r0, r7, #1
    ca7e:	f000 8210 	beq.w	cea2 <_vfiprintf_r+0x71a>
    ca82:	9803      	ldr	r0, [sp, #12]
    ca84:	f020 0680 	bic.w	r6, r0, #128	; 0x80
    ca88:	ea53 0002 	orrs.w	r0, r3, r2
    ca8c:	f040 8208 	bne.w	cea0 <_vfiprintf_r+0x718>
    ca90:	2f00      	cmp	r7, #0
    ca92:	f040 8538 	bne.w	d506 <_vfiprintf_r+0xd7e>
    ca96:	2900      	cmp	r1, #0
    ca98:	f040 83d5 	bne.w	d246 <_vfiprintf_r+0xabe>
    ca9c:	9b03      	ldr	r3, [sp, #12]
    ca9e:	f013 0301 	ands.w	r3, r3, #1
    caa2:	9304      	str	r3, [sp, #16]
    caa4:	f000 8411 	beq.w	d2ca <_vfiprintf_r+0xb42>
    caa8:	2330      	movs	r3, #48	; 0x30
    caaa:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
    caae:	f20d 140f 	addw	r4, sp, #271	; 0x10f
    cab2:	e792      	b.n	c9da <_vfiprintf_r+0x252>
    cab4:	2208      	movs	r2, #8
    cab6:	2100      	movs	r1, #0
    cab8:	4650      	mov	r0, sl
    caba:	f7fb ffd3 	bl	8a64 <memset>
    cabe:	2301      	movs	r3, #1
    cac0:	441c      	add	r4, r3
    cac2:	e6ad      	b.n	c820 <_vfiprintf_r+0x98>
    cac4:	200011e4 	.word	0x200011e4
    cac8:	ebb4 0608 	subs.w	r6, r4, r8
    cacc:	4605      	mov	r5, r0
    cace:	d01b      	beq.n	cb08 <_vfiprintf_r+0x380>
    cad0:	9b19      	ldr	r3, [sp, #100]	; 0x64
    cad2:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    cad4:	3301      	adds	r3, #1
    cad6:	4432      	add	r2, r6
    cad8:	2b07      	cmp	r3, #7
    cada:	e9c9 8600 	strd	r8, r6, [r9]
    cade:	921a      	str	r2, [sp, #104]	; 0x68
    cae0:	9319      	str	r3, [sp, #100]	; 0x64
    cae2:	dd1c      	ble.n	cb1e <_vfiprintf_r+0x396>
    cae4:	2a00      	cmp	r2, #0
    cae6:	f000 83a6 	beq.w	d236 <_vfiprintf_r+0xaae>
    caea:	ee18 1a10 	vmov	r1, s16
    caee:	aa18      	add	r2, sp, #96	; 0x60
    caf0:	4658      	mov	r0, fp
    caf2:	f7ff fe0d 	bl	c710 <__sprint_r.part.0>
    caf6:	bb20      	cbnz	r0, cb42 <_vfiprintf_r+0x3ba>
    caf8:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cafc:	9b05      	ldr	r3, [sp, #20]
    cafe:	4433      	add	r3, r6
    cb00:	9305      	str	r3, [sp, #20]
    cb02:	2d00      	cmp	r5, #0
    cb04:	f47f aea8 	bne.w	c858 <_vfiprintf_r+0xd0>
    cb08:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    cb0a:	2b00      	cmp	r3, #0
    cb0c:	f040 85c1 	bne.w	d692 <_vfiprintf_r+0xf0a>
    cb10:	ee18 3a10 	vmov	r3, s16
    cb14:	2200      	movs	r2, #0
    cb16:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    cb1a:	9219      	str	r2, [sp, #100]	; 0x64
    cb1c:	e015      	b.n	cb4a <_vfiprintf_r+0x3c2>
    cb1e:	f109 0908 	add.w	r9, r9, #8
    cb22:	e7eb      	b.n	cafc <_vfiprintf_r+0x374>
    cb24:	ee18 1a10 	vmov	r1, s16
    cb28:	aa18      	add	r2, sp, #96	; 0x60
    cb2a:	4658      	mov	r0, fp
    cb2c:	f7ff fdf0 	bl	c710 <__sprint_r.part.0>
    cb30:	2800      	cmp	r0, #0
    cb32:	f000 80a6 	beq.w	cc82 <_vfiprintf_r+0x4fa>
    cb36:	9b08      	ldr	r3, [sp, #32]
    cb38:	b11b      	cbz	r3, cb42 <_vfiprintf_r+0x3ba>
    cb3a:	9908      	ldr	r1, [sp, #32]
    cb3c:	4658      	mov	r0, fp
    cb3e:	f7fc f97d 	bl	8e3c <_free_r>
    cb42:	ee18 3a10 	vmov	r3, s16
    cb46:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    cb4a:	ee18 2a10 	vmov	r2, s16
    cb4e:	6e52      	ldr	r2, [r2, #100]	; 0x64
    cb50:	f012 0f01 	tst.w	r2, #1
    cb54:	b29a      	uxth	r2, r3
    cb56:	f000 80a0 	beq.w	cc9a <_vfiprintf_r+0x512>
    cb5a:	0650      	lsls	r0, r2, #25
    cb5c:	f100 85b2 	bmi.w	d6c4 <_vfiprintf_r+0xf3c>
    cb60:	9805      	ldr	r0, [sp, #20]
    cb62:	b045      	add	sp, #276	; 0x114
    cb64:	ecbd 8b02 	vpop	{d8}
    cb68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb6c:	2900      	cmp	r1, #0
    cb6e:	d0cb      	beq.n	cb08 <_vfiprintf_r+0x380>
    cb70:	2300      	movs	r3, #0
    cb72:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    cb76:	2301      	movs	r3, #1
    cb78:	e9cd 3303 	strd	r3, r3, [sp, #12]
    cb7c:	f88d 10ac 	strb.w	r1, [sp, #172]	; 0xac
    cb80:	ac2b      	add	r4, sp, #172	; 0xac
    cb82:	2300      	movs	r3, #0
    cb84:	9308      	str	r3, [sp, #32]
    cb86:	461f      	mov	r7, r3
    cb88:	f016 0302 	ands.w	r3, r6, #2
    cb8c:	9309      	str	r3, [sp, #36]	; 0x24
    cb8e:	d002      	beq.n	cb96 <_vfiprintf_r+0x40e>
    cb90:	9b03      	ldr	r3, [sp, #12]
    cb92:	3302      	adds	r3, #2
    cb94:	9303      	str	r3, [sp, #12]
    cb96:	f016 0384 	ands.w	r3, r6, #132	; 0x84
    cb9a:	930a      	str	r3, [sp, #40]	; 0x28
    cb9c:	d105      	bne.n	cbaa <_vfiprintf_r+0x422>
    cb9e:	9b06      	ldr	r3, [sp, #24]
    cba0:	9a03      	ldr	r2, [sp, #12]
    cba2:	1a9d      	subs	r5, r3, r2
    cba4:	2d00      	cmp	r5, #0
    cba6:	f300 827b 	bgt.w	d0a0 <_vfiprintf_r+0x918>
    cbaa:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cbae:	1c41      	adds	r1, r0, #1
    cbb0:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
    cbb4:	b182      	cbz	r2, cbd8 <_vfiprintf_r+0x450>
    cbb6:	2201      	movs	r2, #1
    cbb8:	3301      	adds	r3, #1
    cbba:	f8c9 2004 	str.w	r2, [r9, #4]
    cbbe:	2907      	cmp	r1, #7
    cbc0:	f10d 0243 	add.w	r2, sp, #67	; 0x43
    cbc4:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    cbc8:	f8c9 2000 	str.w	r2, [r9]
    cbcc:	f300 824a 	bgt.w	d064 <_vfiprintf_r+0x8dc>
    cbd0:	4608      	mov	r0, r1
    cbd2:	f109 0908 	add.w	r9, r9, #8
    cbd6:	3101      	adds	r1, #1
    cbd8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    cbda:	b1e2      	cbz	r2, cc16 <_vfiprintf_r+0x48e>
    cbdc:	aa11      	add	r2, sp, #68	; 0x44
    cbde:	3302      	adds	r3, #2
    cbe0:	f8c9 2000 	str.w	r2, [r9]
    cbe4:	2907      	cmp	r1, #7
    cbe6:	f04f 0202 	mov.w	r2, #2
    cbea:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    cbee:	f8c9 2004 	str.w	r2, [r9, #4]
    cbf2:	f340 8250 	ble.w	d096 <_vfiprintf_r+0x90e>
    cbf6:	2b00      	cmp	r3, #0
    cbf8:	f000 8343 	beq.w	d282 <_vfiprintf_r+0xafa>
    cbfc:	ee18 1a10 	vmov	r1, s16
    cc00:	aa18      	add	r2, sp, #96	; 0x60
    cc02:	4658      	mov	r0, fp
    cc04:	f7ff fd84 	bl	c710 <__sprint_r.part.0>
    cc08:	2800      	cmp	r0, #0
    cc0a:	d194      	bne.n	cb36 <_vfiprintf_r+0x3ae>
    cc0c:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cc10:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cc14:	1c41      	adds	r1, r0, #1
    cc16:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    cc18:	2a80      	cmp	r2, #128	; 0x80
    cc1a:	f000 8184 	beq.w	cf26 <_vfiprintf_r+0x79e>
    cc1e:	9a04      	ldr	r2, [sp, #16]
    cc20:	1abd      	subs	r5, r7, r2
    cc22:	2d00      	cmp	r5, #0
    cc24:	f300 81d7 	bgt.w	cfd6 <_vfiprintf_r+0x84e>
    cc28:	9a04      	ldr	r2, [sp, #16]
    cc2a:	f8c9 4000 	str.w	r4, [r9]
    cc2e:	4413      	add	r3, r2
    cc30:	2907      	cmp	r1, #7
    cc32:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    cc36:	f8c9 2004 	str.w	r2, [r9, #4]
    cc3a:	f340 816e 	ble.w	cf1a <_vfiprintf_r+0x792>
    cc3e:	2b00      	cmp	r3, #0
    cc40:	f000 8275 	beq.w	d12e <_vfiprintf_r+0x9a6>
    cc44:	ee18 1a10 	vmov	r1, s16
    cc48:	aa18      	add	r2, sp, #96	; 0x60
    cc4a:	4658      	mov	r0, fp
    cc4c:	f7ff fd60 	bl	c710 <__sprint_r.part.0>
    cc50:	2800      	cmp	r0, #0
    cc52:	f47f af70 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    cc56:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    cc58:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cc5c:	0775      	lsls	r5, r6, #29
    cc5e:	d505      	bpl.n	cc6c <_vfiprintf_r+0x4e4>
    cc60:	9a06      	ldr	r2, [sp, #24]
    cc62:	9903      	ldr	r1, [sp, #12]
    cc64:	1a54      	subs	r4, r2, r1
    cc66:	2c00      	cmp	r4, #0
    cc68:	f300 826b 	bgt.w	d142 <_vfiprintf_r+0x9ba>
    cc6c:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
    cc70:	9803      	ldr	r0, [sp, #12]
    cc72:	4281      	cmp	r1, r0
    cc74:	bfac      	ite	ge
    cc76:	1852      	addge	r2, r2, r1
    cc78:	1812      	addlt	r2, r2, r0
    cc7a:	9205      	str	r2, [sp, #20]
    cc7c:	2b00      	cmp	r3, #0
    cc7e:	f47f af51 	bne.w	cb24 <_vfiprintf_r+0x39c>
    cc82:	9908      	ldr	r1, [sp, #32]
    cc84:	2300      	movs	r3, #0
    cc86:	9319      	str	r3, [sp, #100]	; 0x64
    cc88:	2900      	cmp	r1, #0
    cc8a:	f000 8149 	beq.w	cf20 <_vfiprintf_r+0x798>
    cc8e:	4658      	mov	r0, fp
    cc90:	f7fc f8d4 	bl	8e3c <_free_r>
    cc94:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cc98:	e5c1      	b.n	c81e <_vfiprintf_r+0x96>
    cc9a:	059c      	lsls	r4, r3, #22
    cc9c:	f53f af5d 	bmi.w	cb5a <_vfiprintf_r+0x3d2>
    cca0:	ee18 4a10 	vmov	r4, s16
    cca4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    cca6:	f7fb fffd 	bl	8ca4 <__retarget_lock_release_recursive>
    ccaa:	89a2      	ldrh	r2, [r4, #12]
    ccac:	e755      	b.n	cb5a <_vfiprintf_r+0x3d2>
    ccae:	06f0      	lsls	r0, r6, #27
    ccb0:	9a07      	ldr	r2, [sp, #28]
    ccb2:	f100 831f 	bmi.w	d2f4 <_vfiprintf_r+0xb6c>
    ccb6:	0671      	lsls	r1, r6, #25
    ccb8:	f140 8319 	bpl.w	d2ee <_vfiprintf_r+0xb66>
    ccbc:	f932 3b04 	ldrsh.w	r3, [r2], #4
    ccc0:	9207      	str	r2, [sp, #28]
    ccc2:	17da      	asrs	r2, r3, #31
    ccc4:	4611      	mov	r1, r2
    ccc6:	e66e      	b.n	c9a6 <_vfiprintf_r+0x21e>
    ccc8:	f016 0310 	ands.w	r3, r6, #16
    cccc:	9907      	ldr	r1, [sp, #28]
    ccce:	f040 8309 	bne.w	d2e4 <_vfiprintf_r+0xb5c>
    ccd2:	f016 0040 	ands.w	r0, r6, #64	; 0x40
    ccd6:	f000 8301 	beq.w	d2dc <_vfiprintf_r+0xb54>
    ccda:	461a      	mov	r2, r3
    ccdc:	f851 3b04 	ldr.w	r3, [r1], #4
    cce0:	9107      	str	r1, [sp, #28]
    cce2:	b29b      	uxth	r3, r3
    cce4:	e6c3      	b.n	ca6e <_vfiprintf_r+0x2e6>
    cce6:	9b07      	ldr	r3, [sp, #28]
    cce8:	461a      	mov	r2, r3
    ccea:	2300      	movs	r3, #0
    ccec:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    ccf0:	4613      	mov	r3, r2
    ccf2:	f853 4b04 	ldr.w	r4, [r3], #4
    ccf6:	9303      	str	r3, [sp, #12]
    ccf8:	2c00      	cmp	r4, #0
    ccfa:	f000 8412 	beq.w	d522 <_vfiprintf_r+0xd9a>
    ccfe:	2953      	cmp	r1, #83	; 0x53
    cd00:	f000 8365 	beq.w	d3ce <_vfiprintf_r+0xc46>
    cd04:	f016 0510 	ands.w	r5, r6, #16
    cd08:	f040 8361 	bne.w	d3ce <_vfiprintf_r+0xc46>
    cd0c:	1c7b      	adds	r3, r7, #1
    cd0e:	f000 84b3 	beq.w	d678 <_vfiprintf_r+0xef0>
    cd12:	463a      	mov	r2, r7
    cd14:	4629      	mov	r1, r5
    cd16:	4620      	mov	r0, r4
    cd18:	f7fe fc42 	bl	b5a0 <memchr>
    cd1c:	9008      	str	r0, [sp, #32]
    cd1e:	2800      	cmp	r0, #0
    cd20:	f000 849f 	beq.w	d662 <_vfiprintf_r+0xeda>
    cd24:	1b03      	subs	r3, r0, r4
    cd26:	9a03      	ldr	r2, [sp, #12]
    cd28:	9304      	str	r3, [sp, #16]
    cd2a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    cd2e:	462f      	mov	r7, r5
    cd30:	9207      	str	r2, [sp, #28]
    cd32:	9303      	str	r3, [sp, #12]
    cd34:	9508      	str	r5, [sp, #32]
    cd36:	e657      	b.n	c9e8 <_vfiprintf_r+0x260>
    cd38:	2943      	cmp	r1, #67	; 0x43
    cd3a:	d002      	beq.n	cd42 <_vfiprintf_r+0x5ba>
    cd3c:	06f5      	lsls	r5, r6, #27
    cd3e:	f140 832d 	bpl.w	d39c <_vfiprintf_r+0xc14>
    cd42:	9d07      	ldr	r5, [sp, #28]
    cd44:	2208      	movs	r2, #8
    cd46:	2100      	movs	r1, #0
    cd48:	a816      	add	r0, sp, #88	; 0x58
    cd4a:	ac2b      	add	r4, sp, #172	; 0xac
    cd4c:	f7fb fe8a 	bl	8a64 <memset>
    cd50:	ab16      	add	r3, sp, #88	; 0x58
    cd52:	f855 2b04 	ldr.w	r2, [r5], #4
    cd56:	4621      	mov	r1, r4
    cd58:	4658      	mov	r0, fp
    cd5a:	f7ff fc13 	bl	c584 <_wcrtomb_r>
    cd5e:	4603      	mov	r3, r0
    cd60:	3301      	adds	r3, #1
    cd62:	9004      	str	r0, [sp, #16]
    cd64:	f000 84b3 	beq.w	d6ce <_vfiprintf_r+0xf46>
    cd68:	9b04      	ldr	r3, [sp, #16]
    cd6a:	9507      	str	r5, [sp, #28]
    cd6c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    cd70:	9303      	str	r3, [sp, #12]
    cd72:	2300      	movs	r3, #0
    cd74:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    cd78:	e703      	b.n	cb82 <_vfiprintf_r+0x3fa>
    cd7a:	9b07      	ldr	r3, [sp, #28]
    cd7c:	f853 2b04 	ldr.w	r2, [r3], #4
    cd80:	9206      	str	r2, [sp, #24]
    cd82:	2a00      	cmp	r2, #0
    cd84:	f280 829c 	bge.w	d2c0 <_vfiprintf_r+0xb38>
    cd88:	9a06      	ldr	r2, [sp, #24]
    cd8a:	4252      	negs	r2, r2
    cd8c:	e9cd 2306 	strd	r2, r3, [sp, #24]
    cd90:	f898 1000 	ldrb.w	r1, [r8]
    cd94:	f046 0604 	orr.w	r6, r6, #4
    cd98:	e569      	b.n	c86e <_vfiprintf_r+0xe6>
    cd9a:	f898 1000 	ldrb.w	r1, [r8]
    cd9e:	f88d 4043 	strb.w	r4, [sp, #67]	; 0x43
    cda2:	e564      	b.n	c86e <_vfiprintf_r+0xe6>
    cda4:	f898 1000 	ldrb.w	r1, [r8]
    cda8:	f046 0680 	orr.w	r6, r6, #128	; 0x80
    cdac:	e55f      	b.n	c86e <_vfiprintf_r+0xe6>
    cdae:	4642      	mov	r2, r8
    cdb0:	f812 1b01 	ldrb.w	r1, [r2], #1
    cdb4:	292a      	cmp	r1, #42	; 0x2a
    cdb6:	f000 8496 	beq.w	d6e6 <_vfiprintf_r+0xf5e>
    cdba:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    cdbe:	2b09      	cmp	r3, #9
    cdc0:	4690      	mov	r8, r2
    cdc2:	f04f 0700 	mov.w	r7, #0
    cdc6:	f63f ad54 	bhi.w	c872 <_vfiprintf_r+0xea>
    cdca:	f818 1b01 	ldrb.w	r1, [r8], #1
    cdce:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    cdd2:	eb03 0747 	add.w	r7, r3, r7, lsl #1
    cdd6:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    cdda:	2b09      	cmp	r3, #9
    cddc:	d9f5      	bls.n	cdca <_vfiprintf_r+0x642>
    cdde:	e548      	b.n	c872 <_vfiprintf_r+0xea>
    cde0:	f898 1000 	ldrb.w	r1, [r8]
    cde4:	f046 0601 	orr.w	r6, r6, #1
    cde8:	e541      	b.n	c86e <_vfiprintf_r+0xe6>
    cdea:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    cdee:	2b00      	cmp	r3, #0
    cdf0:	f47f adc2 	bne.w	c978 <_vfiprintf_r+0x1f0>
    cdf4:	2320      	movs	r3, #32
    cdf6:	f898 1000 	ldrb.w	r1, [r8]
    cdfa:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    cdfe:	e536      	b.n	c86e <_vfiprintf_r+0xe6>
    ce00:	f898 1000 	ldrb.w	r1, [r8]
    ce04:	296c      	cmp	r1, #108	; 0x6c
    ce06:	bf03      	ittte	eq
    ce08:	f898 1001 	ldrbeq.w	r1, [r8, #1]
    ce0c:	f046 0620 	orreq.w	r6, r6, #32
    ce10:	f108 0801 	addeq.w	r8, r8, #1
    ce14:	f046 0610 	orrne.w	r6, r6, #16
    ce18:	e529      	b.n	c86e <_vfiprintf_r+0xe6>
    ce1a:	f898 1000 	ldrb.w	r1, [r8]
    ce1e:	2968      	cmp	r1, #104	; 0x68
    ce20:	bf03      	ittte	eq
    ce22:	f898 1001 	ldrbeq.w	r1, [r8, #1]
    ce26:	f446 7600 	orreq.w	r6, r6, #512	; 0x200
    ce2a:	f108 0801 	addeq.w	r8, r8, #1
    ce2e:	f046 0640 	orrne.w	r6, r6, #64	; 0x40
    ce32:	e51c      	b.n	c86e <_vfiprintf_r+0xe6>
    ce34:	f046 0310 	orr.w	r3, r6, #16
    ce38:	9303      	str	r3, [sp, #12]
    ce3a:	9b03      	ldr	r3, [sp, #12]
    ce3c:	f013 0220 	ands.w	r2, r3, #32
    ce40:	f000 8206 	beq.w	d250 <_vfiprintf_r+0xac8>
    ce44:	9b07      	ldr	r3, [sp, #28]
    ce46:	3307      	adds	r3, #7
    ce48:	f023 0307 	bic.w	r3, r3, #7
    ce4c:	4619      	mov	r1, r3
    ce4e:	685a      	ldr	r2, [r3, #4]
    ce50:	f851 3b08 	ldr.w	r3, [r1], #8
    ce54:	9107      	str	r1, [sp, #28]
    ce56:	2101      	movs	r1, #1
    ce58:	e60d      	b.n	ca76 <_vfiprintf_r+0x2ee>
    ce5a:	9a07      	ldr	r2, [sp, #28]
    ce5c:	f046 0302 	orr.w	r3, r6, #2
    ce60:	9303      	str	r3, [sp, #12]
    ce62:	f852 3b04 	ldr.w	r3, [r2], #4
    ce66:	9207      	str	r2, [sp, #28]
    ce68:	f647 0230 	movw	r2, #30768	; 0x7830
    ce6c:	f8ad 2044 	strh.w	r2, [sp, #68]	; 0x44
    ce70:	4ab8      	ldr	r2, [pc, #736]	; (d154 <_vfiprintf_r+0x9cc>)
    ce72:	920c      	str	r2, [sp, #48]	; 0x30
    ce74:	2102      	movs	r1, #2
    ce76:	2200      	movs	r2, #0
    ce78:	e5fd      	b.n	ca76 <_vfiprintf_r+0x2ee>
    ce7a:	06b7      	lsls	r7, r6, #26
    ce7c:	f100 8248 	bmi.w	d310 <_vfiprintf_r+0xb88>
    ce80:	06f5      	lsls	r5, r6, #27
    ce82:	f100 8346 	bmi.w	d512 <_vfiprintf_r+0xd8a>
    ce86:	0674      	lsls	r4, r6, #25
    ce88:	f100 83d5 	bmi.w	d636 <_vfiprintf_r+0xeae>
    ce8c:	05b0      	lsls	r0, r6, #22
    ce8e:	f140 8340 	bpl.w	d512 <_vfiprintf_r+0xd8a>
    ce92:	9b07      	ldr	r3, [sp, #28]
    ce94:	9905      	ldr	r1, [sp, #20]
    ce96:	f853 2b04 	ldr.w	r2, [r3], #4
    ce9a:	9307      	str	r3, [sp, #28]
    ce9c:	7011      	strb	r1, [r2, #0]
    ce9e:	e4be      	b.n	c81e <_vfiprintf_r+0x96>
    cea0:	9603      	str	r6, [sp, #12]
    cea2:	2901      	cmp	r1, #1
    cea4:	f43f ad8c 	beq.w	c9c0 <_vfiprintf_r+0x238>
    cea8:	2902      	cmp	r1, #2
    ceaa:	ac44      	add	r4, sp, #272	; 0x110
    ceac:	d111      	bne.n	ced2 <_vfiprintf_r+0x74a>
    ceae:	980c      	ldr	r0, [sp, #48]	; 0x30
    ceb0:	f003 010f 	and.w	r1, r3, #15
    ceb4:	091b      	lsrs	r3, r3, #4
    ceb6:	5c41      	ldrb	r1, [r0, r1]
    ceb8:	f804 1d01 	strb.w	r1, [r4, #-1]!
    cebc:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
    cec0:	0912      	lsrs	r2, r2, #4
    cec2:	ea53 0102 	orrs.w	r1, r3, r2
    cec6:	d1f3      	bne.n	ceb0 <_vfiprintf_r+0x728>
    cec8:	9e03      	ldr	r6, [sp, #12]
    ceca:	ab44      	add	r3, sp, #272	; 0x110
    cecc:	1b1b      	subs	r3, r3, r4
    cece:	9304      	str	r3, [sp, #16]
    ced0:	e583      	b.n	c9da <_vfiprintf_r+0x252>
    ced2:	f003 0107 	and.w	r1, r3, #7
    ced6:	08db      	lsrs	r3, r3, #3
    ced8:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
    cedc:	08d2      	lsrs	r2, r2, #3
    cede:	3130      	adds	r1, #48	; 0x30
    cee0:	ea53 0502 	orrs.w	r5, r3, r2
    cee4:	4620      	mov	r0, r4
    cee6:	f804 1d01 	strb.w	r1, [r4, #-1]!
    ceea:	d1f2      	bne.n	ced2 <_vfiprintf_r+0x74a>
    ceec:	9e03      	ldr	r6, [sp, #12]
    ceee:	07f3      	lsls	r3, r6, #31
    cef0:	d5eb      	bpl.n	ceca <_vfiprintf_r+0x742>
    cef2:	2930      	cmp	r1, #48	; 0x30
    cef4:	d0e8      	beq.n	cec8 <_vfiprintf_r+0x740>
    cef6:	2330      	movs	r3, #48	; 0x30
    cef8:	3802      	subs	r0, #2
    cefa:	f804 3c01 	strb.w	r3, [r4, #-1]
    cefe:	ab44      	add	r3, sp, #272	; 0x110
    cf00:	1a1b      	subs	r3, r3, r0
    cf02:	9e03      	ldr	r6, [sp, #12]
    cf04:	9304      	str	r3, [sp, #16]
    cf06:	4604      	mov	r4, r0
    cf08:	e567      	b.n	c9da <_vfiprintf_r+0x252>
    cf0a:	9b04      	ldr	r3, [sp, #16]
    cf0c:	941b      	str	r4, [sp, #108]	; 0x6c
    cf0e:	2201      	movs	r2, #1
    cf10:	931c      	str	r3, [sp, #112]	; 0x70
    cf12:	931a      	str	r3, [sp, #104]	; 0x68
    cf14:	9219      	str	r2, [sp, #100]	; 0x64
    cf16:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cf1a:	f109 0908 	add.w	r9, r9, #8
    cf1e:	e69d      	b.n	cc5c <_vfiprintf_r+0x4d4>
    cf20:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cf24:	e47b      	b.n	c81e <_vfiprintf_r+0x96>
    cf26:	9a06      	ldr	r2, [sp, #24]
    cf28:	9d03      	ldr	r5, [sp, #12]
    cf2a:	1b55      	subs	r5, r2, r5
    cf2c:	2d00      	cmp	r5, #0
    cf2e:	f77f ae76 	ble.w	cc1e <_vfiprintf_r+0x496>
    cf32:	2d10      	cmp	r5, #16
    cf34:	f340 83bb 	ble.w	d6ae <_vfiprintf_r+0xf26>
    cf38:	9409      	str	r4, [sp, #36]	; 0x24
    cf3a:	ee18 4a10 	vmov	r4, s16
    cf3e:	e007      	b.n	cf50 <_vfiprintf_r+0x7c8>
    cf40:	f100 0c02 	add.w	ip, r0, #2
    cf44:	f109 0908 	add.w	r9, r9, #8
    cf48:	4610      	mov	r0, r2
    cf4a:	3d10      	subs	r5, #16
    cf4c:	2d10      	cmp	r5, #16
    cf4e:	dd1e      	ble.n	cf8e <_vfiprintf_r+0x806>
    cf50:	4981      	ldr	r1, [pc, #516]	; (d158 <_vfiprintf_r+0x9d0>)
    cf52:	f8c9 1000 	str.w	r1, [r9]
    cf56:	1c42      	adds	r2, r0, #1
    cf58:	3310      	adds	r3, #16
    cf5a:	2110      	movs	r1, #16
    cf5c:	2a07      	cmp	r2, #7
    cf5e:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    cf62:	f8c9 1004 	str.w	r1, [r9, #4]
    cf66:	ddeb      	ble.n	cf40 <_vfiprintf_r+0x7b8>
    cf68:	aa18      	add	r2, sp, #96	; 0x60
    cf6a:	2b00      	cmp	r3, #0
    cf6c:	d074      	beq.n	d058 <_vfiprintf_r+0x8d0>
    cf6e:	4621      	mov	r1, r4
    cf70:	4658      	mov	r0, fp
    cf72:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cf76:	f7ff fbcb 	bl	c710 <__sprint_r.part.0>
    cf7a:	2800      	cmp	r0, #0
    cf7c:	f47f addb 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    cf80:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cf84:	3d10      	subs	r5, #16
    cf86:	2d10      	cmp	r5, #16
    cf88:	f100 0c01 	add.w	ip, r0, #1
    cf8c:	dce0      	bgt.n	cf50 <_vfiprintf_r+0x7c8>
    cf8e:	9c09      	ldr	r4, [sp, #36]	; 0x24
    cf90:	4a71      	ldr	r2, [pc, #452]	; (d158 <_vfiprintf_r+0x9d0>)
    cf92:	f8c9 5004 	str.w	r5, [r9, #4]
    cf96:	442b      	add	r3, r5
    cf98:	f1bc 0f07 	cmp.w	ip, #7
    cf9c:	e9cd c319 	strd	ip, r3, [sp, #100]	; 0x64
    cfa0:	f8c9 2000 	str.w	r2, [r9]
    cfa4:	f340 8194 	ble.w	d2d0 <_vfiprintf_r+0xb48>
    cfa8:	2b00      	cmp	r3, #0
    cfaa:	f000 831f 	beq.w	d5ec <_vfiprintf_r+0xe64>
    cfae:	ee18 1a10 	vmov	r1, s16
    cfb2:	aa18      	add	r2, sp, #96	; 0x60
    cfb4:	4658      	mov	r0, fp
    cfb6:	f7ff fbab 	bl	c710 <__sprint_r.part.0>
    cfba:	2800      	cmp	r0, #0
    cfbc:	f47f adbb 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    cfc0:	9a04      	ldr	r2, [sp, #16]
    cfc2:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    cfc6:	1abd      	subs	r5, r7, r2
    cfc8:	2d00      	cmp	r5, #0
    cfca:	f100 0101 	add.w	r1, r0, #1
    cfce:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    cfd2:	f77f ae29 	ble.w	cc28 <_vfiprintf_r+0x4a0>
    cfd6:	2d10      	cmp	r5, #16
    cfd8:	dd29      	ble.n	d02e <_vfiprintf_r+0x8a6>
    cfda:	9409      	str	r4, [sp, #36]	; 0x24
    cfdc:	2710      	movs	r7, #16
    cfde:	ee18 4a10 	vmov	r4, s16
    cfe2:	e007      	b.n	cff4 <_vfiprintf_r+0x86c>
    cfe4:	f100 0c02 	add.w	ip, r0, #2
    cfe8:	f109 0908 	add.w	r9, r9, #8
    cfec:	4610      	mov	r0, r2
    cfee:	3d10      	subs	r5, #16
    cff0:	2d10      	cmp	r5, #16
    cff2:	dd1a      	ble.n	d02a <_vfiprintf_r+0x8a2>
    cff4:	1c42      	adds	r2, r0, #1
    cff6:	4958      	ldr	r1, [pc, #352]	; (d158 <_vfiprintf_r+0x9d0>)
    cff8:	3310      	adds	r3, #16
    cffa:	2a07      	cmp	r2, #7
    cffc:	e9c9 1700 	strd	r1, r7, [r9]
    d000:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    d004:	ddee      	ble.n	cfe4 <_vfiprintf_r+0x85c>
    d006:	aa18      	add	r2, sp, #96	; 0x60
    d008:	b303      	cbz	r3, d04c <_vfiprintf_r+0x8c4>
    d00a:	4621      	mov	r1, r4
    d00c:	4658      	mov	r0, fp
    d00e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d012:	f7ff fb7d 	bl	c710 <__sprint_r.part.0>
    d016:	2800      	cmp	r0, #0
    d018:	f47f ad8d 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d01c:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    d020:	3d10      	subs	r5, #16
    d022:	2d10      	cmp	r5, #16
    d024:	f100 0c01 	add.w	ip, r0, #1
    d028:	dce4      	bgt.n	cff4 <_vfiprintf_r+0x86c>
    d02a:	9c09      	ldr	r4, [sp, #36]	; 0x24
    d02c:	4661      	mov	r1, ip
    d02e:	4a4a      	ldr	r2, [pc, #296]	; (d158 <_vfiprintf_r+0x9d0>)
    d030:	f8c9 5004 	str.w	r5, [r9, #4]
    d034:	442b      	add	r3, r5
    d036:	2907      	cmp	r1, #7
    d038:	e9cd 1319 	strd	r1, r3, [sp, #100]	; 0x64
    d03c:	f8c9 2000 	str.w	r2, [r9]
    d040:	f300 80e7 	bgt.w	d212 <_vfiprintf_r+0xa8a>
    d044:	f109 0908 	add.w	r9, r9, #8
    d048:	3101      	adds	r1, #1
    d04a:	e5ed      	b.n	cc28 <_vfiprintf_r+0x4a0>
    d04c:	f04f 0c01 	mov.w	ip, #1
    d050:	4618      	mov	r0, r3
    d052:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d056:	e7ca      	b.n	cfee <_vfiprintf_r+0x866>
    d058:	f04f 0c01 	mov.w	ip, #1
    d05c:	4618      	mov	r0, r3
    d05e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d062:	e772      	b.n	cf4a <_vfiprintf_r+0x7c2>
    d064:	2b00      	cmp	r3, #0
    d066:	f000 8104 	beq.w	d272 <_vfiprintf_r+0xaea>
    d06a:	ee18 1a10 	vmov	r1, s16
    d06e:	aa18      	add	r2, sp, #96	; 0x60
    d070:	4658      	mov	r0, fp
    d072:	f7ff fb4d 	bl	c710 <__sprint_r.part.0>
    d076:	2800      	cmp	r0, #0
    d078:	f47f ad5d 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d07c:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    d080:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d084:	1c41      	adds	r1, r0, #1
    d086:	e5a7      	b.n	cbd8 <_vfiprintf_r+0x450>
    d088:	2302      	movs	r3, #2
    d08a:	aa11      	add	r2, sp, #68	; 0x44
    d08c:	931c      	str	r3, [sp, #112]	; 0x70
    d08e:	921b      	str	r2, [sp, #108]	; 0x6c
    d090:	2101      	movs	r1, #1
    d092:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d096:	4608      	mov	r0, r1
    d098:	f109 0908 	add.w	r9, r9, #8
    d09c:	1c41      	adds	r1, r0, #1
    d09e:	e5ba      	b.n	cc16 <_vfiprintf_r+0x48e>
    d0a0:	2d10      	cmp	r5, #16
    d0a2:	f340 82e5 	ble.w	d670 <_vfiprintf_r+0xee8>
    d0a6:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
    d0aa:	940f      	str	r4, [sp, #60]	; 0x3c
    d0ac:	4608      	mov	r0, r1
    d0ae:	ee18 4a10 	vmov	r4, s16
    d0b2:	e007      	b.n	d0c4 <_vfiprintf_r+0x93c>
    d0b4:	f100 0c02 	add.w	ip, r0, #2
    d0b8:	f109 0908 	add.w	r9, r9, #8
    d0bc:	4610      	mov	r0, r2
    d0be:	3d10      	subs	r5, #16
    d0c0:	2d10      	cmp	r5, #16
    d0c2:	dd1d      	ble.n	d100 <_vfiprintf_r+0x978>
    d0c4:	4925      	ldr	r1, [pc, #148]	; (d15c <_vfiprintf_r+0x9d4>)
    d0c6:	f8c9 1000 	str.w	r1, [r9]
    d0ca:	1c42      	adds	r2, r0, #1
    d0cc:	3310      	adds	r3, #16
    d0ce:	2110      	movs	r1, #16
    d0d0:	2a07      	cmp	r2, #7
    d0d2:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    d0d6:	f8c9 1004 	str.w	r1, [r9, #4]
    d0da:	ddeb      	ble.n	d0b4 <_vfiprintf_r+0x92c>
    d0dc:	aa18      	add	r2, sp, #96	; 0x60
    d0de:	b303      	cbz	r3, d122 <_vfiprintf_r+0x99a>
    d0e0:	4621      	mov	r1, r4
    d0e2:	4658      	mov	r0, fp
    d0e4:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d0e8:	f7ff fb12 	bl	c710 <__sprint_r.part.0>
    d0ec:	2800      	cmp	r0, #0
    d0ee:	f47f ad22 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d0f2:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    d0f6:	3d10      	subs	r5, #16
    d0f8:	2d10      	cmp	r5, #16
    d0fa:	f100 0c01 	add.w	ip, r0, #1
    d0fe:	dce1      	bgt.n	d0c4 <_vfiprintf_r+0x93c>
    d100:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    d102:	4660      	mov	r0, ip
    d104:	4a15      	ldr	r2, [pc, #84]	; (d15c <_vfiprintf_r+0x9d4>)
    d106:	f8c9 5004 	str.w	r5, [r9, #4]
    d10a:	442b      	add	r3, r5
    d10c:	2807      	cmp	r0, #7
    d10e:	e9cd 0319 	strd	r0, r3, [sp, #100]	; 0x64
    d112:	f8c9 2000 	str.w	r2, [r9]
    d116:	f300 80c1 	bgt.w	d29c <_vfiprintf_r+0xb14>
    d11a:	f109 0908 	add.w	r9, r9, #8
    d11e:	1c41      	adds	r1, r0, #1
    d120:	e546      	b.n	cbb0 <_vfiprintf_r+0x428>
    d122:	4618      	mov	r0, r3
    d124:	f04f 0c01 	mov.w	ip, #1
    d128:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d12c:	e7c7      	b.n	d0be <_vfiprintf_r+0x936>
    d12e:	0776      	lsls	r6, r6, #29
    d130:	9319      	str	r3, [sp, #100]	; 0x64
    d132:	d553      	bpl.n	d1dc <_vfiprintf_r+0xa54>
    d134:	9a06      	ldr	r2, [sp, #24]
    d136:	9903      	ldr	r1, [sp, #12]
    d138:	1a54      	subs	r4, r2, r1
    d13a:	2c00      	cmp	r4, #0
    d13c:	dd4e      	ble.n	d1dc <_vfiprintf_r+0xa54>
    d13e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d142:	2c10      	cmp	r4, #16
    d144:	f340 82b0 	ble.w	d6a8 <_vfiprintf_r+0xf20>
    d148:	9919      	ldr	r1, [sp, #100]	; 0x64
    d14a:	ee18 6a10 	vmov	r6, s16
    d14e:	2510      	movs	r5, #16
    d150:	e00d      	b.n	d16e <_vfiprintf_r+0x9e6>
    d152:	bf00      	nop
    d154:	20000b2c 	.word	0x20000b2c
    d158:	20000fd8 	.word	0x20000fd8
    d15c:	20000b6c 	.word	0x20000b6c
    d160:	1c88      	adds	r0, r1, #2
    d162:	f109 0908 	add.w	r9, r9, #8
    d166:	4611      	mov	r1, r2
    d168:	3c10      	subs	r4, #16
    d16a:	2c10      	cmp	r4, #16
    d16c:	dd1a      	ble.n	d1a4 <_vfiprintf_r+0xa1c>
    d16e:	1c4a      	adds	r2, r1, #1
    d170:	48b3      	ldr	r0, [pc, #716]	; (d440 <_vfiprintf_r+0xcb8>)
    d172:	3310      	adds	r3, #16
    d174:	2a07      	cmp	r2, #7
    d176:	e9c9 0500 	strd	r0, r5, [r9]
    d17a:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    d17e:	ddef      	ble.n	d160 <_vfiprintf_r+0x9d8>
    d180:	aa18      	add	r2, sp, #96	; 0x60
    d182:	b333      	cbz	r3, d1d2 <_vfiprintf_r+0xa4a>
    d184:	4631      	mov	r1, r6
    d186:	4658      	mov	r0, fp
    d188:	f7ff fac2 	bl	c710 <__sprint_r.part.0>
    d18c:	2800      	cmp	r0, #0
    d18e:	f47f acd2 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d192:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
    d196:	3c10      	subs	r4, #16
    d198:	2c10      	cmp	r4, #16
    d19a:	f101 0001 	add.w	r0, r1, #1
    d19e:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d1a2:	dce4      	bgt.n	d16e <_vfiprintf_r+0x9e6>
    d1a4:	4aa6      	ldr	r2, [pc, #664]	; (d440 <_vfiprintf_r+0xcb8>)
    d1a6:	f8c9 4004 	str.w	r4, [r9, #4]
    d1aa:	4423      	add	r3, r4
    d1ac:	2807      	cmp	r0, #7
    d1ae:	e9cd 0319 	strd	r0, r3, [sp, #100]	; 0x64
    d1b2:	f8c9 2000 	str.w	r2, [r9]
    d1b6:	f77f ad59 	ble.w	cc6c <_vfiprintf_r+0x4e4>
    d1ba:	b17b      	cbz	r3, d1dc <_vfiprintf_r+0xa54>
    d1bc:	ee18 1a10 	vmov	r1, s16
    d1c0:	aa18      	add	r2, sp, #96	; 0x60
    d1c2:	4658      	mov	r0, fp
    d1c4:	f7ff faa4 	bl	c710 <__sprint_r.part.0>
    d1c8:	2800      	cmp	r0, #0
    d1ca:	f47f acb4 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d1ce:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d1d0:	e54c      	b.n	cc6c <_vfiprintf_r+0x4e4>
    d1d2:	2001      	movs	r0, #1
    d1d4:	4619      	mov	r1, r3
    d1d6:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d1da:	e7c5      	b.n	d168 <_vfiprintf_r+0x9e0>
    d1dc:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
    d1e0:	9903      	ldr	r1, [sp, #12]
    d1e2:	428a      	cmp	r2, r1
    d1e4:	bfac      	ite	ge
    d1e6:	189b      	addge	r3, r3, r2
    d1e8:	185b      	addlt	r3, r3, r1
    d1ea:	9305      	str	r3, [sp, #20]
    d1ec:	e549      	b.n	cc82 <_vfiprintf_r+0x4fa>
    d1ee:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
    d1f2:	058f      	lsls	r7, r1, #22
    d1f4:	ee18 3a10 	vmov	r3, s16
    d1f8:	b28a      	uxth	r2, r1
    d1fa:	f53f aae8 	bmi.w	c7ce <_vfiprintf_r+0x46>
    d1fe:	ee18 5a10 	vmov	r5, s16
    d202:	6d98      	ldr	r0, [r3, #88]	; 0x58
    d204:	f7fb fd4c 	bl	8ca0 <__retarget_lock_acquire_recursive>
    d208:	f9b5 100c 	ldrsh.w	r1, [r5, #12]
    d20c:	b28a      	uxth	r2, r1
    d20e:	f7ff bade 	b.w	c7ce <_vfiprintf_r+0x46>
    d212:	2b00      	cmp	r3, #0
    d214:	f43f ae79 	beq.w	cf0a <_vfiprintf_r+0x782>
    d218:	ee18 1a10 	vmov	r1, s16
    d21c:	aa18      	add	r2, sp, #96	; 0x60
    d21e:	4658      	mov	r0, fp
    d220:	f7ff fa76 	bl	c710 <__sprint_r.part.0>
    d224:	2800      	cmp	r0, #0
    d226:	f47f ac86 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d22a:	9919      	ldr	r1, [sp, #100]	; 0x64
    d22c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d22e:	3101      	adds	r1, #1
    d230:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d234:	e4f8      	b.n	cc28 <_vfiprintf_r+0x4a0>
    d236:	9219      	str	r2, [sp, #100]	; 0x64
    d238:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d23c:	e45e      	b.n	cafc <_vfiprintf_r+0x374>
    d23e:	2f00      	cmp	r7, #0
    d240:	f47f abc3 	bne.w	c9ca <_vfiprintf_r+0x242>
    d244:	9e03      	ldr	r6, [sp, #12]
    d246:	2700      	movs	r7, #0
    d248:	9704      	str	r7, [sp, #16]
    d24a:	ac44      	add	r4, sp, #272	; 0x110
    d24c:	f7ff bbc5 	b.w	c9da <_vfiprintf_r+0x252>
    d250:	9b03      	ldr	r3, [sp, #12]
    d252:	f013 0310 	ands.w	r3, r3, #16
    d256:	d154      	bne.n	d302 <_vfiprintf_r+0xb7a>
    d258:	9a03      	ldr	r2, [sp, #12]
    d25a:	f012 0040 	ands.w	r0, r2, #64	; 0x40
    d25e:	f000 816b 	beq.w	d538 <_vfiprintf_r+0xdb0>
    d262:	9907      	ldr	r1, [sp, #28]
    d264:	461a      	mov	r2, r3
    d266:	f851 3b04 	ldr.w	r3, [r1], #4
    d26a:	9107      	str	r1, [sp, #28]
    d26c:	b29b      	uxth	r3, r3
    d26e:	2101      	movs	r1, #1
    d270:	e401      	b.n	ca76 <_vfiprintf_r+0x2ee>
    d272:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d274:	2a00      	cmp	r2, #0
    d276:	d164      	bne.n	d342 <_vfiprintf_r+0xbba>
    d278:	4618      	mov	r0, r3
    d27a:	2101      	movs	r1, #1
    d27c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d280:	e4c9      	b.n	cc16 <_vfiprintf_r+0x48e>
    d282:	2101      	movs	r1, #1
    d284:	4618      	mov	r0, r3
    d286:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d28a:	e4c4      	b.n	cc16 <_vfiprintf_r+0x48e>
    d28c:	425b      	negs	r3, r3
    d28e:	eb62 0242 	sbc.w	r2, r2, r2, lsl #1
    d292:	9603      	str	r6, [sp, #12]
    d294:	202d      	movs	r0, #45	; 0x2d
    d296:	2101      	movs	r1, #1
    d298:	f7ff bbee 	b.w	ca78 <_vfiprintf_r+0x2f0>
    d29c:	2b00      	cmp	r3, #0
    d29e:	f000 8088 	beq.w	d3b2 <_vfiprintf_r+0xc2a>
    d2a2:	ee18 1a10 	vmov	r1, s16
    d2a6:	aa18      	add	r2, sp, #96	; 0x60
    d2a8:	4658      	mov	r0, fp
    d2aa:	f7ff fa31 	bl	c710 <__sprint_r.part.0>
    d2ae:	2800      	cmp	r0, #0
    d2b0:	f47f ac41 	bne.w	cb36 <_vfiprintf_r+0x3ae>
    d2b4:	e9dd 0319 	ldrd	r0, r3, [sp, #100]	; 0x64
    d2b8:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d2bc:	1c41      	adds	r1, r0, #1
    d2be:	e477      	b.n	cbb0 <_vfiprintf_r+0x428>
    d2c0:	f898 1000 	ldrb.w	r1, [r8]
    d2c4:	9307      	str	r3, [sp, #28]
    d2c6:	f7ff bad2 	b.w	c86e <_vfiprintf_r+0xe6>
    d2ca:	ac44      	add	r4, sp, #272	; 0x110
    d2cc:	f7ff bb85 	b.w	c9da <_vfiprintf_r+0x252>
    d2d0:	f109 0908 	add.w	r9, r9, #8
    d2d4:	f10c 0101 	add.w	r1, ip, #1
    d2d8:	4660      	mov	r0, ip
    d2da:	e4a0      	b.n	cc1e <_vfiprintf_r+0x496>
    d2dc:	f416 7200 	ands.w	r2, r6, #512	; 0x200
    d2e0:	f040 8197 	bne.w	d612 <_vfiprintf_r+0xe8a>
    d2e4:	f851 3b04 	ldr.w	r3, [r1], #4
    d2e8:	9107      	str	r1, [sp, #28]
    d2ea:	f7ff bbc0 	b.w	ca6e <_vfiprintf_r+0x2e6>
    d2ee:	05b3      	lsls	r3, r6, #22
    d2f0:	f100 8188 	bmi.w	d604 <_vfiprintf_r+0xe7c>
    d2f4:	f852 3b04 	ldr.w	r3, [r2], #4
    d2f8:	9207      	str	r2, [sp, #28]
    d2fa:	17da      	asrs	r2, r3, #31
    d2fc:	4611      	mov	r1, r2
    d2fe:	f7ff bb52 	b.w	c9a6 <_vfiprintf_r+0x21e>
    d302:	9907      	ldr	r1, [sp, #28]
    d304:	f851 3b04 	ldr.w	r3, [r1], #4
    d308:	9107      	str	r1, [sp, #28]
    d30a:	2101      	movs	r1, #1
    d30c:	f7ff bbb3 	b.w	ca76 <_vfiprintf_r+0x2ee>
    d310:	9b07      	ldr	r3, [sp, #28]
    d312:	9805      	ldr	r0, [sp, #20]
    d314:	f853 1b04 	ldr.w	r1, [r3], #4
    d318:	9307      	str	r3, [sp, #28]
    d31a:	17c2      	asrs	r2, r0, #31
    d31c:	e9c1 0200 	strd	r0, r2, [r1]
    d320:	f7ff ba7d 	b.w	c81e <_vfiprintf_r+0x96>
    d324:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d326:	2b00      	cmp	r3, #0
    d328:	f43f ab26 	beq.w	c978 <_vfiprintf_r+0x1f0>
    d32c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d32e:	781b      	ldrb	r3, [r3, #0]
    d330:	2b00      	cmp	r3, #0
    d332:	f43f ab21 	beq.w	c978 <_vfiprintf_r+0x1f0>
    d336:	f898 1000 	ldrb.w	r1, [r8]
    d33a:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
    d33e:	f7ff ba96 	b.w	c86e <_vfiprintf_r+0xe6>
    d342:	2302      	movs	r3, #2
    d344:	aa11      	add	r2, sp, #68	; 0x44
    d346:	931c      	str	r3, [sp, #112]	; 0x70
    d348:	921b      	str	r2, [sp, #108]	; 0x6c
    d34a:	2001      	movs	r0, #1
    d34c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d350:	e6a2      	b.n	d098 <_vfiprintf_r+0x910>
    d352:	9603      	str	r6, [sp, #12]
    d354:	e571      	b.n	ce3a <_vfiprintf_r+0x6b2>
    d356:	4b3b      	ldr	r3, [pc, #236]	; (d444 <_vfiprintf_r+0xcbc>)
    d358:	930c      	str	r3, [sp, #48]	; 0x30
    d35a:	f016 0220 	ands.w	r2, r6, #32
    d35e:	d059      	beq.n	d414 <_vfiprintf_r+0xc8c>
    d360:	9b07      	ldr	r3, [sp, #28]
    d362:	3307      	adds	r3, #7
    d364:	f023 0307 	bic.w	r3, r3, #7
    d368:	4618      	mov	r0, r3
    d36a:	685a      	ldr	r2, [r3, #4]
    d36c:	f850 3b08 	ldr.w	r3, [r0], #8
    d370:	9007      	str	r0, [sp, #28]
    d372:	07f4      	lsls	r4, r6, #31
    d374:	d509      	bpl.n	d38a <_vfiprintf_r+0xc02>
    d376:	ea53 0002 	orrs.w	r0, r3, r2
    d37a:	d006      	beq.n	d38a <_vfiprintf_r+0xc02>
    d37c:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
    d380:	2130      	movs	r1, #48	; 0x30
    d382:	f046 0602 	orr.w	r6, r6, #2
    d386:	f88d 1044 	strb.w	r1, [sp, #68]	; 0x44
    d38a:	f426 6180 	bic.w	r1, r6, #1024	; 0x400
    d38e:	9103      	str	r1, [sp, #12]
    d390:	2102      	movs	r1, #2
    d392:	f7ff bb70 	b.w	ca76 <_vfiprintf_r+0x2ee>
    d396:	4b2c      	ldr	r3, [pc, #176]	; (d448 <_vfiprintf_r+0xcc0>)
    d398:	930c      	str	r3, [sp, #48]	; 0x30
    d39a:	e7de      	b.n	d35a <_vfiprintf_r+0xbd2>
    d39c:	9b07      	ldr	r3, [sp, #28]
    d39e:	2101      	movs	r1, #1
    d3a0:	f853 2b04 	ldr.w	r2, [r3], #4
    d3a4:	9103      	str	r1, [sp, #12]
    d3a6:	f88d 20ac 	strb.w	r2, [sp, #172]	; 0xac
    d3aa:	9307      	str	r3, [sp, #28]
    d3ac:	9104      	str	r1, [sp, #16]
    d3ae:	ac2b      	add	r4, sp, #172	; 0xac
    d3b0:	e4df      	b.n	cd72 <_vfiprintf_r+0x5ea>
    d3b2:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
    d3b6:	2a00      	cmp	r2, #0
    d3b8:	f040 8132 	bne.w	d620 <_vfiprintf_r+0xe98>
    d3bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d3be:	2a00      	cmp	r2, #0
    d3c0:	f47f ae62 	bne.w	d088 <_vfiprintf_r+0x900>
    d3c4:	4618      	mov	r0, r3
    d3c6:	2101      	movs	r1, #1
    d3c8:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d3cc:	e427      	b.n	cc1e <_vfiprintf_r+0x496>
    d3ce:	2100      	movs	r1, #0
    d3d0:	2208      	movs	r2, #8
    d3d2:	a816      	add	r0, sp, #88	; 0x58
    d3d4:	9413      	str	r4, [sp, #76]	; 0x4c
    d3d6:	f7fb fb45 	bl	8a64 <memset>
    d3da:	1c79      	adds	r1, r7, #1
    d3dc:	f000 80bc 	beq.w	d558 <_vfiprintf_r+0xdd0>
    d3e0:	2500      	movs	r5, #0
    d3e2:	9407      	str	r4, [sp, #28]
    d3e4:	462c      	mov	r4, r5
    d3e6:	e00c      	b.n	d402 <_vfiprintf_r+0xc7a>
    d3e8:	a92b      	add	r1, sp, #172	; 0xac
    d3ea:	4658      	mov	r0, fp
    d3ec:	f7ff f8ca 	bl	c584 <_wcrtomb_r>
    d3f0:	1c42      	adds	r2, r0, #1
    d3f2:	4420      	add	r0, r4
    d3f4:	f000 816b 	beq.w	d6ce <_vfiprintf_r+0xf46>
    d3f8:	42b8      	cmp	r0, r7
    d3fa:	dc08      	bgt.n	d40e <_vfiprintf_r+0xc86>
    d3fc:	f000 8170 	beq.w	d6e0 <_vfiprintf_r+0xf58>
    d400:	4604      	mov	r4, r0
    d402:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    d404:	5952      	ldr	r2, [r2, r5]
    d406:	ab16      	add	r3, sp, #88	; 0x58
    d408:	3504      	adds	r5, #4
    d40a:	2a00      	cmp	r2, #0
    d40c:	d1ec      	bne.n	d3e8 <_vfiprintf_r+0xc60>
    d40e:	9404      	str	r4, [sp, #16]
    d410:	9c07      	ldr	r4, [sp, #28]
    d412:	e0af      	b.n	d574 <_vfiprintf_r+0xdec>
    d414:	f016 0310 	ands.w	r3, r6, #16
    d418:	9807      	ldr	r0, [sp, #28]
    d41a:	d10c      	bne.n	d436 <_vfiprintf_r+0xcae>
    d41c:	f016 0440 	ands.w	r4, r6, #64	; 0x40
    d420:	d005      	beq.n	d42e <_vfiprintf_r+0xca6>
    d422:	461a      	mov	r2, r3
    d424:	f850 3b04 	ldr.w	r3, [r0], #4
    d428:	9007      	str	r0, [sp, #28]
    d42a:	b29b      	uxth	r3, r3
    d42c:	e7a1      	b.n	d372 <_vfiprintf_r+0xbea>
    d42e:	f416 7200 	ands.w	r2, r6, #512	; 0x200
    d432:	f040 80e1 	bne.w	d5f8 <_vfiprintf_r+0xe70>
    d436:	f850 3b04 	ldr.w	r3, [r0], #4
    d43a:	9007      	str	r0, [sp, #28]
    d43c:	e799      	b.n	d372 <_vfiprintf_r+0xbea>
    d43e:	bf00      	nop
    d440:	20000b6c 	.word	0x20000b6c
    d444:	20000b2c 	.word	0x20000b2c
    d448:	20000b40 	.word	0x20000b40
    d44c:	9903      	ldr	r1, [sp, #12]
    d44e:	9704      	str	r7, [sp, #16]
    d450:	ac44      	add	r4, sp, #272	; 0x110
    d452:	469e      	mov	lr, r3
    d454:	ee08 ba90 	vmov	s17, fp
    d458:	f401 6680 	and.w	r6, r1, #1024	; 0x400
    d45c:	f04f 0c00 	mov.w	ip, #0
    d460:	4623      	mov	r3, r4
    d462:	e006      	b.n	d472 <_vfiprintf_r+0xcea>
    d464:	f1be 0f0a 	cmp.w	lr, #10
    d468:	f172 0200 	sbcs.w	r2, r2, #0
    d46c:	d339      	bcc.n	d4e2 <_vfiprintf_r+0xd5a>
    d46e:	46a6      	mov	lr, r4
    d470:	462a      	mov	r2, r5
    d472:	49a6      	ldr	r1, [pc, #664]	; (d70c <_vfiprintf_r+0xf84>)
    d474:	eb1e 0002 	adds.w	r0, lr, r2
    d478:	f140 0000 	adc.w	r0, r0, #0
    d47c:	460f      	mov	r7, r1
    d47e:	fba1 1400 	umull	r1, r4, r1, r0
    d482:	f024 0103 	bic.w	r1, r4, #3
    d486:	eb01 0194 	add.w	r1, r1, r4, lsr #2
    d48a:	1a40      	subs	r0, r0, r1
    d48c:	ebbe 0100 	subs.w	r1, lr, r0
    d490:	f04f 35cc 	mov.w	r5, #3435973836	; 0xcccccccc
    d494:	f162 0400 	sbc.w	r4, r2, #0
    d498:	fb05 f501 	mul.w	r5, r5, r1
    d49c:	fb07 5504 	mla	r5, r7, r4, r5
    d4a0:	fba1 4107 	umull	r4, r1, r1, r7
    d4a4:	440d      	add	r5, r1
    d4a6:	2705      	movs	r7, #5
    d4a8:	f004 0101 	and.w	r1, r4, #1
    d4ac:	fba1 1b07 	umull	r1, fp, r1, r7
    d4b0:	1809      	adds	r1, r1, r0
    d4b2:	0864      	lsrs	r4, r4, #1
    d4b4:	3130      	adds	r1, #48	; 0x30
    d4b6:	f803 1c01 	strb.w	r1, [r3, #-1]
    d4ba:	ea44 74c5 	orr.w	r4, r4, r5, lsl #31
    d4be:	f10c 0c01 	add.w	ip, ip, #1
    d4c2:	3b01      	subs	r3, #1
    d4c4:	086d      	lsrs	r5, r5, #1
    d4c6:	2e00      	cmp	r6, #0
    d4c8:	d0cc      	beq.n	d464 <_vfiprintf_r+0xcdc>
    d4ca:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d4cc:	7809      	ldrb	r1, [r1, #0]
    d4ce:	4561      	cmp	r1, ip
    d4d0:	d1c8      	bne.n	d464 <_vfiprintf_r+0xcdc>
    d4d2:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    d4d6:	d0c5      	beq.n	d464 <_vfiprintf_r+0xcdc>
    d4d8:	f1be 0f0a 	cmp.w	lr, #10
    d4dc:	f172 0200 	sbcs.w	r2, r2, #0
    d4e0:	d26c      	bcs.n	d5bc <_vfiprintf_r+0xe34>
    d4e2:	461c      	mov	r4, r3
    d4e4:	ab44      	add	r3, sp, #272	; 0x110
    d4e6:	1b1b      	subs	r3, r3, r4
    d4e8:	9f04      	ldr	r7, [sp, #16]
    d4ea:	9e03      	ldr	r6, [sp, #12]
    d4ec:	9304      	str	r3, [sp, #16]
    d4ee:	ee18 ba90 	vmov	fp, s17
    d4f2:	f7ff ba72 	b.w	c9da <_vfiprintf_r+0x252>
    d4f6:	9603      	str	r6, [sp, #12]
    d4f8:	f7ff ba62 	b.w	c9c0 <_vfiprintf_r+0x238>
    d4fc:	4658      	mov	r0, fp
    d4fe:	f7fb f93b 	bl	8778 <__sinit>
    d502:	f7ff b95b 	b.w	c7bc <_vfiprintf_r+0x34>
    d506:	2901      	cmp	r1, #1
    d508:	9603      	str	r6, [sp, #12]
    d50a:	f47f accd 	bne.w	cea8 <_vfiprintf_r+0x720>
    d50e:	f7ff ba5c 	b.w	c9ca <_vfiprintf_r+0x242>
    d512:	9b07      	ldr	r3, [sp, #28]
    d514:	9905      	ldr	r1, [sp, #20]
    d516:	f853 2b04 	ldr.w	r2, [r3], #4
    d51a:	6011      	str	r1, [r2, #0]
    d51c:	9307      	str	r3, [sp, #28]
    d51e:	f7ff b97e 	b.w	c81e <_vfiprintf_r+0x96>
    d522:	2f06      	cmp	r7, #6
    d524:	463b      	mov	r3, r7
    d526:	9a03      	ldr	r2, [sp, #12]
    d528:	4c79      	ldr	r4, [pc, #484]	; (d710 <_vfiprintf_r+0xf88>)
    d52a:	9207      	str	r2, [sp, #28]
    d52c:	bf28      	it	cs
    d52e:	2306      	movcs	r3, #6
    d530:	9304      	str	r3, [sp, #16]
    d532:	9303      	str	r3, [sp, #12]
    d534:	f7ff bb25 	b.w	cb82 <_vfiprintf_r+0x3fa>
    d538:	9b03      	ldr	r3, [sp, #12]
    d53a:	9907      	ldr	r1, [sp, #28]
    d53c:	f413 7200 	ands.w	r2, r3, #512	; 0x200
    d540:	bf14      	ite	ne
    d542:	f851 3b04 	ldrne.w	r3, [r1], #4
    d546:	f851 3b04 	ldreq.w	r3, [r1], #4
    d54a:	9107      	str	r1, [sp, #28]
    d54c:	bf1c      	itt	ne
    d54e:	4602      	movne	r2, r0
    d550:	b2db      	uxtbne	r3, r3
    d552:	2101      	movs	r1, #1
    d554:	f7ff ba8f 	b.w	ca76 <_vfiprintf_r+0x2ee>
    d558:	ab16      	add	r3, sp, #88	; 0x58
    d55a:	9300      	str	r3, [sp, #0]
    d55c:	2300      	movs	r3, #0
    d55e:	4619      	mov	r1, r3
    d560:	aa13      	add	r2, sp, #76	; 0x4c
    d562:	4658      	mov	r0, fp
    d564:	f7ff f834 	bl	c5d0 <_wcsrtombs_r>
    d568:	4603      	mov	r3, r0
    d56a:	3301      	adds	r3, #1
    d56c:	9004      	str	r0, [sp, #16]
    d56e:	f000 80ae 	beq.w	d6ce <_vfiprintf_r+0xf46>
    d572:	9413      	str	r4, [sp, #76]	; 0x4c
    d574:	9b04      	ldr	r3, [sp, #16]
    d576:	2b00      	cmp	r3, #0
    d578:	d030      	beq.n	d5dc <_vfiprintf_r+0xe54>
    d57a:	2b63      	cmp	r3, #99	; 0x63
    d57c:	dc63      	bgt.n	d646 <_vfiprintf_r+0xebe>
    d57e:	2300      	movs	r3, #0
    d580:	9308      	str	r3, [sp, #32]
    d582:	ac2b      	add	r4, sp, #172	; 0xac
    d584:	2208      	movs	r2, #8
    d586:	2100      	movs	r1, #0
    d588:	a816      	add	r0, sp, #88	; 0x58
    d58a:	f7fb fa6b 	bl	8a64 <memset>
    d58e:	9d04      	ldr	r5, [sp, #16]
    d590:	ab16      	add	r3, sp, #88	; 0x58
    d592:	9300      	str	r3, [sp, #0]
    d594:	aa13      	add	r2, sp, #76	; 0x4c
    d596:	462b      	mov	r3, r5
    d598:	4621      	mov	r1, r4
    d59a:	4658      	mov	r0, fp
    d59c:	f7ff f818 	bl	c5d0 <_wcsrtombs_r>
    d5a0:	4285      	cmp	r5, r0
    d5a2:	f040 80ab 	bne.w	d6fc <_vfiprintf_r+0xf74>
    d5a6:	9b03      	ldr	r3, [sp, #12]
    d5a8:	9a04      	ldr	r2, [sp, #16]
    d5aa:	9307      	str	r3, [sp, #28]
    d5ac:	2300      	movs	r3, #0
    d5ae:	54a3      	strb	r3, [r4, r2]
    d5b0:	461f      	mov	r7, r3
    d5b2:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    d5b6:	9303      	str	r3, [sp, #12]
    d5b8:	f7ff ba16 	b.w	c9e8 <_vfiprintf_r+0x260>
    d5bc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    d5be:	990d      	ldr	r1, [sp, #52]	; 0x34
    d5c0:	1a9b      	subs	r3, r3, r2
    d5c2:	4618      	mov	r0, r3
    d5c4:	9308      	str	r3, [sp, #32]
    d5c6:	f7fb fa9f 	bl	8b08 <strncpy>
    d5ca:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d5cc:	9b08      	ldr	r3, [sp, #32]
    d5ce:	784a      	ldrb	r2, [r1, #1]
    d5d0:	b10a      	cbz	r2, d5d6 <_vfiprintf_r+0xe4e>
    d5d2:	3101      	adds	r1, #1
    d5d4:	910b      	str	r1, [sp, #44]	; 0x2c
    d5d6:	f04f 0c00 	mov.w	ip, #0
    d5da:	e748      	b.n	d46e <_vfiprintf_r+0xce6>
    d5dc:	9b03      	ldr	r3, [sp, #12]
    d5de:	9307      	str	r3, [sp, #28]
    d5e0:	9b04      	ldr	r3, [sp, #16]
    d5e2:	9303      	str	r3, [sp, #12]
    d5e4:	461f      	mov	r7, r3
    d5e6:	9308      	str	r3, [sp, #32]
    d5e8:	f7ff b9fe 	b.w	c9e8 <_vfiprintf_r+0x260>
    d5ec:	2101      	movs	r1, #1
    d5ee:	4618      	mov	r0, r3
    d5f0:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d5f4:	f7ff bb13 	b.w	cc1e <_vfiprintf_r+0x496>
    d5f8:	f850 3b04 	ldr.w	r3, [r0], #4
    d5fc:	9007      	str	r0, [sp, #28]
    d5fe:	4622      	mov	r2, r4
    d600:	b2db      	uxtb	r3, r3
    d602:	e6b6      	b.n	d372 <_vfiprintf_r+0xbea>
    d604:	f912 3b04 	ldrsb.w	r3, [r2], #4
    d608:	9207      	str	r2, [sp, #28]
    d60a:	17da      	asrs	r2, r3, #31
    d60c:	4611      	mov	r1, r2
    d60e:	f7ff b9ca 	b.w	c9a6 <_vfiprintf_r+0x21e>
    d612:	f851 3b04 	ldr.w	r3, [r1], #4
    d616:	9107      	str	r1, [sp, #28]
    d618:	4602      	mov	r2, r0
    d61a:	b2db      	uxtb	r3, r3
    d61c:	f7ff ba27 	b.w	ca6e <_vfiprintf_r+0x2e6>
    d620:	2301      	movs	r3, #1
    d622:	931c      	str	r3, [sp, #112]	; 0x70
    d624:	2101      	movs	r1, #1
    d626:	f10d 0343 	add.w	r3, sp, #67	; 0x43
    d62a:	931b      	str	r3, [sp, #108]	; 0x6c
    d62c:	f10d 096c 	add.w	r9, sp, #108	; 0x6c
    d630:	460b      	mov	r3, r1
    d632:	f7ff bacd 	b.w	cbd0 <_vfiprintf_r+0x448>
    d636:	9b07      	ldr	r3, [sp, #28]
    d638:	9905      	ldr	r1, [sp, #20]
    d63a:	f853 2b04 	ldr.w	r2, [r3], #4
    d63e:	9307      	str	r3, [sp, #28]
    d640:	8011      	strh	r1, [r2, #0]
    d642:	f7ff b8ec 	b.w	c81e <_vfiprintf_r+0x96>
    d646:	1c59      	adds	r1, r3, #1
    d648:	4658      	mov	r0, fp
    d64a:	f7fa fb57 	bl	7cfc <_malloc_r>
    d64e:	4604      	mov	r4, r0
    d650:	2800      	cmp	r0, #0
    d652:	d03c      	beq.n	d6ce <_vfiprintf_r+0xf46>
    d654:	9008      	str	r0, [sp, #32]
    d656:	e795      	b.n	d584 <_vfiprintf_r+0xdfc>
    d658:	6d88      	ldr	r0, [r1, #88]	; 0x58
    d65a:	f7fb fb23 	bl	8ca4 <__retarget_lock_release_recursive>
    d65e:	f7ff b9e9 	b.w	ca34 <_vfiprintf_r+0x2ac>
    d662:	9b03      	ldr	r3, [sp, #12]
    d664:	9307      	str	r3, [sp, #28]
    d666:	e9cd 7703 	strd	r7, r7, [sp, #12]
    d66a:	9f08      	ldr	r7, [sp, #32]
    d66c:	f7ff b9bc 	b.w	c9e8 <_vfiprintf_r+0x260>
    d670:	9819      	ldr	r0, [sp, #100]	; 0x64
    d672:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d674:	3001      	adds	r0, #1
    d676:	e545      	b.n	d104 <_vfiprintf_r+0x97c>
    d678:	9b03      	ldr	r3, [sp, #12]
    d67a:	9307      	str	r3, [sp, #28]
    d67c:	4620      	mov	r0, r4
    d67e:	f7fb fb1f 	bl	8cc0 <strlen>
    d682:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
    d686:	462f      	mov	r7, r5
    d688:	9004      	str	r0, [sp, #16]
    d68a:	9303      	str	r3, [sp, #12]
    d68c:	9508      	str	r5, [sp, #32]
    d68e:	f7ff b9ab 	b.w	c9e8 <_vfiprintf_r+0x260>
    d692:	ee18 1a10 	vmov	r1, s16
    d696:	aa18      	add	r2, sp, #96	; 0x60
    d698:	4658      	mov	r0, fp
    d69a:	f7ff f839 	bl	c710 <__sprint_r.part.0>
    d69e:	2800      	cmp	r0, #0
    d6a0:	f43f aa36 	beq.w	cb10 <_vfiprintf_r+0x388>
    d6a4:	f7ff ba4d 	b.w	cb42 <_vfiprintf_r+0x3ba>
    d6a8:	9819      	ldr	r0, [sp, #100]	; 0x64
    d6aa:	3001      	adds	r0, #1
    d6ac:	e57a      	b.n	d1a4 <_vfiprintf_r+0xa1c>
    d6ae:	468c      	mov	ip, r1
    d6b0:	e46e      	b.n	cf90 <_vfiprintf_r+0x808>
    d6b2:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    d6b4:	07d9      	lsls	r1, r3, #31
    d6b6:	d405      	bmi.n	d6c4 <_vfiprintf_r+0xf3c>
    d6b8:	89ab      	ldrh	r3, [r5, #12]
    d6ba:	059a      	lsls	r2, r3, #22
    d6bc:	d402      	bmi.n	d6c4 <_vfiprintf_r+0xf3c>
    d6be:	6da8      	ldr	r0, [r5, #88]	; 0x58
    d6c0:	f7fb faf0 	bl	8ca4 <__retarget_lock_release_recursive>
    d6c4:	f04f 33ff 	mov.w	r3, #4294967295
    d6c8:	9305      	str	r3, [sp, #20]
    d6ca:	f7ff ba49 	b.w	cb60 <_vfiprintf_r+0x3d8>
    d6ce:	ee18 2a10 	vmov	r2, s16
    d6d2:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
    d6d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d6da:	8193      	strh	r3, [r2, #12]
    d6dc:	f7ff ba35 	b.w	cb4a <_vfiprintf_r+0x3c2>
    d6e0:	9c07      	ldr	r4, [sp, #28]
    d6e2:	9704      	str	r7, [sp, #16]
    d6e4:	e746      	b.n	d574 <_vfiprintf_r+0xdec>
    d6e6:	9b07      	ldr	r3, [sp, #28]
    d6e8:	f898 1001 	ldrb.w	r1, [r8, #1]
    d6ec:	f853 7b04 	ldr.w	r7, [r3], #4
    d6f0:	9307      	str	r3, [sp, #28]
    d6f2:	4690      	mov	r8, r2
    d6f4:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
    d6f8:	f7ff b8b9 	b.w	c86e <_vfiprintf_r+0xe6>
    d6fc:	ee18 2a10 	vmov	r2, s16
    d700:	8993      	ldrh	r3, [r2, #12]
    d702:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d706:	8193      	strh	r3, [r2, #12]
    d708:	f7ff ba15 	b.w	cb36 <_vfiprintf_r+0x3ae>
    d70c:	cccccccd 	.word	0xcccccccd
    d710:	20000b54 	.word	0x20000b54

0000d714 <__sbprintf>:
    d714:	b570      	push	{r4, r5, r6, lr}
    d716:	460c      	mov	r4, r1
    d718:	8989      	ldrh	r1, [r1, #12]
    d71a:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
    d71e:	f021 0102 	bic.w	r1, r1, #2
    d722:	f8ad 1014 	strh.w	r1, [sp, #20]
    d726:	6e61      	ldr	r1, [r4, #100]	; 0x64
    d728:	911b      	str	r1, [sp, #108]	; 0x6c
    d72a:	89e1      	ldrh	r1, [r4, #14]
    d72c:	f8ad 1016 	strh.w	r1, [sp, #22]
    d730:	69e1      	ldr	r1, [r4, #28]
    d732:	9109      	str	r1, [sp, #36]	; 0x24
    d734:	6a61      	ldr	r1, [r4, #36]	; 0x24
    d736:	910b      	str	r1, [sp, #44]	; 0x2c
    d738:	a91c      	add	r1, sp, #112	; 0x70
    d73a:	9102      	str	r1, [sp, #8]
    d73c:	9106      	str	r1, [sp, #24]
    d73e:	f44f 6180 	mov.w	r1, #1024	; 0x400
    d742:	4606      	mov	r6, r0
    d744:	9104      	str	r1, [sp, #16]
    d746:	9107      	str	r1, [sp, #28]
    d748:	a818      	add	r0, sp, #96	; 0x60
    d74a:	2100      	movs	r1, #0
    d74c:	e9cd 3200 	strd	r3, r2, [sp]
    d750:	9108      	str	r1, [sp, #32]
    d752:	f7fb faa1 	bl	8c98 <__retarget_lock_init_recursive>
    d756:	e9dd 3200 	ldrd	r3, r2, [sp]
    d75a:	a902      	add	r1, sp, #8
    d75c:	4630      	mov	r0, r6
    d75e:	f7ff f813 	bl	c788 <_vfiprintf_r>
    d762:	1e05      	subs	r5, r0, #0
    d764:	db07      	blt.n	d776 <__sbprintf+0x62>
    d766:	a902      	add	r1, sp, #8
    d768:	4630      	mov	r0, r6
    d76a:	f7fd feeb 	bl	b544 <_fflush_r>
    d76e:	2800      	cmp	r0, #0
    d770:	bf18      	it	ne
    d772:	f04f 35ff 	movne.w	r5, #4294967295
    d776:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    d77a:	065b      	lsls	r3, r3, #25
    d77c:	d503      	bpl.n	d786 <__sbprintf+0x72>
    d77e:	89a3      	ldrh	r3, [r4, #12]
    d780:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d784:	81a3      	strh	r3, [r4, #12]
    d786:	9818      	ldr	r0, [sp, #96]	; 0x60
    d788:	f7fb fa88 	bl	8c9c <__retarget_lock_close_recursive>
    d78c:	4628      	mov	r0, r5
    d78e:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
    d792:	bd70      	pop	{r4, r5, r6, pc}

0000d794 <__sfvwrite_r>:
    d794:	6893      	ldr	r3, [r2, #8]
    d796:	2b00      	cmp	r3, #0
    d798:	f000 8085 	beq.w	d8a6 <__sfvwrite_r+0x112>
    d79c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d7a0:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
    d7a4:	460c      	mov	r4, r1
    d7a6:	0719      	lsls	r1, r3, #28
    d7a8:	4680      	mov	r8, r0
    d7aa:	b083      	sub	sp, #12
    d7ac:	4617      	mov	r7, r2
    d7ae:	b298      	uxth	r0, r3
    d7b0:	d525      	bpl.n	d7fe <__sfvwrite_r+0x6a>
    d7b2:	6923      	ldr	r3, [r4, #16]
    d7b4:	b31b      	cbz	r3, d7fe <__sfvwrite_r+0x6a>
    d7b6:	f010 0302 	ands.w	r3, r0, #2
    d7ba:	683d      	ldr	r5, [r7, #0]
    d7bc:	d02d      	beq.n	d81a <__sfvwrite_r+0x86>
    d7be:	f04f 0a00 	mov.w	sl, #0
    d7c2:	f8df b2c0 	ldr.w	fp, [pc, #704]	; da84 <__sfvwrite_r+0x2f0>
    d7c6:	4656      	mov	r6, sl
    d7c8:	46b9      	mov	r9, r7
    d7ca:	455e      	cmp	r6, fp
    d7cc:	4633      	mov	r3, r6
    d7ce:	4652      	mov	r2, sl
    d7d0:	bf28      	it	cs
    d7d2:	465b      	movcs	r3, fp
    d7d4:	4640      	mov	r0, r8
    d7d6:	2e00      	cmp	r6, #0
    d7d8:	d052      	beq.n	d880 <__sfvwrite_r+0xec>
    d7da:	69e1      	ldr	r1, [r4, #28]
    d7dc:	6a67      	ldr	r7, [r4, #36]	; 0x24
    d7de:	47b8      	blx	r7
    d7e0:	2800      	cmp	r0, #0
    d7e2:	dd56      	ble.n	d892 <__sfvwrite_r+0xfe>
    d7e4:	f8d9 3008 	ldr.w	r3, [r9, #8]
    d7e8:	1a1b      	subs	r3, r3, r0
    d7ea:	4482      	add	sl, r0
    d7ec:	1a36      	subs	r6, r6, r0
    d7ee:	f8c9 3008 	str.w	r3, [r9, #8]
    d7f2:	2b00      	cmp	r3, #0
    d7f4:	d1e9      	bne.n	d7ca <__sfvwrite_r+0x36>
    d7f6:	2000      	movs	r0, #0
    d7f8:	b003      	add	sp, #12
    d7fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d7fe:	4621      	mov	r1, r4
    d800:	4640      	mov	r0, r8
    d802:	f000 f941 	bl	da88 <__swsetup_r>
    d806:	2800      	cmp	r0, #0
    d808:	f040 8138 	bne.w	da7c <__sfvwrite_r+0x2e8>
    d80c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d810:	683d      	ldr	r5, [r7, #0]
    d812:	b298      	uxth	r0, r3
    d814:	f010 0302 	ands.w	r3, r0, #2
    d818:	d1d1      	bne.n	d7be <__sfvwrite_r+0x2a>
    d81a:	f010 0901 	ands.w	r9, r0, #1
    d81e:	d144      	bne.n	d8aa <__sfvwrite_r+0x116>
    d820:	464e      	mov	r6, r9
    d822:	9700      	str	r7, [sp, #0]
    d824:	b346      	cbz	r6, d878 <__sfvwrite_r+0xe4>
    d826:	0582      	lsls	r2, r0, #22
    d828:	f8d4 b008 	ldr.w	fp, [r4, #8]
    d82c:	f140 8085 	bpl.w	d93a <__sfvwrite_r+0x1a6>
    d830:	45b3      	cmp	fp, r6
    d832:	465a      	mov	r2, fp
    d834:	f200 80b4 	bhi.w	d9a0 <__sfvwrite_r+0x20c>
    d838:	f410 6f90 	tst.w	r0, #1152	; 0x480
    d83c:	f040 80c1 	bne.w	d9c2 <__sfvwrite_r+0x22e>
    d840:	6820      	ldr	r0, [r4, #0]
    d842:	9201      	str	r2, [sp, #4]
    d844:	4649      	mov	r1, r9
    d846:	f7fb f891 	bl	896c <memmove>
    d84a:	68a3      	ldr	r3, [r4, #8]
    d84c:	9a01      	ldr	r2, [sp, #4]
    d84e:	eba3 010b 	sub.w	r1, r3, fp
    d852:	6823      	ldr	r3, [r4, #0]
    d854:	60a1      	str	r1, [r4, #8]
    d856:	4413      	add	r3, r2
    d858:	46b2      	mov	sl, r6
    d85a:	6023      	str	r3, [r4, #0]
    d85c:	2600      	movs	r6, #0
    d85e:	9a00      	ldr	r2, [sp, #0]
    d860:	6893      	ldr	r3, [r2, #8]
    d862:	eba3 030a 	sub.w	r3, r3, sl
    d866:	44d1      	add	r9, sl
    d868:	6093      	str	r3, [r2, #8]
    d86a:	2b00      	cmp	r3, #0
    d86c:	d0c3      	beq.n	d7f6 <__sfvwrite_r+0x62>
    d86e:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
    d872:	b280      	uxth	r0, r0
    d874:	2e00      	cmp	r6, #0
    d876:	d1d6      	bne.n	d826 <__sfvwrite_r+0x92>
    d878:	e9d5 9600 	ldrd	r9, r6, [r5]
    d87c:	3508      	adds	r5, #8
    d87e:	e7d1      	b.n	d824 <__sfvwrite_r+0x90>
    d880:	e9d5 a600 	ldrd	sl, r6, [r5]
    d884:	3508      	adds	r5, #8
    d886:	e7a0      	b.n	d7ca <__sfvwrite_r+0x36>
    d888:	4621      	mov	r1, r4
    d88a:	4640      	mov	r0, r8
    d88c:	f7fd fe5a 	bl	b544 <_fflush_r>
    d890:	b388      	cbz	r0, d8f6 <__sfvwrite_r+0x162>
    d892:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    d896:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d89a:	f04f 30ff 	mov.w	r0, #4294967295
    d89e:	81a3      	strh	r3, [r4, #12]
    d8a0:	b003      	add	sp, #12
    d8a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d8a6:	2000      	movs	r0, #0
    d8a8:	4770      	bx	lr
    d8aa:	461e      	mov	r6, r3
    d8ac:	46ba      	mov	sl, r7
    d8ae:	4699      	mov	r9, r3
    d8b0:	4618      	mov	r0, r3
    d8b2:	9500      	str	r5, [sp, #0]
    d8b4:	461f      	mov	r7, r3
    d8b6:	b366      	cbz	r6, d912 <__sfvwrite_r+0x17e>
    d8b8:	2800      	cmp	r0, #0
    d8ba:	d032      	beq.n	d922 <__sfvwrite_r+0x18e>
    d8bc:	464a      	mov	r2, r9
    d8be:	e9d4 1304 	ldrd	r1, r3, [r4, #16]
    d8c2:	6820      	ldr	r0, [r4, #0]
    d8c4:	68a5      	ldr	r5, [r4, #8]
    d8c6:	42b2      	cmp	r2, r6
    d8c8:	bf28      	it	cs
    d8ca:	4632      	movcs	r2, r6
    d8cc:	4288      	cmp	r0, r1
    d8ce:	d904      	bls.n	d8da <__sfvwrite_r+0x146>
    d8d0:	eb05 0b03 	add.w	fp, r5, r3
    d8d4:	455a      	cmp	r2, fp
    d8d6:	f300 80a7 	bgt.w	da28 <__sfvwrite_r+0x294>
    d8da:	4293      	cmp	r3, r2
    d8dc:	dc64      	bgt.n	d9a8 <__sfvwrite_r+0x214>
    d8de:	69e1      	ldr	r1, [r4, #28]
    d8e0:	6a65      	ldr	r5, [r4, #36]	; 0x24
    d8e2:	463a      	mov	r2, r7
    d8e4:	4640      	mov	r0, r8
    d8e6:	47a8      	blx	r5
    d8e8:	f1b0 0b00 	subs.w	fp, r0, #0
    d8ec:	ddd1      	ble.n	d892 <__sfvwrite_r+0xfe>
    d8ee:	ebb9 090b 	subs.w	r9, r9, fp
    d8f2:	d0c9      	beq.n	d888 <__sfvwrite_r+0xf4>
    d8f4:	2001      	movs	r0, #1
    d8f6:	f8da 3008 	ldr.w	r3, [sl, #8]
    d8fa:	eba3 030b 	sub.w	r3, r3, fp
    d8fe:	445f      	add	r7, fp
    d900:	eba6 060b 	sub.w	r6, r6, fp
    d904:	f8ca 3008 	str.w	r3, [sl, #8]
    d908:	2b00      	cmp	r3, #0
    d90a:	f43f af74 	beq.w	d7f6 <__sfvwrite_r+0x62>
    d90e:	2e00      	cmp	r6, #0
    d910:	d1d2      	bne.n	d8b8 <__sfvwrite_r+0x124>
    d912:	9a00      	ldr	r2, [sp, #0]
    d914:	6856      	ldr	r6, [r2, #4]
    d916:	4613      	mov	r3, r2
    d918:	3208      	adds	r2, #8
    d91a:	9200      	str	r2, [sp, #0]
    d91c:	2e00      	cmp	r6, #0
    d91e:	d0f8      	beq.n	d912 <__sfvwrite_r+0x17e>
    d920:	681f      	ldr	r7, [r3, #0]
    d922:	4632      	mov	r2, r6
    d924:	210a      	movs	r1, #10
    d926:	4638      	mov	r0, r7
    d928:	f7fd fe3a 	bl	b5a0 <memchr>
    d92c:	2800      	cmp	r0, #0
    d92e:	f000 809c 	beq.w	da6a <__sfvwrite_r+0x2d6>
    d932:	3001      	adds	r0, #1
    d934:	eba0 0907 	sub.w	r9, r0, r7
    d938:	e7c0      	b.n	d8bc <__sfvwrite_r+0x128>
    d93a:	6820      	ldr	r0, [r4, #0]
    d93c:	6923      	ldr	r3, [r4, #16]
    d93e:	4298      	cmp	r0, r3
    d940:	d816      	bhi.n	d970 <__sfvwrite_r+0x1dc>
    d942:	6962      	ldr	r2, [r4, #20]
    d944:	42b2      	cmp	r2, r6
    d946:	d813      	bhi.n	d970 <__sfvwrite_r+0x1dc>
    d948:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    d94c:	42b3      	cmp	r3, r6
    d94e:	bf28      	it	cs
    d950:	4633      	movcs	r3, r6
    d952:	69e1      	ldr	r1, [r4, #28]
    d954:	fb93 f3f2 	sdiv	r3, r3, r2
    d958:	6a67      	ldr	r7, [r4, #36]	; 0x24
    d95a:	fb02 f303 	mul.w	r3, r2, r3
    d95e:	4640      	mov	r0, r8
    d960:	464a      	mov	r2, r9
    d962:	47b8      	blx	r7
    d964:	f1b0 0a00 	subs.w	sl, r0, #0
    d968:	dd93      	ble.n	d892 <__sfvwrite_r+0xfe>
    d96a:	eba6 060a 	sub.w	r6, r6, sl
    d96e:	e776      	b.n	d85e <__sfvwrite_r+0xca>
    d970:	45b3      	cmp	fp, r6
    d972:	46da      	mov	sl, fp
    d974:	bf28      	it	cs
    d976:	46b2      	movcs	sl, r6
    d978:	4652      	mov	r2, sl
    d97a:	4649      	mov	r1, r9
    d97c:	f7fa fff6 	bl	896c <memmove>
    d980:	68a3      	ldr	r3, [r4, #8]
    d982:	6822      	ldr	r2, [r4, #0]
    d984:	eba3 030a 	sub.w	r3, r3, sl
    d988:	4452      	add	r2, sl
    d98a:	60a3      	str	r3, [r4, #8]
    d98c:	6022      	str	r2, [r4, #0]
    d98e:	2b00      	cmp	r3, #0
    d990:	d1eb      	bne.n	d96a <__sfvwrite_r+0x1d6>
    d992:	4621      	mov	r1, r4
    d994:	4640      	mov	r0, r8
    d996:	f7fd fdd5 	bl	b544 <_fflush_r>
    d99a:	2800      	cmp	r0, #0
    d99c:	d0e5      	beq.n	d96a <__sfvwrite_r+0x1d6>
    d99e:	e778      	b.n	d892 <__sfvwrite_r+0xfe>
    d9a0:	6820      	ldr	r0, [r4, #0]
    d9a2:	46b3      	mov	fp, r6
    d9a4:	4632      	mov	r2, r6
    d9a6:	e74c      	b.n	d842 <__sfvwrite_r+0xae>
    d9a8:	4639      	mov	r1, r7
    d9aa:	9201      	str	r2, [sp, #4]
    d9ac:	f7fa ffde 	bl	896c <memmove>
    d9b0:	9a01      	ldr	r2, [sp, #4]
    d9b2:	68a3      	ldr	r3, [r4, #8]
    d9b4:	1a9b      	subs	r3, r3, r2
    d9b6:	60a3      	str	r3, [r4, #8]
    d9b8:	6823      	ldr	r3, [r4, #0]
    d9ba:	4413      	add	r3, r2
    d9bc:	6023      	str	r3, [r4, #0]
    d9be:	4693      	mov	fp, r2
    d9c0:	e795      	b.n	d8ee <__sfvwrite_r+0x15a>
    d9c2:	6823      	ldr	r3, [r4, #0]
    d9c4:	6921      	ldr	r1, [r4, #16]
    d9c6:	eba3 0b01 	sub.w	fp, r3, r1
    d9ca:	6963      	ldr	r3, [r4, #20]
    d9cc:	eb03 0a43 	add.w	sl, r3, r3, lsl #1
    d9d0:	eb0a 7ada 	add.w	sl, sl, sl, lsr #31
    d9d4:	f10b 0301 	add.w	r3, fp, #1
    d9d8:	ea4f 0a6a 	mov.w	sl, sl, asr #1
    d9dc:	4433      	add	r3, r6
    d9de:	4553      	cmp	r3, sl
    d9e0:	4652      	mov	r2, sl
    d9e2:	bf84      	itt	hi
    d9e4:	469a      	movhi	sl, r3
    d9e6:	4652      	movhi	r2, sl
    d9e8:	0543      	lsls	r3, r0, #21
    d9ea:	d52c      	bpl.n	da46 <__sfvwrite_r+0x2b2>
    d9ec:	4611      	mov	r1, r2
    d9ee:	4640      	mov	r0, r8
    d9f0:	f7fa f984 	bl	7cfc <_malloc_r>
    d9f4:	2800      	cmp	r0, #0
    d9f6:	d03b      	beq.n	da70 <__sfvwrite_r+0x2dc>
    d9f8:	465a      	mov	r2, fp
    d9fa:	6921      	ldr	r1, [r4, #16]
    d9fc:	9001      	str	r0, [sp, #4]
    d9fe:	f7f8 fd39 	bl	6474 <memcpy>
    da02:	89a2      	ldrh	r2, [r4, #12]
    da04:	9b01      	ldr	r3, [sp, #4]
    da06:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    da0a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    da0e:	81a2      	strh	r2, [r4, #12]
    da10:	eb03 000b 	add.w	r0, r3, fp
    da14:	6123      	str	r3, [r4, #16]
    da16:	ebaa 030b 	sub.w	r3, sl, fp
    da1a:	f8c4 a014 	str.w	sl, [r4, #20]
    da1e:	60a3      	str	r3, [r4, #8]
    da20:	6020      	str	r0, [r4, #0]
    da22:	46b3      	mov	fp, r6
    da24:	4632      	mov	r2, r6
    da26:	e70c      	b.n	d842 <__sfvwrite_r+0xae>
    da28:	4639      	mov	r1, r7
    da2a:	465a      	mov	r2, fp
    da2c:	f7fa ff9e 	bl	896c <memmove>
    da30:	6823      	ldr	r3, [r4, #0]
    da32:	445b      	add	r3, fp
    da34:	6023      	str	r3, [r4, #0]
    da36:	4621      	mov	r1, r4
    da38:	4640      	mov	r0, r8
    da3a:	f7fd fd83 	bl	b544 <_fflush_r>
    da3e:	2800      	cmp	r0, #0
    da40:	f43f af55 	beq.w	d8ee <__sfvwrite_r+0x15a>
    da44:	e725      	b.n	d892 <__sfvwrite_r+0xfe>
    da46:	4640      	mov	r0, r8
    da48:	f7fa fc14 	bl	8274 <_realloc_r>
    da4c:	4603      	mov	r3, r0
    da4e:	2800      	cmp	r0, #0
    da50:	d1de      	bne.n	da10 <__sfvwrite_r+0x27c>
    da52:	6921      	ldr	r1, [r4, #16]
    da54:	4640      	mov	r0, r8
    da56:	f7fb f9f1 	bl	8e3c <_free_r>
    da5a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    da5e:	220c      	movs	r2, #12
    da60:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    da64:	f8c8 2000 	str.w	r2, [r8]
    da68:	e715      	b.n	d896 <__sfvwrite_r+0x102>
    da6a:	1c72      	adds	r2, r6, #1
    da6c:	4691      	mov	r9, r2
    da6e:	e726      	b.n	d8be <__sfvwrite_r+0x12a>
    da70:	220c      	movs	r2, #12
    da72:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    da76:	f8c8 2000 	str.w	r2, [r8]
    da7a:	e70c      	b.n	d896 <__sfvwrite_r+0x102>
    da7c:	f04f 30ff 	mov.w	r0, #4294967295
    da80:	e6ba      	b.n	d7f8 <__sfvwrite_r+0x64>
    da82:	bf00      	nop
    da84:	7ffffc00 	.word	0x7ffffc00

0000da88 <__swsetup_r>:
    da88:	b538      	push	{r3, r4, r5, lr}
    da8a:	4b31      	ldr	r3, [pc, #196]	; (db50 <__swsetup_r+0xc8>)
    da8c:	681b      	ldr	r3, [r3, #0]
    da8e:	4605      	mov	r5, r0
    da90:	460c      	mov	r4, r1
    da92:	b113      	cbz	r3, da9a <__swsetup_r+0x12>
    da94:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    da96:	2a00      	cmp	r2, #0
    da98:	d04e      	beq.n	db38 <__swsetup_r+0xb0>
    da9a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    da9e:	0718      	lsls	r0, r3, #28
    daa0:	b29a      	uxth	r2, r3
    daa2:	d51c      	bpl.n	dade <__swsetup_r+0x56>
    daa4:	6921      	ldr	r1, [r4, #16]
    daa6:	b329      	cbz	r1, daf4 <__swsetup_r+0x6c>
    daa8:	f012 0001 	ands.w	r0, r2, #1
    daac:	d007      	beq.n	dabe <__swsetup_r+0x36>
    daae:	2000      	movs	r0, #0
    dab0:	60a0      	str	r0, [r4, #8]
    dab2:	6960      	ldr	r0, [r4, #20]
    dab4:	4240      	negs	r0, r0
    dab6:	61a0      	str	r0, [r4, #24]
    dab8:	b139      	cbz	r1, daca <__swsetup_r+0x42>
    daba:	2000      	movs	r0, #0
    dabc:	bd38      	pop	{r3, r4, r5, pc}
    dabe:	0795      	lsls	r5, r2, #30
    dac0:	bf58      	it	pl
    dac2:	6960      	ldrpl	r0, [r4, #20]
    dac4:	60a0      	str	r0, [r4, #8]
    dac6:	2900      	cmp	r1, #0
    dac8:	d1f7      	bne.n	daba <__swsetup_r+0x32>
    daca:	0612      	lsls	r2, r2, #24
    dacc:	bf58      	it	pl
    dace:	4608      	movpl	r0, r1
    dad0:	d5f4      	bpl.n	dabc <__swsetup_r+0x34>
    dad2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    dad6:	81a3      	strh	r3, [r4, #12]
    dad8:	f04f 30ff 	mov.w	r0, #4294967295
    dadc:	bd38      	pop	{r3, r4, r5, pc}
    dade:	06d1      	lsls	r1, r2, #27
    dae0:	d52e      	bpl.n	db40 <__swsetup_r+0xb8>
    dae2:	0752      	lsls	r2, r2, #29
    dae4:	d414      	bmi.n	db10 <__swsetup_r+0x88>
    dae6:	6921      	ldr	r1, [r4, #16]
    dae8:	f043 0308 	orr.w	r3, r3, #8
    daec:	81a3      	strh	r3, [r4, #12]
    daee:	b29a      	uxth	r2, r3
    daf0:	2900      	cmp	r1, #0
    daf2:	d1d9      	bne.n	daa8 <__swsetup_r+0x20>
    daf4:	f402 7020 	and.w	r0, r2, #640	; 0x280
    daf8:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    dafc:	d0d4      	beq.n	daa8 <__swsetup_r+0x20>
    dafe:	4621      	mov	r1, r4
    db00:	4628      	mov	r0, r5
    db02:	f000 f947 	bl	dd94 <__smakebuf_r>
    db06:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    db0a:	6921      	ldr	r1, [r4, #16]
    db0c:	b29a      	uxth	r2, r3
    db0e:	e7cb      	b.n	daa8 <__swsetup_r+0x20>
    db10:	6b21      	ldr	r1, [r4, #48]	; 0x30
    db12:	b151      	cbz	r1, db2a <__swsetup_r+0xa2>
    db14:	f104 0240 	add.w	r2, r4, #64	; 0x40
    db18:	4291      	cmp	r1, r2
    db1a:	d004      	beq.n	db26 <__swsetup_r+0x9e>
    db1c:	4628      	mov	r0, r5
    db1e:	f7fb f98d 	bl	8e3c <_free_r>
    db22:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    db26:	2200      	movs	r2, #0
    db28:	6322      	str	r2, [r4, #48]	; 0x30
    db2a:	6921      	ldr	r1, [r4, #16]
    db2c:	2200      	movs	r2, #0
    db2e:	e9c4 1200 	strd	r1, r2, [r4]
    db32:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    db36:	e7d7      	b.n	dae8 <__swsetup_r+0x60>
    db38:	4618      	mov	r0, r3
    db3a:	f7fa fe1d 	bl	8778 <__sinit>
    db3e:	e7ac      	b.n	da9a <__swsetup_r+0x12>
    db40:	2209      	movs	r2, #9
    db42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    db46:	602a      	str	r2, [r5, #0]
    db48:	f04f 30ff 	mov.w	r0, #4294967295
    db4c:	81a3      	strh	r3, [r4, #12]
    db4e:	bd38      	pop	{r3, r4, r5, pc}
    db50:	2000176c 	.word	0x2000176c

0000db54 <__fputwc>:
    db54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    db58:	b082      	sub	sp, #8
    db5a:	4682      	mov	sl, r0
    db5c:	4688      	mov	r8, r1
    db5e:	4614      	mov	r4, r2
    db60:	f7fb f804 	bl	8b6c <__locale_mb_cur_max>
    db64:	2801      	cmp	r0, #1
    db66:	d103      	bne.n	db70 <__fputwc+0x1c>
    db68:	f108 33ff 	add.w	r3, r8, #4294967295
    db6c:	2bfe      	cmp	r3, #254	; 0xfe
    db6e:	d936      	bls.n	dbde <__fputwc+0x8a>
    db70:	f10d 0904 	add.w	r9, sp, #4
    db74:	4642      	mov	r2, r8
    db76:	f104 035c 	add.w	r3, r4, #92	; 0x5c
    db7a:	4649      	mov	r1, r9
    db7c:	4650      	mov	r0, sl
    db7e:	f7fe fd01 	bl	c584 <_wcrtomb_r>
    db82:	1c42      	adds	r2, r0, #1
    db84:	4606      	mov	r6, r0
    db86:	d032      	beq.n	dbee <__fputwc+0x9a>
    db88:	b320      	cbz	r0, dbd4 <__fputwc+0x80>
    db8a:	f89d c004 	ldrb.w	ip, [sp, #4]
    db8e:	2500      	movs	r5, #0
    db90:	e009      	b.n	dba6 <__fputwc+0x52>
    db92:	6823      	ldr	r3, [r4, #0]
    db94:	1c5a      	adds	r2, r3, #1
    db96:	6022      	str	r2, [r4, #0]
    db98:	f883 c000 	strb.w	ip, [r3]
    db9c:	3501      	adds	r5, #1
    db9e:	42b5      	cmp	r5, r6
    dba0:	d218      	bcs.n	dbd4 <__fputwc+0x80>
    dba2:	f819 cf01 	ldrb.w	ip, [r9, #1]!
    dba6:	68a3      	ldr	r3, [r4, #8]
    dba8:	3b01      	subs	r3, #1
    dbaa:	2b00      	cmp	r3, #0
    dbac:	60a3      	str	r3, [r4, #8]
    dbae:	daf0      	bge.n	db92 <__fputwc+0x3e>
    dbb0:	69a7      	ldr	r7, [r4, #24]
    dbb2:	42bb      	cmp	r3, r7
    dbb4:	4661      	mov	r1, ip
    dbb6:	4622      	mov	r2, r4
    dbb8:	4650      	mov	r0, sl
    dbba:	db02      	blt.n	dbc2 <__fputwc+0x6e>
    dbbc:	f1bc 0f0a 	cmp.w	ip, #10
    dbc0:	d1e7      	bne.n	db92 <__fputwc+0x3e>
    dbc2:	f000 f953 	bl	de6c <__swbuf_r>
    dbc6:	1c43      	adds	r3, r0, #1
    dbc8:	d1e8      	bne.n	db9c <__fputwc+0x48>
    dbca:	4606      	mov	r6, r0
    dbcc:	4630      	mov	r0, r6
    dbce:	b002      	add	sp, #8
    dbd0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dbd4:	4646      	mov	r6, r8
    dbd6:	4630      	mov	r0, r6
    dbd8:	b002      	add	sp, #8
    dbda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dbde:	fa5f fc88 	uxtb.w	ip, r8
    dbe2:	f88d c004 	strb.w	ip, [sp, #4]
    dbe6:	4606      	mov	r6, r0
    dbe8:	f10d 0904 	add.w	r9, sp, #4
    dbec:	e7cf      	b.n	db8e <__fputwc+0x3a>
    dbee:	89a3      	ldrh	r3, [r4, #12]
    dbf0:	4630      	mov	r0, r6
    dbf2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    dbf6:	81a3      	strh	r3, [r4, #12]
    dbf8:	b002      	add	sp, #8
    dbfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dbfe:	bf00      	nop

0000dc00 <_fputwc_r>:
    dc00:	b530      	push	{r4, r5, lr}
    dc02:	6e53      	ldr	r3, [r2, #100]	; 0x64
    dc04:	f013 0f01 	tst.w	r3, #1
    dc08:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
    dc0c:	4614      	mov	r4, r2
    dc0e:	b083      	sub	sp, #12
    dc10:	4605      	mov	r5, r0
    dc12:	b29a      	uxth	r2, r3
    dc14:	d101      	bne.n	dc1a <_fputwc_r+0x1a>
    dc16:	0598      	lsls	r0, r3, #22
    dc18:	d51c      	bpl.n	dc54 <_fputwc_r+0x54>
    dc1a:	0490      	lsls	r0, r2, #18
    dc1c:	d406      	bmi.n	dc2c <_fputwc_r+0x2c>
    dc1e:	6e62      	ldr	r2, [r4, #100]	; 0x64
    dc20:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    dc24:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    dc28:	81a3      	strh	r3, [r4, #12]
    dc2a:	6662      	str	r2, [r4, #100]	; 0x64
    dc2c:	4622      	mov	r2, r4
    dc2e:	4628      	mov	r0, r5
    dc30:	f7ff ff90 	bl	db54 <__fputwc>
    dc34:	6e63      	ldr	r3, [r4, #100]	; 0x64
    dc36:	07da      	lsls	r2, r3, #31
    dc38:	4605      	mov	r5, r0
    dc3a:	d402      	bmi.n	dc42 <_fputwc_r+0x42>
    dc3c:	89a3      	ldrh	r3, [r4, #12]
    dc3e:	059b      	lsls	r3, r3, #22
    dc40:	d502      	bpl.n	dc48 <_fputwc_r+0x48>
    dc42:	4628      	mov	r0, r5
    dc44:	b003      	add	sp, #12
    dc46:	bd30      	pop	{r4, r5, pc}
    dc48:	6da0      	ldr	r0, [r4, #88]	; 0x58
    dc4a:	f7fb f82b 	bl	8ca4 <__retarget_lock_release_recursive>
    dc4e:	4628      	mov	r0, r5
    dc50:	b003      	add	sp, #12
    dc52:	bd30      	pop	{r4, r5, pc}
    dc54:	6da0      	ldr	r0, [r4, #88]	; 0x58
    dc56:	9101      	str	r1, [sp, #4]
    dc58:	f7fb f822 	bl	8ca0 <__retarget_lock_acquire_recursive>
    dc5c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    dc60:	9901      	ldr	r1, [sp, #4]
    dc62:	b29a      	uxth	r2, r3
    dc64:	e7d9      	b.n	dc1a <_fputwc_r+0x1a>
    dc66:	bf00      	nop

0000dc68 <_wcsnrtombs_l>:
    dc68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dc6c:	b08b      	sub	sp, #44	; 0x2c
    dc6e:	e9dd 8a15 	ldrd	r8, sl, [sp, #84]	; 0x54
    dc72:	9f14      	ldr	r7, [sp, #80]	; 0x50
    dc74:	9103      	str	r1, [sp, #12]
    dc76:	4681      	mov	r9, r0
    dc78:	9205      	str	r2, [sp, #20]
    dc7a:	461e      	mov	r6, r3
    dc7c:	f1b8 0f00 	cmp.w	r8, #0
    dc80:	d05c      	beq.n	dd3c <_wcsnrtombs_l+0xd4>
    dc82:	9b03      	ldr	r3, [sp, #12]
    dc84:	2b00      	cmp	r3, #0
    dc86:	d05e      	beq.n	dd46 <_wcsnrtombs_l+0xde>
    dc88:	9b05      	ldr	r3, [sp, #20]
    dc8a:	681d      	ldr	r5, [r3, #0]
    dc8c:	2f00      	cmp	r7, #0
    dc8e:	d06a      	beq.n	dd66 <_wcsnrtombs_l+0xfe>
    dc90:	1e74      	subs	r4, r6, #1
    dc92:	b34e      	cbz	r6, dce8 <_wcsnrtombs_l+0x80>
    dc94:	9b03      	ldr	r3, [sp, #12]
    dc96:	9304      	str	r3, [sp, #16]
    dc98:	3d04      	subs	r5, #4
    dc9a:	2600      	movs	r6, #0
    dc9c:	9501      	str	r5, [sp, #4]
    dc9e:	e00b      	b.n	dcb8 <_wcsnrtombs_l+0x50>
    dca0:	9b03      	ldr	r3, [sp, #12]
    dca2:	bb2b      	cbnz	r3, dcf0 <_wcsnrtombs_l+0x88>
    dca4:	9b01      	ldr	r3, [sp, #4]
    dca6:	681a      	ldr	r2, [r3, #0]
    dca8:	2a00      	cmp	r2, #0
    dcaa:	d03a      	beq.n	dd22 <_wcsnrtombs_l+0xba>
    dcac:	45bc      	cmp	ip, r7
    dcae:	d25c      	bcs.n	dd6a <_wcsnrtombs_l+0x102>
    dcb0:	3c01      	subs	r4, #1
    dcb2:	1c63      	adds	r3, r4, #1
    dcb4:	4666      	mov	r6, ip
    dcb6:	d017      	beq.n	dce8 <_wcsnrtombs_l+0x80>
    dcb8:	f8d8 3000 	ldr.w	r3, [r8]
    dcbc:	9302      	str	r3, [sp, #8]
    dcbe:	9b01      	ldr	r3, [sp, #4]
    dcc0:	f8da 50e0 	ldr.w	r5, [sl, #224]	; 0xe0
    dcc4:	f853 2f04 	ldr.w	r2, [r3, #4]!
    dcc8:	9301      	str	r3, [sp, #4]
    dcca:	a907      	add	r1, sp, #28
    dccc:	4643      	mov	r3, r8
    dcce:	4648      	mov	r0, r9
    dcd0:	f8d8 b004 	ldr.w	fp, [r8, #4]
    dcd4:	47a8      	blx	r5
    dcd6:	1c42      	adds	r2, r0, #1
    dcd8:	d03a      	beq.n	dd50 <_wcsnrtombs_l+0xe8>
    dcda:	eb00 0c06 	add.w	ip, r0, r6
    dcde:	45bc      	cmp	ip, r7
    dce0:	d9de      	bls.n	dca0 <_wcsnrtombs_l+0x38>
    dce2:	9b02      	ldr	r3, [sp, #8]
    dce4:	e9c8 3b00 	strd	r3, fp, [r8]
    dce8:	4630      	mov	r0, r6
    dcea:	b00b      	add	sp, #44	; 0x2c
    dcec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dcf0:	2800      	cmp	r0, #0
    dcf2:	dd0e      	ble.n	dd12 <_wcsnrtombs_l+0xaa>
    dcf4:	9b04      	ldr	r3, [sp, #16]
    dcf6:	9d01      	ldr	r5, [sp, #4]
    dcf8:	4418      	add	r0, r3
    dcfa:	1e5a      	subs	r2, r3, #1
    dcfc:	a907      	add	r1, sp, #28
    dcfe:	f100 3eff 	add.w	lr, r0, #4294967295
    dd02:	f811 3b01 	ldrb.w	r3, [r1], #1
    dd06:	f802 3f01 	strb.w	r3, [r2, #1]!
    dd0a:	4572      	cmp	r2, lr
    dd0c:	d1f9      	bne.n	dd02 <_wcsnrtombs_l+0x9a>
    dd0e:	9501      	str	r5, [sp, #4]
    dd10:	9004      	str	r0, [sp, #16]
    dd12:	9b05      	ldr	r3, [sp, #20]
    dd14:	681a      	ldr	r2, [r3, #0]
    dd16:	3204      	adds	r2, #4
    dd18:	601a      	str	r2, [r3, #0]
    dd1a:	9b01      	ldr	r3, [sp, #4]
    dd1c:	681a      	ldr	r2, [r3, #0]
    dd1e:	2a00      	cmp	r2, #0
    dd20:	d1c4      	bne.n	dcac <_wcsnrtombs_l+0x44>
    dd22:	9b03      	ldr	r3, [sp, #12]
    dd24:	b10b      	cbz	r3, dd2a <_wcsnrtombs_l+0xc2>
    dd26:	9b05      	ldr	r3, [sp, #20]
    dd28:	601a      	str	r2, [r3, #0]
    dd2a:	f10c 36ff 	add.w	r6, ip, #4294967295
    dd2e:	2200      	movs	r2, #0
    dd30:	4630      	mov	r0, r6
    dd32:	f8c8 2000 	str.w	r2, [r8]
    dd36:	b00b      	add	sp, #44	; 0x2c
    dd38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd3c:	9b03      	ldr	r3, [sp, #12]
    dd3e:	f500 7886 	add.w	r8, r0, #268	; 0x10c
    dd42:	2b00      	cmp	r3, #0
    dd44:	d1a0      	bne.n	dc88 <_wcsnrtombs_l+0x20>
    dd46:	9b05      	ldr	r3, [sp, #20]
    dd48:	f04f 37ff 	mov.w	r7, #4294967295
    dd4c:	681d      	ldr	r5, [r3, #0]
    dd4e:	e79f      	b.n	dc90 <_wcsnrtombs_l+0x28>
    dd50:	4606      	mov	r6, r0
    dd52:	218a      	movs	r1, #138	; 0x8a
    dd54:	2200      	movs	r2, #0
    dd56:	4630      	mov	r0, r6
    dd58:	f8c9 1000 	str.w	r1, [r9]
    dd5c:	f8c8 2000 	str.w	r2, [r8]
    dd60:	b00b      	add	sp, #44	; 0x2c
    dd62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd66:	463e      	mov	r6, r7
    dd68:	e7be      	b.n	dce8 <_wcsnrtombs_l+0x80>
    dd6a:	4666      	mov	r6, ip
    dd6c:	e7bc      	b.n	dce8 <_wcsnrtombs_l+0x80>
    dd6e:	bf00      	nop

0000dd70 <_wcsnrtombs_r>:
    dd70:	b510      	push	{r4, lr}
    dd72:	b084      	sub	sp, #16
    dd74:	4c05      	ldr	r4, [pc, #20]	; (dd8c <_wcsnrtombs_r+0x1c>)
    dd76:	9806      	ldr	r0, [sp, #24]
    dd78:	9000      	str	r0, [sp, #0]
    dd7a:	9807      	ldr	r0, [sp, #28]
    dd7c:	9001      	str	r0, [sp, #4]
    dd7e:	4804      	ldr	r0, [pc, #16]	; (dd90 <_wcsnrtombs_r+0x20>)
    dd80:	6800      	ldr	r0, [r0, #0]
    dd82:	9402      	str	r4, [sp, #8]
    dd84:	f7ff ff70 	bl	dc68 <_wcsnrtombs_l>
    dd88:	b004      	add	sp, #16
    dd8a:	bd10      	pop	{r4, pc}
    dd8c:	200011e4 	.word	0x200011e4
    dd90:	2000176c 	.word	0x2000176c

0000dd94 <__smakebuf_r>:
    dd94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dd98:	898b      	ldrh	r3, [r1, #12]
    dd9a:	460c      	mov	r4, r1
    dd9c:	0799      	lsls	r1, r3, #30
    dd9e:	b096      	sub	sp, #88	; 0x58
    dda0:	d508      	bpl.n	ddb4 <__smakebuf_r+0x20>
    dda2:	f104 0343 	add.w	r3, r4, #67	; 0x43
    dda6:	2201      	movs	r2, #1
    dda8:	e9c4 3204 	strd	r3, r2, [r4, #16]
    ddac:	6023      	str	r3, [r4, #0]
    ddae:	b016      	add	sp, #88	; 0x58
    ddb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ddb4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    ddb8:	2900      	cmp	r1, #0
    ddba:	4606      	mov	r6, r0
    ddbc:	db25      	blt.n	de0a <__smakebuf_r+0x76>
    ddbe:	466a      	mov	r2, sp
    ddc0:	f000 f8ac 	bl	df1c <_fstat_r>
    ddc4:	2800      	cmp	r0, #0
    ddc6:	db1f      	blt.n	de08 <__smakebuf_r+0x74>
    ddc8:	9d01      	ldr	r5, [sp, #4]
    ddca:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    ddce:	f5a5 5500 	sub.w	r5, r5, #8192	; 0x2000
    ddd2:	fab5 f585 	clz	r5, r5
    ddd6:	f44f 6880 	mov.w	r8, #1024	; 0x400
    ddda:	096d      	lsrs	r5, r5, #5
    dddc:	f44f 6700 	mov.w	r7, #2048	; 0x800
    dde0:	4641      	mov	r1, r8
    dde2:	4630      	mov	r0, r6
    dde4:	f7f9 ff8a 	bl	7cfc <_malloc_r>
    dde8:	b1e0      	cbz	r0, de24 <__smakebuf_r+0x90>
    ddea:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ddee:	f8c4 8014 	str.w	r8, [r4, #20]
    ddf2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    ddf6:	6020      	str	r0, [r4, #0]
    ddf8:	6120      	str	r0, [r4, #16]
    ddfa:	81a3      	strh	r3, [r4, #12]
    ddfc:	bb35      	cbnz	r5, de4c <__smakebuf_r+0xb8>
    ddfe:	433b      	orrs	r3, r7
    de00:	81a3      	strh	r3, [r4, #12]
    de02:	b016      	add	sp, #88	; 0x58
    de04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    de08:	89a3      	ldrh	r3, [r4, #12]
    de0a:	f013 0580 	ands.w	r5, r3, #128	; 0x80
    de0e:	d019      	beq.n	de44 <__smakebuf_r+0xb0>
    de10:	f04f 0840 	mov.w	r8, #64	; 0x40
    de14:	2500      	movs	r5, #0
    de16:	4641      	mov	r1, r8
    de18:	4630      	mov	r0, r6
    de1a:	462f      	mov	r7, r5
    de1c:	f7f9 ff6e 	bl	7cfc <_malloc_r>
    de20:	2800      	cmp	r0, #0
    de22:	d1e2      	bne.n	ddea <__smakebuf_r+0x56>
    de24:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    de28:	059a      	lsls	r2, r3, #22
    de2a:	d4c0      	bmi.n	ddae <__smakebuf_r+0x1a>
    de2c:	f023 0303 	bic.w	r3, r3, #3
    de30:	f104 0243 	add.w	r2, r4, #67	; 0x43
    de34:	f043 0302 	orr.w	r3, r3, #2
    de38:	2101      	movs	r1, #1
    de3a:	e9c4 2104 	strd	r2, r1, [r4, #16]
    de3e:	81a3      	strh	r3, [r4, #12]
    de40:	6022      	str	r2, [r4, #0]
    de42:	e7b4      	b.n	ddae <__smakebuf_r+0x1a>
    de44:	f44f 6880 	mov.w	r8, #1024	; 0x400
    de48:	462f      	mov	r7, r5
    de4a:	e7c9      	b.n	dde0 <__smakebuf_r+0x4c>
    de4c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    de50:	4630      	mov	r0, r6
    de52:	f000 f879 	bl	df48 <_isatty_r>
    de56:	b910      	cbnz	r0, de5e <__smakebuf_r+0xca>
    de58:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    de5c:	e7cf      	b.n	ddfe <__smakebuf_r+0x6a>
    de5e:	89a3      	ldrh	r3, [r4, #12]
    de60:	f023 0303 	bic.w	r3, r3, #3
    de64:	f043 0301 	orr.w	r3, r3, #1
    de68:	b21b      	sxth	r3, r3
    de6a:	e7c8      	b.n	ddfe <__smakebuf_r+0x6a>

0000de6c <__swbuf_r>:
    de6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    de6e:	460d      	mov	r5, r1
    de70:	4614      	mov	r4, r2
    de72:	4606      	mov	r6, r0
    de74:	b110      	cbz	r0, de7c <__swbuf_r+0x10>
    de76:	6b43      	ldr	r3, [r0, #52]	; 0x34
    de78:	2b00      	cmp	r3, #0
    de7a:	d04c      	beq.n	df16 <__swbuf_r+0xaa>
    de7c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    de80:	69a3      	ldr	r3, [r4, #24]
    de82:	60a3      	str	r3, [r4, #8]
    de84:	0717      	lsls	r7, r2, #28
    de86:	b290      	uxth	r0, r2
    de88:	d51b      	bpl.n	dec2 <__swbuf_r+0x56>
    de8a:	6923      	ldr	r3, [r4, #16]
    de8c:	b1cb      	cbz	r3, dec2 <__swbuf_r+0x56>
    de8e:	b2ed      	uxtb	r5, r5
    de90:	0481      	lsls	r1, r0, #18
    de92:	462f      	mov	r7, r5
    de94:	d522      	bpl.n	dedc <__swbuf_r+0x70>
    de96:	6822      	ldr	r2, [r4, #0]
    de98:	6961      	ldr	r1, [r4, #20]
    de9a:	1ad3      	subs	r3, r2, r3
    de9c:	4299      	cmp	r1, r3
    de9e:	dd29      	ble.n	def4 <__swbuf_r+0x88>
    dea0:	3301      	adds	r3, #1
    dea2:	68a1      	ldr	r1, [r4, #8]
    dea4:	3901      	subs	r1, #1
    dea6:	60a1      	str	r1, [r4, #8]
    dea8:	1c51      	adds	r1, r2, #1
    deaa:	6021      	str	r1, [r4, #0]
    deac:	7015      	strb	r5, [r2, #0]
    deae:	6962      	ldr	r2, [r4, #20]
    deb0:	429a      	cmp	r2, r3
    deb2:	d027      	beq.n	df04 <__swbuf_r+0x98>
    deb4:	89a3      	ldrh	r3, [r4, #12]
    deb6:	07db      	lsls	r3, r3, #31
    deb8:	d501      	bpl.n	debe <__swbuf_r+0x52>
    deba:	2d0a      	cmp	r5, #10
    debc:	d022      	beq.n	df04 <__swbuf_r+0x98>
    debe:	4638      	mov	r0, r7
    dec0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dec2:	4621      	mov	r1, r4
    dec4:	4630      	mov	r0, r6
    dec6:	f7ff fddf 	bl	da88 <__swsetup_r>
    deca:	bb08      	cbnz	r0, df10 <__swbuf_r+0xa4>
    decc:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    ded0:	6923      	ldr	r3, [r4, #16]
    ded2:	b290      	uxth	r0, r2
    ded4:	b2ed      	uxtb	r5, r5
    ded6:	0481      	lsls	r1, r0, #18
    ded8:	462f      	mov	r7, r5
    deda:	d4dc      	bmi.n	de96 <__swbuf_r+0x2a>
    dedc:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    dee0:	81a2      	strh	r2, [r4, #12]
    dee2:	6e62      	ldr	r2, [r4, #100]	; 0x64
    dee4:	6961      	ldr	r1, [r4, #20]
    dee6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
    deea:	6662      	str	r2, [r4, #100]	; 0x64
    deec:	6822      	ldr	r2, [r4, #0]
    deee:	1ad3      	subs	r3, r2, r3
    def0:	4299      	cmp	r1, r3
    def2:	dcd5      	bgt.n	dea0 <__swbuf_r+0x34>
    def4:	4621      	mov	r1, r4
    def6:	4630      	mov	r0, r6
    def8:	f7fd fb24 	bl	b544 <_fflush_r>
    defc:	b940      	cbnz	r0, df10 <__swbuf_r+0xa4>
    defe:	6822      	ldr	r2, [r4, #0]
    df00:	2301      	movs	r3, #1
    df02:	e7ce      	b.n	dea2 <__swbuf_r+0x36>
    df04:	4621      	mov	r1, r4
    df06:	4630      	mov	r0, r6
    df08:	f7fd fb1c 	bl	b544 <_fflush_r>
    df0c:	2800      	cmp	r0, #0
    df0e:	d0d6      	beq.n	debe <__swbuf_r+0x52>
    df10:	f04f 37ff 	mov.w	r7, #4294967295
    df14:	e7d3      	b.n	debe <__swbuf_r+0x52>
    df16:	f7fa fc2f 	bl	8778 <__sinit>
    df1a:	e7af      	b.n	de7c <__swbuf_r+0x10>

0000df1c <_fstat_r>:
    df1c:	b570      	push	{r4, r5, r6, lr}
    df1e:	460c      	mov	r4, r1
    df20:	4d08      	ldr	r5, [pc, #32]	; (df44 <_fstat_r+0x28>)
    df22:	4603      	mov	r3, r0
    df24:	2600      	movs	r6, #0
    df26:	4620      	mov	r0, r4
    df28:	4611      	mov	r1, r2
    df2a:	461c      	mov	r4, r3
    df2c:	602e      	str	r6, [r5, #0]
    df2e:	f7f8 fdcb 	bl	6ac8 <_fstat>
    df32:	1c43      	adds	r3, r0, #1
    df34:	d000      	beq.n	df38 <_fstat_r+0x1c>
    df36:	bd70      	pop	{r4, r5, r6, pc}
    df38:	682b      	ldr	r3, [r5, #0]
    df3a:	2b00      	cmp	r3, #0
    df3c:	d0fb      	beq.n	df36 <_fstat_r+0x1a>
    df3e:	6023      	str	r3, [r4, #0]
    df40:	bd70      	pop	{r4, r5, r6, pc}
    df42:	bf00      	nop
    df44:	2000a4e8 	.word	0x2000a4e8

0000df48 <_isatty_r>:
    df48:	b538      	push	{r3, r4, r5, lr}
    df4a:	4d07      	ldr	r5, [pc, #28]	; (df68 <_isatty_r+0x20>)
    df4c:	2200      	movs	r2, #0
    df4e:	4604      	mov	r4, r0
    df50:	4608      	mov	r0, r1
    df52:	602a      	str	r2, [r5, #0]
    df54:	f7f8 fdbe 	bl	6ad4 <_isatty>
    df58:	1c43      	adds	r3, r0, #1
    df5a:	d000      	beq.n	df5e <_isatty_r+0x16>
    df5c:	bd38      	pop	{r3, r4, r5, pc}
    df5e:	682b      	ldr	r3, [r5, #0]
    df60:	2b00      	cmp	r3, #0
    df62:	d0fb      	beq.n	df5c <_isatty_r+0x14>
    df64:	6023      	str	r3, [r4, #0]
    df66:	bd38      	pop	{r3, r4, r5, pc}
    df68:	2000a4e8 	.word	0x2000a4e8
    df6c:	00000000 	.word	0x00000000

0000df70 <___reboot_Teensyduino__veneer>:
    df70:	f85f f000 	ldr.w	pc, [pc]	; df74 <___reboot_Teensyduino__veneer+0x4>
    df74:	60001a05 	.word	0x60001a05

0000df78 <___init_veneer>:
    df78:	f85f f000 	ldr.w	pc, [pc]	; df7c <___init_veneer+0x4>
    df7c:	60001aad 	.word	0x60001aad

Disassembly of section .fini:

0000df80 <_fini>:
    df80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    df82:	bf00      	nop
